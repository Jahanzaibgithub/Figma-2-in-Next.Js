"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/globals.css":
/*!*************************!*\
  !*** ./app/globals.css ***!
  \*************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"d3d18d4bfb99\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9nbG9iYWxzLmNzcyIsIm1hcHBpbmdzIjoiO0FBQUEsK0RBQWUsY0FBYztBQUM3QixJQUFJLElBQVUsSUFBSSxpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL2dsb2JhbHMuY3NzPzJiNzciXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCJkM2QxOGQ0YmZiOTlcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/globals.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./components/PartnershipProjects/PartnershipProject.jsx":
/*!***************************************************************!*\
  !*** ./components/PartnershipProjects/PartnershipProject.jsx ***!
  \***************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var tw_elements__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tw-elements */ \"(app-pages-browser)/./node_modules/tw-elements/dist/js/tw-elements.es.min.js\");\n\n\n// Initialization for ES Users\n\n(0,tw_elements__WEBPACK_IMPORTED_MODULE_2__.initTE)({\n    Carousel: tw_elements__WEBPACK_IMPORTED_MODULE_2__.Carousel\n});\nconst PartnershipProject = (param)=>{\n    let { isRTL } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        id: \"carouselExampleCaptions\",\n        className: \"relative\",\n        \"data-te-carousel-init\": true,\n        \"data-te-ride\": \"carousel\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"absolute bottom-0 left-0 right-0 z-[2] mx-[15%] mb-4 flex list-none justify-center p-0\",\n                \"data-te-carousel-indicators\": true,\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                    type: \"button\",\n                    \"data-te-target\": \"#carouselExampleCaptions\",\n                    \"data-te-slide-to\": \"0\",\n                    \"data-te-carousel-active\": true,\n                    className: \"mx-[3px] box-content h-[3px] w-[30px] flex-initial cursor-pointer border-0 border-y-[10px] border-solid border-transparent bg-white bg-clip-padding p-0 -indent-[999px] opacity-50 transition-opacity duration-[600ms] ease-[cubic-bezier(0.25,0.1,0.25,1.0)] motion-reduce:transition-none\",\n                    \"aria-current\": \"true\",\n                    \"aria-label\": \"Slide 1\"\n                }, void 0, false, {\n                    fileName: \"/home/jahanzaib/Figma-2/Figma-2-in-Next.Js/components/PartnershipProjects/PartnershipProject.jsx\",\n                    lineNumber: 26,\n                    columnNumber: 9\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/home/jahanzaib/Figma-2/Figma-2-in-Next.Js/components/PartnershipProjects/PartnershipProject.jsx\",\n                lineNumber: 21,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"relative w-full overflow-hidden after:clear-both after:block after:content-['']\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"relative float-left -mr-[100%] w-full transition-transform duration-[600ms] ease-in-out motion-reduce:transition-none\",\n                    \"data-te-carousel-active\": true,\n                    \"data-te-carousel-item\": true,\n                    style: {\n                        backfaceVisibility: \"hidden\"\n                    },\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n                            src: \"https://tecdn.b-cdn.net/img/Photos/Slides/img%20(15).jpg\",\n                            className: \"block w-full\",\n                            alt: \"...\"\n                        }, void 0, false, {\n                            fileName: \"/home/jahanzaib/Figma-2/Figma-2-in-Next.Js/components/PartnershipProjects/PartnershipProject.jsx\",\n                            lineNumber: 47,\n                            columnNumber: 11\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"absolute inset-x-[15%] bottom-5 hidden py-5 text-center text-white md:block\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h5\", {\n                                    className: \"text-xl\",\n                                    children: \"First slide label\"\n                                }, void 0, false, {\n                                    fileName: \"/home/jahanzaib/Figma-2/Figma-2-in-Next.Js/components/PartnershipProjects/PartnershipProject.jsx\",\n                                    lineNumber: 53,\n                                    columnNumber: 13\n                                }, undefined),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                    children: \"Some representative placeholder content for the first slide.\"\n                                }, void 0, false, {\n                                    fileName: \"/home/jahanzaib/Figma-2/Figma-2-in-Next.Js/components/PartnershipProjects/PartnershipProject.jsx\",\n                                    lineNumber: 54,\n                                    columnNumber: 13\n                                }, undefined)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/home/jahanzaib/Figma-2/Figma-2-in-Next.Js/components/PartnershipProjects/PartnershipProject.jsx\",\n                            lineNumber: 52,\n                            columnNumber: 11\n                        }, undefined)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/home/jahanzaib/Figma-2/Figma-2-in-Next.Js/components/PartnershipProjects/PartnershipProject.jsx\",\n                    lineNumber: 41,\n                    columnNumber: 9\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/home/jahanzaib/Figma-2/Figma-2-in-Next.Js/components/PartnershipProjects/PartnershipProject.jsx\",\n                lineNumber: 39,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                className: \"absolute bottom-0 left-0 top-0 z-[1] flex w-[15%] items-center justify-center border-0 bg-none p-0 text-center text-white opacity-50 transition-opacity duration-150 ease-[cubic-bezier(0.25,0.1,0.25,1.0)] hover:text-white hover:no-underline hover:opacity-90 hover:outline-none focus:text-white focus:no-underline focus:opacity-90 focus:outline-none motion-reduce:transition-none\",\n                type: \"button\",\n                \"data-te-target\": \"#carouselExampleCaptions\",\n                \"data-te-slide\": \"prev\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                        className: \"inline-block h-8 w-8\"\n                    }, void 0, false, {\n                        fileName: \"/home/jahanzaib/Figma-2/Figma-2-in-Next.Js/components/PartnershipProjects/PartnershipProject.jsx\",\n                        lineNumber: 67,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                        className: \"!absolute !-m-px !h-px !w-px !overflow-hidden !whitespace-nowrap !border-0 !p-0 ![clip:rect(0,0,0,0)]\",\n                        children: \"Previous\"\n                    }, void 0, false, {\n                        fileName: \"/home/jahanzaib/Figma-2/Figma-2-in-Next.Js/components/PartnershipProjects/PartnershipProject.jsx\",\n                        lineNumber: 70,\n                        columnNumber: 9\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/home/jahanzaib/Figma-2/Figma-2-in-Next.Js/components/PartnershipProjects/PartnershipProject.jsx\",\n                lineNumber: 61,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                className: \"absolute bottom-0 right-0 top-0 z-[1] flex w-[15%] items-center justify-center border-0 bg-none p-0 text-center text-white opacity-50 transition-opacity duration-150 ease-[cubic-bezier(0.25,0.1,0.25,1.0)] hover:text-white hover:no-underline hover:opacity-90 hover:outline-none focus:text-white focus:no-underline focus:opacity-90 focus:outline-none motion-reduce:transition-none\",\n                type: \"button\",\n                \"data-te-target\": \"#carouselExampleCaptions\",\n                \"data-te-slide\": \"next\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                        className: \"inline-block h-8 w-8\"\n                    }, void 0, false, {\n                        fileName: \"/home/jahanzaib/Figma-2/Figma-2-in-Next.Js/components/PartnershipProjects/PartnershipProject.jsx\",\n                        lineNumber: 82,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                        className: \"!absolute !-m-px !h-px !w-px !overflow-hidden !whitespace-nowrap !border-0 !p-0 ![clip:rect(0,0,0,0)]\",\n                        children: \"Next\"\n                    }, void 0, false, {\n                        fileName: \"/home/jahanzaib/Figma-2/Figma-2-in-Next.Js/components/PartnershipProjects/PartnershipProject.jsx\",\n                        lineNumber: 85,\n                        columnNumber: 9\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/home/jahanzaib/Figma-2/Figma-2-in-Next.Js/components/PartnershipProjects/PartnershipProject.jsx\",\n                lineNumber: 76,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/home/jahanzaib/Figma-2/Figma-2-in-Next.Js/components/PartnershipProjects/PartnershipProject.jsx\",\n        lineNumber: 14,\n        columnNumber: 5\n    }, undefined);\n};\n_c = PartnershipProject;\n/* harmony default export */ __webpack_exports__[\"default\"] = (PartnershipProject);\nvar _c;\n$RefreshReg$(_c, \"PartnershipProject\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvUGFydG5lcnNoaXBQcm9qZWN0cy9QYXJ0bmVyc2hpcFByb2plY3QuanN4IiwibWFwcGluZ3MiOiI7Ozs7OztBQUMwQjtBQUMxQiw4QkFBOEI7QUFJVDtBQUVyQkUsbURBQU1BLENBQUM7SUFBRUQsUUFBUUEsbURBQUFBO0FBQUM7QUFFbEIsTUFBTUUscUJBQXFCO1FBQUMsRUFBRUMsS0FBSyxFQUFFO0lBRW5DLHFCQUNFLDhEQUFDQztRQUNDQyxJQUFHO1FBQ0hDLFdBQVU7UUFDVkMsdUJBQXFCO1FBQ3JCQyxnQkFBYTs7MEJBR2IsOERBQUNKO2dCQUNDRSxXQUFVO2dCQUNWRyw2QkFBMkI7MEJBRzNCLDRFQUFDQztvQkFDQ0MsTUFBSztvQkFDTEMsa0JBQWU7b0JBQ2ZDLG9CQUFpQjtvQkFDakJDLHlCQUF1QjtvQkFDdkJSLFdBQVU7b0JBQ1ZTLGdCQUFhO29CQUNiQyxjQUFXOzs7Ozs7Ozs7OzswQkFNZiw4REFBQ1o7Z0JBQUlFLFdBQVU7MEJBRWIsNEVBQUNGO29CQUNDRSxXQUFVO29CQUNWUSx5QkFBdUI7b0JBQ3ZCRyx1QkFBcUI7b0JBQ3JCQyxPQUFPO3dCQUFFQyxvQkFBb0I7b0JBQVM7O3NDQUV0Qyw4REFBQ0M7NEJBQ0NDLEtBQUk7NEJBQ0pmLFdBQVU7NEJBQ1ZnQixLQUFJOzs7Ozs7c0NBRU4sOERBQUNsQjs0QkFBSUUsV0FBVTs7OENBQ2IsOERBQUNpQjtvQ0FBR2pCLFdBQVU7OENBQVU7Ozs7Ozs4Q0FDeEIsOERBQUNrQjs4Q0FBRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MEJBT1QsOERBQUNkO2dCQUNDSixXQUFVO2dCQUNWSyxNQUFLO2dCQUNMQyxrQkFBZTtnQkFDZmEsaUJBQWM7O2tDQUVkLDhEQUFDQzt3QkFBS3BCLFdBQVU7Ozs7OztrQ0FHaEIsOERBQUNvQjt3QkFBS3BCLFdBQVU7a0NBQXdHOzs7Ozs7Ozs7Ozs7MEJBTTFILDhEQUFDSTtnQkFDQ0osV0FBVTtnQkFDVkssTUFBSztnQkFDTEMsa0JBQWU7Z0JBQ2ZhLGlCQUFjOztrQ0FFZCw4REFBQ0M7d0JBQUtwQixXQUFVOzs7Ozs7a0NBR2hCLDhEQUFDb0I7d0JBQUtwQixXQUFVO2tDQUF3Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBTWhJO0tBaEZNSjtBQWtGTiwrREFBZUEsa0JBQWtCQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvUGFydG5lcnNoaXBQcm9qZWN0cy9QYXJ0bmVyc2hpcFByb2plY3QuanN4P2M5N2IiXSwic291cmNlc0NvbnRlbnQiOlsiXG5pbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG4vLyBJbml0aWFsaXphdGlvbiBmb3IgRVMgVXNlcnNcbmltcG9ydCB7XG4gIENhcm91c2VsLFxuICBpbml0VEUsXG59IGZyb20gXCJ0dy1lbGVtZW50c1wiO1xuXG5pbml0VEUoeyBDYXJvdXNlbCB9KTtcblxuY29uc3QgUGFydG5lcnNoaXBQcm9qZWN0ID0gKHsgaXNSVEwgfSkgPT4ge1xuICBcbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICBpZD1cImNhcm91c2VsRXhhbXBsZUNhcHRpb25zXCJcbiAgICAgIGNsYXNzTmFtZT1cInJlbGF0aXZlXCJcbiAgICAgIGRhdGEtdGUtY2Fyb3VzZWwtaW5pdFxuICAgICAgZGF0YS10ZS1yaWRlPVwiY2Fyb3VzZWxcIlxuICAgID5cbiAgICAgIHsvKiBDYXJvdXNlbCBpbmRpY2F0b3JzICovfVxuICAgICAgPGRpdlxuICAgICAgICBjbGFzc05hbWU9XCJhYnNvbHV0ZSBib3R0b20tMCBsZWZ0LTAgcmlnaHQtMCB6LVsyXSBteC1bMTUlXSBtYi00IGZsZXggbGlzdC1ub25lIGp1c3RpZnktY2VudGVyIHAtMFwiXG4gICAgICAgIGRhdGEtdGUtY2Fyb3VzZWwtaW5kaWNhdG9yc1xuICAgICAgPlxuICAgICAgICB7LyogSW5kaWNhdG9yIGJ1dHRvbnMgKi99XG4gICAgICAgIDxidXR0b25cbiAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICBkYXRhLXRlLXRhcmdldD1cIiNjYXJvdXNlbEV4YW1wbGVDYXB0aW9uc1wiXG4gICAgICAgICAgZGF0YS10ZS1zbGlkZS10bz1cIjBcIlxuICAgICAgICAgIGRhdGEtdGUtY2Fyb3VzZWwtYWN0aXZlXG4gICAgICAgICAgY2xhc3NOYW1lPVwibXgtWzNweF0gYm94LWNvbnRlbnQgaC1bM3B4XSB3LVszMHB4XSBmbGV4LWluaXRpYWwgY3Vyc29yLXBvaW50ZXIgYm9yZGVyLTAgYm9yZGVyLXktWzEwcHhdIGJvcmRlci1zb2xpZCBib3JkZXItdHJhbnNwYXJlbnQgYmctd2hpdGUgYmctY2xpcC1wYWRkaW5nIHAtMCAtaW5kZW50LVs5OTlweF0gb3BhY2l0eS01MCB0cmFuc2l0aW9uLW9wYWNpdHkgZHVyYXRpb24tWzYwMG1zXSBlYXNlLVtjdWJpYy1iZXppZXIoMC4yNSwwLjEsMC4yNSwxLjApXSBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZVwiXG4gICAgICAgICAgYXJpYS1jdXJyZW50PVwidHJ1ZVwiXG4gICAgICAgICAgYXJpYS1sYWJlbD1cIlNsaWRlIDFcIlxuICAgICAgICA+PC9idXR0b24+XG4gICAgICAgIHsvKiBSZXBlYXQgdGhlIGFib3ZlIGJ1dHRvbiBzdHJ1Y3R1cmUgZm9yIGVhY2ggc2xpZGUgKi99XG4gICAgICA8L2Rpdj5cblxuICAgICAgey8qIENhcm91c2VsIGl0ZW1zICovfVxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJyZWxhdGl2ZSB3LWZ1bGwgb3ZlcmZsb3ctaGlkZGVuIGFmdGVyOmNsZWFyLWJvdGggYWZ0ZXI6YmxvY2sgYWZ0ZXI6Y29udGVudC1bJyddXCI+XG4gICAgICAgIHsvKiBGaXJzdCBpdGVtICovfVxuICAgICAgICA8ZGl2XG4gICAgICAgICAgY2xhc3NOYW1lPVwicmVsYXRpdmUgZmxvYXQtbGVmdCAtbXItWzEwMCVdIHctZnVsbCB0cmFuc2l0aW9uLXRyYW5zZm9ybSBkdXJhdGlvbi1bNjAwbXNdIGVhc2UtaW4tb3V0IG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lXCJcbiAgICAgICAgICBkYXRhLXRlLWNhcm91c2VsLWFjdGl2ZVxuICAgICAgICAgIGRhdGEtdGUtY2Fyb3VzZWwtaXRlbVxuICAgICAgICAgIHN0eWxlPXt7IGJhY2tmYWNlVmlzaWJpbGl0eTogXCJoaWRkZW5cIiB9fVxuICAgICAgICA+XG4gICAgICAgICAgPGltZ1xuICAgICAgICAgICAgc3JjPVwiaHR0cHM6Ly90ZWNkbi5iLWNkbi5uZXQvaW1nL1Bob3Rvcy9TbGlkZXMvaW1nJTIwKDE1KS5qcGdcIlxuICAgICAgICAgICAgY2xhc3NOYW1lPVwiYmxvY2sgdy1mdWxsXCJcbiAgICAgICAgICAgIGFsdD1cIi4uLlwiXG4gICAgICAgICAgLz5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFic29sdXRlIGluc2V0LXgtWzE1JV0gYm90dG9tLTUgaGlkZGVuIHB5LTUgdGV4dC1jZW50ZXIgdGV4dC13aGl0ZSBtZDpibG9ja1wiPlxuICAgICAgICAgICAgPGg1IGNsYXNzTmFtZT1cInRleHQteGxcIj5GaXJzdCBzbGlkZSBsYWJlbDwvaDU+XG4gICAgICAgICAgICA8cD5Tb21lIHJlcHJlc2VudGF0aXZlIHBsYWNlaG9sZGVyIGNvbnRlbnQgZm9yIHRoZSBmaXJzdCBzbGlkZS48L3A+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICB7LyogUmVwZWF0IHRoZSBhYm92ZSBzdHJ1Y3R1cmUgZm9yIGVhY2ggc2xpZGUgKi99XG4gICAgICA8L2Rpdj5cblxuICAgICAgey8qIENhcm91c2VsIGNvbnRyb2xzIC0gcHJldiBpdGVtICovfVxuICAgICAgPGJ1dHRvblxuICAgICAgICBjbGFzc05hbWU9XCJhYnNvbHV0ZSBib3R0b20tMCBsZWZ0LTAgdG9wLTAgei1bMV0gZmxleCB3LVsxNSVdIGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBib3JkZXItMCBiZy1ub25lIHAtMCB0ZXh0LWNlbnRlciB0ZXh0LXdoaXRlIG9wYWNpdHktNTAgdHJhbnNpdGlvbi1vcGFjaXR5IGR1cmF0aW9uLTE1MCBlYXNlLVtjdWJpYy1iZXppZXIoMC4yNSwwLjEsMC4yNSwxLjApXSBob3Zlcjp0ZXh0LXdoaXRlIGhvdmVyOm5vLXVuZGVybGluZSBob3ZlcjpvcGFjaXR5LTkwIGhvdmVyOm91dGxpbmUtbm9uZSBmb2N1czp0ZXh0LXdoaXRlIGZvY3VzOm5vLXVuZGVybGluZSBmb2N1czpvcGFjaXR5LTkwIGZvY3VzOm91dGxpbmUtbm9uZSBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZVwiXG4gICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICBkYXRhLXRlLXRhcmdldD1cIiNjYXJvdXNlbEV4YW1wbGVDYXB0aW9uc1wiXG4gICAgICAgIGRhdGEtdGUtc2xpZGU9XCJwcmV2XCJcbiAgICAgID5cbiAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiaW5saW5lLWJsb2NrIGgtOCB3LThcIj5cbiAgICAgICAgICB7LyogU1ZHIGZvciBwcmV2aW91cyBhcnJvdyAqL31cbiAgICAgICAgPC9zcGFuPlxuICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCIhYWJzb2x1dGUgIS1tLXB4ICFoLXB4ICF3LXB4ICFvdmVyZmxvdy1oaWRkZW4gIXdoaXRlc3BhY2Utbm93cmFwICFib3JkZXItMCAhcC0wICFbY2xpcDpyZWN0KDAsMCwwLDApXVwiPlxuICAgICAgICAgIFByZXZpb3VzXG4gICAgICAgIDwvc3Bhbj5cbiAgICAgIDwvYnV0dG9uPlxuXG4gICAgICB7LyogQ2Fyb3VzZWwgY29udHJvbHMgLSBuZXh0IGl0ZW0gKi99XG4gICAgICA8YnV0dG9uXG4gICAgICAgIGNsYXNzTmFtZT1cImFic29sdXRlIGJvdHRvbS0wIHJpZ2h0LTAgdG9wLTAgei1bMV0gZmxleCB3LVsxNSVdIGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBib3JkZXItMCBiZy1ub25lIHAtMCB0ZXh0LWNlbnRlciB0ZXh0LXdoaXRlIG9wYWNpdHktNTAgdHJhbnNpdGlvbi1vcGFjaXR5IGR1cmF0aW9uLTE1MCBlYXNlLVtjdWJpYy1iZXppZXIoMC4yNSwwLjEsMC4yNSwxLjApXSBob3Zlcjp0ZXh0LXdoaXRlIGhvdmVyOm5vLXVuZGVybGluZSBob3ZlcjpvcGFjaXR5LTkwIGhvdmVyOm91dGxpbmUtbm9uZSBmb2N1czp0ZXh0LXdoaXRlIGZvY3VzOm5vLXVuZGVybGluZSBmb2N1czpvcGFjaXR5LTkwIGZvY3VzOm91dGxpbmUtbm9uZSBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZVwiXG4gICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICBkYXRhLXRlLXRhcmdldD1cIiNjYXJvdXNlbEV4YW1wbGVDYXB0aW9uc1wiXG4gICAgICAgIGRhdGEtdGUtc2xpZGU9XCJuZXh0XCJcbiAgICAgID5cbiAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiaW5saW5lLWJsb2NrIGgtOCB3LThcIj5cbiAgICAgICAgICB7LyogU1ZHIGZvciBuZXh0IGFycm93ICovfVxuICAgICAgICA8L3NwYW4+XG4gICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cIiFhYnNvbHV0ZSAhLW0tcHggIWgtcHggIXctcHggIW92ZXJmbG93LWhpZGRlbiAhd2hpdGVzcGFjZS1ub3dyYXAgIWJvcmRlci0wICFwLTAgIVtjbGlwOnJlY3QoMCwwLDAsMCldXCI+XG4gICAgICAgICAgTmV4dFxuICAgICAgICA8L3NwYW4+XG4gICAgICA8L2J1dHRvbj5cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFBhcnRuZXJzaGlwUHJvamVjdDtcblxuIl0sIm5hbWVzIjpbIlJlYWN0IiwiQ2Fyb3VzZWwiLCJpbml0VEUiLCJQYXJ0bmVyc2hpcFByb2plY3QiLCJpc1JUTCIsImRpdiIsImlkIiwiY2xhc3NOYW1lIiwiZGF0YS10ZS1jYXJvdXNlbC1pbml0IiwiZGF0YS10ZS1yaWRlIiwiZGF0YS10ZS1jYXJvdXNlbC1pbmRpY2F0b3JzIiwiYnV0dG9uIiwidHlwZSIsImRhdGEtdGUtdGFyZ2V0IiwiZGF0YS10ZS1zbGlkZS10byIsImRhdGEtdGUtY2Fyb3VzZWwtYWN0aXZlIiwiYXJpYS1jdXJyZW50IiwiYXJpYS1sYWJlbCIsImRhdGEtdGUtY2Fyb3VzZWwtaXRlbSIsInN0eWxlIiwiYmFja2ZhY2VWaXNpYmlsaXR5IiwiaW1nIiwic3JjIiwiYWx0IiwiaDUiLCJwIiwiZGF0YS10ZS1zbGlkZSIsInNwYW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/PartnershipProjects/PartnershipProject.jsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/tw-elements/dist/js/tw-elements.es.min.js":
/*!****************************************************************!*\
  !*** ./node_modules/tw-elements/dist/js/tw-elements.es.min.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Alert: function() { return /* binding */ Lo; },\n/* harmony export */   Animate: function() { return /* binding */ pr; },\n/* harmony export */   Button: function() { return /* binding */ rc; },\n/* harmony export */   Carousel: function() { return /* binding */ Ut; },\n/* harmony export */   Chart: function() { return /* binding */ dh; },\n/* harmony export */   Chip: function() { return /* binding */ _i; },\n/* harmony export */   ChipsInput: function() { return /* binding */ GC; },\n/* harmony export */   Clipboard: function() { return /* binding */ wh; },\n/* harmony export */   Collapse: function() { return /* binding */ Zt; },\n/* harmony export */   Datatable: function() { return /* binding */ gh; },\n/* harmony export */   Datepicker: function() { return /* binding */ Nm; },\n/* harmony export */   Datetimepicker: function() { return /* binding */ Ih; },\n/* harmony export */   Dropdown: function() { return /* binding */ Dt; },\n/* harmony export */   InfiniteScroll: function() { return /* binding */ kh; },\n/* harmony export */   Input: function() { return /* binding */ V; },\n/* harmony export */   LazyLoad: function() { return /* binding */ Uo; },\n/* harmony export */   Lightbox: function() { return /* binding */ Zs; },\n/* harmony export */   LoadingManagement: function() { return /* binding */ xh; },\n/* harmony export */   Modal: function() { return /* binding */ No; },\n/* harmony export */   Offcanvas: function() { return /* binding */ Bs; },\n/* harmony export */   PerfectScrollbar: function() { return /* binding */ mh; },\n/* harmony export */   Popconfirm: function() { return /* binding */ vh; },\n/* harmony export */   Popover: function() { return /* binding */ Rc; },\n/* harmony export */   Rating: function() { return /* binding */ qC; },\n/* harmony export */   Ripple: function() { return /* binding */ Ze; },\n/* harmony export */   ScrollSpy: function() { return /* binding */ Hc; },\n/* harmony export */   Select: function() { return /* binding */ _r; },\n/* harmony export */   Sidenav: function() { return /* binding */ gi; },\n/* harmony export */   SmoothScroll: function() { return /* binding */ yh; },\n/* harmony export */   Stepper: function() { return /* binding */ XC; },\n/* harmony export */   Sticky: function() { return /* binding */ $h; },\n/* harmony export */   Tab: function() { return /* binding */ Vc; },\n/* harmony export */   Timepicker: function() { return /* binding */ ng; },\n/* harmony export */   Toast: function() { return /* binding */ Ro; },\n/* harmony export */   Tooltip: function() { return /* binding */ ii; },\n/* harmony export */   Touch: function() { return /* binding */ Ah; },\n/* harmony export */   Validation: function() { return /* binding */ Ch; },\n/* harmony export */   initTE: function() { return /* binding */ ZC; }\n/* harmony export */ });\n/*!\n* Tailwind Elements 1.0.0\n* \n* Tailwind Elements is an open-source UI kit of advanced components for TailwindCSS.\n* Copyright Â© 2023 MDBootstrap.com\n* \n* Unless a custom, individually assigned license has been granted, this program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\n* In addition, a custom license may be available upon request, subject to the terms and conditions of that license. Please contact tailwind@mdbootstrap.com for more information on obtaining a custom license.\n* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.\n* \n*/\nvar Hh = Object.defineProperty;\nvar Vh = (s, t, e) => t in s ? Hh(s, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : s[t] = e;\nvar yt = (s, t, e) => (Vh(s, typeof t != \"symbol\" ? t + \"\" : t, e), e);\nconst Tn = (() => {\n  const s = {};\n  let t = 1;\n  return {\n    set(e, i, n) {\n      typeof e[i] > \"u\" && (e[i] = {\n        key: i,\n        id: t\n      }, t++), s[e[i].id] = n;\n    },\n    get(e, i) {\n      if (!e || typeof e[i] > \"u\")\n        return null;\n      const n = e[i];\n      return n.key === i ? s[n.id] : null;\n    },\n    delete(e, i) {\n      if (typeof e[i] > \"u\")\n        return;\n      const n = e[i];\n      n.key === i && (delete s[n.id], delete e[i]);\n    }\n  };\n})(), y = {\n  setData(s, t, e) {\n    Tn.set(s, t, e);\n  },\n  getData(s, t) {\n    return Tn.get(s, t);\n  },\n  removeData(s, t) {\n    Tn.delete(s, t);\n  }\n}, Wh = 1e6, Fh = 1e3, xo = \"transitionend\", Yh = (s) => s == null ? `${s}` : {}.toString.call(s).match(/\\s([a-z]+)/i)[1].toLowerCase(), rt = (s) => {\n  do\n    s += Math.floor(Math.random() * Wh);\n  while (document.getElementById(s));\n  return s;\n}, Ul = (s) => {\n  let t = s.getAttribute(\"data-te-target\");\n  if (!t || t === \"#\") {\n    let e = s.getAttribute(\"href\");\n    if (!e || !e.includes(\"#\") && !e.startsWith(\".\"))\n      return null;\n    e.includes(\"#\") && !e.startsWith(\"#\") && (e = `#${e.split(\"#\")[1]}`), t = e && e !== \"#\" ? e.trim() : null;\n  }\n  return t;\n}, qo = (s) => {\n  const t = Ul(s);\n  return t && document.querySelector(t) ? t : null;\n}, Jt = (s) => {\n  const t = Ul(s);\n  return t ? document.querySelector(t) : null;\n}, jh = (s) => {\n  if (!s)\n    return 0;\n  let { transitionDuration: t, transitionDelay: e } = window.getComputedStyle(s);\n  const i = Number.parseFloat(t), n = Number.parseFloat(e);\n  return !i && !n ? 0 : (t = t.split(\",\")[0], e = e.split(\",\")[0], (Number.parseFloat(t) + Number.parseFloat(e)) * Fh);\n}, Xl = (s) => {\n  s.dispatchEvent(new Event(xo));\n}, je = (s) => !s || typeof s != \"object\" ? !1 : (typeof s.jquery < \"u\" && (s = s[0]), typeof s.nodeType < \"u\"), te = (s) => je(s) ? s.jquery ? s[0] : s : typeof s == \"string\" && s.length > 0 ? document.querySelector(s) : null, D = (s, t, e) => {\n  Object.keys(e).forEach((i) => {\n    const n = e[i], o = t[i], r = o && je(o) ? \"element\" : Yh(o);\n    if (!new RegExp(n).test(r))\n      throw new Error(\n        `${s.toUpperCase()}: Option \"${i}\" provided type \"${r}\" but expected type \"${n}\".`\n      );\n  });\n}, Nt = (s) => {\n  if (!s || s.getClientRects().length === 0)\n    return !1;\n  if (s.style && s.parentNode && s.parentNode.style) {\n    const t = getComputedStyle(s), e = getComputedStyle(s.parentNode);\n    return getComputedStyle(s).getPropertyValue(\"visibility\") === \"visible\" || t.display !== \"none\" && e.display !== \"none\" && t.visibility !== \"hidden\";\n  }\n  return !1;\n}, ge = (s) => !s || s.nodeType !== Node.ELEMENT_NODE || s.classList.contains(\"disabled\") ? !0 : typeof s.disabled < \"u\" ? s.disabled : s.hasAttribute(\"disabled\") && s.getAttribute(\"disabled\") !== \"false\", Gl = (s) => {\n  if (!document.documentElement.attachShadow)\n    return null;\n  if (typeof s.getRootNode == \"function\") {\n    const t = s.getRootNode();\n    return t instanceof ShadowRoot ? t : null;\n  }\n  return s instanceof ShadowRoot ? s : s.parentNode ? Gl(s.parentNode) : null;\n}, tn = () => function() {\n}, Je = (s) => {\n  s.offsetHeight;\n}, ql = () => {\n  const { jQuery: s } = window;\n  return s && !document.body.hasAttribute(\"data-te-no-jquery\") ? s : null;\n}, En = [], Zl = (s) => {\n  document.readyState === \"loading\" ? (En.length || document.addEventListener(\"DOMContentLoaded\", () => {\n    En.forEach((t) => t());\n  }), En.push(s)) : s();\n}, F = () => document.documentElement.dir === \"rtl\", Kh = (s) => Array.from(s), $ = (s) => document.createElement(s), me = (s) => {\n  typeof s == \"function\" && s();\n}, Ql = (s, t, e = !0) => {\n  if (!e) {\n    me(s);\n    return;\n  }\n  const i = 5, n = jh(t) + i;\n  let o = !1;\n  const r = ({ target: a }) => {\n    a === t && (o = !0, t.removeEventListener(xo, r), me(s));\n  };\n  t.addEventListener(xo, r), setTimeout(() => {\n    o || Xl(t);\n  }, n);\n}, Jl = (s, t, e, i) => {\n  let n = s.indexOf(t);\n  if (n === -1)\n    return s[!e && i ? s.length - 1 : 0];\n  const o = s.length;\n  return n += e ? 1 : -1, i && (n = (n + o) % o), s[Math.max(0, Math.min(n, o - 1))];\n}, zh = /[^.]*(?=\\..*)\\.|.*/, Uh = /\\..*/, Xh = /::\\d+$/, Cn = {};\nlet xr = 1;\nconst Gh = {\n  mouseenter: \"mouseover\",\n  mouseleave: \"mouseout\"\n}, qh = /^(mouseenter|mouseleave)/i, tc = /* @__PURE__ */ new Set([\n  \"click\",\n  \"dblclick\",\n  \"mouseup\",\n  \"mousedown\",\n  \"contextmenu\",\n  \"mousewheel\",\n  \"DOMMouseScroll\",\n  \"mouseover\",\n  \"mouseout\",\n  \"mousemove\",\n  \"selectstart\",\n  \"selectend\",\n  \"keydown\",\n  \"keypress\",\n  \"keyup\",\n  \"orientationchange\",\n  \"touchstart\",\n  \"touchmove\",\n  \"touchend\",\n  \"touchcancel\",\n  \"pointerdown\",\n  \"pointermove\",\n  \"pointerup\",\n  \"pointerleave\",\n  \"pointercancel\",\n  \"gesturestart\",\n  \"gesturechange\",\n  \"gestureend\",\n  \"focus\",\n  \"blur\",\n  \"change\",\n  \"reset\",\n  \"select\",\n  \"submit\",\n  \"focusin\",\n  \"focusout\",\n  \"load\",\n  \"unload\",\n  \"beforeunload\",\n  \"resize\",\n  \"move\",\n  \"DOMContentLoaded\",\n  \"readystatechange\",\n  \"error\",\n  \"abort\",\n  \"scroll\"\n]);\nfunction ec(s, t) {\n  return t && `${t}::${xr++}` || s.uidEvent || xr++;\n}\nfunction ic(s) {\n  const t = ec(s);\n  return s.uidEvent = t, Cn[t] = Cn[t] || {}, Cn[t];\n}\nfunction Zh(s, t) {\n  return function e(i) {\n    return i.delegateTarget = s, e.oneOff && c.off(s, i.type, t), t.apply(s, [i]);\n  };\n}\nfunction Qh(s, t, e) {\n  return function i(n) {\n    const o = s.querySelectorAll(t);\n    for (let { target: r } = n; r && r !== this; r = r.parentNode)\n      for (let a = o.length; a--; \"\")\n        if (o[a] === r)\n          return n.delegateTarget = r, i.oneOff && c.off(s, n.type, e), e.apply(r, [n]);\n    return null;\n  };\n}\nfunction sc(s, t, e = null) {\n  const i = Object.keys(s);\n  for (let n = 0, o = i.length; n < o; n++) {\n    const r = s[i[n]];\n    if (r.originalHandler === t && r.delegationSelector === e)\n      return r;\n  }\n  return null;\n}\nfunction nc(s, t, e) {\n  const i = typeof t == \"string\", n = i ? e : t;\n  let o = oc(s);\n  return tc.has(o) || (o = s), [i, n, o];\n}\nfunction Or(s, t, e, i, n) {\n  if (typeof t != \"string\" || !s)\n    return;\n  if (e || (e = i, i = null), qh.test(t)) {\n    const g = (m) => function(b) {\n      if (!b.relatedTarget || b.relatedTarget !== b.delegateTarget && !b.delegateTarget.contains(b.relatedTarget))\n        return m.call(this, b);\n    };\n    i ? i = g(i) : e = g(e);\n  }\n  const [o, r, a] = nc(\n    t,\n    e,\n    i\n  ), l = ic(s), p = l[a] || (l[a] = {}), u = sc(\n    p,\n    r,\n    o ? e : null\n  );\n  if (u) {\n    u.oneOff = u.oneOff && n;\n    return;\n  }\n  const _ = ec(\n    r,\n    t.replace(zh, \"\")\n  ), f = o ? Qh(s, e, i) : Zh(s, e);\n  f.delegationSelector = o ? e : null, f.originalHandler = r, f.oneOff = n, f.uidEvent = _, p[_] = f, s.addEventListener(a, f, o);\n}\nfunction Oo(s, t, e, i, n) {\n  const o = sc(t[e], i, n);\n  o && (s.removeEventListener(e, o, !!n), delete t[e][o.uidEvent]);\n}\nfunction Jh(s, t, e, i) {\n  const n = t[e] || {};\n  Object.keys(n).forEach((o) => {\n    if (o.includes(i)) {\n      const r = n[o];\n      Oo(\n        s,\n        t,\n        e,\n        r.originalHandler,\n        r.delegationSelector\n      );\n    }\n  });\n}\nfunction oc(s) {\n  return s = s.replace(Uh, \"\"), Gh[s] || s;\n}\nconst c = {\n  on(s, t, e, i) {\n    Or(s, t, e, i, !1);\n  },\n  one(s, t, e, i) {\n    Or(s, t, e, i, !0);\n  },\n  off(s, t, e, i) {\n    if (typeof t != \"string\" || !s)\n      return;\n    const [n, o, r] = nc(\n      t,\n      e,\n      i\n    ), a = r !== t, l = ic(s), p = t.startsWith(\".\");\n    if (typeof o < \"u\") {\n      if (!l || !l[r])\n        return;\n      Oo(\n        s,\n        l,\n        r,\n        o,\n        n ? e : null\n      );\n      return;\n    }\n    p && Object.keys(l).forEach((_) => {\n      Jh(\n        s,\n        l,\n        _,\n        t.slice(1)\n      );\n    });\n    const u = l[r] || {};\n    Object.keys(u).forEach((_) => {\n      const f = _.replace(Xh, \"\");\n      if (!a || t.includes(f)) {\n        const g = u[_];\n        Oo(\n          s,\n          l,\n          r,\n          g.originalHandler,\n          g.delegationSelector\n        );\n      }\n    });\n  },\n  trigger(s, t, e) {\n    if (typeof t != \"string\" || !s)\n      return null;\n    const i = ql(), n = oc(t), o = t !== n, r = tc.has(n);\n    let a, l = !0, p = !0, u = !1, _ = null;\n    return o && i && (a = i.Event(t, e), i(s).trigger(a), l = !a.isPropagationStopped(), p = !a.isImmediatePropagationStopped(), u = a.isDefaultPrevented()), r ? (_ = document.createEvent(\"HTMLEvents\"), _.initEvent(n, l, !0)) : _ = new CustomEvent(t, {\n      bubbles: l,\n      cancelable: !0\n    }), typeof e < \"u\" && Object.keys(e).forEach((f) => {\n      Object.defineProperty(_, f, {\n        get() {\n          return e[f];\n        }\n      });\n    }), u && _.preventDefault(), p && s.dispatchEvent(_), _.defaultPrevented && typeof a < \"u\" && a.preventDefault(), _;\n  }\n}, re = {\n  on(s, t, e, i) {\n    const n = t.split(\" \");\n    for (let o = 0; o < n.length; o++)\n      c.on(s, n[o], e, i);\n  },\n  off(s, t, e, i) {\n    const n = t.split(\" \");\n    for (let o = 0; o < n.length; o++)\n      c.off(s, n[o], e, i);\n  }\n}, td = \"5.1.3\";\nclass gt {\n  constructor(t) {\n    t = te(t), t && (this._element = t, y.setData(this._element, this.constructor.DATA_KEY, this));\n  }\n  dispose() {\n    y.removeData(this._element, this.constructor.DATA_KEY), c.off(this._element, this.constructor.EVENT_KEY), Object.getOwnPropertyNames(this).forEach((t) => {\n      this[t] = null;\n    });\n  }\n  _queueCallback(t, e, i = !0) {\n    Ql(t, e, i);\n  }\n  /** Static */\n  static getInstance(t) {\n    return y.getData(te(t), this.DATA_KEY);\n  }\n  static getOrCreateInstance(t, e = {}) {\n    return this.getInstance(t) || new this(t, typeof e == \"object\" ? e : null);\n  }\n  static get VERSION() {\n    return td;\n  }\n  static get NAME() {\n    throw new Error(\n      'You have to implement the static method \"NAME\", for each component!'\n    );\n  }\n  static get DATA_KEY() {\n    return `te.${this.NAME}`;\n  }\n  static get EVENT_KEY() {\n    return `.${this.DATA_KEY}`;\n  }\n}\nconst ed = \"button\", id = \"active\";\nclass rc extends gt {\n  // Getters\n  static get NAME() {\n    return ed;\n  }\n  // Public\n  toggle() {\n    this._element.setAttribute(\n      \"aria-pressed\",\n      this._element.classList.toggle(id)\n    );\n  }\n  // Static\n  static jQueryInterface(t) {\n    return this.each(function() {\n      const e = rc.getOrCreateInstance(this);\n      t === \"toggle\" && e[t]();\n    });\n  }\n}\nvar Q = \"top\", dt = \"bottom\", ut = \"right\", J = \"left\", Hi = \"auto\", ti = [Q, dt, ut, J], Te = \"start\", Ke = \"end\", ac = \"clippingParents\", Zo = \"viewport\", $e = \"popper\", lc = \"reference\", So = /* @__PURE__ */ ti.reduce(function(s, t) {\n  return s.concat([t + \"-\" + Te, t + \"-\" + Ke]);\n}, []), Qo = /* @__PURE__ */ [].concat(ti, [Hi]).reduce(function(s, t) {\n  return s.concat([t, t + \"-\" + Te, t + \"-\" + Ke]);\n}, []), cc = \"beforeRead\", hc = \"read\", dc = \"afterRead\", uc = \"beforeMain\", pc = \"main\", _c = \"afterMain\", fc = \"beforeWrite\", mc = \"write\", gc = \"afterWrite\", en = [cc, hc, dc, uc, pc, _c, fc, mc, gc];\nfunction Mt(s) {\n  return s ? (s.nodeName || \"\").toLowerCase() : null;\n}\nfunction pt(s) {\n  if (s == null)\n    return window;\n  if (s.toString() !== \"[object Window]\") {\n    var t = s.ownerDocument;\n    return t && t.defaultView || window;\n  }\n  return s;\n}\nfunction Ee(s) {\n  var t = pt(s).Element;\n  return s instanceof t || s instanceof Element;\n}\nfunction ht(s) {\n  var t = pt(s).HTMLElement;\n  return s instanceof t || s instanceof HTMLElement;\n}\nfunction Jo(s) {\n  if (typeof ShadowRoot > \"u\")\n    return !1;\n  var t = pt(s).ShadowRoot;\n  return s instanceof t || s instanceof ShadowRoot;\n}\nfunction sd(s) {\n  var t = s.state;\n  Object.keys(t.elements).forEach(function(e) {\n    var i = t.styles[e] || {}, n = t.attributes[e] || {}, o = t.elements[e];\n    !ht(o) || !Mt(o) || (Object.assign(o.style, i), Object.keys(n).forEach(function(r) {\n      var a = n[r];\n      a === !1 ? o.removeAttribute(r) : o.setAttribute(r, a === !0 ? \"\" : a);\n    }));\n  });\n}\nfunction nd(s) {\n  var t = s.state, e = {\n    popper: {\n      position: t.options.strategy,\n      left: \"0\",\n      top: \"0\",\n      margin: \"0\"\n    },\n    arrow: {\n      position: \"absolute\"\n    },\n    reference: {}\n  };\n  return Object.assign(t.elements.popper.style, e.popper), t.styles = e, t.elements.arrow && Object.assign(t.elements.arrow.style, e.arrow), function() {\n    Object.keys(t.elements).forEach(function(i) {\n      var n = t.elements[i], o = t.attributes[i] || {}, r = Object.keys(t.styles.hasOwnProperty(i) ? t.styles[i] : e[i]), a = r.reduce(function(l, p) {\n        return l[p] = \"\", l;\n      }, {});\n      !ht(n) || !Mt(n) || (Object.assign(n.style, a), Object.keys(o).forEach(function(l) {\n        n.removeAttribute(l);\n      }));\n    });\n  };\n}\nconst tr = {\n  name: \"applyStyles\",\n  enabled: !0,\n  phase: \"write\",\n  fn: sd,\n  effect: nd,\n  requires: [\"computeStyles\"]\n};\nfunction Tt(s) {\n  return s.split(\"-\")[0];\n}\nvar be = Math.max, sn = Math.min, ze = Math.round;\nfunction Io() {\n  var s = navigator.userAgentData;\n  return s != null && s.brands && Array.isArray(s.brands) ? s.brands.map(function(t) {\n    return t.brand + \"/\" + t.version;\n  }).join(\" \") : navigator.userAgent;\n}\nfunction bc() {\n  return !/^((?!chrome|android).)*safari/i.test(Io());\n}\nfunction Ue(s, t, e) {\n  t === void 0 && (t = !1), e === void 0 && (e = !1);\n  var i = s.getBoundingClientRect(), n = 1, o = 1;\n  t && ht(s) && (n = s.offsetWidth > 0 && ze(i.width) / s.offsetWidth || 1, o = s.offsetHeight > 0 && ze(i.height) / s.offsetHeight || 1);\n  var r = Ee(s) ? pt(s) : window, a = r.visualViewport, l = !bc() && e, p = (i.left + (l && a ? a.offsetLeft : 0)) / n, u = (i.top + (l && a ? a.offsetTop : 0)) / o, _ = i.width / n, f = i.height / o;\n  return {\n    width: _,\n    height: f,\n    top: u,\n    right: p + _,\n    bottom: u + f,\n    left: p,\n    x: p,\n    y: u\n  };\n}\nfunction er(s) {\n  var t = Ue(s), e = s.offsetWidth, i = s.offsetHeight;\n  return Math.abs(t.width - e) <= 1 && (e = t.width), Math.abs(t.height - i) <= 1 && (i = t.height), {\n    x: s.offsetLeft,\n    y: s.offsetTop,\n    width: e,\n    height: i\n  };\n}\nfunction vc(s, t) {\n  var e = t.getRootNode && t.getRootNode();\n  if (s.contains(t))\n    return !0;\n  if (e && Jo(e)) {\n    var i = t;\n    do {\n      if (i && s.isSameNode(i))\n        return !0;\n      i = i.parentNode || i.host;\n    } while (i);\n  }\n  return !1;\n}\nfunction Ct(s) {\n  return pt(s).getComputedStyle(s);\n}\nfunction od(s) {\n  return [\"table\", \"td\", \"th\"].indexOf(Mt(s)) >= 0;\n}\nfunction ee(s) {\n  return ((Ee(s) ? s.ownerDocument : (\n    // $FlowFixMe[prop-missing]\n    s.document\n  )) || window.document).documentElement;\n}\nfunction rn(s) {\n  return Mt(s) === \"html\" ? s : (\n    // this is a quicker (but less type safe) way to save quite some bytes from the bundle\n    // $FlowFixMe[incompatible-return]\n    // $FlowFixMe[prop-missing]\n    s.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n    s.parentNode || // DOM Element detected\n    (Jo(s) ? s.host : null) || // ShadowRoot detected\n    // $FlowFixMe[incompatible-call]: HTMLElement is a Node\n    ee(s)\n  );\n}\nfunction Sr(s) {\n  return !ht(s) || // https://github.com/popperjs/popper-core/issues/837\n  Ct(s).position === \"fixed\" ? null : s.offsetParent;\n}\nfunction rd(s) {\n  var t = /firefox/i.test(Io()), e = /Trident/i.test(Io());\n  if (e && ht(s)) {\n    var i = Ct(s);\n    if (i.position === \"fixed\")\n      return null;\n  }\n  var n = rn(s);\n  for (Jo(n) && (n = n.host); ht(n) && [\"html\", \"body\"].indexOf(Mt(n)) < 0; ) {\n    var o = Ct(n);\n    if (o.transform !== \"none\" || o.perspective !== \"none\" || o.contain === \"paint\" || [\"transform\", \"perspective\"].indexOf(o.willChange) !== -1 || t && o.willChange === \"filter\" || t && o.filter && o.filter !== \"none\")\n      return n;\n    n = n.parentNode;\n  }\n  return null;\n}\nfunction Vi(s) {\n  for (var t = pt(s), e = Sr(s); e && od(e) && Ct(e).position === \"static\"; )\n    e = Sr(e);\n  return e && (Mt(e) === \"html\" || Mt(e) === \"body\" && Ct(e).position === \"static\") ? t : e || rd(s) || t;\n}\nfunction ir(s) {\n  return [\"top\", \"bottom\"].indexOf(s) >= 0 ? \"x\" : \"y\";\n}\nfunction Si(s, t, e) {\n  return be(s, sn(t, e));\n}\nfunction ad(s, t, e) {\n  var i = Si(s, t, e);\n  return i > e ? e : i;\n}\nfunction Tc() {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  };\n}\nfunction Ec(s) {\n  return Object.assign({}, Tc(), s);\n}\nfunction Cc(s, t) {\n  return t.reduce(function(e, i) {\n    return e[i] = s, e;\n  }, {});\n}\nvar ld = function(t, e) {\n  return t = typeof t == \"function\" ? t(Object.assign({}, e.rects, {\n    placement: e.placement\n  })) : t, Ec(typeof t != \"number\" ? t : Cc(t, ti));\n};\nfunction cd(s) {\n  var t, e = s.state, i = s.name, n = s.options, o = e.elements.arrow, r = e.modifiersData.popperOffsets, a = Tt(e.placement), l = ir(a), p = [J, ut].indexOf(a) >= 0, u = p ? \"height\" : \"width\";\n  if (!(!o || !r)) {\n    var _ = ld(n.padding, e), f = er(o), g = l === \"y\" ? Q : J, m = l === \"y\" ? dt : ut, b = e.rects.reference[u] + e.rects.reference[l] - r[l] - e.rects.popper[u], v = r[l] - e.rects.reference[l], C = Vi(o), w = C ? l === \"y\" ? C.clientHeight || 0 : C.clientWidth || 0 : 0, E = b / 2 - v / 2, T = _[g], A = w - f[u] - _[m], k = w / 2 - f[u] / 2 + E, I = Si(T, k, A), O = l;\n    e.modifiersData[i] = (t = {}, t[O] = I, t.centerOffset = I - k, t);\n  }\n}\nfunction hd(s) {\n  var t = s.state, e = s.options, i = e.element, n = i === void 0 ? \"[data-popper-arrow]\" : i;\n  if (n != null && !(typeof n == \"string\" && (n = t.elements.popper.querySelector(n), !n))) {\n    if ({}.NODE_ENV !== \"production\" && (ht(n) || console.error(['Popper: \"arrow\" element must be an HTMLElement (not an SVGElement).', \"To use an SVG arrow, wrap it in an HTMLElement that will be used as\", \"the arrow.\"].join(\" \"))), !vc(t.elements.popper, n)) {\n      ({}).NODE_ENV !== \"production\" && console.error(['Popper: \"arrow\" modifier\\'s `element` must be a child of the popper', \"element.\"].join(\" \"));\n      return;\n    }\n    t.elements.arrow = n;\n  }\n}\nconst Ac = {\n  name: \"arrow\",\n  enabled: !0,\n  phase: \"main\",\n  fn: cd,\n  effect: hd,\n  requires: [\"popperOffsets\"],\n  requiresIfExists: [\"preventOverflow\"]\n};\nfunction Xe(s) {\n  return s.split(\"-\")[1];\n}\nvar dd = {\n  top: \"auto\",\n  right: \"auto\",\n  bottom: \"auto\",\n  left: \"auto\"\n};\nfunction ud(s, t) {\n  var e = s.x, i = s.y, n = t.devicePixelRatio || 1;\n  return {\n    x: ze(e * n) / n || 0,\n    y: ze(i * n) / n || 0\n  };\n}\nfunction Ir(s) {\n  var t, e = s.popper, i = s.popperRect, n = s.placement, o = s.variation, r = s.offsets, a = s.position, l = s.gpuAcceleration, p = s.adaptive, u = s.roundOffsets, _ = s.isFixed, f = r.x, g = f === void 0 ? 0 : f, m = r.y, b = m === void 0 ? 0 : m, v = typeof u == \"function\" ? u({\n    x: g,\n    y: b\n  }) : {\n    x: g,\n    y: b\n  };\n  g = v.x, b = v.y;\n  var C = r.hasOwnProperty(\"x\"), w = r.hasOwnProperty(\"y\"), E = J, T = Q, A = window;\n  if (p) {\n    var k = Vi(e), I = \"clientHeight\", O = \"clientWidth\";\n    if (k === pt(e) && (k = ee(e), Ct(k).position !== \"static\" && a === \"absolute\" && (I = \"scrollHeight\", O = \"scrollWidth\")), k = k, n === Q || (n === J || n === ut) && o === Ke) {\n      T = dt;\n      var x = _ && k === A && A.visualViewport ? A.visualViewport.height : (\n        // $FlowFixMe[prop-missing]\n        k[I]\n      );\n      b -= x - i.height, b *= l ? 1 : -1;\n    }\n    if (n === J || (n === Q || n === dt) && o === Ke) {\n      E = ut;\n      var L = _ && k === A && A.visualViewport ? A.visualViewport.width : (\n        // $FlowFixMe[prop-missing]\n        k[O]\n      );\n      g -= L - i.width, g *= l ? 1 : -1;\n    }\n  }\n  var S = Object.assign({\n    position: a\n  }, p && dd), N = u === !0 ? ud({\n    x: g,\n    y: b\n  }, pt(e)) : {\n    x: g,\n    y: b\n  };\n  if (g = N.x, b = N.y, l) {\n    var P;\n    return Object.assign({}, S, (P = {}, P[T] = w ? \"0\" : \"\", P[E] = C ? \"0\" : \"\", P.transform = (A.devicePixelRatio || 1) <= 1 ? \"translate(\" + g + \"px, \" + b + \"px)\" : \"translate3d(\" + g + \"px, \" + b + \"px, 0)\", P));\n  }\n  return Object.assign({}, S, (t = {}, t[T] = w ? b + \"px\" : \"\", t[E] = C ? g + \"px\" : \"\", t.transform = \"\", t));\n}\nfunction pd(s) {\n  var t = s.state, e = s.options, i = e.gpuAcceleration, n = i === void 0 ? !0 : i, o = e.adaptive, r = o === void 0 ? !0 : o, a = e.roundOffsets, l = a === void 0 ? !0 : a;\n  if ({}.NODE_ENV !== \"production\") {\n    var p = Ct(t.elements.popper).transitionProperty || \"\";\n    r && [\"transform\", \"top\", \"right\", \"bottom\", \"left\"].some(function(_) {\n      return p.indexOf(_) >= 0;\n    }) && console.warn([\"Popper: Detected CSS transitions on at least one of the following\", 'CSS properties: \"transform\", \"top\", \"right\", \"bottom\", \"left\".', `\n\n`, 'Disable the \"computeStyles\" modifier\\'s `adaptive` option to allow', \"for smooth transitions, or remove these properties from the CSS\", \"transition declaration on the popper element if only transitioning\", \"opacity or background-color for example.\", `\n\n`, \"We recommend using the popper element as a wrapper around an inner\", \"element that can have any CSS property transitioned for animations.\"].join(\" \"));\n  }\n  var u = {\n    placement: Tt(t.placement),\n    variation: Xe(t.placement),\n    popper: t.elements.popper,\n    popperRect: t.rects.popper,\n    gpuAcceleration: n,\n    isFixed: t.options.strategy === \"fixed\"\n  };\n  t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign({}, t.styles.popper, Ir(Object.assign({}, u, {\n    offsets: t.modifiersData.popperOffsets,\n    position: t.options.strategy,\n    adaptive: r,\n    roundOffsets: l\n  })))), t.modifiersData.arrow != null && (t.styles.arrow = Object.assign({}, t.styles.arrow, Ir(Object.assign({}, u, {\n    offsets: t.modifiersData.arrow,\n    position: \"absolute\",\n    adaptive: !1,\n    roundOffsets: l\n  })))), t.attributes.popper = Object.assign({}, t.attributes.popper, {\n    \"data-popper-placement\": t.placement\n  });\n}\nconst sr = {\n  name: \"computeStyles\",\n  enabled: !0,\n  phase: \"beforeWrite\",\n  fn: pd,\n  data: {}\n};\nvar ts = {\n  passive: !0\n};\nfunction _d(s) {\n  var t = s.state, e = s.instance, i = s.options, n = i.scroll, o = n === void 0 ? !0 : n, r = i.resize, a = r === void 0 ? !0 : r, l = pt(t.elements.popper), p = [].concat(t.scrollParents.reference, t.scrollParents.popper);\n  return o && p.forEach(function(u) {\n    u.addEventListener(\"scroll\", e.update, ts);\n  }), a && l.addEventListener(\"resize\", e.update, ts), function() {\n    o && p.forEach(function(u) {\n      u.removeEventListener(\"scroll\", e.update, ts);\n    }), a && l.removeEventListener(\"resize\", e.update, ts);\n  };\n}\nconst nr = {\n  name: \"eventListeners\",\n  enabled: !0,\n  phase: \"write\",\n  fn: function() {\n  },\n  effect: _d,\n  data: {}\n};\nvar fd = {\n  left: \"right\",\n  right: \"left\",\n  bottom: \"top\",\n  top: \"bottom\"\n};\nfunction Ms(s) {\n  return s.replace(/left|right|bottom|top/g, function(t) {\n    return fd[t];\n  });\n}\nvar md = {\n  start: \"end\",\n  end: \"start\"\n};\nfunction Dr(s) {\n  return s.replace(/start|end/g, function(t) {\n    return md[t];\n  });\n}\nfunction or(s) {\n  var t = pt(s), e = t.pageXOffset, i = t.pageYOffset;\n  return {\n    scrollLeft: e,\n    scrollTop: i\n  };\n}\nfunction rr(s) {\n  return Ue(ee(s)).left + or(s).scrollLeft;\n}\nfunction gd(s, t) {\n  var e = pt(s), i = ee(s), n = e.visualViewport, o = i.clientWidth, r = i.clientHeight, a = 0, l = 0;\n  if (n) {\n    o = n.width, r = n.height;\n    var p = bc();\n    (p || !p && t === \"fixed\") && (a = n.offsetLeft, l = n.offsetTop);\n  }\n  return {\n    width: o,\n    height: r,\n    x: a + rr(s),\n    y: l\n  };\n}\nfunction bd(s) {\n  var t, e = ee(s), i = or(s), n = (t = s.ownerDocument) == null ? void 0 : t.body, o = be(e.scrollWidth, e.clientWidth, n ? n.scrollWidth : 0, n ? n.clientWidth : 0), r = be(e.scrollHeight, e.clientHeight, n ? n.scrollHeight : 0, n ? n.clientHeight : 0), a = -i.scrollLeft + rr(s), l = -i.scrollTop;\n  return Ct(n || e).direction === \"rtl\" && (a += be(e.clientWidth, n ? n.clientWidth : 0) - o), {\n    width: o,\n    height: r,\n    x: a,\n    y: l\n  };\n}\nfunction ar(s) {\n  var t = Ct(s), e = t.overflow, i = t.overflowX, n = t.overflowY;\n  return /auto|scroll|overlay|hidden/.test(e + n + i);\n}\nfunction yc(s) {\n  return [\"html\", \"body\", \"#document\"].indexOf(Mt(s)) >= 0 ? s.ownerDocument.body : ht(s) && ar(s) ? s : yc(rn(s));\n}\nfunction Ii(s, t) {\n  var e;\n  t === void 0 && (t = []);\n  var i = yc(s), n = i === ((e = s.ownerDocument) == null ? void 0 : e.body), o = pt(i), r = n ? [o].concat(o.visualViewport || [], ar(i) ? i : []) : i, a = t.concat(r);\n  return n ? a : (\n    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here\n    a.concat(Ii(rn(r)))\n  );\n}\nfunction Do(s) {\n  return Object.assign({}, s, {\n    left: s.x,\n    top: s.y,\n    right: s.x + s.width,\n    bottom: s.y + s.height\n  });\n}\nfunction vd(s, t) {\n  var e = Ue(s, !1, t === \"fixed\");\n  return e.top = e.top + s.clientTop, e.left = e.left + s.clientLeft, e.bottom = e.top + s.clientHeight, e.right = e.left + s.clientWidth, e.width = s.clientWidth, e.height = s.clientHeight, e.x = e.left, e.y = e.top, e;\n}\nfunction $r(s, t, e) {\n  return t === Zo ? Do(gd(s, e)) : Ee(t) ? vd(t, e) : Do(bd(ee(s)));\n}\nfunction Td(s) {\n  var t = Ii(rn(s)), e = [\"absolute\", \"fixed\"].indexOf(Ct(s).position) >= 0, i = e && ht(s) ? Vi(s) : s;\n  return Ee(i) ? t.filter(function(n) {\n    return Ee(n) && vc(n, i) && Mt(n) !== \"body\";\n  }) : [];\n}\nfunction Ed(s, t, e, i) {\n  var n = t === \"clippingParents\" ? Td(s) : [].concat(t), o = [].concat(n, [e]), r = o[0], a = o.reduce(function(l, p) {\n    var u = $r(s, p, i);\n    return l.top = be(u.top, l.top), l.right = sn(u.right, l.right), l.bottom = sn(u.bottom, l.bottom), l.left = be(u.left, l.left), l;\n  }, $r(s, r, i));\n  return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a;\n}\nfunction wc(s) {\n  var t = s.reference, e = s.element, i = s.placement, n = i ? Tt(i) : null, o = i ? Xe(i) : null, r = t.x + t.width / 2 - e.width / 2, a = t.y + t.height / 2 - e.height / 2, l;\n  switch (n) {\n    case Q:\n      l = {\n        x: r,\n        y: t.y - e.height\n      };\n      break;\n    case dt:\n      l = {\n        x: r,\n        y: t.y + t.height\n      };\n      break;\n    case ut:\n      l = {\n        x: t.x + t.width,\n        y: a\n      };\n      break;\n    case J:\n      l = {\n        x: t.x - e.width,\n        y: a\n      };\n      break;\n    default:\n      l = {\n        x: t.x,\n        y: t.y\n      };\n  }\n  var p = n ? ir(n) : null;\n  if (p != null) {\n    var u = p === \"y\" ? \"height\" : \"width\";\n    switch (o) {\n      case Te:\n        l[p] = l[p] - (t[u] / 2 - e[u] / 2);\n        break;\n      case Ke:\n        l[p] = l[p] + (t[u] / 2 - e[u] / 2);\n        break;\n    }\n  }\n  return l;\n}\nfunction Ge(s, t) {\n  t === void 0 && (t = {});\n  var e = t, i = e.placement, n = i === void 0 ? s.placement : i, o = e.strategy, r = o === void 0 ? s.strategy : o, a = e.boundary, l = a === void 0 ? ac : a, p = e.rootBoundary, u = p === void 0 ? Zo : p, _ = e.elementContext, f = _ === void 0 ? $e : _, g = e.altBoundary, m = g === void 0 ? !1 : g, b = e.padding, v = b === void 0 ? 0 : b, C = Ec(typeof v != \"number\" ? v : Cc(v, ti)), w = f === $e ? lc : $e, E = s.rects.popper, T = s.elements[m ? w : f], A = Ed(Ee(T) ? T : T.contextElement || ee(s.elements.popper), l, u, r), k = Ue(s.elements.reference), I = wc({\n    reference: k,\n    element: E,\n    strategy: \"absolute\",\n    placement: n\n  }), O = Do(Object.assign({}, E, I)), x = f === $e ? O : k, L = {\n    top: A.top - x.top + C.top,\n    bottom: x.bottom - A.bottom + C.bottom,\n    left: A.left - x.left + C.left,\n    right: x.right - A.right + C.right\n  }, S = s.modifiersData.offset;\n  if (f === $e && S) {\n    var N = S[n];\n    Object.keys(L).forEach(function(P) {\n      var tt = [ut, dt].indexOf(P) >= 0 ? 1 : -1, et = [Q, dt].indexOf(P) >= 0 ? \"y\" : \"x\";\n      L[P] += N[et] * tt;\n    });\n  }\n  return L;\n}\nfunction Cd(s, t) {\n  t === void 0 && (t = {});\n  var e = t, i = e.placement, n = e.boundary, o = e.rootBoundary, r = e.padding, a = e.flipVariations, l = e.allowedAutoPlacements, p = l === void 0 ? Qo : l, u = Xe(i), _ = u ? a ? So : So.filter(function(m) {\n    return Xe(m) === u;\n  }) : ti, f = _.filter(function(m) {\n    return p.indexOf(m) >= 0;\n  });\n  f.length === 0 && (f = _, {}.NODE_ENV !== \"production\" && console.error([\"Popper: The `allowedAutoPlacements` option did not allow any\", \"placements. Ensure the `placement` option matches the variation\", \"of the allowed placements.\", 'For example, \"auto\" cannot be used to allow \"bottom-start\".', 'Use \"auto-start\" instead.'].join(\" \")));\n  var g = f.reduce(function(m, b) {\n    return m[b] = Ge(s, {\n      placement: b,\n      boundary: n,\n      rootBoundary: o,\n      padding: r\n    })[Tt(b)], m;\n  }, {});\n  return Object.keys(g).sort(function(m, b) {\n    return g[m] - g[b];\n  });\n}\nfunction Ad(s) {\n  if (Tt(s) === Hi)\n    return [];\n  var t = Ms(s);\n  return [Dr(s), t, Dr(t)];\n}\nfunction yd(s) {\n  var t = s.state, e = s.options, i = s.name;\n  if (!t.modifiersData[i]._skip) {\n    for (var n = e.mainAxis, o = n === void 0 ? !0 : n, r = e.altAxis, a = r === void 0 ? !0 : r, l = e.fallbackPlacements, p = e.padding, u = e.boundary, _ = e.rootBoundary, f = e.altBoundary, g = e.flipVariations, m = g === void 0 ? !0 : g, b = e.allowedAutoPlacements, v = t.options.placement, C = Tt(v), w = C === v, E = l || (w || !m ? [Ms(v)] : Ad(v)), T = [v].concat(E).reduce(function(ye, Ht) {\n      return ye.concat(Tt(Ht) === Hi ? Cd(t, {\n        placement: Ht,\n        boundary: u,\n        rootBoundary: _,\n        padding: p,\n        flipVariations: m,\n        allowedAutoPlacements: b\n      }) : Ht);\n    }, []), A = t.rects.reference, k = t.rects.popper, I = /* @__PURE__ */ new Map(), O = !0, x = T[0], L = 0; L < T.length; L++) {\n      var S = T[L], N = Tt(S), P = Xe(S) === Te, tt = [Q, dt].indexOf(N) >= 0, et = tt ? \"width\" : \"height\", U = Ge(t, {\n        placement: S,\n        boundary: u,\n        rootBoundary: _,\n        altBoundary: f,\n        padding: p\n      }), bt = tt ? P ? ut : J : P ? dt : Q;\n      A[et] > k[et] && (bt = Ms(bt));\n      var Gi = Ms(bt), se = [];\n      if (o && se.push(U[N] <= 0), a && se.push(U[bt] <= 0, U[Gi] <= 0), se.every(function(ye) {\n        return ye;\n      })) {\n        x = S, O = !1;\n        break;\n      }\n      I.set(S, se);\n    }\n    if (O)\n      for (var qi = m ? 3 : 1, mn = function(Ht) {\n        var ri = T.find(function(Qi) {\n          var ne = I.get(Qi);\n          if (ne)\n            return ne.slice(0, Ht).every(function(gn) {\n              return gn;\n            });\n        });\n        if (ri)\n          return x = ri, \"break\";\n      }, oi = qi; oi > 0; oi--) {\n        var Zi = mn(oi);\n        if (Zi === \"break\")\n          break;\n      }\n    t.placement !== x && (t.modifiersData[i]._skip = !0, t.placement = x, t.reset = !0);\n  }\n}\nconst kc = {\n  name: \"flip\",\n  enabled: !0,\n  phase: \"main\",\n  fn: yd,\n  requiresIfExists: [\"offset\"],\n  data: {\n    _skip: !1\n  }\n};\nfunction Lr(s, t, e) {\n  return e === void 0 && (e = {\n    x: 0,\n    y: 0\n  }), {\n    top: s.top - t.height - e.y,\n    right: s.right - t.width + e.x,\n    bottom: s.bottom - t.height + e.y,\n    left: s.left - t.width - e.x\n  };\n}\nfunction Nr(s) {\n  return [Q, ut, dt, J].some(function(t) {\n    return s[t] >= 0;\n  });\n}\nfunction wd(s) {\n  var t = s.state, e = s.name, i = t.rects.reference, n = t.rects.popper, o = t.modifiersData.preventOverflow, r = Ge(t, {\n    elementContext: \"reference\"\n  }), a = Ge(t, {\n    altBoundary: !0\n  }), l = Lr(r, i), p = Lr(a, n, o), u = Nr(l), _ = Nr(p);\n  t.modifiersData[e] = {\n    referenceClippingOffsets: l,\n    popperEscapeOffsets: p,\n    isReferenceHidden: u,\n    hasPopperEscaped: _\n  }, t.attributes.popper = Object.assign({}, t.attributes.popper, {\n    \"data-popper-reference-hidden\": u,\n    \"data-popper-escaped\": _\n  });\n}\nconst xc = {\n  name: \"hide\",\n  enabled: !0,\n  phase: \"main\",\n  requiresIfExists: [\"preventOverflow\"],\n  fn: wd\n};\nfunction kd(s, t, e) {\n  var i = Tt(s), n = [J, Q].indexOf(i) >= 0 ? -1 : 1, o = typeof e == \"function\" ? e(Object.assign({}, t, {\n    placement: s\n  })) : e, r = o[0], a = o[1];\n  return r = r || 0, a = (a || 0) * n, [J, ut].indexOf(i) >= 0 ? {\n    x: a,\n    y: r\n  } : {\n    x: r,\n    y: a\n  };\n}\nfunction xd(s) {\n  var t = s.state, e = s.options, i = s.name, n = e.offset, o = n === void 0 ? [0, 0] : n, r = Qo.reduce(function(u, _) {\n    return u[_] = kd(_, t.rects, o), u;\n  }, {}), a = r[t.placement], l = a.x, p = a.y;\n  t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += l, t.modifiersData.popperOffsets.y += p), t.modifiersData[i] = r;\n}\nconst Oc = {\n  name: \"offset\",\n  enabled: !0,\n  phase: \"main\",\n  requires: [\"popperOffsets\"],\n  fn: xd\n};\nfunction Od(s) {\n  var t = s.state, e = s.name;\n  t.modifiersData[e] = wc({\n    reference: t.rects.reference,\n    element: t.rects.popper,\n    strategy: \"absolute\",\n    placement: t.placement\n  });\n}\nconst lr = {\n  name: \"popperOffsets\",\n  enabled: !0,\n  phase: \"read\",\n  fn: Od,\n  data: {}\n};\nfunction Sd(s) {\n  return s === \"x\" ? \"y\" : \"x\";\n}\nfunction Id(s) {\n  var t = s.state, e = s.options, i = s.name, n = e.mainAxis, o = n === void 0 ? !0 : n, r = e.altAxis, a = r === void 0 ? !1 : r, l = e.boundary, p = e.rootBoundary, u = e.altBoundary, _ = e.padding, f = e.tether, g = f === void 0 ? !0 : f, m = e.tetherOffset, b = m === void 0 ? 0 : m, v = Ge(t, {\n    boundary: l,\n    rootBoundary: p,\n    padding: _,\n    altBoundary: u\n  }), C = Tt(t.placement), w = Xe(t.placement), E = !w, T = ir(C), A = Sd(T), k = t.modifiersData.popperOffsets, I = t.rects.reference, O = t.rects.popper, x = typeof b == \"function\" ? b(Object.assign({}, t.rects, {\n    placement: t.placement\n  })) : b, L = typeof x == \"number\" ? {\n    mainAxis: x,\n    altAxis: x\n  } : Object.assign({\n    mainAxis: 0,\n    altAxis: 0\n  }, x), S = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null, N = {\n    x: 0,\n    y: 0\n  };\n  if (k) {\n    if (o) {\n      var P, tt = T === \"y\" ? Q : J, et = T === \"y\" ? dt : ut, U = T === \"y\" ? \"height\" : \"width\", bt = k[T], Gi = bt + v[tt], se = bt - v[et], qi = g ? -O[U] / 2 : 0, mn = w === Te ? I[U] : O[U], oi = w === Te ? -O[U] : -I[U], Zi = t.elements.arrow, ye = g && Zi ? er(Zi) : {\n        width: 0,\n        height: 0\n      }, Ht = t.modifiersData[\"arrow#persistent\"] ? t.modifiersData[\"arrow#persistent\"].padding : Tc(), ri = Ht[tt], Qi = Ht[et], ne = Si(0, I[U], ye[U]), gn = E ? I[U] / 2 - qi - ne - ri - L.mainAxis : mn - ne - ri - L.mainAxis, Lh = E ? -I[U] / 2 + qi + ne + Qi + L.mainAxis : oi + ne + Qi + L.mainAxis, bn = t.elements.arrow && Vi(t.elements.arrow), Nh = bn ? T === \"y\" ? bn.clientTop || 0 : bn.clientLeft || 0 : 0, br = (P = S == null ? void 0 : S[T]) != null ? P : 0, Mh = bt + gn - br - Nh, Rh = bt + Lh - br, vr = Si(g ? sn(Gi, Mh) : Gi, bt, g ? be(se, Rh) : se);\n      k[T] = vr, N[T] = vr - bt;\n    }\n    if (a) {\n      var Tr, Ph = T === \"x\" ? Q : J, Bh = T === \"x\" ? dt : ut, oe = k[A], Ji = A === \"y\" ? \"height\" : \"width\", Er = oe + v[Ph], Cr = oe - v[Bh], vn = [Q, J].indexOf(C) !== -1, Ar = (Tr = S == null ? void 0 : S[A]) != null ? Tr : 0, yr = vn ? Er : oe - I[Ji] - O[Ji] - Ar + L.altAxis, wr = vn ? oe + I[Ji] + O[Ji] - Ar - L.altAxis : Cr, kr = g && vn ? ad(yr, oe, wr) : Si(g ? yr : Er, oe, g ? wr : Cr);\n      k[A] = kr, N[A] = kr - oe;\n    }\n    t.modifiersData[i] = N;\n  }\n}\nconst Sc = {\n  name: \"preventOverflow\",\n  enabled: !0,\n  phase: \"main\",\n  fn: Id,\n  requiresIfExists: [\"offset\"]\n};\nfunction Dd(s) {\n  return {\n    scrollLeft: s.scrollLeft,\n    scrollTop: s.scrollTop\n  };\n}\nfunction $d(s) {\n  return s === pt(s) || !ht(s) ? or(s) : Dd(s);\n}\nfunction Ld(s) {\n  var t = s.getBoundingClientRect(), e = ze(t.width) / s.offsetWidth || 1, i = ze(t.height) / s.offsetHeight || 1;\n  return e !== 1 || i !== 1;\n}\nfunction Nd(s, t, e) {\n  e === void 0 && (e = !1);\n  var i = ht(t), n = ht(t) && Ld(t), o = ee(t), r = Ue(s, n, e), a = {\n    scrollLeft: 0,\n    scrollTop: 0\n  }, l = {\n    x: 0,\n    y: 0\n  };\n  return (i || !i && !e) && ((Mt(t) !== \"body\" || // https://github.com/popperjs/popper-core/issues/1078\n  ar(o)) && (a = $d(t)), ht(t) ? (l = Ue(t, !0), l.x += t.clientLeft, l.y += t.clientTop) : o && (l.x = rr(o))), {\n    x: r.left + a.scrollLeft - l.x,\n    y: r.top + a.scrollTop - l.y,\n    width: r.width,\n    height: r.height\n  };\n}\nfunction Md(s) {\n  var t = /* @__PURE__ */ new Map(), e = /* @__PURE__ */ new Set(), i = [];\n  s.forEach(function(o) {\n    t.set(o.name, o);\n  });\n  function n(o) {\n    e.add(o.name);\n    var r = [].concat(o.requires || [], o.requiresIfExists || []);\n    r.forEach(function(a) {\n      if (!e.has(a)) {\n        var l = t.get(a);\n        l && n(l);\n      }\n    }), i.push(o);\n  }\n  return s.forEach(function(o) {\n    e.has(o.name) || n(o);\n  }), i;\n}\nfunction Rd(s) {\n  var t = Md(s);\n  return en.reduce(function(e, i) {\n    return e.concat(t.filter(function(n) {\n      return n.phase === i;\n    }));\n  }, []);\n}\nfunction Pd(s) {\n  var t;\n  return function() {\n    return t || (t = new Promise(function(e) {\n      Promise.resolve().then(function() {\n        t = void 0, e(s());\n      });\n    })), t;\n  };\n}\nfunction Vt(s) {\n  for (var t = arguments.length, e = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)\n    e[i - 1] = arguments[i];\n  return [].concat(e).reduce(function(n, o) {\n    return n.replace(/%s/, o);\n  }, s);\n}\nvar ae = 'Popper: modifier \"%s\" provided an invalid %s property, expected %s but got %s', Bd = 'Popper: modifier \"%s\" requires \"%s\", but \"%s\" modifier is not available', Mr = [\"name\", \"enabled\", \"phase\", \"fn\", \"effect\", \"requires\", \"options\"];\nfunction Hd(s) {\n  s.forEach(function(t) {\n    [].concat(Object.keys(t), Mr).filter(function(e, i, n) {\n      return n.indexOf(e) === i;\n    }).forEach(function(e) {\n      switch (e) {\n        case \"name\":\n          typeof t.name != \"string\" && console.error(Vt(ae, String(t.name), '\"name\"', '\"string\"', '\"' + String(t.name) + '\"'));\n          break;\n        case \"enabled\":\n          typeof t.enabled != \"boolean\" && console.error(Vt(ae, t.name, '\"enabled\"', '\"boolean\"', '\"' + String(t.enabled) + '\"'));\n          break;\n        case \"phase\":\n          en.indexOf(t.phase) < 0 && console.error(Vt(ae, t.name, '\"phase\"', \"either \" + en.join(\", \"), '\"' + String(t.phase) + '\"'));\n          break;\n        case \"fn\":\n          typeof t.fn != \"function\" && console.error(Vt(ae, t.name, '\"fn\"', '\"function\"', '\"' + String(t.fn) + '\"'));\n          break;\n        case \"effect\":\n          t.effect != null && typeof t.effect != \"function\" && console.error(Vt(ae, t.name, '\"effect\"', '\"function\"', '\"' + String(t.fn) + '\"'));\n          break;\n        case \"requires\":\n          t.requires != null && !Array.isArray(t.requires) && console.error(Vt(ae, t.name, '\"requires\"', '\"array\"', '\"' + String(t.requires) + '\"'));\n          break;\n        case \"requiresIfExists\":\n          Array.isArray(t.requiresIfExists) || console.error(Vt(ae, t.name, '\"requiresIfExists\"', '\"array\"', '\"' + String(t.requiresIfExists) + '\"'));\n          break;\n        case \"options\":\n        case \"data\":\n          break;\n        default:\n          console.error('PopperJS: an invalid property has been provided to the \"' + t.name + '\" modifier, valid properties are ' + Mr.map(function(i) {\n            return '\"' + i + '\"';\n          }).join(\", \") + '; but \"' + e + '\" was provided.');\n      }\n      t.requires && t.requires.forEach(function(i) {\n        s.find(function(n) {\n          return n.name === i;\n        }) == null && console.error(Vt(Bd, String(t.name), i, i));\n      });\n    });\n  });\n}\nfunction Vd(s, t) {\n  var e = /* @__PURE__ */ new Set();\n  return s.filter(function(i) {\n    var n = t(i);\n    if (!e.has(n))\n      return e.add(n), !0;\n  });\n}\nfunction Wd(s) {\n  var t = s.reduce(function(e, i) {\n    var n = e[i.name];\n    return e[i.name] = n ? Object.assign({}, n, i, {\n      options: Object.assign({}, n.options, i.options),\n      data: Object.assign({}, n.data, i.data)\n    }) : i, e;\n  }, {});\n  return Object.keys(t).map(function(e) {\n    return t[e];\n  });\n}\nvar Rr = \"Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.\", Fd = \"Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.\", Pr = {\n  placement: \"bottom\",\n  modifiers: [],\n  strategy: \"absolute\"\n};\nfunction Br() {\n  for (var s = arguments.length, t = new Array(s), e = 0; e < s; e++)\n    t[e] = arguments[e];\n  return !t.some(function(i) {\n    return !(i && typeof i.getBoundingClientRect == \"function\");\n  });\n}\nfunction an(s) {\n  s === void 0 && (s = {});\n  var t = s, e = t.defaultModifiers, i = e === void 0 ? [] : e, n = t.defaultOptions, o = n === void 0 ? Pr : n;\n  return function(a, l, p) {\n    p === void 0 && (p = o);\n    var u = {\n      placement: \"bottom\",\n      orderedModifiers: [],\n      options: Object.assign({}, Pr, o),\n      modifiersData: {},\n      elements: {\n        reference: a,\n        popper: l\n      },\n      attributes: {},\n      styles: {}\n    }, _ = [], f = !1, g = {\n      state: u,\n      setOptions: function(C) {\n        var w = typeof C == \"function\" ? C(u.options) : C;\n        b(), u.options = Object.assign({}, o, u.options, w), u.scrollParents = {\n          reference: Ee(a) ? Ii(a) : a.contextElement ? Ii(a.contextElement) : [],\n          popper: Ii(l)\n        };\n        var E = Rd(Wd([].concat(i, u.options.modifiers)));\n        if (u.orderedModifiers = E.filter(function(S) {\n          return S.enabled;\n        }), {}.NODE_ENV !== \"production\") {\n          var T = Vd([].concat(E, u.options.modifiers), function(S) {\n            var N = S.name;\n            return N;\n          });\n          if (Hd(T), Tt(u.options.placement) === Hi) {\n            var A = u.orderedModifiers.find(function(S) {\n              var N = S.name;\n              return N === \"flip\";\n            });\n            A || console.error(['Popper: \"auto\" placements require the \"flip\" modifier be', \"present and enabled to work.\"].join(\" \"));\n          }\n          var k = Ct(l), I = k.marginTop, O = k.marginRight, x = k.marginBottom, L = k.marginLeft;\n          [I, O, x, L].some(function(S) {\n            return parseFloat(S);\n          }) && console.warn(['Popper: CSS \"margin\" styles cannot be used to apply padding', \"between the popper and its reference element or boundary.\", \"To replicate margin, use the `offset` modifier, as well as\", \"the `padding` option in the `preventOverflow` and `flip`\", \"modifiers.\"].join(\" \"));\n        }\n        return m(), g.update();\n      },\n      // Sync update â it will always be executed, even if not necessary. This\n      // is useful for low frequency updates where sync behavior simplifies the\n      // logic.\n      // For high frequency updates (e.g. `resize` and `scroll` events), always\n      // prefer the async Popper#update method\n      forceUpdate: function() {\n        if (!f) {\n          var C = u.elements, w = C.reference, E = C.popper;\n          if (!Br(w, E)) {\n            ({}).NODE_ENV !== \"production\" && console.error(Rr);\n            return;\n          }\n          u.rects = {\n            reference: Nd(w, Vi(E), u.options.strategy === \"fixed\"),\n            popper: er(E)\n          }, u.reset = !1, u.placement = u.options.placement, u.orderedModifiers.forEach(function(S) {\n            return u.modifiersData[S.name] = Object.assign({}, S.data);\n          });\n          for (var T = 0, A = 0; A < u.orderedModifiers.length; A++) {\n            if ({}.NODE_ENV !== \"production\" && (T += 1, T > 100)) {\n              console.error(Fd);\n              break;\n            }\n            if (u.reset === !0) {\n              u.reset = !1, A = -1;\n              continue;\n            }\n            var k = u.orderedModifiers[A], I = k.fn, O = k.options, x = O === void 0 ? {} : O, L = k.name;\n            typeof I == \"function\" && (u = I({\n              state: u,\n              options: x,\n              name: L,\n              instance: g\n            }) || u);\n          }\n        }\n      },\n      // Async and optimistically optimized update â it will not be executed if\n      // not necessary (debounced to run at most once-per-tick)\n      update: Pd(function() {\n        return new Promise(function(v) {\n          g.forceUpdate(), v(u);\n        });\n      }),\n      destroy: function() {\n        b(), f = !0;\n      }\n    };\n    if (!Br(a, l))\n      return {}.NODE_ENV !== \"production\" && console.error(Rr), g;\n    g.setOptions(p).then(function(v) {\n      !f && p.onFirstUpdate && p.onFirstUpdate(v);\n    });\n    function m() {\n      u.orderedModifiers.forEach(function(v) {\n        var C = v.name, w = v.options, E = w === void 0 ? {} : w, T = v.effect;\n        if (typeof T == \"function\") {\n          var A = T({\n            state: u,\n            name: C,\n            instance: g,\n            options: E\n          }), k = function() {\n          };\n          _.push(A || k);\n        }\n      });\n    }\n    function b() {\n      _.forEach(function(v) {\n        return v();\n      }), _ = [];\n    }\n    return g;\n  };\n}\nvar Yd = /* @__PURE__ */ an(), jd = [nr, lr, sr, tr], Kd = /* @__PURE__ */ an({\n  defaultModifiers: jd\n}), zd = [nr, lr, sr, tr, Oc, kc, Sc, Ac, xc], Ce = /* @__PURE__ */ an({\n  defaultModifiers: zd\n});\nconst Ic = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  afterMain: _c,\n  afterRead: dc,\n  afterWrite: gc,\n  applyStyles: tr,\n  arrow: Ac,\n  auto: Hi,\n  basePlacements: ti,\n  beforeMain: uc,\n  beforeRead: cc,\n  beforeWrite: fc,\n  bottom: dt,\n  clippingParents: ac,\n  computeStyles: sr,\n  createPopper: Ce,\n  createPopperBase: Yd,\n  createPopperLite: Kd,\n  detectOverflow: Ge,\n  end: Ke,\n  eventListeners: nr,\n  flip: kc,\n  hide: xc,\n  left: J,\n  main: pc,\n  modifierPhases: en,\n  offset: Oc,\n  placements: Qo,\n  popper: $e,\n  popperGenerator: an,\n  popperOffsets: lr,\n  preventOverflow: Sc,\n  read: hc,\n  reference: lc,\n  right: ut,\n  start: Te,\n  top: Q,\n  variationPlacements: So,\n  viewport: Zo,\n  write: mc\n}, Symbol.toStringTag, { value: \"Module\" }));\nfunction An(s) {\n  return s === \"true\" ? !0 : s === \"false\" ? !1 : s === Number(s).toString() ? Number(s) : s === \"\" || s === \"null\" ? null : s;\n}\nfunction yn(s) {\n  return s.replace(/[A-Z]/g, (t) => `-${t.toLowerCase()}`);\n}\nconst h = {\n  setDataAttribute(s, t, e) {\n    s.setAttribute(`data-te-${yn(t)}`, e);\n  },\n  removeDataAttribute(s, t) {\n    s.removeAttribute(`data-te-${yn(t)}`);\n  },\n  getDataAttributes(s) {\n    if (!s)\n      return {};\n    const t = {};\n    return Object.keys(s.dataset).filter((e) => e.startsWith(\"te\")).forEach((e) => {\n      if (e.startsWith(\"teClass\"))\n        return;\n      let i = e.replace(/^te/, \"\");\n      i = i.charAt(0).toLowerCase() + i.slice(1, i.length), t[i] = An(s.dataset[e]);\n    }), t;\n  },\n  getDataClassAttributes(s) {\n    if (!s)\n      return {};\n    const t = {\n      ...s.dataset\n    };\n    return Object.keys(t).filter((e) => e.startsWith(\"teClass\")).forEach((e) => {\n      let i = e.replace(/^teClass/, \"\");\n      i = i.charAt(0).toLowerCase() + i.slice(1, i.length), t[i] = An(t[e]);\n    }), t;\n  },\n  getDataAttribute(s, t) {\n    return An(\n      s.getAttribute(`data-te-${yn(t)}`)\n    );\n  },\n  offset(s) {\n    const t = s.getBoundingClientRect();\n    return {\n      top: t.top + document.body.scrollTop,\n      left: t.left + document.body.scrollLeft\n    };\n  },\n  position(s) {\n    return {\n      top: s.offsetTop,\n      left: s.offsetLeft\n    };\n  },\n  style(s, t) {\n    Object.assign(s.style, t);\n  },\n  toggleClass(s, t) {\n    s && wn(t).forEach((e) => {\n      s.classList.contains(e) ? s.classList.remove(e) : s.classList.add(e);\n    });\n  },\n  addClass(s, t) {\n    wn(t).forEach(\n      (e) => !s.classList.contains(e) && s.classList.add(e)\n    );\n  },\n  addStyle(s, t) {\n    Object.keys(t).forEach((e) => {\n      s.style[e] = t[e];\n    });\n  },\n  removeClass(s, t) {\n    wn(t).forEach(\n      (e) => s.classList.contains(e) && s.classList.remove(e)\n    );\n  },\n  hasClass(s, t) {\n    return s.classList.contains(t);\n  },\n  maxOffset(s) {\n    const t = s.getBoundingClientRect();\n    return {\n      top: t.top + Math.max(\n        document.body.scrollTop,\n        document.documentElement.scrollTop,\n        window.scrollY\n      ),\n      left: t.left + Math.max(\n        document.body.scrollLeft,\n        document.documentElement.scrollLeft,\n        window.scrollX\n      )\n    };\n  }\n};\nfunction wn(s) {\n  return typeof s == \"string\" ? s.split(\" \") : Array.isArray(s) ? s : !1;\n}\nconst Ud = 3, d = {\n  closest(s, t) {\n    return s.closest(t);\n  },\n  matches(s, t) {\n    return s.matches(t);\n  },\n  find(s, t = document.documentElement) {\n    return [].concat(\n      ...Element.prototype.querySelectorAll.call(t, s)\n    );\n  },\n  findOne(s, t = document.documentElement) {\n    return Element.prototype.querySelector.call(t, s);\n  },\n  children(s, t) {\n    return [].concat(...s.children).filter((i) => i.matches(t));\n  },\n  parents(s, t) {\n    const e = [];\n    let i = s.parentNode;\n    for (; i && i.nodeType === Node.ELEMENT_NODE && i.nodeType !== Ud; )\n      this.matches(i, t) && e.push(i), i = i.parentNode;\n    return e;\n  },\n  prev(s, t) {\n    let e = s.previousElementSibling;\n    for (; e; ) {\n      if (e.matches(t))\n        return [e];\n      e = e.previousElementSibling;\n    }\n    return [];\n  },\n  next(s, t) {\n    let e = s.nextElementSibling;\n    for (; e; ) {\n      if (this.matches(e, t))\n        return [e];\n      e = e.nextElementSibling;\n    }\n    return [];\n  },\n  focusableChildren(s) {\n    const t = [\n      \"a\",\n      \"button\",\n      \"input\",\n      \"textarea\",\n      \"select\",\n      \"details\",\n      \"[tabindex]\",\n      '[contenteditable=\"true\"]'\n    ].map((e) => `${e}:not([tabindex^=\"-\"])`).join(\", \");\n    return this.find(t, s).filter(\n      (e) => !ge(e) && Nt(e)\n    );\n  }\n}, kn = \"dropdown\", Xd = \"te.dropdown\", Ae = `.${Xd}`, cr = \".data-api\", Rs = \"Escape\", Hr = \"Space\", Vr = \"Tab\", $o = \"ArrowUp\", Ps = \"ArrowDown\", Gd = 2, qd = new RegExp(\n  `${$o}|${Ps}|${Rs}`\n), Zd = `hide${Ae}`, Qd = `hidden${Ae}`, Jd = `show${Ae}`, tu = `shown${Ae}`, eu = `click${Ae}${cr}`, Wr = `keydown${Ae}${cr}`, iu = `keyup${Ae}${cr}`, Wt = \"show\", su = \"dropup\", nu = \"dropend\", ou = \"dropstart\", ru = \"[data-te-navbar-ref]\", es = \"[data-te-dropdown-toggle-ref]\", xn = \"[data-te-dropdown-menu-ref]\", au = \"[data-te-navbar-nav-ref]\", lu = \"[data-te-dropdown-menu-ref] [data-te-dropdown-item-ref]:not(.disabled):not(:disabled)\", cu = F() ? \"top-end\" : \"top-start\", hu = F() ? \"top-start\" : \"top-end\", du = F() ? \"bottom-end\" : \"bottom-start\", uu = F() ? \"bottom-start\" : \"bottom-end\", pu = F() ? \"left-start\" : \"right-start\", _u = F() ? \"right-start\" : \"left-start\", fu = [{ opacity: \"0\" }, { opacity: \"1\" }], mu = [{ opacity: \"1\" }, { opacity: \"0\" }], is = {\n  duration: 550,\n  iterations: 1,\n  easing: \"ease\",\n  fill: \"both\"\n}, gu = {\n  offset: [0, 2],\n  boundary: \"clippingParents\",\n  reference: \"toggle\",\n  display: \"dynamic\",\n  popperConfig: null,\n  autoClose: !0,\n  dropdownAnimation: \"on\"\n}, bu = {\n  offset: \"(array|string|function)\",\n  boundary: \"(string|element)\",\n  reference: \"(string|element|object)\",\n  display: \"string\",\n  popperConfig: \"(null|object|function)\",\n  autoClose: \"(boolean|string)\",\n  dropdownAnimation: \"string\"\n};\nclass Dt extends gt {\n  constructor(t, e) {\n    super(t), this._popper = null, this._config = this._getConfig(e), this._menu = this._getMenuElement(), this._inNavbar = this._detectNavbar(), this._fadeOutAnimate = null;\n    const i = window.matchMedia(\n      \"(prefers-reduced-motion: reduce)\"\n    ).matches;\n    this._animationCanPlay = this._config.dropdownAnimation === \"on\" && !i, this._didInit = !1, this._init();\n  }\n  // Getters\n  static get Default() {\n    return gu;\n  }\n  static get DefaultType() {\n    return bu;\n  }\n  static get NAME() {\n    return kn;\n  }\n  // Public\n  toggle() {\n    return this._isShown() ? this.hide() : this.show();\n  }\n  show() {\n    if (ge(this._element) || this._isShown(this._menu))\n      return;\n    const t = {\n      relatedTarget: this._element\n    };\n    if (c.trigger(\n      this._element,\n      Jd,\n      t\n    ).defaultPrevented)\n      return;\n    const i = Dt.getParentFromElement(this._element);\n    this._inNavbar ? h.setDataAttribute(this._menu, \"popper\", \"none\") : this._createPopper(i), \"ontouchstart\" in document.documentElement && !i.closest(au) && [].concat(...document.body.children).forEach((n) => c.on(n, \"mouseover\", tn)), this._element.focus(), this._element.setAttribute(\"aria-expanded\", !0), this._menu.setAttribute(`data-te-dropdown-${Wt}`, \"\"), this._animationCanPlay && this._menu.animate(fu, is), this._element.setAttribute(`data-te-dropdown-${Wt}`, \"\"), setTimeout(\n      () => {\n        c.trigger(this._element, tu, t);\n      },\n      this._animationCanPlay ? is.duration : 0\n    );\n  }\n  hide() {\n    if (ge(this._element) || !this._isShown(this._menu))\n      return;\n    const t = {\n      relatedTarget: this._element\n    };\n    this._completeHide(t);\n  }\n  dispose() {\n    this._popper && this._popper.destroy(), super.dispose();\n  }\n  update() {\n    this._inNavbar = this._detectNavbar(), this._popper && this._popper.update();\n  }\n  // Private\n  _init() {\n    this._didInit || (c.on(\n      document,\n      Wr,\n      es,\n      Dt.dataApiKeydownHandler\n    ), c.on(\n      document,\n      Wr,\n      xn,\n      Dt.dataApiKeydownHandler\n    ), c.on(document, eu, Dt.clearMenus), c.on(document, iu, Dt.clearMenus), this._didInit = !0);\n  }\n  _completeHide(t) {\n    this._fadeOutAnimate && this._fadeOutAnimate.playState === \"running\" || c.trigger(\n      this._element,\n      Zd,\n      t\n    ).defaultPrevented || (\"ontouchstart\" in document.documentElement && [].concat(...document.body.children).forEach((i) => c.off(i, \"mouseover\", tn)), this._animationCanPlay && (this._fadeOutAnimate = this._menu.animate(\n      mu,\n      is\n    )), setTimeout(\n      () => {\n        this._popper && this._popper.destroy(), this._menu.removeAttribute(`data-te-dropdown-${Wt}`), this._element.removeAttribute(`data-te-dropdown-${Wt}`), this._element.setAttribute(\"aria-expanded\", \"false\"), h.removeDataAttribute(this._menu, \"popper\"), c.trigger(this._element, Qd, t);\n      },\n      this._animationCanPlay ? is.duration : 0\n    ));\n  }\n  _getConfig(t) {\n    if (t = {\n      ...this.constructor.Default,\n      ...h.getDataAttributes(this._element),\n      ...t\n    }, D(kn, t, this.constructor.DefaultType), typeof t.reference == \"object\" && !je(t.reference) && typeof t.reference.getBoundingClientRect != \"function\")\n      throw new TypeError(\n        `${kn.toUpperCase()}: Option \"reference\" provided type \"object\" without a required \"getBoundingClientRect\" method.`\n      );\n    return t;\n  }\n  _createPopper(t) {\n    if (typeof Ic > \"u\")\n      throw new TypeError(\n        \"Bootstrap's dropdowns require Popper (https://popper.js.org)\"\n      );\n    let e = this._element;\n    this._config.reference === \"parent\" ? e = t : je(this._config.reference) ? e = te(this._config.reference) : typeof this._config.reference == \"object\" && (e = this._config.reference);\n    const i = this._getPopperConfig(), n = i.modifiers.find(\n      (o) => o.name === \"applyStyles\" && o.enabled === !1\n    );\n    this._popper = Ce(\n      e,\n      this._menu,\n      i\n    ), n && h.setDataAttribute(this._menu, \"popper\", \"static\");\n  }\n  _isShown(t = this._element) {\n    return t.dataset[`teDropdown${Wt.charAt(0).toUpperCase() + Wt.slice(1)}`] === \"\";\n  }\n  _getMenuElement() {\n    return d.next(this._element, xn)[0];\n  }\n  _getPlacement() {\n    const t = this._element.parentNode;\n    if (t.dataset.teDropdownPosition === nu)\n      return pu;\n    if (t.dataset.teDropdownPosition === ou)\n      return _u;\n    const e = t.dataset.teDropdownAlignment === \"end\";\n    return t.dataset.teDropdownPosition === su ? e ? hu : cu : e ? uu : du;\n  }\n  _detectNavbar() {\n    return this._element.closest(ru) !== null;\n  }\n  _getOffset() {\n    const { offset: t } = this._config;\n    return typeof t == \"string\" ? t.split(\",\").map((e) => Number.parseInt(e, 10)) : typeof t == \"function\" ? (e) => t(e, this._element) : t;\n  }\n  _getPopperConfig() {\n    const t = {\n      placement: this._getPlacement(),\n      modifiers: [\n        {\n          name: \"preventOverflow\",\n          options: {\n            boundary: this._config.boundary\n          }\n        },\n        {\n          name: \"offset\",\n          options: {\n            offset: this._getOffset()\n          }\n        }\n      ]\n    };\n    return this._config.display === \"static\" && (t.modifiers = [\n      {\n        name: \"applyStyles\",\n        enabled: !1\n      }\n    ]), {\n      ...t,\n      ...typeof this._config.popperConfig == \"function\" ? this._config.popperConfig(t) : this._config.popperConfig\n    };\n  }\n  _selectMenuItem({ key: t, target: e }) {\n    const i = d.find(\n      lu,\n      this._menu\n    ).filter(Nt);\n    i.length && Jl(\n      i,\n      e,\n      t === Ps,\n      !i.includes(e)\n    ).focus();\n  }\n  // Static\n  static jQueryInterface(t) {\n    return this.each(function() {\n      const e = Dt.getOrCreateInstance(this, t);\n      if (typeof t == \"string\") {\n        if (typeof e[t] > \"u\")\n          throw new TypeError(`No method named \"${t}\"`);\n        e[t]();\n      }\n    });\n  }\n  static clearMenus(t) {\n    if (t && (t.button === Gd || t.type === \"keyup\" && t.key !== Vr))\n      return;\n    const e = d.find(es);\n    for (let i = 0, n = e.length; i < n; i++) {\n      const o = Dt.getInstance(e[i]);\n      if (!o || o._config.autoClose === !1 || !o._isShown())\n        continue;\n      const r = {\n        relatedTarget: o._element\n      };\n      if (t) {\n        const a = t.composedPath(), l = a.includes(o._menu);\n        if (a.includes(o._element) || o._config.autoClose === \"inside\" && !l || o._config.autoClose === \"outside\" && l || o._menu.contains(t.target) && (t.type === \"keyup\" && t.key === Vr || /input|select|option|textarea|form/i.test(t.target.tagName)))\n          continue;\n        t.type === \"click\" && (r.clickEvent = t);\n      }\n      o._completeHide(r);\n    }\n  }\n  static getParentFromElement(t) {\n    return Jt(t) || t.parentNode;\n  }\n  static dataApiKeydownHandler(t) {\n    if (/input|textarea/i.test(t.target.tagName) ? t.key === Hr || t.key !== Rs && (t.key !== Ps && t.key !== $o || t.target.closest(xn)) : !qd.test(t.key))\n      return;\n    const e = this.dataset[`teDropdown${Wt.charAt(0).toUpperCase() + Wt.slice(1)}`] === \"\";\n    if (!e && t.key === Rs || (t.preventDefault(), t.stopPropagation(), ge(this)))\n      return;\n    const i = this.matches(es) ? this : d.prev(this, es)[0], n = Dt.getOrCreateInstance(i);\n    if (t.key === Rs) {\n      n.hide();\n      return;\n    }\n    if (t.key === $o || t.key === Ps) {\n      e || n.show(), n._selectMenuItem(t);\n      return;\n    }\n    (!e || t.key === Hr) && Dt.clearMenus();\n  }\n}\nconst On = \"collapse\", Dc = \"te.collapse\", ln = `.${Dc}`, Fr = {\n  toggle: !0,\n  parent: null\n}, vu = {\n  toggle: \"boolean\",\n  parent: \"(null|element)\"\n}, Tu = `show${ln}`, Eu = `shown${ln}`, Cu = `hide${ln}`, Au = `hidden${ln}`, Sn = \"data-te-collapse-show\", Yr = \"data-te-collapse-collapsed\", ss = \"data-te-collapse-collapsing\", yu = \"data-te-collapse-horizontal\", Me = \"data-te-collapse-item\", jr = `:scope [${Me}] [${Me}]`, wu = \"width\", ku = \"height\", xu = \"[data-te-collapse-item][data-te-collapse-show], [data-te-collapse-item][data-te-collapse-collapsing]\", Kr = \"[data-te-collapse-init]\", Ou = {\n  visible: \"!visible\",\n  hidden: \"hidden\",\n  baseTransition: \"overflow-hidden duration-[350ms] ease-[cubic-bezier(0.25,0.1,0.25,1.0)] motion-reduce:transition-none\",\n  collapsing: \"h-0 transition-[height] overflow-hidden duration-[350ms] ease-[cubic-bezier(0.25,0.1,0.25,1.0)] motion-reduce:transition-none\",\n  collapsingHorizontal: \"w-0 h-auto transition-[width] overflow-hidden duration-[350ms] ease-[cubic-bezier(0.25,0.1,0.25,1.0)] motion-reduce:transition-none\"\n}, Su = {\n  visible: \"string\",\n  hidden: \"string\",\n  baseTransition: \"string\",\n  collapsing: \"string\",\n  collapsingHorizontal: \"string\"\n};\nclass Zt extends gt {\n  constructor(t, e, i) {\n    super(t), this._isTransitioning = !1, this._config = this._getConfig(e), this._classes = this._getClasses(i), this._triggerArray = [];\n    const n = d.find(Kr);\n    for (let o = 0, r = n.length; o < r; o++) {\n      const a = n[o], l = qo(a), p = d.find(l).filter(\n        (u) => u === this._element\n      );\n      l !== null && p.length && (this._selector = l, this._triggerArray.push(a));\n    }\n    this._initializeChildren(), this._config.parent || this._addAriaAndCollapsedClass(this._triggerArray, this._isShown()), this._config.toggle && this.toggle();\n  }\n  // Getters\n  static get Default() {\n    return Fr;\n  }\n  static get NAME() {\n    return On;\n  }\n  // Public\n  toggle() {\n    this._isShown() ? this.hide() : this.show();\n  }\n  show() {\n    if (this._isTransitioning || this._isShown())\n      return;\n    let t = [], e;\n    if (this._config.parent) {\n      const u = d.find(\n        jr,\n        this._config.parent\n      );\n      t = d.find(\n        xu,\n        this._config.parent\n      ).filter((_) => !u.includes(_));\n    }\n    const i = d.findOne(this._selector);\n    if (t.length) {\n      const u = t.find((_) => i !== _);\n      if (e = u ? Zt.getInstance(u) : null, e && e._isTransitioning)\n        return;\n    }\n    if (c.trigger(this._element, Tu).defaultPrevented)\n      return;\n    t.forEach((u) => {\n      i !== u && Zt.getOrCreateInstance(u, { toggle: !1 }).hide(), e || y.setData(u, Dc, null);\n    });\n    const o = this._getDimension(), r = o === \"height\" ? this._classes.collapsing : this._classes.collapsingHorizontal;\n    h.removeClass(this._element, this._classes.visible), h.removeClass(this._element, this._classes.hidden), h.addClass(this._element, r), this._element.removeAttribute(Me), this._element.setAttribute(ss, \"\"), this._element.style[o] = 0, this._addAriaAndCollapsedClass(this._triggerArray, !0), this._isTransitioning = !0;\n    const a = () => {\n      this._isTransitioning = !1, h.removeClass(this._element, this._classes.hidden), h.removeClass(this._element, r), h.addClass(this._element, this._classes.visible), this._element.removeAttribute(ss), this._element.setAttribute(Me, \"\"), this._element.setAttribute(Sn, \"\"), this._element.style[o] = \"\", c.trigger(this._element, Eu);\n    }, p = `scroll${o[0].toUpperCase() + o.slice(1)}`;\n    this._queueCallback(a, this._element, !0), this._element.style[o] = `${this._element[p]}px`;\n  }\n  hide() {\n    if (this._isTransitioning || !this._isShown() || c.trigger(this._element, Cu).defaultPrevented)\n      return;\n    const e = this._getDimension(), i = e === \"height\" ? this._classes.collapsing : this._classes.collapsingHorizontal;\n    this._element.style[e] = `${this._element.getBoundingClientRect()[e]}px`, Je(this._element), h.addClass(this._element, i), h.removeClass(this._element, this._classes.visible), h.removeClass(this._element, this._classes.hidden), this._element.setAttribute(ss, \"\"), this._element.removeAttribute(Me), this._element.removeAttribute(Sn);\n    const n = this._triggerArray.length;\n    for (let r = 0; r < n; r++) {\n      const a = this._triggerArray[r], l = Jt(a);\n      l && !this._isShown(l) && this._addAriaAndCollapsedClass([a], !1);\n    }\n    this._isTransitioning = !0;\n    const o = () => {\n      this._isTransitioning = !1, h.removeClass(this._element, i), h.addClass(this._element, this._classes.visible), h.addClass(this._element, this._classes.hidden), this._element.removeAttribute(ss), this._element.setAttribute(Me, \"\"), c.trigger(this._element, Au);\n    };\n    this._element.style[e] = \"\", this._queueCallback(o, this._element, !0);\n  }\n  _isShown(t = this._element) {\n    return t.hasAttribute(Sn);\n  }\n  // Private\n  _getConfig(t) {\n    return t = {\n      ...Fr,\n      ...h.getDataAttributes(this._element),\n      ...t\n    }, t.toggle = !!t.toggle, t.parent = te(t.parent), D(On, t, vu), t;\n  }\n  _getClasses(t) {\n    const e = h.getDataClassAttributes(this._element);\n    return t = {\n      ...Ou,\n      ...e,\n      ...t\n    }, D(On, t, Su), t;\n  }\n  _getDimension() {\n    return this._element.hasAttribute(yu) ? wu : ku;\n  }\n  _initializeChildren() {\n    if (!this._config.parent)\n      return;\n    const t = d.find(\n      jr,\n      this._config.parent\n    );\n    d.find(Kr, this._config.parent).filter((e) => !t.includes(e)).forEach((e) => {\n      const i = Jt(e);\n      i && this._addAriaAndCollapsedClass([e], this._isShown(i));\n    });\n  }\n  _addAriaAndCollapsedClass(t, e) {\n    t.length && t.forEach((i) => {\n      e ? i.removeAttribute(Yr) : i.setAttribute(`${Yr}`, \"\"), i.setAttribute(\"aria-expanded\", e);\n    });\n  }\n  // Static\n  static jQueryInterface(t) {\n    return this.each(function() {\n      const e = {};\n      typeof t == \"string\" && /show|hide/.test(t) && (e.toggle = !1);\n      const i = Zt.getOrCreateInstance(this, e);\n      if (typeof t == \"string\") {\n        if (typeof i[t] > \"u\")\n          throw new TypeError(`No method named \"${t}\"`);\n        i[t]();\n      }\n    });\n  }\n}\nconst zr = \".fixed-top, .fixed-bottom, .is-fixed, .sticky-top\", Ur = \".sticky-top\";\nclass qe {\n  constructor() {\n    this._element = document.body;\n  }\n  getWidth() {\n    const t = document.documentElement.clientWidth;\n    return Math.abs(window.innerWidth - t);\n  }\n  hide() {\n    const t = this.getWidth();\n    this._disableOverFlow(), this._setElementAttributes(\n      this._element,\n      \"paddingRight\",\n      (e) => e + t\n    ), this._setElementAttributes(\n      zr,\n      \"paddingRight\",\n      (e) => e + t\n    ), this._setElementAttributes(\n      Ur,\n      \"marginRight\",\n      (e) => e - t\n    );\n  }\n  _disableOverFlow() {\n    this._saveInitialAttribute(this._element, \"overflow\"), this._element.style.overflow = \"hidden\";\n  }\n  _setElementAttributes(t, e, i) {\n    const n = this.getWidth(), o = (r) => {\n      if (r !== this._element && window.innerWidth > r.clientWidth + n)\n        return;\n      this._saveInitialAttribute(r, e);\n      const a = window.getComputedStyle(r)[e];\n      r.style[e] = `${i(\n        Number.parseFloat(a)\n      )}px`;\n    };\n    this._applyManipulationCallback(t, o);\n  }\n  reset() {\n    this._resetElementAttributes(this._element, \"overflow\"), this._resetElementAttributes(this._element, \"paddingRight\"), this._resetElementAttributes(zr, \"paddingRight\"), this._resetElementAttributes(Ur, \"marginRight\");\n  }\n  _saveInitialAttribute(t, e) {\n    const i = t.style[e];\n    i && h.setDataAttribute(t, e, i);\n  }\n  _resetElementAttributes(t, e) {\n    const i = (n) => {\n      const o = h.getDataAttribute(n, e);\n      typeof o > \"u\" ? n.style.removeProperty(e) : (h.removeDataAttribute(n, e), n.style[e] = o);\n    };\n    this._applyManipulationCallback(t, i);\n  }\n  _applyManipulationCallback(t, e) {\n    je(t) ? e(t) : d.find(t, this._element).forEach(e);\n  }\n  isOverflowing() {\n    return this.getWidth() > 0;\n  }\n}\nconst Iu = {\n  isVisible: !0,\n  // if false, we use the backdrop helper without adding any element to the dom\n  isAnimated: !1,\n  rootElement: \"body\",\n  // give the choice to place backdrop under different elements\n  clickCallback: null,\n  backdropClasses: null\n}, Du = {\n  isVisible: \"boolean\",\n  isAnimated: \"boolean\",\n  rootElement: \"(element|string)\",\n  clickCallback: \"(function|null)\",\n  backdropClasses: \"(array|null)\"\n}, $c = \"backdrop\", Xr = `mousedown.te.${$c}`;\nclass hr {\n  constructor(t) {\n    this._config = this._getConfig(t), this._isAppended = !1, this._element = null;\n  }\n  show(t) {\n    if (!this._config.isVisible) {\n      me(t);\n      return;\n    }\n    this._append(), this._config.isAnimated && Je(this._getElement());\n    const e = this._config.backdropClasses || [\n      \"opacity-50\",\n      \"transition-all\",\n      \"duration-300\",\n      \"ease-in-out\",\n      \"fixed\",\n      \"top-0\",\n      \"left-0\",\n      \"z-[1040]\",\n      \"bg-black\",\n      \"w-screen\",\n      \"h-screen\"\n    ];\n    h.removeClass(this._getElement(), \"opacity-0\"), h.addClass(this._getElement(), e), this._element.setAttribute(\"data-te-backdrop-show\", \"\"), this._emulateAnimation(() => {\n      me(t);\n    });\n  }\n  hide(t) {\n    if (!this._config.isVisible) {\n      me(t);\n      return;\n    }\n    this._element.removeAttribute(\"data-te-backdrop-show\"), this._getElement().classList.add(\"opacity-0\"), this._getElement().classList.remove(\"opacity-50\"), this._emulateAnimation(() => {\n      this.dispose(), me(t);\n    });\n  }\n  // Private\n  _getElement() {\n    if (!this._element) {\n      const t = document.createElement(\"div\");\n      t.className = this._config.className, this._config.isAnimated && t.classList.add(\"opacity-50\"), this._element = t;\n    }\n    return this._element;\n  }\n  _getConfig(t) {\n    return t = {\n      ...Iu,\n      ...typeof t == \"object\" ? t : {}\n    }, t.rootElement = te(t.rootElement), D($c, t, Du), t;\n  }\n  _append() {\n    this._isAppended || (this._config.rootElement.append(this._getElement()), c.on(this._getElement(), Xr, () => {\n      me(this._config.clickCallback);\n    }), this._isAppended = !0);\n  }\n  dispose() {\n    this._isAppended && (c.off(this._element, Xr), this._element.remove(), this._isAppended = !1);\n  }\n  _emulateAnimation(t) {\n    Ql(\n      t,\n      this._getElement(),\n      this._config.isAnimated\n    );\n  }\n}\nclass Wi {\n  constructor(t, e = {}, i) {\n    this._element = t, this._toggler = i, this._event = e.event || \"blur\", this._condition = e.condition || (() => !0), this._selector = e.selector || 'button, a, input, select, textarea, [tabindex]:not([tabindex=\"-1\"])', this._onlyVisible = e.onlyVisible || !1, this._focusableElements = [], this._firstElement = null, this._lastElement = null, this.handler = (n) => {\n      this._condition(n) && !n.shiftKey && n.target === this._lastElement ? (n.preventDefault(), this._firstElement.focus()) : this._condition(n) && n.shiftKey && n.target === this._firstElement && (n.preventDefault(), this._lastElement.focus());\n    };\n  }\n  trap() {\n    this._setElements(), this._init(), this._setFocusTrap();\n  }\n  disable() {\n    this._focusableElements.forEach((t) => {\n      t.removeEventListener(this._event, this.handler);\n    }), this._toggler && this._toggler.focus();\n  }\n  update() {\n    this._setElements(), this._setFocusTrap();\n  }\n  _init() {\n    const t = (e) => {\n      !this._firstElement || e.key !== \"Tab\" || this._focusableElements.includes(e.target) || (e.preventDefault(), this._firstElement.focus(), window.removeEventListener(\"keydown\", t));\n    };\n    window.addEventListener(\"keydown\", t);\n  }\n  _filterVisible(t) {\n    return t.filter((e) => {\n      if (!Nt(e))\n        return !1;\n      const i = d.parents(e, \"*\");\n      for (let n = 0; n < i.length; n++) {\n        const o = window.getComputedStyle(i[n]);\n        if (o && (o.display === \"none\" || o.visibility === \"hidden\"))\n          return !1;\n      }\n      return !0;\n    });\n  }\n  _setElements() {\n    this._focusableElements = d.focusableChildren(this._element), this._onlyVisible && (this._focusableElements = this._filterVisible(this._focusableElements)), this._firstElement = this._focusableElements[0], this._lastElement = this._focusableElements[this._focusableElements.length - 1];\n  }\n  _setFocusTrap() {\n    this._focusableElements.forEach((t, e) => {\n      e === this._focusableElements.length - 1 || e === 0 ? t.addEventListener(this._event, this.handler) : t.removeEventListener(this._event, this.handler);\n    });\n  }\n}\nlet Gr = [];\nconst cn = (s, t = \"hide\") => {\n  const e = `click.dismiss${s.EVENT_KEY}`, i = s.NAME;\n  Gr.includes(i) || (Gr.push(i), c.on(\n    document,\n    e,\n    `[data-te-${i}-dismiss]`,\n    function(n) {\n      if ([\"A\", \"AREA\"].includes(this.tagName) && n.preventDefault(), ge(this))\n        return;\n      const o = Jt(this) || this.closest(`.${i}`) || this.closest(`[data-te-${i}-init]`);\n      if (!o)\n        return;\n      s.getOrCreateInstance(o)[t]();\n    }\n  ));\n}, qr = \"offcanvas\", $u = \"te.offcanvas\", ei = `.${$u}`, Lu = \".data-api\", Nu = `load${ei}${Lu}`, Mu = \"Escape\", Zr = {\n  backdrop: !0,\n  keyboard: !0,\n  scroll: !1\n}, Ru = {\n  backdrop: \"boolean\",\n  keyboard: \"boolean\",\n  scroll: \"boolean\"\n}, Qr = \"show\", Pu = \"[data-te-offcanvas-init][data-te-offcanvas-show]\", Bu = `show${ei}`, Hu = `shown${ei}`, Vu = `hide${ei}`, Wu = `hidden${ei}`, Fu = `keydown.dismiss${ei}`;\nclass Bs extends gt {\n  constructor(t, e) {\n    super(t), this._config = this._getConfig(e), this._isShown = !1, this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._addEventListeners(), this._didInit = !1, this._init();\n  }\n  // Getters\n  static get NAME() {\n    return qr;\n  }\n  static get Default() {\n    return Zr;\n  }\n  // Public\n  toggle(t) {\n    return this._isShown ? this.hide() : this.show(t);\n  }\n  show(t) {\n    if (this._isShown || c.trigger(this._element, Bu, {\n      relatedTarget: t\n    }).defaultPrevented)\n      return;\n    this._isShown = !0, this._element.style.visibility = \"visible\", this._backdrop.show(), this._config.scroll || new qe().hide(), this._element.removeAttribute(\"aria-hidden\"), this._element.setAttribute(\"aria-modal\", !0), this._element.setAttribute(\"role\", \"dialog\"), this._element.setAttribute(`data-te-offcanvas-${Qr}`, \"\");\n    const i = () => {\n      this._config.scroll || this._focustrap.trap(), c.trigger(this._element, Hu, { relatedTarget: t });\n    };\n    this._queueCallback(i, this._element, !0);\n  }\n  hide() {\n    if (!this._isShown || c.trigger(this._element, Vu).defaultPrevented)\n      return;\n    this._focustrap.disable(), this._element.blur(), this._isShown = !1, this._element.removeAttribute(`data-te-offcanvas-${Qr}`), this._backdrop.hide();\n    const e = () => {\n      this._element.setAttribute(\"aria-hidden\", !0), this._element.removeAttribute(\"aria-modal\"), this._element.removeAttribute(\"role\"), this._element.style.visibility = \"hidden\", this._config.scroll || new qe().reset(), c.trigger(this._element, Wu);\n    };\n    this._queueCallback(e, this._element, !0);\n  }\n  dispose() {\n    this._backdrop.dispose(), this._focustrap.disable(), super.dispose();\n  }\n  // Private\n  _init() {\n    this._didInit || (c.on(\n      window,\n      Nu,\n      () => d.find(Pu).forEach(\n        (t) => Bs.getOrCreateInstance(t).show()\n      )\n    ), this._didInit = !0, cn(Bs));\n  }\n  _getConfig(t) {\n    return t = {\n      ...Zr,\n      ...h.getDataAttributes(this._element),\n      ...typeof t == \"object\" ? t : {}\n    }, D(qr, t, Ru), t;\n  }\n  _initializeBackDrop() {\n    return new hr({\n      isVisible: this._config.backdrop,\n      isAnimated: !0,\n      rootElement: this._element.parentNode,\n      clickCallback: () => this.hide()\n    });\n  }\n  _initializeFocusTrap() {\n    return new Wi(this._element, {\n      event: \"keydown\",\n      condition: (t) => t.key === \"Tab\"\n    });\n  }\n  _addEventListeners() {\n    c.on(this._element, Fu, (t) => {\n      this._config.keyboard && t.key === Mu && this.hide();\n    });\n  }\n  // Static\n  static jQueryInterface(t) {\n    return this.each(function() {\n      const e = Bs.getOrCreateInstance(this, t);\n      if (typeof t == \"string\") {\n        if (e[t] === void 0 || t.startsWith(\"_\") || t === \"constructor\")\n          throw new TypeError(`No method named \"${t}\"`);\n        e[t](this);\n      }\n    });\n  }\n}\nconst In = \"alert\", Yu = \"te.alert\", Lc = `.${Yu}`, ju = `close${Lc}`, Ku = `closed${Lc}`, ai = \"data-te-alert-show\", zu = {\n  animation: \"boolean\",\n  autohide: \"boolean\",\n  delay: \"number\"\n}, Jr = {\n  animation: !0,\n  autohide: !0,\n  delay: 1e3\n}, Uu = {\n  fadeIn: \"animate-[fade-in_0.3s_both] p-[auto] motion-reduce:transition-none motion-reduce:animate-none\",\n  fadeOut: \"animate-[fade-out_0.3s_both] p-[auto] motion-reduce:transition-none motion-reduce:animate-none\"\n}, Xu = {\n  fadeIn: \"string\",\n  fadeOut: \"string\"\n};\nclass Lo extends gt {\n  constructor(t, e, i) {\n    super(t), this._element = t, this._config = this._getConfig(e), this._classes = this._getClasses(i), this._didInit = !1, this._init();\n  }\n  // Getters\n  static get DefaultType() {\n    return zu;\n  }\n  static get Default() {\n    return Jr;\n  }\n  static get NAME() {\n    return In;\n  }\n  // Public\n  close() {\n    if (c.trigger(this._element, ju).defaultPrevented)\n      return;\n    let e = 0;\n    this._config.animation && (e = 300, h.addClass(this._element, this._classes.fadeOut)), this._element.removeAttribute(ai), setTimeout(() => {\n      this._queueCallback(\n        () => this._destroyElement(),\n        this._element,\n        this._config.animation\n      );\n    }, e);\n  }\n  show() {\n    if (this._element) {\n      if (this._config.autohide && this._setupAutohide(), !this._element.hasAttribute(ai) && (h.removeClass(this._element, \"hidden\"), h.addClass(this._element, \"block\"), Nt(this._element))) {\n        const t = (e) => {\n          h.removeClass(this._element, \"hidden\"), h.addClass(this._element, \"block\"), c.off(e.target, \"animationend\", t);\n        };\n        this._element.setAttribute(ai, \"\"), c.on(this._element, \"animationend\", t);\n      }\n      this._config.animation && (h.removeClass(this._element, this._classes.fadeOut), h.addClass(this._element, this._classes.fadeIn));\n    }\n  }\n  hide() {\n    if (this._element && this._element.hasAttribute(ai)) {\n      this._element.removeAttribute(ai);\n      const t = (e) => {\n        h.addClass(this._element, \"hidden\"), h.removeClass(this._element, \"block\"), this._timeout !== null && (clearTimeout(this._timeout), this._timeout = null), c.off(e.target, \"animationend\", t);\n      };\n      c.on(this._element, \"animationend\", t), h.removeClass(this._element, this._classes.fadeIn), h.addClass(this._element, this._classes.fadeOut);\n    }\n  }\n  // Private\n  _init() {\n    this._didInit || (cn(Lo, \"close\"), this._didInit = !0);\n  }\n  _getConfig(t) {\n    return t = {\n      ...Jr,\n      ...h.getDataAttributes(this._element),\n      ...typeof t == \"object\" && t ? t : {}\n    }, D(In, t, this.constructor.DefaultType), t;\n  }\n  _getClasses(t) {\n    const e = h.getDataClassAttributes(this._element);\n    return t = {\n      ...Uu,\n      ...e,\n      ...t\n    }, D(In, t, Xu), t;\n  }\n  _setupAutohide() {\n    this._timeout = setTimeout(() => {\n      this.hide();\n    }, this._config.delay);\n  }\n  _destroyElement() {\n    this._element.remove(), c.trigger(this._element, Ku), this.dispose();\n  }\n  // Static\n  static jQueryInterface(t) {\n    return this.each(function() {\n      const e = Lo.getOrCreateInstance(this);\n      if (typeof t == \"string\") {\n        if (e[t] === void 0 || t.startsWith(\"_\") || t === \"constructor\")\n          throw new TypeError(`No method named \"${t}\"`);\n        e[t](this);\n      }\n    });\n  }\n}\nconst Dn = \"carousel\", Gu = \"te.carousel\", _t = `.${Gu}`, Nc = \".data-api\", qu = \"ArrowLeft\", Zu = \"ArrowRight\", Qu = 500, Ju = 40, ta = {\n  interval: 5e3,\n  keyboard: !0,\n  ride: !1,\n  pause: \"hover\",\n  wrap: !0,\n  touch: !0\n}, tp = {\n  interval: \"(number|boolean)\",\n  keyboard: \"boolean\",\n  ride: \"(boolean|string)\",\n  pause: \"(string|boolean)\",\n  wrap: \"boolean\",\n  touch: \"boolean\"\n}, ep = {\n  pointer: \"touch-pan-y\",\n  block: \"!block\",\n  visible: \"data-[te-carousel-fade]:opacity-100 data-[te-carousel-fade]:z-[1]\",\n  invisible: \"data-[te-carousel-fade]:z-0 data-[te-carousel-fade]:opacity-0 data-[te-carousel-fade]:duration-[600ms] data-[te-carousel-fade]:delay-600\",\n  slideRight: \"translate-x-full\",\n  slideLeft: \"-translate-x-full\"\n}, ip = {\n  pointer: \"string\",\n  block: \"string\",\n  visible: \"string\",\n  invisible: \"string\",\n  slideRight: \"string\",\n  slideLeft: \"string\"\n}, le = \"next\", ce = \"prev\", _e = \"left\", mi = \"right\", sp = {\n  [qu]: mi,\n  [Zu]: _e\n}, np = `slide${_t}`, $n = `slid${_t}`, op = `keydown${_t}`, rp = `mouseenter${_t}`, ap = `mouseleave${_t}`, lp = `touchstart${_t}`, cp = `touchmove${_t}`, hp = `touchend${_t}`, dp = `pointerdown${_t}`, up = `pointerup${_t}`, pp = `dragstart${_t}`, _p = `load${_t}${Nc}`, fp = `click${_t}${Nc}`, ea = \"data-te-carousel-init\", he = \"data-te-carousel-active\", mp = \"data-te-carousel-item-end\", Ln = \"data-te-carousel-item-start\", gp = \"data-te-carousel-item-next\", bp = \"data-te-carousel-item-prev\", vp = \"data-te-carousel-pointer-event\", Tp = \"[data-te-carousel-init]\", Mc = \"[data-te-carousel-active]\", dr = \"[data-te-carousel-item]\", we = `${Mc}${dr}`, Ep = `${dr} img`, Cp = \"[data-te-carousel-item-next], [data-te-carousel-item-prev]\", Ap = \"[data-te-carousel-indicators]\", yp = \"[data-te-target]\", wp = \"[data-te-slide], [data-te-slide-to]\", kp = \"touch\", xp = \"pen\";\nclass Ut extends gt {\n  constructor(t, e, i) {\n    super(t), this._items = null, this._interval = null, this._activeElement = null, this._isPaused = !1, this._isSliding = !1, this.touchTimeout = null, this.touchStartX = 0, this.touchDeltaX = 0, this._config = this._getConfig(e), this._classes = this._getClasses(i), this._indicatorsElement = d.findOne(\n      Ap,\n      this._element\n    ), this._touchSupported = \"ontouchstart\" in document.documentElement || navigator.maxTouchPoints > 0, this._pointerEvent = !!window.PointerEvent, this._setActiveElementClass(), this._addEventListeners(), this._didInit = !1, this._init(), this._config.ride === \"carousel\" && this.cycle();\n  }\n  // Getters\n  static get Default() {\n    return ta;\n  }\n  static get NAME() {\n    return Dn;\n  }\n  // Public\n  next() {\n    this._slide(le);\n  }\n  nextWhenVisible() {\n    !document.hidden && Nt(this._element) && this.next();\n  }\n  prev() {\n    this._slide(ce);\n  }\n  pause(t) {\n    t || (this._isPaused = !0), d.findOne(Cp, this._element) && (Xl(this._element), this.cycle(!0)), clearInterval(this._interval), this._interval = null;\n  }\n  cycle(t) {\n    t || (this._isPaused = !1), this._interval && (clearInterval(this._interval), this._interval = null), this._config && this._config.interval && !this._isPaused && (this._updateInterval(), this._interval = setInterval(\n      (document.visibilityState ? this.nextWhenVisible : this.next).bind(\n        this\n      ),\n      this._config.interval\n    ));\n  }\n  to(t) {\n    this._activeElement = d.findOne(\n      we,\n      this._element\n    );\n    const e = this._getItemIndex(this._activeElement);\n    if (t > this._items.length - 1 || t < 0)\n      return;\n    if (this._isSliding) {\n      c.one(this._element, $n, () => this.to(t));\n      return;\n    }\n    if (e === t) {\n      this.pause(), this.cycle();\n      return;\n    }\n    const i = t > e ? le : ce;\n    this._slide(i, this._items[t]);\n  }\n  // Private\n  _init() {\n    this._didInit || (c.on(\n      document,\n      fp,\n      wp,\n      Ut.dataApiClickHandler\n    ), c.on(window, _p, () => {\n      const t = d.find(Tp);\n      for (let e = 0, i = t.length; e < i; e++)\n        Ut.carouselInterface(\n          t[e],\n          Ut.getInstance(t[e])\n        );\n    }), this._didInit = !0);\n  }\n  _getConfig(t) {\n    return t = {\n      ...ta,\n      ...h.getDataAttributes(this._element),\n      ...typeof t == \"object\" ? t : {}\n    }, D(Dn, t, tp), t;\n  }\n  _getClasses(t) {\n    const e = h.getDataClassAttributes(this._element);\n    return t = {\n      ...ep,\n      ...e,\n      ...t\n    }, D(Dn, t, ip), t;\n  }\n  _enableCycle() {\n    if (this._config.ride) {\n      if (this._isSliding) {\n        c.one(this._element, $n, () => this.cycle());\n        return;\n      }\n      this.cycle();\n    }\n  }\n  _applyInitialClasses() {\n    const t = d.findOne(\n      we,\n      this._element\n    );\n    t.classList.add(\n      this._classes.block,\n      ...this._classes.visible.split(\" \")\n    ), this._setActiveIndicatorElement(t);\n  }\n  _handleSwipe() {\n    const t = Math.abs(this.touchDeltaX);\n    if (t <= Ju)\n      return;\n    const e = t / this.touchDeltaX;\n    this.touchDeltaX = 0, e && this._slide(e > 0 ? mi : _e);\n  }\n  _setActiveElementClass() {\n    this._activeElement = d.findOne(\n      we,\n      this._element\n    ), h.addClass(this._activeElement, \"hidden\");\n  }\n  _addEventListeners() {\n    this._config.keyboard && c.on(\n      this._element,\n      op,\n      (t) => this._keydown(t)\n    ), this._config.pause === \"hover\" && (c.on(\n      this._element,\n      rp,\n      (t) => this.pause(t)\n    ), c.on(\n      this._element,\n      ap,\n      (t) => this._enableCycle(t)\n    )), this._config.touch && this._touchSupported && this._addTouchEventListeners(), this._applyInitialClasses();\n  }\n  _addTouchEventListeners() {\n    const t = (o) => this._pointerEvent && (o.pointerType === xp || o.pointerType === kp), e = (o) => {\n      t(o) ? this.touchStartX = o.clientX : this._pointerEvent || (this.touchStartX = o.touches[0].clientX);\n    }, i = (o) => {\n      this.touchDeltaX = o.touches && o.touches.length > 1 ? 0 : o.touches[0].clientX - this.touchStartX;\n    }, n = (o) => {\n      t(o) && (this.touchDeltaX = o.clientX - this.touchStartX), this._handleSwipe(), this._config.pause === \"hover\" && (this.pause(), this.touchTimeout && clearTimeout(this.touchTimeout), this.touchTimeout = setTimeout(\n        (r) => this._enableCycle(r),\n        Qu + this._config.interval\n      ));\n    };\n    d.find(Ep, this._element).forEach(\n      (o) => {\n        c.on(\n          o,\n          pp,\n          (r) => r.preventDefault()\n        );\n      }\n    ), this._pointerEvent ? (c.on(\n      this._element,\n      dp,\n      (o) => e(o)\n    ), c.on(this._element, up, (o) => n(o)), this._element.classList.add(this._classes.pointer), this._element.setAttribute(`${vp}`, \"\")) : (c.on(this._element, lp, (o) => e(o)), c.on(this._element, cp, (o) => i(o)), c.on(this._element, hp, (o) => n(o)));\n  }\n  _keydown(t) {\n    if (/input|textarea/i.test(t.target.tagName))\n      return;\n    const e = sp[t.key];\n    e && (t.preventDefault(), this._slide(e));\n  }\n  _getItemIndex(t) {\n    return this._items = t && t.parentNode ? d.find(dr, t.parentNode) : [], this._items.indexOf(t);\n  }\n  _getItemByOrder(t, e) {\n    const i = t === le;\n    return Jl(\n      this._items,\n      e,\n      i,\n      this._config.wrap\n    );\n  }\n  _triggerSlideEvent(t, e) {\n    const i = this._getItemIndex(t), n = this._getItemIndex(\n      d.findOne(we, this._element)\n    );\n    return c.trigger(this._element, np, {\n      relatedTarget: t,\n      direction: e,\n      from: n,\n      to: i\n    });\n  }\n  _setActiveIndicatorElement(t) {\n    if (this._indicatorsElement) {\n      const e = d.findOne(\n        Mc,\n        this._indicatorsElement\n      );\n      e.removeAttribute(he), e.removeAttribute(\"aria-current\"), e.classList.remove(\"!opacity-100\");\n      const i = d.find(\n        yp,\n        this._indicatorsElement\n      );\n      for (let n = 0; n < i.length; n++)\n        if (Number.parseInt(\n          i[n].getAttribute(\"data-te-slide-to\"),\n          10\n        ) === this._getItemIndex(t)) {\n          i[n].setAttribute(`${he}`, \"\"), i[n].setAttribute(\"aria-current\", \"true\"), i[n].classList.add(\"!opacity-100\");\n          break;\n        }\n    }\n  }\n  _updateInterval() {\n    const t = this._activeElement || d.findOne(we, this._element);\n    if (!t)\n      return;\n    const e = Number.parseInt(\n      t.getAttribute(\"data-te-interval\"),\n      10\n    );\n    e ? (this._config.defaultInterval = this._config.defaultInterval || this._config.interval, this._config.interval = e) : this._config.interval = this._config.defaultInterval || this._config.interval;\n  }\n  _slide(t, e) {\n    const i = this._directionToOrder(t), n = d.findOne(\n      we,\n      this._element\n    ), o = this._getItemIndex(n), r = e || this._getItemByOrder(i, n), a = this._getItemIndex(r), l = !!this._interval, p = i === le, u = p ? Ln : mp, _ = p ? gp : bp, f = this._orderToDirection(i), g = u === Ln ? this._classes.slideLeft : this._classes.slideRight, m = u !== Ln ? this._classes.slideLeft : this._classes.slideRight;\n    if (r && r.hasAttribute(he)) {\n      this._isSliding = !1;\n      return;\n    }\n    if (this._isSliding || this._triggerSlideEvent(r, f).defaultPrevented || !n || !r)\n      return;\n    this._isSliding = !0, l && this.pause(), this._setActiveIndicatorElement(r), this._activeElement = r;\n    const v = () => {\n      c.trigger(this._element, $n, {\n        relatedTarget: r,\n        direction: f,\n        from: o,\n        to: a\n      });\n    };\n    if (this._element.hasAttribute(ea)) {\n      r.setAttribute(`${_}`, \"\"), r.classList.add(this._classes.block, m), Je(r), n.setAttribute(`${u}`, \"\"), n.classList.add(\n        g,\n        ...this._classes.invisible.split(\" \")\n      ), n.classList.remove(...this._classes.visible.split(\" \")), r.setAttribute(`${u}`, \"\"), r.classList.add(...this._classes.visible.split(\" \")), r.classList.remove(\n        this._classes.slideRight,\n        this._classes.slideLeft\n      );\n      const C = () => {\n        r.removeAttribute(u), r.removeAttribute(_), r.setAttribute(`${he}`, \"\"), n.removeAttribute(he), n.classList.remove(\n          g,\n          ...this._classes.invisible.split(\" \"),\n          this._classes.block\n        ), n.removeAttribute(_), n.removeAttribute(u), this._isSliding = !1, setTimeout(v, 0);\n      };\n      this._queueCallback(C, n, !0);\n    } else\n      n.removeAttribute(he), n.classList.remove(this._classes.block), r.setAttribute(`${he}`, \"\"), r.classList.add(this._classes.block), this._isSliding = !1, v();\n    l && this.cycle();\n  }\n  _directionToOrder(t) {\n    return [mi, _e].includes(t) ? F() ? t === _e ? ce : le : t === _e ? le : ce : t;\n  }\n  _orderToDirection(t) {\n    return [le, ce].includes(t) ? F() ? t === ce ? _e : mi : t === ce ? mi : _e : t;\n  }\n  // Static\n  static carouselInterface(t, e) {\n    const i = Ut.getOrCreateInstance(t, e);\n    let { _config: n } = i;\n    typeof e == \"object\" && (n = {\n      ...n,\n      ...e\n    });\n    const o = typeof e == \"string\" ? e : e.slide;\n    if (typeof e == \"number\") {\n      i.to(e);\n      return;\n    }\n    if (typeof o == \"string\") {\n      if (typeof i[o] > \"u\")\n        throw new TypeError(`No method named \"${o}\"`);\n      i[o]();\n    } else\n      n.interval && n.ride === !0 && i.pause();\n  }\n  static jQueryInterface(t) {\n    return this.each(function() {\n      Ut.carouselInterface(this, t);\n    });\n  }\n  static dataApiClickHandler(t) {\n    const e = Jt(this);\n    if (!e || !e.hasAttribute(ea))\n      return;\n    const i = {\n      ...h.getDataAttributes(e),\n      ...h.getDataAttributes(this)\n    }, n = this.getAttribute(\"data-te-slide-to\");\n    n && (i.interval = !1), Ut.carouselInterface(e, i), n && Ut.getInstance(e).to(n), t.preventDefault();\n  }\n}\nconst Nn = \"modal\", Op = \"te.modal\", At = `.${Op}`, ia = \"Escape\", sa = {\n  backdrop: !0,\n  keyboard: !0,\n  focus: !0,\n  modalNonInvasive: !1\n}, Sp = {\n  backdrop: \"(boolean|string)\",\n  keyboard: \"boolean\",\n  focus: \"boolean\",\n  modalNonInvasive: \"boolean\"\n}, Ip = {\n  show: \"transform-none\",\n  static: \"scale-[1.02]\",\n  staticProperties: \"transition-scale duration-300 ease-in-out\"\n}, Dp = {\n  show: \"string\",\n  static: \"string\",\n  staticProperties: \"string\"\n}, $p = `hide${At}`, Lp = `hidePrevented${At}`, Np = `hidden${At}`, Mp = `show${At}`, Rp = `shown${At}`, na = `resize${At}`, oa = `click.dismiss${At}`, ra = `keydown.dismiss${At}`, Pp = `mouseup.dismiss${At}`, aa = `mousedown.dismiss${At}`, la = \"data-te-modal-open\", ca = \"data-te-open\", li = \"[data-te-modal-dialog-ref]\", Bp = \"[data-te-modal-body-ref]\";\nclass No extends gt {\n  constructor(t, e, i) {\n    super(t), this._config = this._getConfig(e), this._classes = this._getClasses(i), this._dialog = d.findOne(li, this._element), this._backdrop = this._config.modalNonInvasive ? null : this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._isShown = !1, this._ignoreBackdropClick = !1, this._isTransitioning = !1, this._scrollBar = new qe(), this._didInit = !1, this._init();\n  }\n  // Getters\n  static get Default() {\n    return sa;\n  }\n  static get NAME() {\n    return Nn;\n  }\n  // Public\n  toggle(t) {\n    return this._isShown ? this.hide() : this.show(t);\n  }\n  show(t) {\n    this._isShown || this._isTransitioning || c.trigger(this._element, Mp, {\n      relatedTarget: t\n    }).defaultPrevented || (this._isShown = !0, this._isAnimated() && (this._isTransitioning = !0), !this._config.modalNonInvasive && this._scrollBar.hide(), document.body.setAttribute(la, \"true\"), this._adjustDialog(), this._setEscapeEvent(), this._setResizeEvent(), c.on(this._dialog, aa, () => {\n      c.one(this._element, Pp, (i) => {\n        i.target === this._element && (this._ignoreBackdropClick = !0);\n      });\n    }), this._showElement(t), !this._config.modalNonInvasive && this._showBackdrop());\n  }\n  hide() {\n    if (!this._isShown || this._isTransitioning || c.trigger(this._element, $p).defaultPrevented)\n      return;\n    this._isShown = !1;\n    const e = this._isAnimated();\n    e && (this._isTransitioning = !0), this._setEscapeEvent(), this._setResizeEvent(), this._focustrap.disable(), d.findOne(li, this._element).classList.remove(this._classes.show), c.off(this._element, oa), c.off(this._dialog, aa), this._queueCallback(() => this._hideModal(), this._element, e), this._element.removeAttribute(ca);\n  }\n  dispose() {\n    [window, this._dialog].forEach(\n      (t) => c.off(t, At)\n    ), this._backdrop && this._backdrop.dispose(), this._focustrap.disable(), super.dispose();\n  }\n  handleUpdate() {\n    this._adjustDialog();\n  }\n  // Private\n  _init() {\n    this._didInit || (cn(No), this._didInit = !0);\n  }\n  _initializeBackDrop() {\n    return new hr({\n      isVisible: !!this._config.backdrop,\n      // 'static' option will be translated to true, and booleans will keep their value\n      isAnimated: this._isAnimated()\n    });\n  }\n  _initializeFocusTrap() {\n    return new Wi(this._element, {\n      event: \"keydown\",\n      condition: (t) => t.key === \"Tab\"\n    });\n  }\n  _getConfig(t) {\n    return t = {\n      ...sa,\n      ...h.getDataAttributes(this._element),\n      ...typeof t == \"object\" ? t : {}\n    }, D(Nn, t, Sp), t;\n  }\n  _getClasses(t) {\n    const e = h.getDataClassAttributes(this._element);\n    return t = {\n      ...Ip,\n      ...e,\n      ...t\n    }, D(Nn, t, Dp), t;\n  }\n  _showElement(t) {\n    const e = this._isAnimated(), i = d.findOne(Bp, this._dialog);\n    (!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE) && document.body.append(this._element), this._element.style.display = \"block\", this._element.classList.remove(\"hidden\"), this._element.removeAttribute(\"aria-hidden\"), this._element.setAttribute(\"aria-modal\", !0), this._element.setAttribute(\"role\", \"dialog\"), this._element.setAttribute(`${ca}`, \"true\"), this._element.scrollTop = 0;\n    const n = d.findOne(li, this._element);\n    n.classList.add(this._classes.show), n.classList.remove(\"opacity-0\"), n.classList.add(\"opacity-100\"), i && (i.scrollTop = 0), e && Je(this._element);\n    const o = () => {\n      this._config.focus && this._focustrap.trap(), this._isTransitioning = !1, c.trigger(this._element, Rp, {\n        relatedTarget: t\n      });\n    };\n    this._queueCallback(o, this._dialog, e);\n  }\n  _setEscapeEvent() {\n    this._isShown ? c.on(document, ra, (t) => {\n      this._config.keyboard && t.key === ia ? (t.preventDefault(), this.hide()) : !this._config.keyboard && t.key === ia && this._triggerBackdropTransition();\n    }) : c.off(this._element, ra);\n  }\n  _setResizeEvent() {\n    this._isShown ? c.on(window, na, () => this._adjustDialog()) : c.off(window, na);\n  }\n  _hideModal() {\n    const t = d.findOne(li, this._element);\n    t.classList.remove(this._classes.show), t.classList.remove(\"opacity-100\"), t.classList.add(\"opacity-0\"), setTimeout(() => {\n      this._element.style.display = \"none\";\n    }, 300), this._element.setAttribute(\"aria-hidden\", !0), this._element.removeAttribute(\"aria-modal\"), this._element.removeAttribute(\"role\"), this._isTransitioning = !1, this._backdrop && this._backdrop.hide(() => {\n      document.body.removeAttribute(la), this._resetAdjustments(), !this._config.modalNonInvasive && this._scrollBar.reset(), c.trigger(this._element, Np);\n    });\n  }\n  _showBackdrop(t) {\n    c.on(this._element, oa, (e) => {\n      if (this._ignoreBackdropClick) {\n        this._ignoreBackdropClick = !1;\n        return;\n      }\n      e.target === e.currentTarget && (this._config.backdrop === !0 ? this.hide() : this._config.backdrop === \"static\" && this._triggerBackdropTransition());\n    }), this._backdrop && this._backdrop.show(t);\n  }\n  _isAnimated() {\n    return !!d.findOne(li, this._element);\n  }\n  _triggerBackdropTransition() {\n    if (c.trigger(this._element, Lp).defaultPrevented)\n      return;\n    const { classList: e, scrollHeight: i, style: n } = this._element, o = i > document.documentElement.clientHeight;\n    !o && n.overflowY === \"hidden\" || e.contains(this._classes.static) || (o || (n.overflowY = \"hidden\"), e.add(...this._classes.static.split(\" \")), e.add(...this._classes.staticProperties.split(\" \")), this._queueCallback(() => {\n      e.remove(this._classes.static), setTimeout(() => {\n        e.remove(...this._classes.staticProperties.split(\" \"));\n      }, 300), o || this._queueCallback(() => {\n        n.overflowY = \"\";\n      }, this._dialog);\n    }, this._dialog), this._element.focus());\n  }\n  // ----------------------------------------------------------------------\n  // the following methods are used to handle overflowing modals\n  // ----------------------------------------------------------------------\n  _adjustDialog() {\n    const t = this._element.scrollHeight > document.documentElement.clientHeight, e = this._scrollBar.getWidth(), i = e > 0;\n    (!i && t && !F() || i && !t && F()) && (this._element.style.paddingLeft = `${e}px`), (i && !t && !F() || !i && t && F()) && (this._element.style.paddingRight = `${e}px`);\n  }\n  _resetAdjustments() {\n    this._element.style.paddingLeft = \"\", this._element.style.paddingRight = \"\";\n  }\n  // Static\n  static jQueryInterface(t, e) {\n    return this.each(function() {\n      const i = No.getOrCreateInstance(this, t);\n      if (typeof t == \"string\") {\n        if (typeof i[t] > \"u\")\n          throw new TypeError(`No method named \"${t}\"`);\n        i[t](e);\n      }\n    });\n  }\n}\nconst Hp = /* @__PURE__ */ new Set([\n  \"background\",\n  \"cite\",\n  \"href\",\n  \"itemtype\",\n  \"longdesc\",\n  \"poster\",\n  \"src\",\n  \"xlink:href\"\n]), Vp = /^aria-[\\w-]*$/i, Wp = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i, Fp = /^data:(?:image\\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\\/(?:mpeg|mp4|ogg|webm)|audio\\/(?:mp3|oga|ogg|opus));base64,[\\d+/a-z]+=*$/i, Yp = (s, t) => {\n  const e = s.nodeName.toLowerCase();\n  if (t.includes(e))\n    return Hp.has(e) ? !!(Wp.test(s.nodeValue) || Fp.test(s.nodeValue)) : !0;\n  const i = t.filter(\n    (n) => n instanceof RegExp\n  );\n  for (let n = 0, o = i.length; n < o; n++)\n    if (i[n].test(e))\n      return !0;\n  return !1;\n}, jp = {\n  // Global attributes allowed on any supplied element below.\n  \"*\": [\"class\", \"dir\", \"id\", \"lang\", \"role\", Vp],\n  a: [\"target\", \"href\", \"title\", \"rel\"],\n  area: [],\n  b: [],\n  br: [],\n  col: [],\n  code: [],\n  div: [],\n  em: [],\n  hr: [],\n  h1: [],\n  h2: [],\n  h3: [],\n  h4: [],\n  h5: [],\n  h6: [],\n  i: [],\n  img: [\"src\", \"srcset\", \"alt\", \"title\", \"width\", \"height\"],\n  li: [],\n  ol: [],\n  p: [],\n  pre: [],\n  s: [],\n  small: [],\n  span: [],\n  sub: [],\n  sup: [],\n  strong: [],\n  u: [],\n  ul: []\n};\nfunction ha(s, t, e) {\n  if (!s.length)\n    return s;\n  if (e && typeof e == \"function\")\n    return e(s);\n  const n = new window.DOMParser().parseFromString(s, \"text/html\"), o = [].concat(...n.body.querySelectorAll(\"*\"));\n  for (let r = 0, a = o.length; r < a; r++) {\n    const l = o[r], p = l.nodeName.toLowerCase();\n    if (!Object.keys(t).includes(p)) {\n      l.remove();\n      continue;\n    }\n    const u = [].concat(...l.attributes), _ = [].concat(\n      t[\"*\"] || [],\n      t[p] || []\n    );\n    u.forEach((f) => {\n      Yp(f, _) || l.removeAttribute(f.nodeName);\n    });\n  }\n  return n.body.innerHTML;\n}\nconst da = \"tooltip\", Kp = \"te.tooltip\", wt = `.${Kp}`, zp = \"te-tooltip\", Up = /* @__PURE__ */ new Set([\"sanitize\", \"allowList\", \"sanitizeFn\"]), Xp = {\n  animation: \"boolean\",\n  template: \"string\",\n  title: \"(string|element|function)\",\n  trigger: \"string\",\n  delay: \"(number|object)\",\n  html: \"boolean\",\n  selector: \"(string|boolean)\",\n  placement: \"(string|function)\",\n  offset: \"(array|string|function)\",\n  container: \"(string|element|boolean)\",\n  fallbackPlacements: \"array\",\n  boundary: \"(string|element)\",\n  customClass: \"(string|function)\",\n  sanitize: \"boolean\",\n  sanitizeFn: \"(null|function)\",\n  allowList: \"object\",\n  popperConfig: \"(null|object|function)\"\n}, Gp = {\n  AUTO: \"auto\",\n  TOP: \"top\",\n  RIGHT: F() ? \"left\" : \"right\",\n  BOTTOM: \"bottom\",\n  LEFT: F() ? \"right\" : \"left\"\n}, qp = {\n  animation: !0,\n  template: '<div class=\"opacity-0 transition-opacity duration-300 ease-in-out absolute z-[1080] block m-0 text-sm not-italic font-normal text-left no-underline underline-offset-auto normal-case leading-6 tracking-normal break-normal whitespace-normal\" role=\"tooltip\"><div data-te-tooltip-inner-ref class=\"tooltip-inner max-w-[200px] text-sm py-1.5 px-4 text-white text-center bg-[#6d6d6d] rounded\"></div></div>',\n  trigger: \"hover focus\",\n  title: \"\",\n  delay: 0,\n  html: !1,\n  selector: !1,\n  placement: \"top\",\n  offset: [0, 0],\n  container: !1,\n  fallbackPlacements: [\"top\", \"right\", \"bottom\", \"left\"],\n  boundary: \"clippingParents\",\n  customClass: \"\",\n  sanitize: !0,\n  sanitizeFn: null,\n  allowList: jp,\n  popperConfig: { hide: !0 }\n}, Zp = {\n  HIDE: `hide${wt}`,\n  HIDDEN: `hidden${wt}`,\n  SHOW: `show${wt}`,\n  SHOWN: `shown${wt}`,\n  INSERTED: `inserted${wt}`,\n  CLICK: `click${wt}`,\n  FOCUSIN: `focusin${wt}`,\n  FOCUSOUT: `focusout${wt}`,\n  MOUSEENTER: `mouseenter${wt}`,\n  MOUSELEAVE: `mouseleave${wt}`\n}, Qp = \"fade\", Jp = \"modal\", Mn = \"show\", ci = \"show\", Rn = \"out\", ua = \".tooltip-inner\", pa = `.${Jp}`, _a = \"hide.te.modal\", hi = \"hover\", Pn = \"focus\", t_ = \"click\", e_ = \"manual\";\nclass ii extends gt {\n  constructor(t, e) {\n    if (typeof Ic > \"u\")\n      throw new TypeError(\n        \"Bootstrap's tooltips require Popper (https://popper.js.org)\"\n      );\n    super(t), this._isEnabled = !0, this._timeout = 0, this._hoverState = \"\", this._activeTrigger = {}, this._popper = null, this._config = this._getConfig(e), this.tip = null, this._setListeners();\n  }\n  // Getters\n  static get Default() {\n    return qp;\n  }\n  static get NAME() {\n    return da;\n  }\n  static get Event() {\n    return Zp;\n  }\n  static get DefaultType() {\n    return Xp;\n  }\n  // Public\n  enable() {\n    this._isEnabled = !0;\n  }\n  disable() {\n    this._isEnabled = !1;\n  }\n  toggleEnabled() {\n    this._isEnabled = !this._isEnabled;\n  }\n  toggle(t) {\n    if (this._isEnabled)\n      if (t) {\n        const e = this._initializeOnDelegatedTarget(t);\n        e._activeTrigger.click = !e._activeTrigger.click, e._isWithActiveTrigger() ? e._enter(null, e) : e._leave(null, e);\n      } else {\n        if (this.getTipElement().classList.contains(Mn)) {\n          this._leave(null, this);\n          return;\n        }\n        this._enter(null, this);\n      }\n  }\n  dispose() {\n    clearTimeout(this._timeout), c.off(\n      this._element.closest(pa),\n      _a,\n      this._hideModalHandler\n    ), this.tip && this.tip.remove(), this._disposePopper(), super.dispose();\n  }\n  show() {\n    if (this._element.style.display === \"none\")\n      throw new Error(\"Please use show on visible elements\");\n    if (!(this.isWithContent() && this._isEnabled))\n      return;\n    const t = c.trigger(\n      this._element,\n      this.constructor.Event.SHOW\n    ), e = Gl(this._element), i = e === null ? this._element.ownerDocument.documentElement.contains(this._element) : e.contains(this._element);\n    if (t.defaultPrevented || !i)\n      return;\n    this.constructor.NAME === \"tooltip\" && this.tip && this.getTitle() !== this.tip.querySelector(ua).innerHTML && (this._disposePopper(), this.tip.remove(), this.tip = null);\n    const n = this.getTipElement(), o = rt(this.constructor.NAME);\n    n.setAttribute(\"id\", o), this._element.setAttribute(\"aria-describedby\", o), this._config.animation && setTimeout(() => {\n      this.tip.classList.add(\"opacity-100\"), this.tip.classList.remove(\"opacity-0\");\n    }, 100);\n    const r = typeof this._config.placement == \"function\" ? this._config.placement.call(this, n, this._element) : this._config.placement, a = this._getAttachment(r);\n    this._addAttachmentClass(a);\n    const { container: l } = this._config;\n    if (y.setData(n, this.constructor.DATA_KEY, this), this._element.ownerDocument.documentElement.contains(this.tip) || (l.append(n), c.trigger(this._element, this.constructor.Event.INSERTED)), this._popper ? this._popper.update() : this._popper = Ce(\n      this._element,\n      n,\n      this._getPopperConfig(a)\n    ), n.getAttribute(\"id\").includes(\"tooltip\"))\n      switch (r) {\n        case \"bottom\":\n          n.classList.add(\"py-[0.4rem]\");\n          break;\n        case \"left\":\n          n.classList.add(\"px-[0.4rem]\");\n          break;\n        case \"right\":\n          n.classList.add(\"px-[0.4rem]\");\n          break;\n        default:\n          n.classList.add(\"py-[0.4rem]\");\n          break;\n      }\n    const u = this._resolvePossibleFunction(this._config.customClass);\n    u && n.classList.add(...u.split(\" \")), \"ontouchstart\" in document.documentElement && [].concat(...document.body.children).forEach((g) => {\n      c.on(g, \"mouseover\", tn);\n    });\n    const _ = () => {\n      const g = this._hoverState;\n      this._hoverState = null, c.trigger(this._element, this.constructor.Event.SHOWN), g === Rn && this._leave(null, this);\n    }, f = this.tip.classList.contains(\"transition-opacity\");\n    this._queueCallback(_, this.tip, f);\n  }\n  hide() {\n    if (!this._popper)\n      return;\n    const t = this.getTipElement(), e = () => {\n      this._isWithActiveTrigger() || (this._hoverState !== ci && t.remove(), this._cleanTipClass(), this._element.removeAttribute(\"aria-describedby\"), c.trigger(this._element, this.constructor.Event.HIDDEN), this._disposePopper());\n    };\n    if (c.trigger(\n      this._element,\n      this.constructor.Event.HIDE\n    ).defaultPrevented)\n      return;\n    t.classList.add(\"opacity-0\"), t.classList.remove(\"opacity-100\"), \"ontouchstart\" in document.documentElement && [].concat(...document.body.children).forEach((o) => c.off(o, \"mouseover\", tn)), this._activeTrigger[t_] = !1, this._activeTrigger[Pn] = !1, this._activeTrigger[hi] = !1;\n    const n = this.tip.classList.contains(\"opacity-0\");\n    this._queueCallback(e, this.tip, n), this._hoverState = \"\";\n  }\n  update() {\n    this._popper !== null && this._popper.update();\n  }\n  // Protected\n  isWithContent() {\n    return !!this.getTitle();\n  }\n  getTipElement() {\n    if (this.tip)\n      return this.tip;\n    const t = document.createElement(\"div\");\n    t.innerHTML = this._config.template;\n    const e = t.children[0];\n    return this.setContent(e), e.classList.remove(Qp, Mn), this.tip = e, this.tip;\n  }\n  setContent(t) {\n    this._sanitizeAndSetContent(t, this.getTitle(), ua);\n  }\n  _sanitizeAndSetContent(t, e, i) {\n    const n = d.findOne(i, t);\n    if (!e && n) {\n      n.remove();\n      return;\n    }\n    this.setElementContent(n, e);\n  }\n  setElementContent(t, e) {\n    if (t !== null) {\n      if (je(e)) {\n        e = te(e), this._config.html ? e.parentNode !== t && (t.innerHTML = \"\", t.append(e)) : t.textContent = e.textContent;\n        return;\n      }\n      this._config.html ? (this._config.sanitize && (e = ha(\n        e,\n        this._config.allowList,\n        this._config.sanitizeFn\n      )), t.innerHTML = e) : t.textContent = e;\n    }\n  }\n  getTitle() {\n    const t = this._element.getAttribute(\"data-te-original-title\") || this._config.title;\n    return this._resolvePossibleFunction(t);\n  }\n  updateAttachment(t) {\n    return t === \"right\" ? \"end\" : t === \"left\" ? \"start\" : t;\n  }\n  // Private\n  _initializeOnDelegatedTarget(t, e) {\n    return e || this.constructor.getOrCreateInstance(\n      t.delegateTarget,\n      this._getDelegateConfig()\n    );\n  }\n  _getOffset() {\n    const { offset: t } = this._config;\n    return typeof t == \"string\" ? t.split(\",\").map((e) => Number.parseInt(e, 10)) : typeof t == \"function\" ? (e) => t(e, this._element) : t;\n  }\n  _resolvePossibleFunction(t) {\n    return typeof t == \"function\" ? t.call(this._element) : t;\n  }\n  _getPopperConfig(t) {\n    const e = {\n      placement: t,\n      modifiers: [\n        {\n          name: \"flip\",\n          options: {\n            fallbackPlacements: this._config.fallbackPlacements\n          }\n        },\n        {\n          name: \"offset\",\n          options: {\n            offset: this._getOffset()\n          }\n        },\n        {\n          name: \"preventOverflow\",\n          options: {\n            boundary: this._config.boundary\n          }\n        },\n        {\n          name: \"arrow\",\n          options: {\n            element: `.${this.constructor.NAME}-arrow`\n          }\n        },\n        {\n          name: \"onChange\",\n          enabled: !0,\n          phase: \"afterWrite\",\n          fn: (i) => this._handlePopperPlacementChange(i)\n        }\n      ],\n      onFirstUpdate: (i) => {\n        i.options.placement !== i.placement && this._handlePopperPlacementChange(i);\n      }\n    };\n    return {\n      ...e,\n      ...typeof this._config.popperConfig == \"function\" ? this._config.popperConfig(e) : this._config.popperConfig\n    };\n  }\n  _addAttachmentClass(t) {\n    this.getTipElement().classList.add(\n      `${this._getBasicClassPrefix()}-${this.updateAttachment(t)}`\n    );\n  }\n  _getAttachment(t) {\n    return Gp[t.toUpperCase()];\n  }\n  _setListeners() {\n    this._config.trigger.split(\" \").forEach((e) => {\n      if (e === \"click\")\n        c.on(\n          this._element,\n          this.constructor.Event.CLICK,\n          this._config.selector,\n          (i) => this.toggle(i)\n        );\n      else if (e !== e_) {\n        const i = e === hi ? this.constructor.Event.MOUSEENTER : this.constructor.Event.FOCUSIN, n = e === hi ? this.constructor.Event.MOUSELEAVE : this.constructor.Event.FOCUSOUT;\n        c.on(\n          this._element,\n          i,\n          this._config.selector,\n          (o) => this._enter(o)\n        ), c.on(\n          this._element,\n          n,\n          this._config.selector,\n          (o) => this._leave(o)\n        );\n      }\n    }), this._hideModalHandler = () => {\n      this._element && this.hide();\n    }, c.on(\n      this._element.closest(pa),\n      _a,\n      this._hideModalHandler\n    ), this._config.selector ? this._config = {\n      ...this._config,\n      trigger: \"manual\",\n      selector: \"\"\n    } : this._fixTitle();\n  }\n  _fixTitle() {\n    const t = this._element.getAttribute(\"title\"), e = typeof this._element.getAttribute(\n      \"data-te-original-title\"\n    );\n    (t || e !== \"string\") && (this._element.setAttribute(\"data-te-original-title\", t || \"\"), t && !this._element.getAttribute(\"aria-label\") && !this._element.textContent && this._element.setAttribute(\"aria-label\", t), this._element.setAttribute(\"title\", \"\"));\n  }\n  _enter(t, e) {\n    if (e = this._initializeOnDelegatedTarget(t, e), t && (e._activeTrigger[t.type === \"focusin\" ? Pn : hi] = !0), e.getTipElement().classList.contains(Mn) || e._hoverState === ci) {\n      e._hoverState = ci;\n      return;\n    }\n    if (clearTimeout(e._timeout), e._hoverState = ci, !e._config.delay || !e._config.delay.show) {\n      e.show();\n      return;\n    }\n    e._timeout = setTimeout(() => {\n      e._hoverState === ci && e.show();\n    }, e._config.delay.show);\n  }\n  _leave(t, e) {\n    if (e = this._initializeOnDelegatedTarget(t, e), t && (e._activeTrigger[t.type === \"focusout\" ? Pn : hi] = e._element.contains(t.relatedTarget)), !e._isWithActiveTrigger()) {\n      if (clearTimeout(e._timeout), e._hoverState = Rn, !e._config.delay || !e._config.delay.hide) {\n        e.hide();\n        return;\n      }\n      e._timeout = setTimeout(() => {\n        e._hoverState === Rn && e.hide();\n      }, e._config.delay.hide);\n    }\n  }\n  _isWithActiveTrigger() {\n    for (const t in this._activeTrigger)\n      if (this._activeTrigger[t])\n        return !0;\n    return !1;\n  }\n  _getConfig(t) {\n    const e = h.getDataAttributes(this._element);\n    return Object.keys(e).forEach((i) => {\n      Up.has(i) && delete e[i];\n    }), t = {\n      ...this.constructor.Default,\n      ...e,\n      ...typeof t == \"object\" && t ? t : {}\n    }, t.container = t.container === !1 ? document.body : te(t.container), typeof t.delay == \"number\" && (t.delay = {\n      show: t.delay,\n      hide: t.delay\n    }), typeof t.title == \"number\" && (t.title = t.title.toString()), typeof t.content == \"number\" && (t.content = t.content.toString()), D(da, t, this.constructor.DefaultType), t.sanitize && (t.template = ha(\n      t.template,\n      t.allowList,\n      t.sanitizeFn\n    )), t;\n  }\n  _getDelegateConfig() {\n    const t = {};\n    for (const e in this._config)\n      this.constructor.Default[e] !== this._config[e] && (t[e] = this._config[e]);\n    return t;\n  }\n  _cleanTipClass() {\n    const t = this.getTipElement(), e = new RegExp(\n      `(^|\\\\s)${this._getBasicClassPrefix()}\\\\S+`,\n      \"g\"\n    ), i = t.getAttribute(\"class\").match(e);\n    i !== null && i.length > 0 && i.map((n) => n.trim()).forEach((n) => t.classList.remove(n));\n  }\n  _getBasicClassPrefix() {\n    return zp;\n  }\n  _handlePopperPlacementChange(t) {\n    const { state: e } = t;\n    e && (this.tip = e.elements.popper, this._cleanTipClass(), this._addAttachmentClass(this._getAttachment(e.placement)));\n  }\n  _disposePopper() {\n    this._popper && (this._popper.destroy(), this._popper = null);\n  }\n  // Static\n  static jQueryInterface(t) {\n    return this.each(function() {\n      const e = ii.getOrCreateInstance(this, t);\n      if (typeof t == \"string\") {\n        if (typeof e[t] > \"u\")\n          throw new TypeError(`No method named \"${t}\"`);\n        e[t]();\n      }\n    });\n  }\n}\nconst i_ = \"popover\", s_ = \"te.popover\", kt = `.${s_}`, n_ = \"te-popover\", o_ = {\n  ...ii.Default,\n  placement: \"right\",\n  offset: [0, 8],\n  trigger: \"click\",\n  content: \"\",\n  template: '<div class=\"opacity-0 transition-opacity duration-150 ease-in-out absolute top-0 left-0 z-[1070] block max-w-[267px] break-words bg-white bg-clip-padding border border-neutral-100 rounded-lg shadow-[0_0px_3px_0_rgba(0,0,0,0.07),0_2px_2px_0_rgba(0,0,0,0.04)] text-sm not-italic font-normal text-left no-underline underline-offset-auto normal-case leading-6 tracking-normal break-normal whitespace-normal dark:bg-neutral-700 dark:border-0 dark:text-white data-[popper-reference-hidden]:hidden\" role=\"tooltip\"><h3 class=\"popover-header py-2 px-4 mb-0 border-b-2 border-neutral-100 rounded-t-lg font-medium empty:hidden dark:border-neutral-500\"></h3><div class=\"popover-body p-4 text-[#212529] dark:text-white\"></div></div>'\n}, r_ = {\n  ...ii.DefaultType,\n  content: \"(string|element|function)\"\n}, a_ = {\n  HIDE: `hide${kt}`,\n  HIDDEN: `hidden${kt}`,\n  SHOW: `show${kt}`,\n  SHOWN: `shown${kt}`,\n  INSERTED: `inserted${kt}`,\n  CLICK: `click${kt}`,\n  FOCUSIN: `focusin${kt}`,\n  FOCUSOUT: `focusout${kt}`,\n  MOUSEENTER: `mouseenter${kt}`,\n  MOUSELEAVE: `mouseleave${kt}`\n}, l_ = \".popover-header\", c_ = \".popover-body\";\nclass Rc extends ii {\n  // Getters\n  static get Default() {\n    return o_;\n  }\n  static get NAME() {\n    return i_;\n  }\n  static get Event() {\n    return a_;\n  }\n  static get DefaultType() {\n    return r_;\n  }\n  // Overrides\n  isWithContent() {\n    return this.getTitle() || this._getContent();\n  }\n  setContent(t) {\n    this._sanitizeAndSetContent(t, this.getTitle(), l_), this._sanitizeAndSetContent(t, this._getContent(), c_);\n  }\n  // Private\n  _getContent() {\n    return this._resolvePossibleFunction(this._config.content);\n  }\n  _getBasicClassPrefix() {\n    return n_;\n  }\n  // Static\n  static jQueryInterface(t) {\n    return this.each(function() {\n      const e = Rc.getOrCreateInstance(this, t);\n      if (typeof t == \"string\") {\n        if (typeof e[t] > \"u\")\n          throw new TypeError(`No method named \"${t}\"`);\n        e[t]();\n      }\n    });\n  }\n}\nconst Bn = \"scrollspy\", h_ = \"te.scrollspy\", ur = `.${h_}`, fa = {\n  offset: 10,\n  method: \"auto\",\n  target: \"\"\n}, d_ = {\n  offset: \"number\",\n  method: \"string\",\n  target: \"(string|element)\"\n}, u_ = {\n  active: \"!text-primary dark:!text-primary-400 font-semibold border-l-[0.125rem] border-solid border-primary dark:border-primary-400\"\n}, p_ = {\n  active: \"string\"\n}, __ = `activate${ur}`, f_ = `scroll${ur}`, Hn = \"data-te-nav-link-active\", Pc = \"[data-te-dropdown-item-ref]\", m_ = \"[data-te-nav-list-ref]\", Mo = \"[data-te-nav-link-ref]\", g_ = \"[data-te-nav-item-ref]\", Bc = \"[data-te-list-group-item-ref]\", Vn = `${Mo}, ${Bc}, ${Pc}`, b_ = \"[data-te-dropdown-ref]\", v_ = \"[data-te-dropdown-toggle-ref]\", T_ = \"maxOffset\", ma = \"position\";\nclass Hc extends gt {\n  constructor(t, e, i) {\n    super(t), this._scrollElement = this._element.tagName === \"BODY\" ? window : this._element, this._config = this._getConfig(e), this._classes = this._getClasses(i), this._offsets = [], this._targets = [], this._activeTarget = null, this._scrollHeight = 0, c.on(this._scrollElement, f_, () => this._process()), this.refresh(), this._process();\n  }\n  // Getters\n  static get Default() {\n    return fa;\n  }\n  static get NAME() {\n    return Bn;\n  }\n  // Public\n  refresh() {\n    const t = this._scrollElement === this._scrollElement.window ? T_ : ma, e = this._config.method === \"auto\" ? t : this._config.method, i = e === ma ? this._getScrollTop() : 0;\n    this._offsets = [], this._targets = [], this._scrollHeight = this._getScrollHeight(), d.find(\n      Vn,\n      this._config.target\n    ).map((o) => {\n      const r = qo(o), a = r ? d.findOne(r) : null;\n      if (a) {\n        const l = a.getBoundingClientRect();\n        if (l.width || l.height)\n          return [\n            h[e](a).top + i,\n            r\n          ];\n      }\n      return null;\n    }).filter((o) => o).sort((o, r) => o[0] - r[0]).forEach((o) => {\n      this._offsets.push(o[0]), this._targets.push(o[1]);\n    });\n  }\n  dispose() {\n    c.off(this._scrollElement, ur), super.dispose();\n  }\n  // Private\n  _getConfig(t) {\n    return t = {\n      ...fa,\n      ...h.getDataAttributes(this._element),\n      ...typeof t == \"object\" && t ? t : {}\n    }, t.target = te(t.target) || document.documentElement, D(Bn, t, d_), t;\n  }\n  _getClasses(t) {\n    const e = h.getDataClassAttributes(this._element);\n    return t = {\n      ...u_,\n      ...e,\n      ...t\n    }, D(Bn, t, p_), t;\n  }\n  _getScrollTop() {\n    return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop;\n  }\n  _getScrollHeight() {\n    return this._scrollElement.scrollHeight || Math.max(\n      document.body.scrollHeight,\n      document.documentElement.scrollHeight\n    );\n  }\n  _getOffsetHeight() {\n    return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height;\n  }\n  _process() {\n    const t = this._getScrollTop() + this._config.offset, e = this._getScrollHeight(), i = this._config.offset + e - this._getOffsetHeight();\n    if (this._scrollHeight !== e && this.refresh(), t >= i) {\n      const n = this._targets[this._targets.length - 1];\n      this._activeTarget !== n && this._activate(n);\n      return;\n    }\n    if (this._activeTarget && t < this._offsets[0] && this._offsets[0] > 0) {\n      this._activeTarget = null, this._clear();\n      return;\n    }\n    for (let n = this._offsets.length; n--; )\n      this._activeTarget !== this._targets[n] && t >= this._offsets[n] && (typeof this._offsets[n + 1] > \"u\" || t < this._offsets[n + 1]) && this._activate(this._targets[n]);\n  }\n  _activate(t) {\n    this._activeTarget = t, this._clear();\n    const e = Vn.split(\",\").map(\n      (n) => `${n}[data-te-target=\"${t}\"],${n}[href=\"${t}\"]`\n    ), i = d.findOne(e.join(\",\"), this._config.target);\n    i.classList.add(...this._classes.active.split(\" \")), i.setAttribute(Hn, \"\"), i.getAttribute(Pc) ? d.findOne(\n      v_,\n      i.closest(b_)\n    ).classList.add(...this._classes.active.split(\" \")) : d.parents(i, m_).forEach(\n      (n) => {\n        d.prev(\n          n,\n          `${Mo}, ${Bc}`\n        ).forEach((o) => {\n          o.classList.add(...this._classes.active.split(\" \")), o.setAttribute(Hn, \"\");\n        }), d.prev(n, g_).forEach(\n          (o) => {\n            d.children(o, Mo).forEach(\n              (r) => r.classList.add(...this._classes.active.split(\" \"))\n            );\n          }\n        );\n      }\n    ), c.trigger(this._scrollElement, __, {\n      relatedTarget: t\n    });\n  }\n  _clear() {\n    d.find(Vn, this._config.target).filter(\n      (t) => t.classList.contains(...this._classes.active.split(\" \"))\n    ).forEach((t) => {\n      t.classList.remove(...this._classes.active.split(\" \")), t.removeAttribute(Hn);\n    });\n  }\n  // Static\n  static jQueryInterface(t) {\n    return this.each(function() {\n      const e = Hc.getOrCreateInstance(this, t);\n      if (typeof t == \"string\") {\n        if (typeof e[t] > \"u\")\n          throw new TypeError(`No method named \"${t}\"`);\n        e[t]();\n      }\n    });\n  }\n}\nconst ga = \"tab\", E_ = \"te.tab\", hn = `.${E_}`, C_ = `hide${hn}`, A_ = `hidden${hn}`, y_ = `show${hn}`, w_ = `shown${hn}`, k_ = \"data-te-dropdown-menu-ref\", Le = \"data-te-tab-active\", Hs = \"data-te-nav-active\", x_ = \"[data-te-dropdown-ref]\", O_ = \"[data-te-nav-ref]\", ba = `[${Le}]`, S_ = `[${Hs}]`, va = \":scope > li > .active\", I_ = \"[data-te-dropdown-toggle-ref]\", D_ = \":scope > [data-te-dropdown-menu-ref] [data-te-dropdown-show]\", $_ = {\n  show: \"opacity-100\",\n  hide: \"opacity-0\"\n}, L_ = {\n  show: \"string\",\n  hide: \"string\"\n};\nclass Vc extends gt {\n  constructor(t, e) {\n    super(t), this._classes = this._getClasses(e);\n  }\n  // Getters\n  static get NAME() {\n    return ga;\n  }\n  // Public\n  show() {\n    if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && this._element.getAttribute(Hs) === \"\")\n      return;\n    let t;\n    const e = Jt(this._element), i = this._element.closest(O_), n = d.findOne(\n      S_,\n      i\n    );\n    if (i) {\n      const l = i.nodeName === \"UL\" || i.nodeName === \"OL\" ? va : ba;\n      t = d.find(l, i), t = t[t.length - 1];\n    }\n    const o = t ? c.trigger(t, C_, {\n      relatedTarget: this._element\n    }) : null;\n    if (c.trigger(this._element, y_, {\n      relatedTarget: t\n    }).defaultPrevented || o !== null && o.defaultPrevented)\n      return;\n    this._activate(\n      this._element,\n      i,\n      null,\n      n,\n      this._element\n    );\n    const a = () => {\n      c.trigger(t, A_, {\n        relatedTarget: this._element\n      }), c.trigger(this._element, w_, {\n        relatedTarget: t\n      });\n    };\n    e ? this._activate(\n      e,\n      e.parentNode,\n      a,\n      n,\n      this._element\n    ) : a();\n  }\n  // Private\n  _getClasses(t) {\n    const e = h.getDataClassAttributes(this._element);\n    return t = {\n      ...$_,\n      ...e,\n      ...t\n    }, D(ga, t, L_), t;\n  }\n  _activate(t, e, i, n, o) {\n    const a = (e && (e.nodeName === \"UL\" || e.nodeName === \"OL\") ? d.find(va, e) : d.children(e, ba))[0], l = i && a && a.hasAttribute(Le), p = () => this._transitionComplete(\n      t,\n      a,\n      i,\n      n,\n      o\n    );\n    a && l ? (h.removeClass(a, this._classes.show), h.addClass(a, this._classes.hide), this._queueCallback(p, t, !0)) : p();\n  }\n  _transitionComplete(t, e, i, n, o) {\n    if (e && n) {\n      e.removeAttribute(Le), n.removeAttribute(Hs);\n      const a = d.findOne(\n        D_,\n        e.parentNode\n      );\n      a && a.removeAttribute(Le), e.getAttribute(\"role\") === \"tab\" && e.setAttribute(\"aria-selected\", !1);\n    }\n    t.setAttribute(Le, \"\"), o.setAttribute(Hs, \"\"), t.getAttribute(\"role\") === \"tab\" && t.setAttribute(\"aria-selected\", !0), Je(t), t.classList.contains(this._classes.hide) && (h.removeClass(t, this._classes.hide), h.addClass(t, this._classes.show));\n    let r = t.parentNode;\n    if (r && r.nodeName === \"LI\" && (r = r.parentNode), r && r.hasAttribute(k_)) {\n      const a = t.closest(x_);\n      a && d.find(I_, a).forEach(\n        (l) => l.setAttribute(Le, \"\")\n      ), t.setAttribute(\"aria-expanded\", !0);\n    }\n    i && i();\n  }\n  // Static\n  static jQueryInterface(t) {\n    return this.each(function() {\n      const e = Vc.getOrCreateInstance(this);\n      if (typeof t == \"string\") {\n        if (typeof e[t] > \"u\")\n          throw new TypeError(`No method named \"${t}\"`);\n        e[t]();\n      }\n    });\n  }\n}\nconst Wn = \"toast\", N_ = \"te.toast\", ie = `.${N_}`, M_ = `mouseover${ie}`, R_ = `mouseout${ie}`, P_ = `focusin${ie}`, B_ = `focusout${ie}`, H_ = `hide${ie}`, V_ = `hidden${ie}`, W_ = `show${ie}`, F_ = `shown${ie}`, Ta = \"data-te-toast-hide\", Fn = \"data-te-toast-show\", ns = \"data-te-toast-showing\", Y_ = {\n  animation: \"boolean\",\n  autohide: \"boolean\",\n  delay: \"number\"\n}, Ea = {\n  animation: !0,\n  autohide: !0,\n  delay: 5e3\n}, j_ = {\n  fadeIn: \"animate-[fade-in_0.3s_both] p-[auto] motion-reduce:transition-none motion-reduce:animate-none\",\n  fadeOut: \"animate-[fade-out_0.3s_both] p-[auto] motion-reduce:transition-none motion-reduce:animate-none\"\n}, K_ = {\n  fadeIn: \"string\",\n  fadeOut: \"string\"\n};\nclass Ro extends gt {\n  constructor(t, e, i) {\n    super(t), this._config = this._getConfig(e), this._classes = this._getClasses(i), this._timeout = null, this._hasMouseInteraction = !1, this._hasKeyboardInteraction = !1, this._setListeners(), this._didInit = !1, this._init();\n  }\n  // Getters\n  static get DefaultType() {\n    return Y_;\n  }\n  static get Default() {\n    return Ea;\n  }\n  static get NAME() {\n    return Wn;\n  }\n  // Public\n  show() {\n    if (c.trigger(this._element, W_).defaultPrevented)\n      return;\n    this._clearTimeout(), this._config.animation && (h.removeClass(this._element, this._classes.fadeOut), h.addClass(this._element, this._classes.fadeIn));\n    const e = () => {\n      this._element.removeAttribute(ns), c.trigger(this._element, F_), this._maybeScheduleHide();\n    };\n    this._element.removeAttribute(Ta), Je(this._element), this._element.setAttribute(Fn, \"\"), this._element.setAttribute(ns, \"\"), this._queueCallback(e, this._element, this._config.animation);\n  }\n  hide() {\n    if (!this._element || this._element.dataset.teToastShow === void 0 || c.trigger(this._element, H_).defaultPrevented)\n      return;\n    const e = () => {\n      let i = 0;\n      this._config.animation && (i = 300, h.removeClass(this._element, this._classes.fadeIn), h.addClass(this._element, this._classes.fadeOut)), setTimeout(() => {\n        this._element.setAttribute(Ta, \"\"), this._element.removeAttribute(ns), this._element.removeAttribute(Fn), c.trigger(this._element, V_);\n      }, i);\n    };\n    this._element.setAttribute(ns, \"\"), this._queueCallback(e, this._element, this._config.animation);\n  }\n  dispose() {\n    this._clearTimeout(), this._element.dataset.teToastShow !== void 0 && this._element.removeAttribute(Fn), super.dispose();\n  }\n  // Private\n  _init() {\n    this._didInit || (cn(Ro), this._didInit = !0);\n  }\n  _getConfig(t) {\n    return t = {\n      ...Ea,\n      ...h.getDataAttributes(this._element),\n      ...typeof t == \"object\" && t ? t : {}\n    }, D(Wn, t, this.constructor.DefaultType), t;\n  }\n  _getClasses(t) {\n    const e = h.getDataClassAttributes(this._element);\n    return t = {\n      ...j_,\n      ...e,\n      ...t\n    }, D(Wn, t, K_), t;\n  }\n  _maybeScheduleHide() {\n    this._config.autohide && (this._hasMouseInteraction || this._hasKeyboardInteraction || (this._timeout = setTimeout(() => {\n      this.hide();\n    }, this._config.delay)));\n  }\n  _onInteraction(t, e) {\n    switch (t.type) {\n      case \"mouseover\":\n      case \"mouseout\":\n        this._hasMouseInteraction = e;\n        break;\n      case \"focusin\":\n      case \"focusout\":\n        this._hasKeyboardInteraction = e;\n        break;\n    }\n    if (e) {\n      this._clearTimeout();\n      return;\n    }\n    const i = t.relatedTarget;\n    this._element === i || this._element.contains(i) || this._maybeScheduleHide();\n  }\n  _setListeners() {\n    c.on(\n      this._element,\n      M_,\n      (t) => this._onInteraction(t, !0)\n    ), c.on(\n      this._element,\n      R_,\n      (t) => this._onInteraction(t, !1)\n    ), c.on(\n      this._element,\n      P_,\n      (t) => this._onInteraction(t, !0)\n    ), c.on(\n      this._element,\n      B_,\n      (t) => this._onInteraction(t, !1)\n    );\n  }\n  _clearTimeout() {\n    clearTimeout(this._timeout), this._timeout = null;\n  }\n  // Static\n  static jQueryInterface(t) {\n    return this.each(function() {\n      const e = Ro.getOrCreateInstance(this, t);\n      if (typeof t == \"string\") {\n        if (typeof e[t] > \"u\")\n          throw new TypeError(`No method named \"${t}\"`);\n        e[t](this);\n      }\n    });\n  }\n}\n(() => {\n  var s = { 454: (i, n, o) => {\n    o.d(n, { Z: () => l });\n    var r = o(645), a = o.n(r)()(function(p) {\n      return p[1];\n    });\n    a.push([i.id, \"INPUT:-webkit-autofill,SELECT:-webkit-autofill,TEXTAREA:-webkit-autofill{animation-name:onautofillstart}INPUT:not(:-webkit-autofill),SELECT:not(:-webkit-autofill),TEXTAREA:not(:-webkit-autofill){animation-name:onautofillcancel}@keyframes onautofillstart{}@keyframes onautofillcancel{}\", \"\"]);\n    const l = a;\n  }, 645: (i) => {\n    i.exports = function(n) {\n      var o = [];\n      return o.toString = function() {\n        return this.map(function(r) {\n          var a = n(r);\n          return r[2] ? \"@media \".concat(r[2], \" {\").concat(a, \"}\") : a;\n        }).join(\"\");\n      }, o.i = function(r, a, l) {\n        typeof r == \"string\" && (r = [[null, r, \"\"]]);\n        var p = {};\n        if (l)\n          for (var u = 0; u < this.length; u++) {\n            var _ = this[u][0];\n            _ != null && (p[_] = !0);\n          }\n        for (var f = 0; f < r.length; f++) {\n          var g = [].concat(r[f]);\n          l && p[g[0]] || (a && (g[2] ? g[2] = \"\".concat(a, \" and \").concat(g[2]) : g[2] = a), o.push(g));\n        }\n      }, o;\n    };\n  }, 810: () => {\n    (function() {\n      if (typeof window < \"u\")\n        try {\n          var i = new window.CustomEvent(\"test\", { cancelable: !0 });\n          if (i.preventDefault(), i.defaultPrevented !== !0)\n            throw new Error(\"Could not prevent default\");\n        } catch {\n          var n = function(r, a) {\n            var l, p;\n            return (a = a || {}).bubbles = !!a.bubbles, a.cancelable = !!a.cancelable, (l = document.createEvent(\"CustomEvent\")).initCustomEvent(r, a.bubbles, a.cancelable, a.detail), p = l.preventDefault, l.preventDefault = function() {\n              p.call(this);\n              try {\n                Object.defineProperty(this, \"defaultPrevented\", { get: function() {\n                  return !0;\n                } });\n              } catch {\n                this.defaultPrevented = !0;\n              }\n            }, l;\n          };\n          n.prototype = window.Event.prototype, window.CustomEvent = n;\n        }\n    })();\n  }, 379: (i, n, o) => {\n    var r, a = function() {\n      var E = {};\n      return function(T) {\n        if (E[T] === void 0) {\n          var A = document.querySelector(T);\n          if (window.HTMLIFrameElement && A instanceof window.HTMLIFrameElement)\n            try {\n              A = A.contentDocument.head;\n            } catch {\n              A = null;\n            }\n          E[T] = A;\n        }\n        return E[T];\n      };\n    }(), l = [];\n    function p(E) {\n      for (var T = -1, A = 0; A < l.length; A++)\n        if (l[A].identifier === E) {\n          T = A;\n          break;\n        }\n      return T;\n    }\n    function u(E, T) {\n      for (var A = {}, k = [], I = 0; I < E.length; I++) {\n        var O = E[I], x = T.base ? O[0] + T.base : O[0], L = A[x] || 0, S = \"\".concat(x, \" \").concat(L);\n        A[x] = L + 1;\n        var N = p(S), P = { css: O[1], media: O[2], sourceMap: O[3] };\n        N !== -1 ? (l[N].references++, l[N].updater(P)) : l.push({ identifier: S, updater: w(P, T), references: 1 }), k.push(S);\n      }\n      return k;\n    }\n    function _(E) {\n      var T = document.createElement(\"style\"), A = E.attributes || {};\n      if (A.nonce === void 0) {\n        var k = o.nc;\n        k && (A.nonce = k);\n      }\n      if (Object.keys(A).forEach(function(O) {\n        T.setAttribute(O, A[O]);\n      }), typeof E.insert == \"function\")\n        E.insert(T);\n      else {\n        var I = a(E.insert || \"head\");\n        if (!I)\n          throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n        I.appendChild(T);\n      }\n      return T;\n    }\n    var f, g = (f = [], function(E, T) {\n      return f[E] = T, f.filter(Boolean).join(`\n`);\n    });\n    function m(E, T, A, k) {\n      var I = A ? \"\" : k.media ? \"@media \".concat(k.media, \" {\").concat(k.css, \"}\") : k.css;\n      if (E.styleSheet)\n        E.styleSheet.cssText = g(T, I);\n      else {\n        var O = document.createTextNode(I), x = E.childNodes;\n        x[T] && E.removeChild(x[T]), x.length ? E.insertBefore(O, x[T]) : E.appendChild(O);\n      }\n    }\n    function b(E, T, A) {\n      var k = A.css, I = A.media, O = A.sourceMap;\n      if (I ? E.setAttribute(\"media\", I) : E.removeAttribute(\"media\"), O && typeof btoa < \"u\" && (k += `\n/*# sourceMappingURL=data:application/json;base64,`.concat(btoa(unescape(encodeURIComponent(JSON.stringify(O)))), \" */\")), E.styleSheet)\n        E.styleSheet.cssText = k;\n      else {\n        for (; E.firstChild; )\n          E.removeChild(E.firstChild);\n        E.appendChild(document.createTextNode(k));\n      }\n    }\n    var v = null, C = 0;\n    function w(E, T) {\n      var A, k, I;\n      if (T.singleton) {\n        var O = C++;\n        A = v || (v = _(T)), k = m.bind(null, A, O, !1), I = m.bind(null, A, O, !0);\n      } else\n        A = _(T), k = b.bind(null, A, T), I = function() {\n          (function(x) {\n            if (x.parentNode === null)\n              return !1;\n            x.parentNode.removeChild(x);\n          })(A);\n        };\n      return k(E), function(x) {\n        if (x) {\n          if (x.css === E.css && x.media === E.media && x.sourceMap === E.sourceMap)\n            return;\n          k(E = x);\n        } else\n          I();\n      };\n    }\n    i.exports = function(E, T) {\n      (T = T || {}).singleton || typeof T.singleton == \"boolean\" || (T.singleton = (r === void 0 && (r = !!(window && document && document.all && !window.atob)), r));\n      var A = u(E = E || [], T);\n      return function(k) {\n        if (k = k || [], Object.prototype.toString.call(k) === \"[object Array]\") {\n          for (var I = 0; I < A.length; I++) {\n            var O = p(A[I]);\n            l[O].references--;\n          }\n          for (var x = u(k, T), L = 0; L < A.length; L++) {\n            var S = p(A[L]);\n            l[S].references === 0 && (l[S].updater(), l.splice(S, 1));\n          }\n          A = x;\n        }\n      };\n    };\n  } }, t = {};\n  function e(i) {\n    var n = t[i];\n    if (n !== void 0)\n      return n.exports;\n    var o = t[i] = { id: i, exports: {} };\n    return s[i](o, o.exports, e), o.exports;\n  }\n  e.n = (i) => {\n    var n = i && i.__esModule ? () => i.default : () => i;\n    return e.d(n, { a: n }), n;\n  }, e.d = (i, n) => {\n    for (var o in n)\n      e.o(n, o) && !e.o(i, o) && Object.defineProperty(i, o, { enumerable: !0, get: n[o] });\n  }, e.o = (i, n) => Object.prototype.hasOwnProperty.call(i, n), (() => {\n    var i = e(379), n = e.n(i), o = e(454);\n    function r(l) {\n      if (!l.hasAttribute(\"autocompleted\")) {\n        l.setAttribute(\"autocompleted\", \"\");\n        var p = new window.CustomEvent(\"onautocomplete\", { bubbles: !0, cancelable: !0, detail: null });\n        l.dispatchEvent(p) || (l.value = \"\");\n      }\n    }\n    function a(l) {\n      l.hasAttribute(\"autocompleted\") && (l.removeAttribute(\"autocompleted\"), l.dispatchEvent(new window.CustomEvent(\"onautocomplete\", { bubbles: !0, cancelable: !1, detail: null })));\n    }\n    n()(o.Z, { insert: \"head\", singleton: !1 }), o.Z.locals, e(810), document.addEventListener(\"animationstart\", function(l) {\n      l.animationName === \"onautofillstart\" ? r(l.target) : a(l.target);\n    }, !0), document.addEventListener(\"input\", function(l) {\n      l.inputType !== \"insertReplacementText\" && \"data\" in l ? a(l.target) : r(l.target);\n    }, !0);\n  })();\n})();\nconst Yn = \"input\", os = \"te.input\", Wc = \"data-te-input-wrapper-init\", Fc = \"data-te-input-notch-ref\", Yc = \"data-te-input-notch-leading-ref\", jc = \"data-te-input-notch-middle-ref\", z_ = \"data-te-input-notch-trailing-ref\", U_ = \"data-te-input-helper-ref\", X_ = \"data-te-input-placeholder-active\", Ft = \"data-te-input-state-active\", Ca = \"data-te-input-focused\", Aa = \"data-te-input-form-counter\", de = `[${Wc}] input`, ue = `[${Wc}] textarea`, ke = `[${Fc}]`, ya = `[${Yc}]`, wa = `[${jc}]`, G_ = `[${U_}]`, q_ = {\n  inputFormWhite: !1\n}, Z_ = {\n  inputFormWhite: \"(boolean)\"\n}, Kc = {\n  notch: \"group flex absolute left-0 top-0 w-full max-w-full h-full text-left pointer-events-none\",\n  notchLeading: \"pointer-events-none border border-solid box-border bg-transparent transition-all duration-200 ease-linear motion-reduce:transition-none left-0 top-0 h-full w-2 border-r-0 rounded-l-[0.25rem] group-data-[te-input-focused]:border-r-0 group-data-[te-input-state-active]:border-r-0\",\n  notchLeadingNormal: \"border-neutral-300 dark:border-neutral-600 group-data-[te-input-focused]:shadow-[-1px_0_0_#3b71ca,_0_1px_0_0_#3b71ca,_0_-1px_0_0_#3b71ca] group-data-[te-input-focused]:border-primary\",\n  notchLeadingWhite: \"border-neutral-200 group-data-[te-input-focused]:shadow-[-1px_0_0_#ffffff,_0_1px_0_0_#ffffff,_0_-1px_0_0_#ffffff] group-data-[te-input-focused]:border-white\",\n  notchMiddle: \"pointer-events-none border border-solid box-border bg-transparent transition-all duration-200 ease-linear motion-reduce:transition-none grow-0 shrink-0 basis-auto w-auto max-w-[calc(100%-1rem)] h-full border-r-0 border-l-0 group-data-[te-input-focused]:border-x-0 group-data-[te-input-state-active]:border-x-0 group-data-[te-input-focused]:border-t group-data-[te-input-state-active]:border-t group-data-[te-input-focused]:border-solid group-data-[te-input-state-active]:border-solid group-data-[te-input-focused]:border-t-transparent group-data-[te-input-state-active]:border-t-transparent\",\n  notchMiddleNormal: \"border-neutral-300 dark:border-neutral-600 group-data-[te-input-focused]:shadow-[0_1px_0_0_#3b71ca] group-data-[te-input-focused]:border-primary\",\n  notchMiddleWhite: \"border-neutral-200 group-data-[te-input-focused]:shadow-[0_1px_0_0_#ffffff] group-data-[te-input-focused]:border-white\",\n  notchTrailing: \"pointer-events-none border border-solid box-border bg-transparent transition-all duration-200 ease-linear motion-reduce:transition-none grow h-full border-l-0 rounded-r-[0.25rem] group-data-[te-input-focused]:border-l-0 group-data-[te-input-state-active]:border-l-0\",\n  notchTrailingNormal: \"border-neutral-300 dark:border-neutral-600 group-data-[te-input-focused]:shadow-[1px_0_0_#3b71ca,_0_-1px_0_0_#3b71ca,_0_1px_0_0_#3b71ca] group-data-[te-input-focused]:border-primary\",\n  notchTrailingWhite: \"border-neutral-200 group-data-[te-input-focused]:shadow-[1px_0_0_#ffffff,_0_-1px_0_0_#ffffff,_0_1px_0_0_#ffffff] group-data-[te-input-focused]:border-white\",\n  counter: \"text-right leading-[1.6]\"\n}, Q_ = {\n  notch: \"string\",\n  notchLeading: \"string\",\n  notchLeadingNormal: \"string\",\n  notchLeadingWhite: \"string\",\n  notchMiddle: \"string\",\n  notchMiddleNormal: \"string\",\n  notchMiddleWhite: \"string\",\n  notchTrailing: \"string\",\n  notchTrailingNormal: \"string\",\n  notchTrailingWhite: \"string\",\n  counter: \"string\"\n};\nclass V {\n  constructor(t, e, i) {\n    this._config = this._getConfig(e, t), this._element = t, this._classes = this._getClasses(i), this._label = null, this._labelWidth = 0, this._labelMarginLeft = 0, this._notchLeading = null, this._notchMiddle = null, this._notchTrailing = null, this._initiated = !1, this._helper = null, this._counter = !1, this._counterElement = null, this._maxLength = 0, this._leadingIcon = null, this._element && (y.setData(t, os, this), this.init());\n  }\n  // Getters\n  static get NAME() {\n    return Yn;\n  }\n  get input() {\n    return d.findOne(\"input\", this._element) || d.findOne(\"textarea\", this._element);\n  }\n  // Public\n  init() {\n    this._initiated || (this._getLabelData(), this._applyDivs(), this._applyNotch(), this._activate(), this._getHelper(), this._getCounter(), this._getEvents(), this._initiated = !0);\n  }\n  update() {\n    this._getLabelData(), this._getNotchData(), this._applyNotch(), this._activate(), this._getHelper(), this._getCounter();\n  }\n  forceActive() {\n    this.input.setAttribute(Ft, \"\"), d.findOne(ke, this.input.parentNode).setAttribute(\n      Ft,\n      \"\"\n    );\n  }\n  forceInactive() {\n    this.input.removeAttribute(Ft), d.findOne(\n      ke,\n      this.input.parentNode\n    ).removeAttribute(Ft);\n  }\n  dispose() {\n    this._removeBorder(), y.removeData(this._element, os), this._element = null;\n  }\n  // Private\n  _getConfig(t, e) {\n    return t = {\n      ...q_,\n      ...h.getDataAttributes(e),\n      ...typeof t == \"object\" ? t : {}\n    }, D(Yn, t, Z_), t;\n  }\n  _getClasses(t) {\n    const e = h.getDataClassAttributes(this._element);\n    return t = {\n      ...Kc,\n      ...e,\n      ...t\n    }, D(Yn, t, Q_), t;\n  }\n  _getLabelData() {\n    this._label = d.findOne(\"label\", this._element), this._label === null ? this._showPlaceholder() : (this._getLabelWidth(), this._getLabelPositionInInputGroup(), this._toggleDefaultDatePlaceholder());\n  }\n  _getHelper() {\n    this._helper = d.findOne(G_, this._element);\n  }\n  _getCounter() {\n    this._counter = h.getDataAttribute(\n      this.input,\n      \"inputShowcounter\"\n    ), this._counter && (this._maxLength = this.input.maxLength, this._showCounter());\n  }\n  _getEvents() {\n    c.on(\n      document,\n      \"focus\",\n      de,\n      V.activate(new V())\n    ), c.on(\n      document,\n      \"input\",\n      de,\n      V.activate(new V())\n    ), c.on(\n      document,\n      \"blur\",\n      de,\n      V.deactivate(new V())\n    ), c.on(\n      document,\n      \"focus\",\n      ue,\n      V.activate(new V())\n    ), c.on(\n      document,\n      \"input\",\n      ue,\n      V.activate(new V())\n    ), c.on(\n      document,\n      \"blur\",\n      ue,\n      V.deactivate(new V())\n    ), c.on(window, \"shown.te.modal\", (t) => {\n      d.find(de, t.target).forEach(\n        (e) => {\n          const i = V.getInstance(e.parentNode);\n          i && i.update();\n        }\n      ), d.find(ue, t.target).forEach(\n        (e) => {\n          const i = V.getInstance(e.parentNode);\n          i && i.update();\n        }\n      );\n    }), c.on(window, \"shown.te.dropdown\", (t) => {\n      const e = t.target.parentNode.querySelector(\n        \"[data-te-dropdown-menu-ref]\"\n      );\n      e && (d.find(de, e).forEach(\n        (i) => {\n          const n = V.getInstance(i.parentNode);\n          n && n.update();\n        }\n      ), d.find(ue, e).forEach(\n        (i) => {\n          const n = V.getInstance(i.parentNode);\n          n && n.update();\n        }\n      ));\n    }), c.on(window, \"shown.te.tab\", (t) => {\n      let e;\n      t.target.href ? e = t.target.href.split(\"#\")[1] : e = h.getDataAttribute(t.target, \"target\").split(\n        \"#\"\n      )[1];\n      const i = d.findOne(`#${e}`);\n      d.find(de, i).forEach((n) => {\n        const o = V.getInstance(n.parentNode);\n        o && o.update();\n      }), d.find(ue, i).forEach(\n        (n) => {\n          const o = V.getInstance(n.parentNode);\n          o && o.update();\n        }\n      );\n    }), c.on(window, \"reset\", (t) => {\n      d.find(de, t.target).forEach(\n        (e) => {\n          const i = V.getInstance(e.parentNode);\n          i && i.forceInactive();\n        }\n      ), d.find(ue, t.target).forEach(\n        (e) => {\n          const i = V.getInstance(e.parentNode);\n          i && i.forceInactive();\n        }\n      );\n    }), c.on(window, \"onautocomplete\", (t) => {\n      const e = V.getInstance(t.target.parentNode);\n      !e || !t.cancelable || e.forceActive();\n    });\n  }\n  _showCounter() {\n    if (d.find(\n      `[${Aa}]`,\n      this._element\n    ).length > 0)\n      return;\n    this._counterElement = document.createElement(\"div\"), h.addClass(this._counterElement, this._classes.counter), this._counterElement.setAttribute(Aa, \"\");\n    const e = this.input.value.length;\n    this._counterElement.innerHTML = `${e} / ${this._maxLength}`, this._helper.appendChild(this._counterElement), this._bindCounter();\n  }\n  _bindCounter() {\n    c.on(this.input, \"input\", () => {\n      const t = this.input.value.length;\n      this._counterElement.innerHTML = `${t} / ${this._maxLength}`;\n    });\n  }\n  _toggleDefaultDatePlaceholder(t = this.input) {\n    if (!(t.getAttribute(\"type\") === \"date\"))\n      return;\n    !(document.activeElement === t) && !t.value ? t.style.opacity = 0 : t.style.opacity = 1;\n  }\n  _showPlaceholder() {\n    this.input.setAttribute(X_, \"\");\n  }\n  _getNotchData() {\n    this._notchMiddle = d.findOne(\n      wa,\n      this._element\n    ), this._notchLeading = d.findOne(\n      ya,\n      this._element\n    );\n  }\n  _getLabelWidth() {\n    this._labelWidth = this._label.clientWidth * 0.8 + 8;\n  }\n  _getLabelPositionInInputGroup() {\n    if (this._labelMarginLeft = 0, !this._element.hasAttribute(\"data-te-input-group-ref\"))\n      return;\n    const t = this.input, e = d.prev(\n      t,\n      \"[data-te-input-group-text-ref]\"\n    )[0];\n    e === void 0 ? this._labelMarginLeft = 0 : this._labelMarginLeft = e.offsetWidth - 1;\n  }\n  _applyDivs() {\n    const t = this._config.inputFormWhite ? this._classes.notchLeadingWhite : this._classes.notchLeadingNormal, e = this._config.inputFormWhite ? this._classes.notchMiddleWhite : this._classes.notchMiddleNormal, i = this._config.inputFormWhite ? this._classes.notchTrailingWhite : this._classes.notchTrailingNormal, n = d.find(ke, this._element), o = $(\"div\");\n    h.addClass(o, this._classes.notch), o.setAttribute(Fc, \"\"), this._notchLeading = $(\"div\"), h.addClass(\n      this._notchLeading,\n      `${this._classes.notchLeading} ${t}`\n    ), this._notchLeading.setAttribute(Yc, \"\"), this._notchMiddle = $(\"div\"), h.addClass(\n      this._notchMiddle,\n      `${this._classes.notchMiddle} ${e}`\n    ), this._notchMiddle.setAttribute(jc, \"\"), this._notchTrailing = $(\"div\"), h.addClass(\n      this._notchTrailing,\n      `${this._classes.notchTrailing} ${i}`\n    ), this._notchTrailing.setAttribute(z_, \"\"), !(n.length >= 1) && (o.append(this._notchLeading), o.append(this._notchMiddle), o.append(this._notchTrailing), this._element.append(o));\n  }\n  _applyNotch() {\n    this._notchMiddle.style.width = `${this._labelWidth}px`, this._notchLeading.style.width = `${this._labelMarginLeft + 9}px`, this._label !== null && (this._label.style.marginLeft = `${this._labelMarginLeft}px`);\n  }\n  _removeBorder() {\n    const t = d.findOne(ke, this._element);\n    t && t.remove();\n  }\n  _activate(t) {\n    Zl(() => {\n      this._getElements(t);\n      const e = t ? t.target : this.input, i = d.findOne(\n        ke,\n        this._element\n      );\n      t && t.type === \"focus\" && i && i.setAttribute(Ca, \"\"), e.value !== \"\" && (e.setAttribute(Ft, \"\"), i && i.setAttribute(Ft, \"\")), this._toggleDefaultDatePlaceholder(e);\n    });\n  }\n  _getElements(t) {\n    if (t && (this._element = t.target.parentNode, this._label = d.findOne(\"label\", this._element)), t && this._label) {\n      const e = this._labelWidth;\n      this._getLabelData(), e !== this._labelWidth && (this._notchMiddle = d.findOne(\n        wa,\n        t.target.parentNode\n      ), this._notchLeading = d.findOne(\n        ya,\n        t.target.parentNode\n      ), this._applyNotch());\n    }\n  }\n  _deactivate(t) {\n    const e = t ? t.target : this.input, i = d.findOne(\n      ke,\n      e.parentNode\n    );\n    i.removeAttribute(Ca), e.value === \"\" && (e.removeAttribute(Ft), i.removeAttribute(Ft)), this._toggleDefaultDatePlaceholder(e);\n  }\n  static activate(t) {\n    return function(e) {\n      t._activate(e);\n    };\n  }\n  static deactivate(t) {\n    return function(e) {\n      t._deactivate(e);\n    };\n  }\n  static jQueryInterface(t, e) {\n    return this.each(function() {\n      let i = y.getData(this, os);\n      const n = typeof t == \"object\" && t;\n      if (!(!i && /dispose/.test(t)) && (i || (i = new V(this, n)), typeof t == \"string\")) {\n        if (typeof i[t] > \"u\")\n          throw new TypeError(`No method named \"${t}\"`);\n        i[t](e);\n      }\n    });\n  }\n  static getInstance(t) {\n    return y.getData(t, os);\n  }\n  static getOrCreateInstance(t, e = {}) {\n    return this.getInstance(t) || new this(t, typeof e == \"object\" ? e : null);\n  }\n}\nconst ka = \"animation\", jn = \"te.animation\", J_ = {\n  animation: \"string\",\n  animationStart: \"string\",\n  animationShowOnLoad: \"boolean\",\n  onStart: \"(null|function)\",\n  onEnd: \"(null|function)\",\n  onHide: \"(null|function)\",\n  onShow: \"(null|function)\",\n  animationOnScroll: \"(string)\",\n  animationWindowHeight: \"number\",\n  animationOffset: \"(number|string)\",\n  animationDelay: \"(number|string)\",\n  animationReverse: \"boolean\",\n  animationInterval: \"(number|string)\",\n  animationRepeat: \"(number|boolean)\",\n  animationReset: \"boolean\"\n}, tf = {\n  animation: \"fade\",\n  animationStart: \"onClick\",\n  animationShowOnLoad: !0,\n  onStart: null,\n  onEnd: null,\n  onHide: null,\n  onShow: null,\n  animationOnScroll: \"once\",\n  animationWindowHeight: 0,\n  animationOffset: 0,\n  animationDelay: 0,\n  animationReverse: !1,\n  animationInterval: 0,\n  animationRepeat: !1,\n  animationReset: !1\n};\nclass pr {\n  constructor(t, e) {\n    this._element = t, this._animateElement = this._getAnimateElement(), this._isFirstScroll = !0, this._repeatAnimateOnScroll = !0, this._options = this._getConfig(e), this._element && (y.setData(t, jn, this), this._init());\n  }\n  // Getters\n  static get NAME() {\n    return ka;\n  }\n  // Public\n  init() {\n    this._init();\n  }\n  startAnimation() {\n    this._startAnimation();\n  }\n  stopAnimation() {\n    this._clearAnimationClass();\n  }\n  changeAnimationType(t) {\n    this._options.animation = t;\n  }\n  dispose() {\n    c.off(this._element, \"mousedown\"), c.off(this._animateElement, \"animationend\"), c.off(window, \"scroll\"), c.off(this._element, \"mouseover\"), y.removeData(this._element, jn), this._element = null, this._animateElement = null, this._isFirstScroll = null, this._repeatAnimateOnScroll = null, this._options = null;\n  }\n  // Private\n  _init() {\n    switch (this._options.animationStart) {\n      case \"onHover\":\n        this._bindHoverEvents();\n        break;\n      case \"onLoad\":\n        this._startAnimation();\n        break;\n      case \"onScroll\":\n        this._bindScrollEvents();\n        break;\n      case \"onClick\":\n        this._bindClickEvents();\n        break;\n    }\n    this._bindTriggerOnEndCallback(), this._options.animationReset && this._bindResetAnimationAfterFinish();\n  }\n  _getAnimateElement() {\n    const t = h.getDataAttribute(\n      this._element,\n      \"animation-target\"\n    );\n    return t ? d.find(t)[0] : this._element;\n  }\n  _getConfig(t) {\n    const e = h.getDataAttributes(this._animateElement);\n    return t = {\n      ...tf,\n      ...e,\n      ...t\n    }, D(ka, t, J_), t;\n  }\n  _animateOnScroll() {\n    const t = h.offset(this._animateElement).top, e = this._animateElement.offsetHeight, i = window.innerHeight, n = t + this._options.animationOffset <= i && t + this._options.animationOffset + e >= 0, o = this._animateElement.style.visibility === \"visible\";\n    switch (!0) {\n      case (n && this._isFirstScroll):\n        this._isFirstScroll = !1, this._startAnimation();\n        break;\n      case (!n && this._isFirstScroll):\n        this._isFirstScroll = !1, this._hideAnimateElement();\n        break;\n      case (n && !o && this._repeatAnimateOnScroll):\n        this._options.animationOnScroll !== \"repeat\" && (this._repeatAnimateOnScroll = !1), this._callback(this._options.onShow), this._showAnimateElement(), this._startAnimation();\n        break;\n      case (!n && o && this._repeatAnimateOnScroll):\n        this._hideAnimateElement(), this._clearAnimationClass(), this._callback(this._options.onHide);\n        break;\n    }\n  }\n  _addAnimatedClass() {\n    h.addClass(\n      this._animateElement,\n      `animate-${this._options.animation}`\n    );\n  }\n  _clearAnimationClass() {\n    this._animateElement.classList.remove(`animate-${this._options.animation}`);\n  }\n  _startAnimation() {\n    this._callback(this._options.onStart), this._addAnimatedClass(), this._options.animationRepeat && !this._options.animationInterval && this._setAnimationRepeat(), this._options.animationReverse && this._setAnimationReverse(), this._options.animationDelay && this._setAnimationDelay(), this._options.animationDuration && this._setAnimationDuration(), this._options.animationInterval && this._setAnimationInterval();\n  }\n  _setAnimationReverse() {\n    h.style(this._animateElement, {\n      animationIterationCount: this._options.animationRepeat === !0 ? \"infinite\" : \"2\",\n      animationDirection: \"alternate\"\n    });\n  }\n  _setAnimationDuration() {\n    h.style(this._animateElement, {\n      animationDuration: `${this._options.animationDuration}ms`\n    });\n  }\n  _setAnimationDelay() {\n    h.style(this._animateElement, {\n      animationDelay: `${this._options.animationDelay}ms`\n    });\n  }\n  _setAnimationRepeat() {\n    h.style(this._animateElement, {\n      animationIterationCount: this._options.animationRepeat === !0 ? \"infinite\" : this._options.animationRepeat\n    });\n  }\n  _setAnimationInterval() {\n    c.on(this._animateElement, \"click\", () => {\n      this._clearAnimationClass(), setTimeout(() => {\n        this._addAnimatedClass();\n      }, this._options.animationInterval);\n    });\n  }\n  _hideAnimateElement() {\n    h.style(this._animateElement, { visibility: \"hidden\" });\n  }\n  _showAnimateElement() {\n    h.style(this._animateElement, { visibility: \"visible\" });\n  }\n  _bindResetAnimationAfterFinish() {\n    c.on(this._animateElement, \"animationend\", () => {\n      this._clearAnimationClass();\n    });\n  }\n  _bindTriggerOnEndCallback() {\n    c.on(this._animateElement, \"animationend\", () => {\n      this._callback(this._options.onEnd);\n    });\n  }\n  _bindScrollEvents() {\n    this._options.animationShowOnLoad || this._animateOnScroll(), c.on(window, \"scroll\", () => {\n      this._animateOnScroll();\n    });\n  }\n  _bindClickEvents() {\n    c.on(this._element, \"mousedown\", () => {\n      this._startAnimation();\n    });\n  }\n  _bindHoverEvents() {\n    c.one(this._element, \"mouseover\", () => {\n      this._startAnimation();\n    }), c.one(this._animateElement, \"animationend\", () => {\n      setTimeout(() => {\n        this._bindHoverEvents();\n      }, 100);\n    });\n  }\n  _callback(t) {\n    t instanceof Function && t();\n  }\n  // Static\n  static autoInit(t) {\n    t._init();\n  }\n  static jQueryInterface(t) {\n    new pr(this[0], t).init();\n  }\n  static getInstance(t) {\n    return y.getData(t, jn);\n  }\n  static getOrCreateInstance(t, e = {}) {\n    return this.getInstance(t) || new this(t, typeof e == \"object\" ? e : null);\n  }\n}\nconst Kn = \"ripple\", rs = \"te.ripple\", ef = \"rgba({{color}}, 0.2) 0, rgba({{color}}, 0.3) 40%, rgba({{color}}, 0.4) 50%, rgba({{color}}, 0.5) 60%, rgba({{color}}, 0) 70%\", sf = [\"[data-te-ripple-init]\"], as = [0, 0, 0], nf = [\n  { name: \"primary\", gradientColor: \"#3B71CA\" },\n  { name: \"secondary\", gradientColor: \"#9FA6B2\" },\n  { name: \"success\", gradientColor: \"#14A44D\" },\n  { name: \"danger\", gradientColor: \"#DC4C64\" },\n  { name: \"warning\", gradientColor: \"#E4A11B\" },\n  { name: \"info\", gradientColor: \"#54B4D3\" },\n  { name: \"light\", gradientColor: \"#fbfbfb\" },\n  { name: \"dark\", gradientColor: \"#262626\" }\n], xa = 0.5, of = {\n  rippleCentered: !1,\n  rippleColor: \"\",\n  rippleColorDark: \"\",\n  rippleDuration: \"500ms\",\n  rippleRadius: 0,\n  rippleUnbound: !1\n}, rf = {\n  rippleCentered: \"boolean\",\n  rippleColor: \"string\",\n  rippleColorDark: \"string\",\n  rippleDuration: \"string\",\n  rippleRadius: \"number\",\n  rippleUnbound: \"boolean\"\n}, af = {\n  ripple: \"relative overflow-hidden inline-block align-bottom\",\n  rippleWave: \"rounded-[50%] opacity-50 pointer-events-none absolute touch-none scale-0 transition-[transform,_opacity] ease-[cubic-bezier(0,0,0.15,1),_cubic-bezier(0,0,0.15,1)] z-[999]\",\n  unbound: \"overflow-visible\"\n}, lf = {\n  ripple: \"string\",\n  rippleWave: \"string\",\n  unbound: \"string\"\n};\nclass Ze {\n  constructor(t, e, i) {\n    this._element = t, this._options = this._getConfig(e), this._classes = this._getClasses(i), this._element && (y.setData(t, rs, this), h.addClass(this._element, this._classes.ripple)), this._clickHandler = this._createRipple.bind(this), this._rippleTimer = null, this._isMinWidthSet = !1, this._initialClasses = null, this.init();\n  }\n  // Getters\n  static get NAME() {\n    return Kn;\n  }\n  // Public\n  init() {\n    this._addClickEvent(this._element);\n  }\n  dispose() {\n    y.removeData(this._element, rs), c.off(this._element, \"click\", this._clickHandler), this._element = null, this._options = null;\n  }\n  // Private\n  _autoInit(t) {\n    sf.forEach((e) => {\n      d.closest(t.target, e) && (this._element = d.closest(t.target, e));\n    }), this._element.style.minWidth || (h.style(this._element, {\n      \"min-width\": getComputedStyle(this._element).width\n    }), this._isMinWidthSet = !0), this._options = this._getConfig(), this._classes = this._getClasses(), this._initialClasses = [...this._element.classList], h.addClass(this._element, this._classes.ripple), this._createRipple(t);\n  }\n  _addClickEvent(t) {\n    c.on(t, \"mousedown\", this._clickHandler);\n  }\n  _createRipple(t) {\n    this._element.className.indexOf(this._classes.ripple) < 0 && h.addClass(this._element, this._classes.ripple);\n    const { layerX: e, layerY: i } = t, n = t.offsetX || e, o = t.offsetY || i, r = this._element.offsetHeight, a = this._element.offsetWidth, l = this._durationToMsNumber(this._options.rippleDuration), p = {\n      offsetX: this._options.rippleCentered ? r / 2 : n,\n      offsetY: this._options.rippleCentered ? a / 2 : o,\n      height: r,\n      width: a\n    }, u = this._getDiameter(p), _ = this._options.rippleRadius || u / 2, f = {\n      delay: l * xa,\n      duration: l - l * xa\n    }, g = {\n      left: this._options.rippleCentered ? `${a / 2 - _}px` : `${n - _}px`,\n      top: this._options.rippleCentered ? `${r / 2 - _}px` : `${o - _}px`,\n      height: `${this._options.rippleRadius * 2 || u}px`,\n      width: `${this._options.rippleRadius * 2 || u}px`,\n      transitionDelay: `0s, ${f.delay}ms`,\n      transitionDuration: `${l}ms, ${f.duration}ms`\n    }, m = $(\"div\");\n    this._createHTMLRipple({\n      wrapper: this._element,\n      ripple: m,\n      styles: g\n    }), this._removeHTMLRipple({ ripple: m, duration: l });\n  }\n  _createHTMLRipple({ wrapper: t, ripple: e, styles: i }) {\n    Object.keys(i).forEach(\n      (n) => e.style[n] = i[n]\n    ), h.addClass(e, this._classes.rippleWave), e.setAttribute(\"data-te-ripple-ref\", \"\"), this._addColor(e, t), this._toggleUnbound(t), this._appendRipple(e, t);\n  }\n  _removeHTMLRipple({ ripple: t, duration: e }) {\n    this._rippleTimer && (clearTimeout(this._rippleTimer), this._rippleTimer = null), t && setTimeout(() => {\n      t.classList.add(\"!opacity-0\");\n    }, 10), this._rippleTimer = setTimeout(() => {\n      if (t && (t.remove(), this._element)) {\n        d.find(\"[data-te-ripple-ref]\", this._element).forEach(\n          (n) => {\n            n.remove();\n          }\n        ), this._isMinWidthSet && (h.style(this._element, { \"min-width\": \"\" }), this._isMinWidthSet = !1);\n        const i = this._initialClasses ? this._addedNewRippleClasses(\n          this._classes.ripple,\n          this._initialClasses\n        ) : this._classes.ripple.split(\" \");\n        h.removeClass(this._element, i);\n      }\n    }, e);\n  }\n  _addedNewRippleClasses(t, e) {\n    return t.split(\" \").filter(\n      (i) => e.findIndex((n) => i === n) === -1\n    );\n  }\n  _durationToMsNumber(t) {\n    return Number(t.replace(\"ms\", \"\").replace(\"s\", \"000\"));\n  }\n  _getConfig(t = {}) {\n    const e = h.getDataAttributes(this._element);\n    return t = {\n      ...of,\n      ...e,\n      ...t\n    }, D(Kn, t, rf), t;\n  }\n  _getClasses(t = {}) {\n    const e = h.getDataClassAttributes(this._element);\n    return t = {\n      ...af,\n      ...e,\n      ...t\n    }, D(Kn, t, lf), t;\n  }\n  _getDiameter({ offsetX: t, offsetY: e, height: i, width: n }) {\n    const o = e <= i / 2, r = t <= n / 2, a = (f, g) => Math.sqrt(f ** 2 + g ** 2), l = e === i / 2 && t === n / 2, p = {\n      first: o === !0 && r === !1,\n      second: o === !0 && r === !0,\n      third: o === !1 && r === !0,\n      fourth: o === !1 && r === !1\n    }, u = {\n      topLeft: a(t, e),\n      topRight: a(n - t, e),\n      bottomLeft: a(t, i - e),\n      bottomRight: a(n - t, i - e)\n    };\n    let _ = 0;\n    return l || p.fourth ? _ = u.topLeft : p.third ? _ = u.topRight : p.second ? _ = u.bottomRight : p.first && (_ = u.bottomLeft), _ * 2;\n  }\n  _appendRipple(t, e) {\n    e.appendChild(t), setTimeout(() => {\n      h.addClass(t, \"opacity-0 scale-100\");\n    }, 50);\n  }\n  _toggleUnbound(t) {\n    this._options.rippleUnbound === !0 ? h.addClass(t, this._classes.unbound) : h.removeClass(t, this._classes.unbound);\n  }\n  _addColor(t) {\n    let e = this._options.rippleColor || \"rgb(0,0,0)\";\n    (localStorage.theme === \"dark\" || !(\"theme\" in localStorage) && window.matchMedia(\"(prefers-color-scheme: dark)\").matches) && (e = this._options.rippleColorDark || this._options.rippleColor);\n    const i = nf.find(\n      (r) => r.name === e.toLowerCase()\n    ), n = i ? this._colorToRGB(i.gradientColor).join(\",\") : this._colorToRGB(e).join(\",\"), o = ef.split(\"{{color}}\").join(`${n}`);\n    t.style.backgroundImage = `radial-gradient(circle, ${o})`;\n  }\n  _colorToRGB(t) {\n    function e(o) {\n      return o.length < 7 && (o = `#${o[1]}${o[1]}${o[2]}${o[2]}${o[3]}${o[3]}`), [\n        parseInt(o.substr(1, 2), 16),\n        parseInt(o.substr(3, 2), 16),\n        parseInt(o.substr(5, 2), 16)\n      ];\n    }\n    function i(o) {\n      const r = document.body.appendChild(\n        document.createElement(\"fictum\")\n      ), a = \"rgb(1, 2, 3)\";\n      return r.style.color = a, r.style.color !== a || (r.style.color = o, r.style.color === a || r.style.color === \"\") ? as : (o = getComputedStyle(r).color, document.body.removeChild(r), o);\n    }\n    function n(o) {\n      return o = o.match(/[.\\d]+/g).map((r) => +Number(r)), o.length = 3, o;\n    }\n    return t.toLowerCase() === \"transparent\" ? as : t[0] === \"#\" ? e(t) : (t.indexOf(\"rgb\") === -1 && (t = i(t)), t.indexOf(\"rgb\") === 0 ? n(t) : as);\n  }\n  // Static\n  static autoInitial(t) {\n    return function(e) {\n      t._autoInit(e);\n    };\n  }\n  static jQueryInterface(t) {\n    return this.each(function() {\n      return y.getData(this, rs) ? null : new Ze(this, t);\n    });\n  }\n  static getInstance(t) {\n    return y.getData(t, rs);\n  }\n  static getOrCreateInstance(t, e = {}) {\n    return this.getInstance(t) || new this(t, typeof e == \"object\" ? e : null);\n  }\n}\nfunction Z(s) {\n  return s.getDate();\n}\nfunction Vs(s) {\n  return s.getDay();\n}\nfunction Y(s) {\n  return s.getMonth();\n}\nfunction B(s) {\n  return s.getFullYear();\n}\nfunction cf(s, t, e) {\n  const i = e.startDay, n = i > 0 ? 7 - i : 0, r = new Date(s, t).getDay() + n;\n  return r >= 7 ? r - 7 : r;\n}\nfunction Po(s) {\n  return hf(s).getDate();\n}\nfunction hf(s) {\n  return Et(s.getFullYear(), s.getMonth() + 1, 0);\n}\nfunction Be() {\n  return /* @__PURE__ */ new Date();\n}\nfunction it(s, t) {\n  return nt(s, t * 12);\n}\nfunction nt(s, t) {\n  const e = Et(\n    s.getFullYear(),\n    s.getMonth() + t,\n    s.getDate()\n  ), i = Z(s), n = Z(e);\n  return i !== n && e.setDate(0), e;\n}\nfunction xe(s, t) {\n  return Et(s.getFullYear(), s.getMonth(), s.getDate() + t);\n}\nfunction Et(s, t, e) {\n  const i = new Date(s, t, e);\n  return s >= 0 && s < 100 && i.setFullYear(i.getFullYear() - 1900), i;\n}\nfunction Oa(s) {\n  const t = s.split(\"-\"), e = t[0], i = t[1], n = t[2];\n  return Et(e, i, n);\n}\nfunction df(s) {\n  return !Number.isNaN(s.getTime());\n}\nfunction Re(s, t) {\n  return B(s) - B(t) || Y(s) - Y(t) || Z(s) - Z(t);\n}\nfunction fe(s, t) {\n  return s.setHours(0, 0, 0, 0), t.setHours(0, 0, 0, 0), s.getTime() === t.getTime();\n}\nfunction Ws(s, t) {\n  const i = B(s) - pf();\n  return uf(i, t);\n}\nfunction uf(s, t) {\n  return (s % t + t) % t;\n}\nfunction pf(s, t, e) {\n  let i = 0;\n  return e ? i = B(e) - s + 1 : t && (i = B(t)), i;\n}\nfunction nn(s, t, e, i, n, o) {\n  const r = /* @__PURE__ */ new Date();\n  r.setHours(0, 0, 0, 0);\n  const a = t && Re(s, t) <= -1, l = e && Re(s, e) >= 1, p = n && Re(s, r) <= -1, u = o && Re(s, r) >= 1, _ = i && i(s) === !1;\n  return a || l || _ || p || u;\n}\nfunction zc(s, t, e, i, n, o) {\n  const r = /* @__PURE__ */ new Date(), a = i && B(i), l = i && Y(i), p = e && B(e), u = e && Y(e), _ = B(r), f = Y(r), g = l && a && (t > a || t === a && s > l), m = u && p && (t < p || t === p && s < u), b = n && (t < _ || t === _ && s < f), v = o && (t > _ || t === _ && s > f);\n  return g || m || b || v;\n}\nfunction Bo(s, t, e, i, n) {\n  const o = t && B(t), r = e && B(e), a = B(/* @__PURE__ */ new Date()), l = r && s > r, p = o && s < o, u = i && s < a, _ = n && s > a;\n  return l || p || u || _;\n}\nfunction _f(s, t, e, i, n, o, r, a) {\n  const l = /* @__PURE__ */ new Date();\n  return l.setHours(0, 0, 0, 0), (s && o && Re(o, l) < 0 || s) && (o = l), o && Di(\n    t,\n    o,\n    e,\n    i,\n    n,\n    o,\n    r,\n    a\n  );\n}\nfunction ff(s, t, e, i, n, o, r, a) {\n  const l = /* @__PURE__ */ new Date();\n  return l.setHours(0, 0, 0, 0), (s && n && Re(n, l) < 0 || s) && (n = l), n && Di(\n    t,\n    n,\n    e,\n    i,\n    n,\n    o,\n    r,\n    a\n  );\n}\nfunction Di(s, t, e, i, n, o, r, a) {\n  return e === \"days\" ? B(s) === B(t) && Y(s) === Y(t) : e === \"months\" ? B(s) === B(t) : e === \"years\" ? B(t) >= a && B(t) <= r : !1;\n}\nconst mf = \"data-te-datepicker-modal-container-ref\", gf = \"data-te-datepicker-dropdown-container-ref\", bf = \"data-te-dropdown-backdrop-ref\", vf = \"data-te-datepicker-date-text-ref\", Sa = \"data-te-datepicker-view-ref\", Tf = \"data-te-datepicker-previous-button-ref\", Ef = \"data-te-datepicker-next-button-ref\", Cf = \"data-te-datepicker-ok-button-ref\", Af = \"data-te-datepicker-cancel-button-ref\", yf = \"data-te-datepicker-clear-button-ref\", wf = \"data-te-datepicker-view-change-button-ref\";\nfunction kf(s, t, e, i, n, o, r, a, l, p) {\n  const u = Y(s), _ = B(s), f = Z(s), g = Vs(s), m = $(\"div\"), b = `\n        ${Ia(\n    s,\n    u,\n    _,\n    t,\n    e,\n    i,\n    n,\n    o,\n    r,\n    a,\n    p\n  )}\n    `, v = `\n      ${Of(f, g, u, n, p)}\n      ${Ia(\n    s,\n    u,\n    _,\n    t,\n    e,\n    i,\n    n,\n    o,\n    r,\n    a,\n    p\n  )}\n    `;\n  return n.inline ? (h.addClass(m, p.datepickerDropdownContainer), m.setAttribute(gf, l), m.innerHTML = b) : (h.addClass(m, p.modalContainer), m.setAttribute(mf, l), m.innerHTML = v), m;\n}\nfunction xf(s) {\n  const t = $(\"div\");\n  return h.addClass(t, s), t.setAttribute(bf, \"\"), t;\n}\nfunction Of(s, t, e, i, n) {\n  return `\n      <div class=\"${n.datepickerHeader}\" data-te-datepicker-header>\n        <div class=\"${n.datepickerTitle}\">\n          <span class=\"${n.datepickerTitleText}\">${i.title}</span>\n        </div>\n        <div class=\"${n.datepickerDate}\">\n          <span class=\"${n.datepickerDateText}\" ${vf} >${i.weekdaysShort[t]}, ${i.monthsShort[e]} ${s}</span>\n        </div>\n      </div>\n    `;\n}\nfunction Ia(s, t, e, i, n, o, r, a, l, p, u) {\n  let _;\n  return r.inline ? _ = `\n    <div class=\"${u.datepickerMain}\">\n      ${$a(t, e, r, u)}\n      <div class=\"${u.datepickerView}\" ${Sa} tabindex=\"0\">\n        ${Da(\n    s,\n    e,\n    i,\n    n,\n    o,\n    r,\n    a,\n    l,\n    p,\n    u\n  )}\n      </div>\n    </div>\n  ` : _ = `\n    <div class=\"${u.datepickerMain}\">\n      ${$a(t, e, r, u)}\n      <div class=\"${u.datepickerView}\" ${Sa} tabindex=\"0\">\n        ${Da(\n    s,\n    e,\n    i,\n    n,\n    o,\n    r,\n    a,\n    l,\n    p,\n    u\n  )}\n      </div>\n      ${Sf(r, u)}\n    </div>\n  `, _;\n}\nfunction Da(s, t, e, i, n, o, r, a, l, p) {\n  let u;\n  return o.view === \"days\" ? u = Fs(s, e, o, p) : o.view === \"months\" ? u = Ys(\n    t,\n    i,\n    n,\n    o,\n    r,\n    p\n  ) : u = js(\n    s,\n    i,\n    o,\n    a,\n    l,\n    p\n  ), u;\n}\nfunction $a(s, t, e, i) {\n  return `\n    <div class=\"${i.datepickerDateControls}\">\n      <button class=\"${i.datepickerViewChangeButton}\" aria-label=\"${e.switchToMultiYearViewLabel}\" ${wf}>\n        ${e.monthsFull[s]} ${t} ${$t(\n    e,\n    i\n  )}\n      </button>\n      <div class=\"${i.datepickerArrowControls}\">\n        <button class=\"${i.datepickerPreviousButton}\" aria-label=\"${e.prevMonthLabel}\" ${Tf}>${e.changeMonthIconTemplate}</button>\n        <button class=\"${i.datepickerNextButton}\" aria-label=\"${e.nextMonthLabel}\" ${Ef}>${e.changeMonthIconTemplate}</button>\n      </div>\n    </div>\n    `;\n}\nfunction $t(s, t) {\n  return `\n  <span class=\"${t.datepickerViewChangeIcon}\">\n  ${s.viewChangeIconTemplate}\n  </span>\n  `;\n}\nfunction Sf(s, t) {\n  const e = `<button class=\"${t.datepickerFooterBtn}\" aria-label=\"${s.okBtnLabel}\" ${Cf}>${s.okBtnText}</button>`, i = `<button class=\"${t.datepickerFooterBtn}\" aria-label=\"${s.cancelBtnLabel}\" ${Af}>${s.cancelBtnText}</button>`, n = `<button class=\"${t.datepickerFooterBtn} ${t.datepickerClearBtn}\" aria-label=\"${s.clearBtnLabel}\" ${yf}>${s.clearBtnText}</button>`;\n  return `\n        <div class=\"${t.datepickerFooter}\">\n          \n        ${s.removeClearBtn ? \"\" : n}\n        ${s.removeCancelBtn ? \"\" : i}\n        ${s.removeOkBtn ? \"\" : e}\n        </div>\n      `;\n}\nfunction Fs(s, t, e, i) {\n  const n = If(s, t, e), r = `\n      <tr>\n        ${e.weekdaysNarrow.map((l, p) => `<th class=\"${i.datepickerDayHeading}\" scope=\"col\" aria-label=\"${e.weekdaysFull[p]}\">${l}</th>`).join(\"\")}\n      </tr>\n    `, a = n.map((l) => `\n        <tr>\n          ${l.map((p) => `\n              <td\n              class=\"${i.datepickerCell} ${i.datepickerCellSmall}\"\n              data-te-date=\"${B(p.date)}-${Y(\n    p.date\n  )}-${Z(p.date)}\"\n              aria-label=\"${p.date}\"\n              aria-selected=\"${p.isSelected}\"\n              ${p.isSelected ? \"data-te-datepicker-cell-selected\" : \"\"}\n              ${!p.currentMonth || p.disabled ? \"data-te-datepicker-cell-disabled\" : \"\"}\n              ${p.isToday ? \"data-te-datepicker-cell-current\" : \"\"}\n              >\n                <div\n                  class=\"${i.datepickerCellContent} ${i.datepickerCellContentSmall}\"\n                  style=\"${p.currentMonth ? \"display: block\" : \"display: none\"}\"\n                  >\n                  ${p.dayNumber}\n                  </div>\n              </td>\n            `).join(\"\")}\n        </tr>\n      `).join(\"\");\n  return `\n      <table class=\"${i.datepickerTable}\">\n        <thead>\n          ${r}\n        </thead>\n        <tbody>\n         ${a}\n        </tbody>\n      </table>\n    `;\n}\nfunction If(s, t, e) {\n  const i = [], n = Y(s), o = Y(nt(s, -1)), r = Y(nt(s, 1)), a = B(s), l = cf(a, n, e), p = Po(s), u = Po(nt(s, -1)), _ = 7;\n  let f = 1, g = !1;\n  for (let m = 1; m < _; m++) {\n    const b = [];\n    if (m === 1) {\n      const v = u - l + 1;\n      for (let w = v; w <= u; w++) {\n        const E = Et(a, o, w);\n        b.push({\n          date: E,\n          currentMonth: g,\n          isSelected: t && fe(E, t),\n          isToday: fe(E, Be()),\n          dayNumber: Z(E)\n        });\n      }\n      g = !0;\n      const C = _ - b.length;\n      for (let w = 0; w < C; w++) {\n        const E = Et(a, n, f);\n        b.push({\n          date: E,\n          currentMonth: g,\n          isSelected: t && fe(E, t),\n          isToday: fe(E, Be()),\n          dayNumber: Z(E),\n          disabled: nn(\n            E,\n            e.min,\n            e.max,\n            e.filter,\n            e.disablePast,\n            e.disableFuture\n          )\n        }), f++;\n      }\n    } else\n      for (let v = 1; v < 8; v++) {\n        f > p && (f = 1, g = !1);\n        const C = Et(\n          a,\n          g ? n : r,\n          f\n        );\n        b.push({\n          date: C,\n          currentMonth: g,\n          isSelected: t && fe(C, t),\n          isToday: fe(C, Be()),\n          dayNumber: Z(C),\n          disabled: nn(\n            C,\n            e.min,\n            e.max,\n            e.filter,\n            e.disablePast,\n            e.disableFuture\n          )\n        }), f++;\n      }\n    i.push(b);\n  }\n  return i;\n}\nfunction Ys(s, t, e, i, n, o) {\n  const r = Df(i, n), a = Y(Be()), l = B(Be()), p = `\n      ${r.map((u) => `\n          <tr>\n            ${u.map((_) => {\n    const f = i.monthsShort.indexOf(_);\n    return `\n                <td class=\"${o.datepickerCell} ${o.datepickerCellLarge}\"\n                ${zc(\n      f,\n      s,\n      i.min,\n      i.max,\n      i.disablePast,\n      i.disableFuture\n    ) ? \"data-te-datepicker-cell-disabled\" : \"\"}\n                \n                data-te-month=\"${f}\" data-te-year=\"${s}\" aria-label=\"${_}, ${s}\"\n                ${f === e && s === t ? \"data-te-datepicker-cell-selected\" : \"\"}\n                ${f === a && s === l ? \"data-te-datepicker-cell-current\" : \"\"}\" data-te-month=\"${f}\" data-te-year=\"${s}\" aria-label=\"${_}, ${s}\">\n                  <div class=\"${o.datepickerCellContent} ${o.datepickerCellContentLarge}\">${_}</div>\n                </td>\n              `;\n  }).join(\"\")}\n          </tr>\n        `).join(\"\")}\n    `;\n  return `\n      <table class=\"${o.datepickerTable}\">\n        <tbody>\n         ${p}\n        </tbody>\n      </table>\n    `;\n}\nfunction Df(s, t) {\n  const e = [];\n  let i = [];\n  for (let n = 0; n < s.monthsShort.length; n++)\n    if (i.push(s.monthsShort[n]), i.length === t) {\n      const o = i;\n      e.push(o), i = [];\n    }\n  return e;\n}\nfunction js(s, t, e, i, n, o) {\n  const r = $f(s, i, n), a = B(Be()), l = `\n    ${r.map((p) => `\n        <tr>\n          ${p.map((u) => `\n              <td class=\"${o.datepickerCell} ${o.datepickerCellLarge}\"  aria-label=\"${u}\" data-te-year=\"${u}\"\n              ${Bo(\n    u,\n    e.min,\n    e.max,\n    e.disablePast,\n    e.disableFuture\n  ) ? \"data-te-datepicker-cell-disabled\" : \"\"}\n              ${u === t ? \"data-te-datepicker-cell-selected\" : \"\"}\n              ${u === a ? \"data-te-datepicker-cell-current\" : \"\"}\n              >\n                <div class=\"${o.datepickerCellContent} ${o.datepickerCellContentLarge}\">${u}</div>\n              </td>\n            `).join(\"\")}\n        </tr>\n      `).join(\"\")}\n  `;\n  return `\n      <table class=\"${o.datepickerTable}\">\n        <tbody>\n        ${l}\n        </tbody>\n      </table>\n    `;\n}\nfunction $f(s, t, e) {\n  const i = [], n = B(s), o = Ws(s, t), r = n - o;\n  let a = [];\n  for (let l = 0; l < t; l++)\n    if (a.push(r + l), a.length === e) {\n      const p = a;\n      i.push(p), a = [];\n    }\n  return i;\n}\nfunction Lf(s, t) {\n  return `\n    <button id=\"${s}\" type=\"button\" class=\"${t}\" data-te-datepicker-toggle-button-ref data-te-datepicker-toggle-ref>\n      <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" fill=\"currentColor\">\n      <path fill-rule=\"evenodd\" d=\"M6.75 2.25A.75.75 0 017.5 3v1.5h9V3A.75.75 0 0118 3v1.5h.75a3 3 0 013 3v11.25a3 3 0 01-3 3H5.25a3 3 0 01-3-3V7.5a3 3 0 013-3H6V3a.75.75 0 01.75-.75zm13.5 9a1.5 1.5 0 00-1.5-1.5H5.25a1.5 1.5 0 00-1.5 1.5v7.5a1.5 1.5 0 001.5 1.5h13.5a1.5 1.5 0 001.5-1.5v-7.5z\" clip-rule=\"evenodd\" />\n      </svg>  \n    </button>\n  `;\n}\nconst He = 37, at = 38, Ve = 39, z = 40, We = 36, Fe = 35, zn = 33, Un = 34, ct = 13, Ks = 32, Fi = 27, Pi = 9, Nf = 8, Mf = 46, vt = 24, ls = 4, cs = 4, Xn = \"datepicker\", zs = \"te.datepicker\", dn = `.${zs}`, Rf = \".data-api\", Pf = `close${dn}`, Bf = `open${dn}`, Hf = `dateChange${dn}`, hs = `click${dn}${Rf}`, Uc = \"data-te-datepicker-modal-container-ref\", Xc = \"data-te-datepicker-dropdown-container-ref\", ds = \"[data-te-datepicker-toggle-ref]\", Vf = `[${Uc}]`, Wf = `[${Xc}]`, Ff = \"[data-te-datepicker-view-change-button-ref]\", Yf = \"[data-te-datepicker-previous-button-ref]\", jf = \"[data-te-datepicker-next-button-ref]\", Kf = \"[data-te-datepicker-ok-button-ref]\", zf = \"[data-te-datepicker-cancel-button-ref]\", Uf = \"[data-te-datepicker-clear-button-ref]\", Xf = \"[data-te-datepicker-view-ref]\", Gf = \"[data-te-datepicker-toggle-button-ref]\", qf = \"[data-te-datepicker-date-text-ref]\", Zf = \"[data-te-dropdown-backdrop-ref]\", Qf = \"animate-[fade-in_0.3s_both] px-[auto] motion-reduce:transition-none motion-reduce:animate-none\", Jf = \"animate-[fade-out_0.3s_both] px-[auto] motion-reduce:transition-none motion-reduce:animate-none\", tm = \"animate-[fade-in_0.15s_both] px-[auto] motion-reduce:transition-none motion-reduce:animate-none\", em = \"animate-[fade-out_0.15s_both] px-[auto] motion-reduce:transition-none motion-reduce:animate-none\", im = \"flex flex-col fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-[328px] h-[512px] bg-white rounded-[0.6rem] shadow-lg z-[1066] xs:max-md:landscape:w-[475px] xs:max-md:landscape:h-[360px] xs:max-md:landscape:flex-row dark:bg-zinc-700\", sm = \"w-full h-full fixed top-0 right-0 left-0 bottom-0 bg-black/40 z-[1065]\", nm = \"relative h-full\", om = \"xs:max-md:landscape:h-full h-[120px] px-6 bg-primary flex flex-col rounded-t-lg dark:bg-zinc-800\", rm = \"h-8 flex flex-col justify-end\", am = \"text-[10px] font-normal uppercase tracking-[1.7px] text-white\", lm = \"xs:max-md:landscape:mt-24 h-[72px] flex flex-col justify-end\", cm = \"text-[34px] font-normal text-white\", hm = \"outline-none px-3\", dm = \"px-3 pt-2.5 pb-0 flex justify-between text-black/[64]\", um = \"flex items-center outline-none p-2.5 text-neutral-500 font-medium text-[0.9rem] rounded-xl shadow-none bg-transparent m-0 border-none hover:bg-neutral-200 focus:bg-neutral-200  dark:text-white dark:hover:bg-white/10 dark:focus:bg-white/10\", pm = \"mt-2.5\", _m = \"p-0 w-10 h-10 leading-10 border-none outline-none m-0 text-gray-600 bg-transparent mr-6 hover:bg-neutral-200 hover:rounded-[50%] focus:bg-neutral-200 focus:rounded-[50%] dark:text-white dark:hover:bg-white/10 dark:focus:bg-white/10 [&>svg]:w-4 [&>svg]:h-4 [&>svg]:mx-auto\", fm = \"p-0 w-10 h-10 leading-10 border-none outline-none m-0 text-gray-600 bg-transparent hover:bg-neutral-200 hover:rounded-[50%] focus:bg-neutral-200 focus:rounded-[50%] dark:text-white dark:hover:bg-white/10 dark:focus:bg-white/10 [&>svg]:w-4 [&>svg]:h-4 [&>svg]:rotate-180 [&>svg]:mx-auto\", mm = \"h-14 flex absolute w-full bottom-0 justify-end items-center px-3\", gm = \"outline-none bg-white text-primary border-none cursor-pointer py-0 px-2.5 uppercase text-[0.8rem] leading-10 font-medium h-10 tracking-[.1rem] rounded-[10px] mb-2.5 hover:bg-neutral-200 focus:bg-neutral-200 dark:bg-transparent dark:text-white dark:hover:bg-white/10 dark:focus:bg-white/10\", bm = \"mr-auto\", vm = \"w-10 h-10 text-center text-[12px] font-normal dark:text-white\", Tm = \"text-center data-[te-datepicker-cell-disabled]:text-neutral-300 data-[te-datepicker-cell-disabled]:cursor-default data-[te-datepicker-cell-disabled]:pointer-events-none data-[te-datepicker-cell-disabled]:hover:cursor-default hover:cursor-pointer group\", Em = \"w-10 h-10 xs:max-md:landscape:w-8 xs:max-md:landscape:h-8\", Cm = \"w-[76px] h-[42px]\", Am = \"mx-auto group-[:not([data-te-datepicker-cell-disabled]):not([data-te-datepicker-cell-selected]):hover]:bg-neutral-300 group-[[data-te-datepicker-cell-selected]]:bg-primary group-[[data-te-datepicker-cell-selected]]:text-white group-[:not([data-te-datepicker-cell-selected])[data-te-datepicker-cell-focused]]:bg-neutral-100 group-[[data-te-datepicker-cell-focused]]:data-[te-datepicker-cell-selected]:bg-primary group-[[data-te-datepicker-cell-current]]:border-solid group-[[data-te-datepicker-cell-current]]:border-black group-[[data-te-datepicker-cell-current]]:border dark:group-[:not([data-te-datepicker-cell-disabled]):not([data-te-datepicker-cell-selected]):hover]:bg-white/10 dark:group-[[data-te-datepicker-cell-current]]:border-white dark:text-white dark:group-[:not([data-te-datepicker-cell-selected])[data-te-datepicker-cell-focused]]:bg-white/10 dark:group-[[data-te-datepicker-cell-disabled]]:text-neutral-500\", ym = \"w-9 h-9 leading-9 rounded-[50%] text-[13px]\", wm = \"w-[72px] h-10 leading-10 py-[1px] px-0.5 rounded-[999px]\", km = \"mx-auto w-[304px]\", xm = \"flex items-center justify-content-center [&>svg]:w-5 [&>svg]:h-5 absolute outline-none border-none bg-transparent right-0.5 top-1/2 -translate-x-1/2 -translate-y-1/2 hover:text-primary focus:text-primary dark:hover:text-primary-400 dark:focus:text-primary-400 dark:text-neutral-200\", Om = \"inline-block pointer-events-none ml-[3px] [&>svg]:w-4 [&>svg]:h-4 [&>svg]:fill-neutral-500 dark:[&>svg]:fill-white\", Sm = \"w-[328px] h-[380px] bg-white rounded-lg shadow-[0px_2px_15px_-3px_rgba(0,0,0,.07),_0px_10px_20px_-2px_rgba(0,0,0,.04)] z-[1066] dark:bg-zinc-700\", Im = {\n  title: \"Select date\",\n  container: \"body\",\n  disablePast: !1,\n  disableFuture: !1,\n  monthsFull: [\n    \"January\",\n    \"February\",\n    \"March\",\n    \"April\",\n    \"May\",\n    \"June\",\n    \"July\",\n    \"August\",\n    \"September\",\n    \"October\",\n    \"November\",\n    \"December\"\n  ],\n  monthsShort: [\n    \"Jan\",\n    \"Feb\",\n    \"Mar\",\n    \"Apr\",\n    \"May\",\n    \"Jun\",\n    \"Jul\",\n    \"Aug\",\n    \"Sep\",\n    \"Oct\",\n    \"Nov\",\n    \"Dec\"\n  ],\n  weekdaysFull: [\n    \"Sunday\",\n    \"Monday\",\n    \"Tuesday\",\n    \"Wednesday\",\n    \"Thursday\",\n    \"Friday\",\n    \"Saturday\"\n  ],\n  weekdaysShort: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n  weekdaysNarrow: [\"S\", \"M\", \"T\", \"W\", \"T\", \"F\", \"S\"],\n  okBtnText: \"Ok\",\n  clearBtnText: \"Clear\",\n  cancelBtnText: \"Cancel\",\n  okBtnLabel: \"Confirm selection\",\n  clearBtnLabel: \"Clear selection\",\n  cancelBtnLabel: \"Cancel selection\",\n  nextMonthLabel: \"Next month\",\n  prevMonthLabel: \"Previous month\",\n  nextYearLabel: \"Next year\",\n  prevYearLabel: \"Previous year\",\n  changeMonthIconTemplate: `<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"3\" stroke=\"currentColor\" class=\"w-6 h-6\">\n  <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M15.75 19.5L8.25 12l7.5-7.5\" />\n  </svg>\n  `,\n  nextMultiYearLabel: \"Next 24 years\",\n  prevMultiYearLabel: \"Previous 24 years\",\n  switchToMultiYearViewLabel: \"Choose year and month\",\n  switchToMonthViewLabel: \"Choose date\",\n  switchToDayViewLabel: \"Choose date\",\n  startDate: null,\n  startDay: 0,\n  format: \"dd/mm/yyyy\",\n  view: \"days\",\n  viewChangeIconTemplate: `<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"0\" stroke=\"currentColor\" class=\"w-6 h-6\">\n  <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M19.5 8.25l-7.5 7.5-7.5-7.5\" />\n  </svg>\n  `,\n  min: null,\n  max: null,\n  filter: null,\n  inline: !1,\n  toggleButton: !0,\n  disableToggleButton: !1,\n  disableInput: !1,\n  animations: !0,\n  confirmDateOnSelect: !1,\n  removeOkBtn: !1,\n  removeCancelBtn: !1,\n  removeClearBtn: !1\n}, Dm = {\n  title: \"string\",\n  container: \"string\",\n  disablePast: \"boolean\",\n  disableFuture: \"boolean\",\n  monthsFull: \"array\",\n  monthsShort: \"array\",\n  weekdaysFull: \"array\",\n  weekdaysShort: \"array\",\n  weekdaysNarrow: \"array\",\n  okBtnText: \"string\",\n  clearBtnText: \"string\",\n  cancelBtnText: \"string\",\n  okBtnLabel: \"string\",\n  clearBtnLabel: \"string\",\n  cancelBtnLabel: \"string\",\n  nextMonthLabel: \"string\",\n  prevMonthLabel: \"string\",\n  nextYearLabel: \"string\",\n  prevYearLabel: \"string\",\n  nextMultiYearLabel: \"string\",\n  prevMultiYearLabel: \"string\",\n  changeMonthIconTemplate: \"string\",\n  switchToMultiYearViewLabel: \"string\",\n  switchToMonthViewLabel: \"string\",\n  switchToDayViewLabel: \"string\",\n  startDate: \"(null|string|date)\",\n  startDay: \"number\",\n  format: \"string\",\n  view: \"string\",\n  viewChangeIconTemplate: \"string\",\n  min: \"(null|string|date)\",\n  max: \"(null|string|date)\",\n  filter: \"(null|function)\",\n  inline: \"boolean\",\n  toggleButton: \"boolean\",\n  disableToggleButton: \"boolean\",\n  disableInput: \"boolean\",\n  animations: \"boolean\",\n  confirmDateOnSelect: \"boolean\",\n  removeOkBtn: \"boolean\",\n  removeCancelBtn: \"boolean\",\n  removeClearBtn: \"boolean\"\n}, $m = {\n  fadeIn: Qf,\n  fadeOut: Jf,\n  fadeInShort: tm,\n  fadeOutShort: em,\n  modalContainer: im,\n  datepickerBackdrop: sm,\n  datepickerMain: nm,\n  datepickerHeader: om,\n  datepickerTitle: rm,\n  datepickerTitleText: am,\n  datepickerDate: lm,\n  datepickerDateText: cm,\n  datepickerView: hm,\n  datepickerDateControls: dm,\n  datepickerViewChangeButton: um,\n  datepickerViewChangeIcon: Om,\n  datepickerArrowControls: pm,\n  datepickerPreviousButton: _m,\n  datepickerNextButton: fm,\n  datepickerFooter: mm,\n  datepickerFooterBtn: gm,\n  datepickerClearBtn: bm,\n  datepickerDayHeading: vm,\n  datepickerCell: Tm,\n  datepickerCellSmall: Em,\n  datepickerCellLarge: Cm,\n  datepickerCellContent: Am,\n  datepickerCellContentSmall: ym,\n  datepickerCellContentLarge: wm,\n  datepickerTable: km,\n  datepickerToggleButton: xm,\n  datepickerDropdownContainer: Sm\n}, Lm = {\n  fadeIn: \"string\",\n  fadeOut: \"string\",\n  fadeInShort: \"string\",\n  fadeOutShort: \"string\",\n  modalContainer: \"string\",\n  datepickerBackdrop: \"string\",\n  datepickerMain: \"string\",\n  datepickerHeader: \"string\",\n  datepickerTitle: \"string\",\n  datepickerTitleText: \"string\",\n  datepickerDate: \"string\",\n  datepickerDateText: \"string\",\n  datepickerView: \"string\",\n  datepickerDateControls: \"string\",\n  datepickerViewChangeButton: \"string\",\n  datepickerArrowControls: \"string\",\n  datepickerPreviousButton: \"string\",\n  datepickerNextButton: \"string\",\n  datepickerFooter: \"string\",\n  datepickerFooterBtn: \"string\",\n  datepickerClearBtn: \"string\",\n  datepickerDayHeading: \"string\",\n  datepickerCell: \"string\",\n  datepickerCellSmall: \"string\",\n  datepickerCellLarge: \"string\",\n  datepickerCellContent: \"string\",\n  datepickerCellContentSmall: \"string\",\n  datepickerCellContentLarge: \"string\",\n  datepickerTable: \"string\",\n  datepickerToggleButton: \"string\",\n  datepickerDropdownContainer: \"string\"\n};\nclass Nm {\n  constructor(t, e, i) {\n    this._element = t, this._input = d.findOne(\"input\", this._element), this._options = this._getConfig(e), this._classes = this._getClasses(i), this._activeDate = /* @__PURE__ */ new Date(), this._selectedDate = null, this._selectedYear = null, this._selectedMonth = null, this._headerDate = null, this._headerYear = null, this._headerMonth = null, this._view = this._options.view, this._popper = null, this._focusTrap = null, this._isOpen = !1, this._toggleButtonId = rt(\"datepicker-toggle-\"), this._animations = !window.matchMedia(\"(prefers-reduced-motion: reduce)\").matches && this._options.animations, this._scrollBar = new qe(), this._element && y.setData(t, zs, this), this._init(), this.toggleButton && this._options.disableToggle && (this.toggleButton.disabled = \"true\"), this._options.disableInput && (this._input.disabled = \"true\");\n  }\n  // Getters\n  static get NAME() {\n    return Xn;\n  }\n  get container() {\n    return d.findOne(\n      `[${Uc}='${this._toggleButtonId}']`\n    ) || d.findOne(\n      `[${Xc}='${this._toggleButtonId}']`\n    );\n  }\n  get options() {\n    return this._options;\n  }\n  get activeCell() {\n    let t;\n    return this._view === \"days\" && (t = this._getActiveDayCell()), this._view === \"months\" && (t = this._getActiveMonthCell()), this._view === \"years\" && (t = this._getActiveYearCell()), t;\n  }\n  get activeDay() {\n    return Z(this._activeDate);\n  }\n  get activeMonth() {\n    return Y(this._activeDate);\n  }\n  get activeYear() {\n    return B(this._activeDate);\n  }\n  get firstYearInView() {\n    return this.activeYear - Ws(this._activeDate, vt);\n  }\n  get lastYearInView() {\n    return this.firstYearInView + vt - 1;\n  }\n  get viewChangeButton() {\n    return d.findOne(Ff, this.container);\n  }\n  get previousButton() {\n    return d.findOne(Yf, this.container);\n  }\n  get nextButton() {\n    return d.findOne(jf, this.container);\n  }\n  get okButton() {\n    return d.findOne(Kf, this.container);\n  }\n  get cancelButton() {\n    return d.findOne(zf, this.container);\n  }\n  get clearButton() {\n    return d.findOne(Uf, this.container);\n  }\n  get datesContainer() {\n    return d.findOne(Xf, this.container);\n  }\n  get toggleButton() {\n    return d.findOne(Gf, this._element);\n  }\n  update(t = {}) {\n    this._options = this._getConfig({ ...this._options, ...t });\n  }\n  _getConfig(t) {\n    const e = h.getDataAttributes(this._element);\n    if (t = {\n      ...Im,\n      ...e,\n      ...t\n    }, D(Xn, t, Dm), t.max && typeof t.max == \"string\" && (t.max = new Date(t.max)), t.min && typeof t.min == \"string\" && (t.min = new Date(t.min)), t.startDay && t.startDay !== 0) {\n      const i = this._getNewDaysOrderArray(t);\n      t.weekdaysNarrow = i;\n    }\n    return t;\n  }\n  _getClasses(t) {\n    const e = h.getDataClassAttributes(this._element);\n    return t = {\n      ...$m,\n      ...e,\n      ...t\n    }, D(Xn, t, Lm), t;\n  }\n  _getContainer() {\n    return d.findOne(this._options.container);\n  }\n  _getNewDaysOrderArray(t) {\n    const e = t.startDay, i = t.weekdaysNarrow;\n    return i.slice(e).concat(i.slice(0, e));\n  }\n  _init() {\n    !this.toggleButton && this._options.toggleButton && (this._appendToggleButton(), (this._input.readOnly || this._input.disabled) && (this.toggleButton.style.pointerEvents = \"none\")), this._listenToUserInput(), this._listenToToggleClick(), this._listenToToggleKeydown();\n  }\n  _appendToggleButton() {\n    const t = Lf(\n      this._toggleButtonId,\n      this._classes.datepickerToggleButton\n    );\n    this._element.insertAdjacentHTML(\"beforeend\", t);\n  }\n  open() {\n    if (this._input.readOnly || this._input.disabled)\n      return;\n    const t = c.trigger(this._element, Bf);\n    if (this._isOpen || t.defaultPrevented)\n      return;\n    this._setInitialDate();\n    const e = xf(this._classes.datepickerBackdrop), i = kf(\n      this._activeDate,\n      this._selectedDate,\n      this._selectedYear,\n      this._selectedMonth,\n      this._options,\n      cs,\n      vt,\n      ls,\n      this._toggleButtonId,\n      this._classes\n    );\n    this._options.inline ? this._openDropdown(i) : (this._openModal(e, i), this._scrollBar.hide()), this._animations && (h.addClass(this.container, this._classes.fadeIn), h.addClass(e, this._classes.fadeInShort)), this._setFocusTrap(this.container), this._listenToDateSelection(), this._addControlsListeners(), this._updateControlsDisabledState(), this._listenToEscapeClick(), this._listenToKeyboardNavigation(), this._listenToDatesContainerFocus(), this._listenToDatesContainerBlur(), this._asyncFocusDatesContainer(), this._updateViewControlsAndAttributes(this._view), this._isOpen = !0, setTimeout(() => {\n      this._listenToOutsideClick();\n    }, 0);\n  }\n  _openDropdown(t) {\n    this._popper = Ce(this._input, t, {\n      placement: \"bottom-start\"\n    }), this._getContainer().appendChild(t);\n  }\n  _openModal(t, e) {\n    const i = this._getContainer();\n    i.appendChild(t), i.appendChild(e);\n  }\n  _setFocusTrap(t) {\n    this._focusTrap = new Wi(t, {\n      event: \"keydown\",\n      condition: (e) => e.key === \"Tab\"\n    }), this._focusTrap.trap();\n  }\n  _listenToUserInput() {\n    c.on(this._input, \"input\", (t) => {\n      this._handleUserInput(t.target.value);\n    });\n  }\n  _listenToToggleClick() {\n    c.on(\n      this._element,\n      hs,\n      ds,\n      (t) => {\n        t.preventDefault(), this.open();\n      }\n    );\n  }\n  _listenToToggleKeydown() {\n    c.on(\n      this._element,\n      \"keydown\",\n      ds,\n      (t) => {\n        t.keyCode === ct && !this._isOpen && this.open();\n      }\n    );\n  }\n  _listenToDateSelection() {\n    c.on(this.datesContainer, \"click\", (t) => {\n      this._handleDateSelection(t);\n    });\n  }\n  _handleDateSelection(t) {\n    const e = t.target.nodeName === \"DIV\" ? t.target.parentNode.dataset : t.target.dataset, i = t.target.nodeName === \"DIV\" ? t.target.parentNode : t.target;\n    if (e.teDate && this._pickDay(e.teDate, i), e.teMonth && e.teYear) {\n      const n = parseInt(e.teMonth, 10), o = parseInt(e.teYear, 10);\n      this._pickMonth(n, o);\n    }\n    if (e.teYear && !e.teMonth) {\n      const n = parseInt(e.teYear, 10);\n      this._pickYear(n);\n    }\n    this._options.inline || this._updateHeaderDate(\n      this._activeDate,\n      this._options.monthsShort,\n      this._options.weekdaysShort\n    );\n  }\n  _updateHeaderDate(t, e, i) {\n    const n = d.findOne(\n      qf,\n      this.container\n    ), o = Y(t), r = Z(t), a = Vs(t);\n    n.innerHTML = `${i[a]}, ${e[o]} ${r}`;\n  }\n  _addControlsListeners() {\n    c.on(this.nextButton, \"click\", () => {\n      this._view === \"days\" ? this.nextMonth() : this._view === \"years\" ? this.nextYears() : this.nextYear(), this._updateControlsDisabledState();\n    }), c.on(this.previousButton, \"click\", () => {\n      this._view === \"days\" ? this.previousMonth() : this._view === \"years\" ? this.previousYears() : this.previousYear(), this._updateControlsDisabledState();\n    }), c.on(this.viewChangeButton, \"click\", () => {\n      this._view === \"days\" ? this._changeView(\"years\") : (this._view === \"years\" || this._view === \"months\") && this._changeView(\"days\");\n    }), this._options.inline || this._listenToFooterButtonsClick();\n  }\n  _listenToFooterButtonsClick() {\n    c.on(this.okButton, \"click\", () => this.handleOk()), c.on(this.cancelButton, \"click\", () => this.handleCancel()), c.on(this.clearButton, \"click\", () => this.handleClear());\n  }\n  _listenToOutsideClick() {\n    c.on(document, hs, (t) => {\n      const e = t.target === this.container, i = this.container && this.container.contains(t.target);\n      !e && !i && this.close();\n    });\n  }\n  _listenToEscapeClick() {\n    c.on(document, \"keydown\", (t) => {\n      t.keyCode === Fi && this._isOpen && this.close();\n    });\n  }\n  _listenToKeyboardNavigation() {\n    c.on(this.datesContainer, \"keydown\", (t) => {\n      this._handleKeydown(t);\n    });\n  }\n  _listenToDatesContainerFocus() {\n    c.on(this.datesContainer, \"focus\", () => {\n      this._focusActiveCell(this.activeCell);\n    });\n  }\n  _listenToDatesContainerBlur() {\n    c.on(this.datesContainer, \"blur\", () => {\n      this._removeCurrentFocusStyles();\n    });\n  }\n  _handleKeydown(t) {\n    this._view === \"days\" && this._handleDaysViewKeydown(t), this._view === \"months\" && this._handleMonthsViewKeydown(t), this._view === \"years\" && this._handleYearsViewKeydown(t);\n  }\n  _handleDaysViewKeydown(t) {\n    const e = this._activeDate, i = this.activeCell;\n    switch (t.keyCode) {\n      case He:\n        this._activeDate = xe(this._activeDate, F() ? 1 : -1);\n        break;\n      case Ve:\n        this._activeDate = xe(this._activeDate, F() ? -1 : 1);\n        break;\n      case at:\n        this._activeDate = xe(this._activeDate, -7);\n        break;\n      case z:\n        this._activeDate = xe(this._activeDate, 7);\n        break;\n      case We:\n        this._activeDate = xe(\n          this._activeDate,\n          1 - Z(this._activeDate)\n        );\n        break;\n      case Fe:\n        this._activeDate = xe(\n          this._activeDate,\n          Po(this._activeDate) - Z(this._activeDate)\n        );\n        break;\n      case zn:\n        this._activeDate = nt(this._activeDate, -1);\n        break;\n      case Un:\n        this._activeDate = nt(this._activeDate, 1);\n        break;\n      case ct:\n      case Ks:\n        this._selectDate(this._activeDate), this._handleDateSelection(t), t.preventDefault();\n        return;\n      default:\n        return;\n    }\n    Di(\n      e,\n      this._activeDate,\n      this._view,\n      vt,\n      this._options.min,\n      this._options.max\n    ) || this._changeView(\"days\"), this._removeHighlightFromCell(i), this._focusActiveCell(this.activeCell), t.preventDefault();\n  }\n  _asyncFocusDatesContainer() {\n    setTimeout(() => {\n      this.datesContainer.focus();\n    }, 0);\n  }\n  _focusActiveCell(t) {\n    t && t.setAttribute(\"data-te-datepicker-cell-focused\", \"\");\n  }\n  _removeHighlightFromCell(t) {\n    t && t.removeAttribute(\"data-te-datepicker-cell-focused\");\n  }\n  _getActiveDayCell() {\n    const t = d.find(\"td\", this.datesContainer);\n    return Array.from(t).find((i) => {\n      const n = Oa(i.dataset.teDate);\n      return fe(n, this._activeDate);\n    });\n  }\n  _handleMonthsViewKeydown(t) {\n    const e = this._activeDate, i = this.activeCell;\n    switch (t.keyCode) {\n      case He:\n        this._activeDate = nt(this._activeDate, F() ? 1 : -1);\n        break;\n      case Ve:\n        this._activeDate = nt(this._activeDate, F() ? -1 : 1);\n        break;\n      case at:\n        this._activeDate = nt(this._activeDate, -4);\n        break;\n      case z:\n        this._activeDate = nt(this._activeDate, 4);\n        break;\n      case We:\n        this._activeDate = nt(this._activeDate, -this.activeMonth);\n        break;\n      case Fe:\n        this._activeDate = nt(this._activeDate, 11 - this.activeMonth);\n        break;\n      case zn:\n        this._activeDate = it(this._activeDate, -1);\n        break;\n      case Un:\n        this._activeDate = it(this._activeDate, 1);\n        break;\n      case ct:\n      case Ks:\n        this._selectMonth(this.activeMonth);\n        return;\n      default:\n        return;\n    }\n    Di(\n      e,\n      this._activeDate,\n      this._view,\n      vt,\n      this._options.min,\n      this._options.max\n    ) || this._changeView(\"months\"), this._removeHighlightFromCell(i), this._focusActiveCell(this.activeCell), t.preventDefault();\n  }\n  _getActiveMonthCell() {\n    const t = d.find(\"td\", this.datesContainer);\n    return Array.from(t).find((i) => {\n      const n = parseInt(i.dataset.teYear, 10), o = parseInt(i.dataset.teMonth, 10);\n      return n === this.activeYear && o === this.activeMonth;\n    });\n  }\n  _handleYearsViewKeydown(t) {\n    const e = this._activeDate, i = this.activeCell, n = 4, o = 24;\n    switch (t.keyCode) {\n      case He:\n        this._activeDate = it(this._activeDate, F() ? 1 : -1);\n        break;\n      case Ve:\n        this._activeDate = it(this._activeDate, F() ? -1 : 1);\n        break;\n      case at:\n        this._activeDate = it(this._activeDate, -n);\n        break;\n      case z:\n        this._activeDate = it(this._activeDate, n);\n        break;\n      case We:\n        this._activeDate = it(\n          this._activeDate,\n          -Ws(this._activeDate, o)\n        );\n        break;\n      case Fe:\n        this._activeDate = it(\n          this._activeDate,\n          o - Ws(this._activeDate, o) - 1\n        );\n        break;\n      case zn:\n        this._activeDate = it(this._activeDate, -o);\n        break;\n      case Un:\n        this._activeDate = it(this._activeDate, o);\n        break;\n      case ct:\n      case Ks:\n        this._selectYear(this.activeYear);\n        return;\n      default:\n        return;\n    }\n    Di(\n      e,\n      this._activeDate,\n      this._view,\n      vt,\n      this._options.min,\n      this._options.max\n    ) || this._changeView(\"years\"), this._removeHighlightFromCell(i), this._focusActiveCell(this.activeCell), t.preventDefault();\n  }\n  _getActiveYearCell() {\n    const t = d.find(\"td\", this.datesContainer);\n    return Array.from(t).find((i) => parseInt(i.dataset.teYear, 10) === this.activeYear);\n  }\n  _setInitialDate() {\n    this._input.value ? this._handleUserInput(this._input.value) : this._options.startDate ? this._activeDate = new Date(this._options.startDate) : this._activeDate = /* @__PURE__ */ new Date();\n  }\n  close() {\n    const t = c.trigger(this._element, Pf);\n    !this._isOpen || t.defaultPrevented || (this._removeDatepickerListeners(), this._animations && h.addClass(this.container, this._classes.fadeOut), this._options.inline ? this._closeDropdown() : this._closeModal(), this._isOpen = !1, this._view = this._options.view, this.toggleButton ? this.toggleButton.focus() : this._input.focus());\n  }\n  _closeDropdown() {\n    const t = d.findOne(Wf), e = this._getContainer();\n    window.matchMedia(\"(prefers-reduced-motion: reduce)\").matches && (t && e.removeChild(t), this._popper && this._popper.destroy()), t.addEventListener(\"animationend\", () => {\n      t && e.removeChild(t), this._popper && this._popper.destroy();\n    }), this._removeFocusTrap();\n  }\n  _closeModal() {\n    const t = d.findOne(Zf), e = d.findOne(Vf);\n    !e || !t || (this._animations ? (h.addClass(t, this._classes.fadeOutShort), t.addEventListener(\"animationend\", () => {\n      this._removePicker(t, e), this._scrollBar.reset();\n    })) : (this._removePicker(t, e), this._scrollBar.reset()));\n  }\n  _removePicker(t, e) {\n    const i = this._getContainer();\n    i.removeChild(t), i.removeChild(e);\n  }\n  _removeFocusTrap() {\n    this._focusTrap && (this._focusTrap.disable(), this._focusTrap = null);\n  }\n  _removeDatepickerListeners() {\n    c.off(this.nextButton, \"click\"), c.off(this.previousButton, \"click\"), c.off(this.viewChangeButton, \"click\"), c.off(this.okButton, \"click\"), c.off(this.cancelButton, \"click\"), c.off(this.clearButton, \"click\"), c.off(this.datesContainer, \"click\"), c.off(this.datesContainer, \"keydown\"), c.off(this.datesContainer, \"focus\"), c.off(this.datesContainer, \"blur\"), c.off(document, hs);\n  }\n  dispose() {\n    this._isOpen && this.close(), this._removeInputAndToggleListeners();\n    const t = d.findOne(\n      `#${this._toggleButtonId}`\n    );\n    t && this._element.removeChild(t), y.removeData(this._element, zs), this._element = null, this._input = null, this._options = null, this._activeDate = null, this._selectedDate = null, this._selectedYear = null, this._selectedMonth = null, this._headerDate = null, this._headerYear = null, this._headerMonth = null, this._view = null, this._popper = null, this._focusTrap = null;\n  }\n  _removeInputAndToggleListeners() {\n    c.off(this._input, \"input\"), c.off(\n      this._element,\n      hs,\n      ds\n    ), c.off(this._element, \"keydown\", ds);\n  }\n  handleOk() {\n    this._confirmSelection(this._headerDate), this.close();\n  }\n  _selectDate(t, e = this.activeCell) {\n    const { min: i, max: n, filter: o, disablePast: r, disableFuture: a } = this._options;\n    nn(t, i, n, o, r, a) || (this._removeCurrentSelectionStyles(), this._removeCurrentFocusStyles(), this._addSelectedStyles(e), this._selectedDate = t, this._selectedYear = B(t), this._selectedMonth = Y(t), this._headerDate = t, (this._options.inline || this.options.confirmDateOnSelect) && (this._confirmSelection(t), this.close()));\n  }\n  _selectYear(t, e = this.activeCell) {\n    this._removeCurrentSelectionStyles(), this._removeCurrentFocusStyles(), this._addSelectedStyles(e), this._headerYear = t, this._asyncChangeView(\"months\");\n  }\n  _selectMonth(t, e = this.activeCell) {\n    this._removeCurrentSelectionStyles(), this._removeCurrentFocusStyles(), this._addSelectedStyles(e), this._headerMonth = t, this._asyncChangeView(\"days\");\n  }\n  _removeSelectedStyles(t) {\n    t && t.removeAttribute(\"data-te-datepicker-cell-selected\");\n  }\n  _addSelectedStyles(t) {\n    t && t.setAttribute(\"data-te-datepicker-cell-selected\", \"\");\n  }\n  _confirmSelection(t) {\n    if (t) {\n      const e = this.formatDate(t);\n      this._input.value = e, c.trigger(this._element, Hf, { date: t }), c.trigger(this._input, \"input\");\n    }\n  }\n  handleCancel() {\n    this._selectedDate = null, this._selectedYear = null, this._selectedMonth = null, this.close();\n  }\n  handleClear() {\n    this._selectedDate = null, this._selectedMonth = null, this._selectedYear = null, this._headerDate = null, this._headerMonth = null, this._headerYear = null, this._removeCurrentSelectionStyles(), this._input.value = \"\", this._setInitialDate(), this._changeView(\"days\"), this._updateHeaderDate(\n      this._activeDate,\n      this._options.monthsShort,\n      this._options.weekdaysShort\n    );\n  }\n  _removeCurrentSelectionStyles() {\n    const t = d.findOne(\n      \"[data-te-datepicker-cell-selected]\",\n      this.container\n    );\n    t && t.removeAttribute(\"data-te-datepicker-cell-selected\");\n  }\n  _removeCurrentFocusStyles() {\n    const t = d.findOne(\n      \"[data-te-datepicker-cell-focused]\",\n      this.container\n    );\n    t && t.removeAttribute(\"data-te-datepicker-cell-focused\");\n  }\n  formatDate(t) {\n    const e = Z(t), i = this._addLeadingZero(Z(t)), n = this._options.weekdaysShort[Vs(t)], o = this._options.weekdaysFull[Vs(t)], r = Y(t) + 1, a = this._addLeadingZero(Y(t) + 1), l = this._options.monthsShort[Y(t)], p = this._options.monthsFull[Y(t)], u = B(t).toString().length === 2 ? B(t) : B(t).toString().slice(2, 4), _ = B(t), f = this._options.format.split(\n      /(d{1,4}|m{1,4}|y{4}|yy|!.)/g\n    );\n    let g = \"\";\n    return f.forEach((m) => {\n      switch (m) {\n        case \"dddd\":\n          m = m.replace(m, o);\n          break;\n        case \"ddd\":\n          m = m.replace(m, n);\n          break;\n        case \"dd\":\n          m = m.replace(m, i);\n          break;\n        case \"d\":\n          m = m.replace(m, e);\n          break;\n        case \"mmmm\":\n          m = m.replace(m, p);\n          break;\n        case \"mmm\":\n          m = m.replace(m, l);\n          break;\n        case \"mm\":\n          m = m.replace(m, a);\n          break;\n        case \"m\":\n          m = m.replace(m, r);\n          break;\n        case \"yyyy\":\n          m = m.replace(m, _);\n          break;\n        case \"yy\":\n          m = m.replace(m, u);\n          break;\n      }\n      g += m;\n    }), g;\n  }\n  _addLeadingZero(t) {\n    return parseInt(t, 10) < 10 ? `0${t}` : t;\n  }\n  _pickDay(t, e) {\n    const i = Oa(t), { min: n, max: o, filter: r, disablePast: a, disableFuture: l } = this._options;\n    nn(i, n, o, r, a, l) || (this._activeDate = i, this._selectDate(i, e));\n  }\n  _pickYear(t) {\n    const { min: e, max: i, disablePast: n, disableFuture: o } = this._options;\n    if (Bo(t, e, i, n, o))\n      return;\n    const r = Et(t, this.activeMonth, this.activeDay);\n    this._activeDate = r, this._selectedDate = r, this._selectYear(t);\n  }\n  _pickMonth(t, e) {\n    const { min: i, max: n, disablePast: o, disableFuture: r } = this._options;\n    if (zc(t, e, i, n, o, r) || Bo(e, i, n, o, r))\n      return;\n    const a = Et(e, t, this.activeDay);\n    this._activeDate = a, this._selectMonth(t);\n  }\n  nextMonth() {\n    const t = nt(this._activeDate, 1), e = Fs(\n      t,\n      this._headerDate,\n      this._options,\n      this._classes\n    );\n    this._activeDate = t, this.viewChangeButton.textContent = `${this._options.monthsFull[this.activeMonth]} ${this.activeYear}`, this.viewChangeButton.innerHTML += $t(\n      this._options,\n      this._classes\n    ), this.datesContainer.innerHTML = e;\n  }\n  previousMonth() {\n    const t = nt(this._activeDate, -1);\n    this._activeDate = t;\n    const e = Fs(\n      t,\n      this._headerDate,\n      this._options,\n      this._classes\n    );\n    this.viewChangeButton.textContent = `${this._options.monthsFull[this.activeMonth]} ${this.activeYear}`, this.viewChangeButton.innerHTML += $t(\n      this._options,\n      this._classes\n    ), this.datesContainer.innerHTML = e;\n  }\n  nextYear() {\n    const t = it(this._activeDate, 1);\n    this._activeDate = t, this.viewChangeButton.textContent = `${this.activeYear}`, this.viewChangeButton.innerHTML += $t(\n      this._options,\n      this._classes\n    );\n    const e = Ys(\n      this.activeYear,\n      this._selectedYear,\n      this._selectedMonth,\n      this._options,\n      cs,\n      this._classes\n    );\n    this.datesContainer.innerHTML = e;\n  }\n  previousYear() {\n    const t = it(this._activeDate, -1);\n    this._activeDate = t, this.viewChangeButton.textContent = `${this.activeYear}`, this.viewChangeButton.innerHTML += $t(\n      this._options,\n      this._classes\n    );\n    const e = Ys(\n      this.activeYear,\n      this._selectedYear,\n      this._selectedMonth,\n      this._options,\n      cs,\n      this._classes\n    );\n    this.datesContainer.innerHTML = e;\n  }\n  nextYears() {\n    const t = it(this._activeDate, 24);\n    this._activeDate = t;\n    const e = js(\n      t,\n      this._selectedYear,\n      this._options,\n      vt,\n      ls,\n      this._classes\n    );\n    this.viewChangeButton.textContent = `${this.firstYearInView} - ${this.lastYearInView}`, this.viewChangeButton.innerHTML += $t(\n      this._options,\n      this._classes\n    ), this.datesContainer.innerHTML = e;\n  }\n  previousYears() {\n    const t = it(this._activeDate, -24);\n    this._activeDate = t;\n    const e = js(\n      t,\n      this._selectedYear,\n      this._options,\n      vt,\n      ls,\n      this._classes\n    );\n    this.viewChangeButton.textContent = `${this.firstYearInView} - ${this.lastYearInView}`, this.viewChangeButton.innerHTML += $t(\n      this._options,\n      this._classes\n    ), this.datesContainer.innerHTML = e;\n  }\n  _asyncChangeView(t) {\n    setTimeout(() => {\n      this._changeView(t);\n    }, 0);\n  }\n  _changeView(t) {\n    this._view = t, this.datesContainer.blur(), t === \"days\" && (this.datesContainer.innerHTML = Fs(\n      this._activeDate,\n      this._headerDate,\n      this._options,\n      this._classes\n    )), t === \"months\" && (this.datesContainer.innerHTML = Ys(\n      this.activeYear,\n      this._selectedYear,\n      this._selectedMonth,\n      this._options,\n      cs,\n      this._classes\n    )), t === \"years\" && (this.datesContainer.innerHTML = js(\n      this._activeDate,\n      this._selectedYear,\n      this._options,\n      vt,\n      ls,\n      this._classes\n    )), this.datesContainer.focus(), this._updateViewControlsAndAttributes(t), this._updateControlsDisabledState();\n  }\n  _updateViewControlsAndAttributes(t) {\n    t === \"days\" && (this.viewChangeButton.textContent = `${this._options.monthsFull[this.activeMonth]} ${this.activeYear}`, this.viewChangeButton.innerHTML += $t(\n      this._options,\n      this._classes\n    ), this.viewChangeButton.setAttribute(\n      \"aria-label\",\n      this._options.switchToMultiYearViewLabel\n    ), this.previousButton.setAttribute(\n      \"aria-label\",\n      this._options.prevMonthLabel\n    ), this.nextButton.setAttribute(\"aria-label\", this._options.nextMonthLabel)), t === \"months\" && (this.viewChangeButton.textContent = `${this.activeYear}`, this.viewChangeButton.innerHTML += $t(\n      this._options,\n      this._classes\n    ), this.viewChangeButton.setAttribute(\n      \"aria-label\",\n      this._options.switchToDayViewLabel\n    ), this.previousButton.setAttribute(\n      \"aria-label\",\n      this._options.prevYearLabel\n    ), this.nextButton.setAttribute(\"aria-label\", this._options.nextYearLabel)), t === \"years\" && (this.viewChangeButton.textContent = `${this.firstYearInView} - ${this.lastYearInView}`, this.viewChangeButton.innerHTML += $t(\n      this._options,\n      this._classes\n    ), this.viewChangeButton.setAttribute(\n      \"aria-label\",\n      this._options.switchToMonthViewLabel\n    ), this.previousButton.setAttribute(\n      \"aria-label\",\n      this._options.prevMultiYearLabel\n    ), this.nextButton.setAttribute(\n      \"aria-label\",\n      this._options.nextMultiYearLabel\n    ));\n  }\n  _updateControlsDisabledState() {\n    _f(\n      this._options.disableFuture,\n      this._activeDate,\n      this._view,\n      vt,\n      this._options.min,\n      this._options.max,\n      this.lastYearInView,\n      this.firstYearInView\n    ) ? this.nextButton.disabled = !0 : this.nextButton.disabled = !1, ff(\n      this._options.disablePast,\n      this._activeDate,\n      this._view,\n      vt,\n      this._options.min,\n      this._options.max,\n      this.lastYearInView,\n      this.firstYearInView\n    ) ? this.previousButton.disabled = !0 : this.previousButton.disabled = !1;\n  }\n  _handleUserInput(t) {\n    const e = this._getDelimeters(this._options.format), i = this._parseDate(t, this._options.format, e);\n    df(i) ? (this._activeDate = i, this._selectedDate = i, this._selectedYear = B(i), this._selectedMonth = Y(i), this._headerDate = i) : (this._activeDate = /* @__PURE__ */ new Date(), this._selectedDate = null, this._selectedMonth = null, this._selectedYear = null, this._headerDate = null, this._headerMonth = null, this._headerYear = null);\n  }\n  _getDelimeters(t) {\n    return t.match(/[^(dmy)]{1,}/g);\n  }\n  _parseDate(t, e, i) {\n    let n;\n    i[0] !== i[1] ? n = i[0] + i[1] : n = i[0];\n    const o = new RegExp(`[${n}]`), r = t.split(o), a = e.split(o), l = e.indexOf(\"mmm\") !== -1, p = [];\n    for (let b = 0; b < a.length; b++)\n      a[b].indexOf(\"yy\") !== -1 && (p[0] = { value: r[b], format: a[b] }), a[b].indexOf(\"m\") !== -1 && (p[1] = { value: r[b], format: a[b] }), a[b].indexOf(\"d\") !== -1 && a[b].length <= 2 && (p[2] = { value: r[b], format: a[b] });\n    let u;\n    e.indexOf(\"mmmm\") !== -1 ? u = this._options.monthsFull : u = this._options.monthsShort;\n    const _ = Number(p[0].value), f = l ? this.getMonthNumberByMonthName(p[1].value, u) : Number(p[1].value) - 1, g = Number(p[2].value);\n    return Et(_, f, g);\n  }\n  getMonthNumberByMonthName(t, e) {\n    return e.findIndex((i) => i === t);\n  }\n  static getInstance(t) {\n    return y.getData(t, zs);\n  }\n  static getOrCreateInstance(t, e = {}) {\n    return this.getInstance(t) || new this(t, typeof e == \"object\" ? e : null);\n  }\n}\nconst Mm = ({\n  format24: s,\n  okLabel: t,\n  cancelLabel: e,\n  headID: i,\n  footerID: n,\n  bodyID: o,\n  pickerID: r,\n  clearLabel: a,\n  inline: l,\n  showClearBtn: p,\n  amLabel: u,\n  pmLabel: _\n}, f) => {\n  const g = `<div id='${r}' class='${f.timepickerWrapper}' data-te-timepicker-wrapper>\n      <div class=\"${f.timepickerContainer}\">\n        <div class=\"${f.timepickerElements}\" data-te-timepicker-elements-wrapper>\n        <div id='${i}' class='${f.timepickerHead}' style='padding-right:${s ? 50 : 10}px'>\n        <div class='${f.timepickerHeadContent}'>\n            <div class=\"${f.timepickerCurrentWrapper}\">\n              <span class=\"${f.timepickerCurrentButtonWrapper}\">\n                <button type='button' class='${f.timepickerCurrentButton}' tabindex=\"0\" data-te-timepicker-active data-te-timepicker-current data-te-timepicker-hour data-te-ripple-init>21</button>\n              </span>\n              <button type='button' class='${f.timepickerDot}' disabled>:</button>\n            <span class=\"${f.timepickerCurrentButtonWrapper}\">\n              <button type='button' class='${f.timepickerCurrentButton}' tabindex=\"0\" data-te-timepicker-current data-te-timepicker-minute data-te-ripple-init>21</button>\n            </span>\n            </div>\n            ${s ? \"\" : `<div class=\"${f.timepickerModeWrapper}\">\n                  <button type='button' class=\"${f.timepickerModeAm}\" tabindex=\"0\" data-te-timepicker-am data-te-timepicker-hour-mode data-te-ripple-init>${u}</button>\n                  <button class=\"${f.timepickerModePm}\" tabindex=\"0\" data-te-timepicker-pm data-te-timepicker-hour-mode data-te-ripple-init>${_}</button>\n                </div>`}\n        </div>\n      </div>\n      ${l ? \"\" : `<div id='${o}' class='${f.timepickerClockWrapper}' data-te-timepicker-clock-wrapper>\n            <div class='${f.timepickerClock}' data-te-timepicker-clock>\n              <span class='${f.timepickerMiddleDot}' data-te-timepicker-middle-dot></span>\n              <div class='${f.timepickerHandPointer}' data-te-timepicker-hand-pointer>\n                <div class='${f.timepickerPointerCircle}' data-te-timepicker-circle></div>\n              </div>\n              ${s ? '<div class=\"' + f.timepickerClockInner + '\" data-te-timepicker-clock-inner></div>' : \"\"}\n            </div>\n          </div>`}\n    </div>\n    <div id='${n}' class='${f.timepickerFooterWrapper}'>\n      <div class=\"${f.timepickerFooter}\">\n        ${p ? `<button type='button' class='${f.timepickerFooterButton}' data-te-timepicker-clear tabindex=\"0\" data-te-ripple-init>${a}</button>` : \"\"}\n        <button type='button' class='${f.timepickerFooterButton}' data-te-timepicker-cancel tabindex=\"0\" data-te-ripple-init>${e}</button>\n        <button type='button' class='${f.timepickerFooterButton}' data-te-timepicker-submit tabindex=\"0\" data-te-ripple-init>${t}</button>\n      </div>\n    </div>\n  </div>\n</div>`, m = `<div id='${r}' class='${f.timepickerInlineWrapper}' data-te-timepicker-wrapper>\n        <div class=\"${f.timepickerInlineContainer}\">\n          <div class=\"${f.timepickerInlineElements}\" data-te-timepicker-elements-wrapper>\n          <div id='${i}' class='${f.timepickerInlineHead}'\n          style='padding-right:10px'>\n          <div class='${f.timepickerInlineHeadContent}'>\n              <div class=\"${f.timepickerCurrentWrapper}\">\n                <span class=\"${f.timepickerInlineHourWrapper}\" data-te-timepicker-inline-hour-icons>\n                  <span class=\"${f.timepickerInlineIconUp}\" data-te-timepicker-icon-up data-te-timepicker-icon-inline-hour>\n                    <span class=\"${f.timepickerInlineIconSvg}\">\n                      <svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"1.5\" stroke=\"currentColor\" class=\"w-5 h-5\">\n                      <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M4.5 15.75l7.5-7.5 7.5 7.5\" />\n                      </svg>   \n                    </span>\n                  </span>\n                  <button type='button' class='${f.timepickerInlineCurrentButton}' data-te-timepicker-hour data-te-timepicker-current data-te-timepicker-current-inline tabindex=\"0\" data-te-ripple-init>21</button>\n                  <span class=\"${f.timepickerInlineIconDown}\" data-te-timepicker-icon-inline-hour data-te-timepicker-icon-down>\n                    <span class=\"${f.timepickerInlineIconSvg}\">\n                      <svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"1.5\" stroke=\"currentColor\" class=\"w-5 h-5\">\n                      <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M19.5 8.25l-7.5 7.5-7.5-7.5\" />\n                      </svg>  \n                    </span>\n                  </span>\n                </span>\n                <button type='button' class='${f.timepickerInlineDot}' data-te-timepicker-current-inline disabled>:</button>\n              <span class=\"${f.timepickerCurrentMinuteWrapper}\">\n                <span class=\"${f.timepickerInlineIconUp}\" data-te-timepicker-icon-up data-te-timepicker-icon-inline-minute>\n                  <span class=\"${f.timepickerInlineIconSvg}\">\n                    <svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"1.5\" stroke=\"currentColor\" class=\"w-5 h-5\">\n                    <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M4.5 15.75l7.5-7.5 7.5 7.5\" />\n                    </svg>\n                  </span>\n                </span>\n                <button type='button' class='${f.timepickerInlineCurrentButton}' data-te-timepicker-minute data-te-timepicker-current data-te-timepicker-current-inline tabindex=\"0\" data-te-ripple-init>21</button>\n                <span class=\"${f.timepickerInlineIconDown}\" data-te-timepicker-icon-inline-minute data-te-timepicker-icon-down>\n                  <span class=\"${f.timepickerInlineIconSvg}\">\n                    <svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"1.5\" stroke=\"currentColor\" class=\"w-5 h-5\">\n                    <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M19.5 8.25l-7.5 7.5-7.5-7.5\" />\n                    </svg> \n                  </span>\n                </span>\n              </span>\n              </div>\n              ${s ? \"\" : `<div class=\"${f.timepickerInlineModeWrapper}\">\n                      <button type='button' class=\"${f.timepickerInlineModeAm}\" data-te-timepicker-am data-te-timepicker-hour-mode tabindex=\"0\" data-te-ripple-init>${u}</button>\n                      <button class=\"${f.timepickerInlineModePm}\" data-te-timepicker-hour-mode data-te-timepicker-pm tabindex=\"0\" data-te-ripple-init>${_}</button>\n                      <button type='button' class='${f.timepickerInlineSubmitButton}' data-te-timepicker-submit tabindex=\"0\" data-te-ripple-init>${t}</button>\n                    </div>`}\n              ${s ? `<button class='${f.timepickerInlineSubmitButton}' data-te-timepicker-submit tabindex=\"0\" data-te-ripple-init>${t}</button>` : \"\"}\n          </div>\n        </div>\n      </div>\n    </div>\n</div>`;\n  return l ? m : g;\n}, Rm = (s, t, e) => {\n  const { iconSVG: i } = s;\n  return `\n  <button id=\"${t}\" tabindex=\"0\" type=\"button\" class=\"${e.timepickerToggleButton}\" data-te-toggle=\"timepicker\" data-te-timepicker-toggle-button data-te-timepicker-icon>\n    ${i}\n  </button>\n`;\n}, un = \"data-te-timepicker-disabled\", us = \"data-te-timepicker-active\", ve = (s) => {\n  if (s === \"\")\n    return;\n  let t, e, i, n;\n  return Gc(s) ? (t = s.getHours(), n = t, e = s.getMinutes(), t %= 12, n === 0 && t === 0 && (i = \"AM\"), t = t || 12, i === void 0 && (i = Number(n) >= 12 ? \"PM\" : \"AM\"), e = e < 10 ? `0${e}` : e) : ([t, e, i] = R(s, !1), n = t, t %= 12, n === 0 && t === 0 && (i = \"AM\"), t = t || 12, i === void 0 && (i = Number(n) >= 12 ? \"PM\" : \"AM\")), {\n    hours: t,\n    minutes: e,\n    amOrPm: i\n  };\n}, Gc = (s) => s && Object.prototype.toString.call(s) === \"[object Date]\" && !Number.isNaN(s), La = (s) => {\n  if (s === \"\")\n    return;\n  let t, e;\n  return Gc(s) ? (t = s.getHours(), e = s.getMinutes()) : [t, e] = R(s, !1), e = Number(e) < 10 ? `0${Number(e)}` : e, {\n    hours: t,\n    minutes: e\n  };\n}, Pm = (s, t, e) => c.on(document, s, t, ({ target: i }) => {\n  if (i.hasAttribute(us))\n    return;\n  document.querySelectorAll(t).forEach((o) => {\n    o.hasAttribute(us) && (h.removeClass(o, e.opacity), o.removeAttribute(us));\n  }), h.addClass(i, e.opacity), i.setAttribute(us, \"\");\n}), Na = ({ clientX: s, clientY: t, touches: e }, i, n = !1) => {\n  const { left: o, top: r } = i.getBoundingClientRect();\n  let a = {};\n  return !n || !e ? a = {\n    x: s - o,\n    y: t - r\n  } : n && Object.keys(e).length > 0 && (a = {\n    x: e[0].clientX - o,\n    y: e[0].clientY - r\n  }), a;\n}, ps = () => navigator.maxTouchPoints && navigator.maxTouchPoints > 2 && /MacIntel/.test(navigator.platform) || /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(\n  navigator.userAgent\n), R = (s, t = !0) => t ? s.value.replace(/:/gi, \" \").split(\" \") : s.replace(/:/gi, \" \").split(\" \"), qc = (s, t) => {\n  const [e, i, n] = R(s, !1), [o, r, a] = R(t, !1);\n  return n === \"PM\" && a === \"AM\" || n === a && e > o || i > r;\n}, Zc = () => {\n  const s = /* @__PURE__ */ new Date(), t = s.getHours(), e = s.getMinutes();\n  return `${t}:${e < 10 ? `0${e}` : e}`;\n}, Xt = (s, t, e) => {\n  if (!t)\n    return s;\n  let i = Zc();\n  return e && (i = `${ve(i).hours}:${ve(i).minutes} ${ve(i).amOrPm}`), (s !== \"\" && qc(i, s) || s === \"\") && (s = i), s;\n}, Gt = (s, t, e) => {\n  if (!t)\n    return s;\n  let i = Zc();\n  return e && (i = `${ve(i).hours}:${ve(i).minutes} ${ve(i).amOrPm}`), (s !== \"\" && !qc(i, s) || s === \"\") && (s = i), s;\n}, Bm = ({ format12: s, maxTime: t, minTime: e, disablePast: i, disableFuture: n }, o, r) => {\n  const a = R(o)[1];\n  e = Xt(e, i, s), t = Gt(t, n, s);\n  const [l, p, u] = R(t, !1), [_, f, g] = R(e, !1);\n  if (u !== void 0 || g !== void 0)\n    return [r, a];\n  if (!(l !== \"\" && _ === \"\" && Number(r) > Number(l)) && !(l === \"\" && _ !== \"\" && p === void 0 && f !== \"\" && Number(r) < Number(_)))\n    return [r, a];\n}, Ma = (s, t, e, i) => {\n  s.forEach((n) => {\n    t = t === \"12\" && i ? \"0\" : t, (n.textContent === \"00\" || Number(n.textContent === \"12\" && i ? \"0\" : n.textContent) > t) && (h.addClass(n, e.tipsDisabled), n.setAttribute(un, \"\"));\n  });\n}, Ra = (s, t, e, i) => {\n  s.forEach((n) => {\n    t = t === \"12\" && i ? \"0\" : t, n.textContent !== \"00\" && Number(n.textContent === \"12\" && i ? \"0\" : n.textContent) < Number(t) && (h.addClass(n, e.tipsDisabled), n.setAttribute(un, \"\"));\n  });\n}, Qc = (s, t, e, i) => {\n  if (t === \"12\" || t === \"24\")\n    return;\n  const n = e ? 12 : 24;\n  return i === \"max\" ? (Number(s) === n ? 0 : Number(s)) > Number(t) : (Number(s) === n ? 0 : Number(s)) < Number(t);\n}, Hm = (s, t, e, i, n, o) => {\n  s.forEach((r) => {\n    (Qc(i, e, o, \"max\") || Number(r.textContent) > t && Number(i) === Number(e)) && (h.addClass(r, n.tipsDisabled), r.setAttribute(un, \"\"));\n  });\n}, Vm = (s, t, e, i, n, o) => {\n  s.forEach((r) => {\n    (Qc(i, e, o, \"min\") || Number(r.textContent) < t && Number(i) === Number(e)) && (h.addClass(r, n.tipsDisabled), r.setAttribute(un, \"\"));\n  });\n}, Wm = (s) => s.startsWith(\"0\") ? Number(s.slice(1)) : Number(s), $i = \"timepicker\", M = `data-te-${$i}`, Pa = \"[data-te-toggle]\", Us = `te.${$i}`, Rt = `.${Us}`, Pt = \".data-api\", Ba = `click${Rt}${Pt}`, _s = `keydown${Rt}${Pt}`, Ha = `mousedown${Rt}${Pt}`, Va = `mouseup${Rt}${Pt}`, Wa = `mousemove${Rt}${Pt}`, Fa = `mouseleave${Rt}${Pt}`, Ya = `mouseover${Rt}${Pt}`, ja = `touchmove${Rt}${Pt}`, Ka = `touchend${Rt}${Pt}`, za = `touchstart${Rt}${Pt}`, Fm = `[${M}-am]`, Ym = `[${M}-pm]`, jm = `[${M}-format24]`, fs = `[${M}-current]`, ms = `[${M}-hour-mode]`, Km = `[${M}-toggle-button]`, Gn = `${M}-cancel`, Ua = `${M}-clear`, qn = `${M}-submit`, zm = `${M}-icon`, Zn = `${M}-icon-up`, Qn = `${M}-icon-down`, Um = `${M}-icon-inline-hour`, Xm = `${M}-icon-inline-minute`, Xa = `${M}-inline-hour-icons`, Gm = `${M}-current-inline`, qm = \"readonly\", Zm = `${M}-invalid-feedback`, Jn = `${M}-is-invalid`, Yt = `${M}-disabled`, H = `${M}-active`, Qm = `${M}-input`, pe = `${M}-clock`, di = `${M}-clock-inner`, to = `${M}-wrapper`, Ga = `${M}-clock-wrapper`, gs = `${M}-hour`, eo = `${M}-minute`, bs = `${M}-tips-element`, K = `${M}-tips-hours`, X = `${M}-tips-minutes`, lt = `${M}-tips-inner`, vs = `${M}-tips-inner-element`, qa = `${M}-middle-dot`, io = `${M}-hand-pointer`, so = `${M}-circle`, Za = `${M}-modal`, Jm = `<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"1.5\" stroke=\"currentColor\">\n  <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M12 6v6h4.5m4.5 0a9 9 0 11-18 0 9 9 0 0118 0z\" />\n</svg>`, tg = {\n  appendValidationInfo: !0,\n  bodyID: \"\",\n  cancelLabel: \"Cancel\",\n  clearLabel: \"Clear\",\n  closeModalOnBackdropClick: !0,\n  closeModalOnMinutesClick: !1,\n  container: \"body\",\n  defaultTime: \"\",\n  disabled: !1,\n  disablePast: !1,\n  disableFuture: !1,\n  enableValidation: !0,\n  focusInputAfterApprove: !1,\n  footerID: \"\",\n  format12: !0,\n  format24: !1,\n  headID: \"\",\n  increment: !1,\n  inline: !1,\n  invalidLabel: \"Invalid Time Format\",\n  maxTime: \"\",\n  minTime: \"\",\n  modalID: \"\",\n  okLabel: \"Ok\",\n  overflowHidden: !0,\n  pickerID: \"\",\n  readOnly: !1,\n  showClearBtn: !0,\n  switchHoursToMinutesOnClick: !0,\n  iconSVG: Jm,\n  withIcon: !0,\n  pmLabel: \"PM\",\n  amLabel: \"AM\",\n  animations: !0\n}, eg = {\n  appendValidationInfo: \"boolean\",\n  bodyID: \"string\",\n  cancelLabel: \"string\",\n  clearLabel: \"string\",\n  closeModalOnBackdropClick: \"boolean\",\n  closeModalOnMinutesClick: \"boolean\",\n  container: \"string\",\n  disabled: \"boolean\",\n  disablePast: \"boolean\",\n  disableFuture: \"boolean\",\n  enableValidation: \"boolean\",\n  footerID: \"string\",\n  format12: \"boolean\",\n  format24: \"boolean\",\n  headID: \"string\",\n  increment: \"boolean\",\n  inline: \"boolean\",\n  invalidLabel: \"string\",\n  modalID: \"string\",\n  okLabel: \"string\",\n  overflowHidden: \"boolean\",\n  pickerID: \"string\",\n  readOnly: \"boolean\",\n  showClearBtn: \"boolean\",\n  switchHoursToMinutesOnClick: \"boolean\",\n  defaultTime: \"(string|date|number)\",\n  iconSVG: \"string\",\n  withIcon: \"boolean\",\n  pmLabel: \"string\",\n  amLabel: \"string\",\n  animations: \"boolean\"\n}, ig = {\n  tips: \"absolute rounded-[100%] w-[32px] h-[32px] text-center cursor-pointer text-[1.1rem] rounded-[100%] bg-transparent flex justify-center items-center font-light focus:outline-none selection:bg-transparent\",\n  tipsActive: \"text-white bg-[#3b71ca] font-normal\",\n  tipsDisabled: \"text-[#b3afaf] pointer-events-none bg-transparent\",\n  transform: \"transition-[transform,height] ease-in-out duration-[400ms]\",\n  modal: \"z-[1065]\",\n  clockAnimation: \"animate-[show-up-clock_350ms_linear]\",\n  opacity: \"!opacity-100\",\n  timepickerWrapper: \"touch-none opacity-100 z-[1065] inset-0 bg-[#00000066] h-full flex items-center justify-center flex-col fixed\",\n  timepickerContainer: \"flex items-center justify-center flex-col max-h-[calc(100%-64px)] overflow-y-auto shadow-[0_10px_15px_-3px_rgba(0,0,0,0.07),0_4px_6px_-2px_rgba(0,0,0,0.05)] min-[320px]:max-[825px]:landscape:rounded-lg\",\n  timepickerElements: \"flex flex-col min-w-[310px] min-h-[325px] bg-white rounded-t-[0.6rem] min-[320px]:max-[825px]:landscape:!flex-row min-[320px]:max-[825px]:landscape:min-w-[auto] min-[320px]:max-[825px]:landscape:min-h-[auto] min-[320px]:max-[825px]:landscape:overflow-y-auto justify-around\",\n  timepickerHead: \"bg-[#3b71ca] dark:bg-zinc-700 h-[100px] rounded-t-lg pr-[24px] pl-[50px] py-[10px] min-[320px]:max-[825px]:landscape:rounded-tr-none min-[320px]:max-[825px]:landscape:rounded-bl-none min-[320px]:max-[825px]:landscape:p-[10px] min-[320px]:max-[825px]:landscape:pr-[10px] min-[320px]:max-[825px]:landscape:h-auto min-[320px]:max-[825px]:landscape:min-h-[305px] flex flex-row items-center justify-center\",\n  timepickerHeadContent: \"min-[320px]:max-[825px]:landscape:flex-col flex w-full justify-evenly\",\n  timepickerCurrentWrapper: \"[direction:ltr] rtl:[direction:rtl]\",\n  timepickerCurrentButtonWrapper: \"relative h-full\",\n  timepickerCurrentButton: \"text-[3.75rem] font-light leading-[1.2] tracking-[-0.00833em] text-white opacity-[.54] border-none bg-transparent p-0 min-[320px]:max-[825px]:landscape:text-5xl min-[320px]:max-[825px]:landscape:font-normal cursor-pointer hover:bg-[#00000026] hover:outline-none focus:bg-[#00000026] focus:outline-none \",\n  timepickerDot: \"font-light leading-[1.2] tracking-[-0.00833em] text-[3.75rem] opacity-[.54] border-none bg-transparent p-0 text-white min-[320px]:max-[825px]:landscape:text-[3rem] min-[320px]:max-[825px]:landscape:font-normal\",\n  timepickerModeWrapper: \"flex flex-col justify-center text-[18px] text-[#ffffff8a] min-[320px]:max-[825px]:landscape:!justify-around min-[320px]:max-[825px]:landscape:!flex-row\",\n  timepickerModeAm: \"p-0 bg-transparent border-none text-white opacity-[.54] cursor-pointer hover:bg-[#00000026] hover:outline-none focus:bg-[#00000026] focus:outline-none\",\n  timepickerModePm: \"p-0 bg-transparent border-none text-white opacity-[.54] cursor-pointer hover:bg-[#00000026] hover:outline-none focus:bg-[#00000026] focus:outline-none\",\n  timepickerClockWrapper: \"min-w-[310px] max-w-[325px] min-h-[305px] overflow-x-hidden h-full flex justify-center flex-col items-center dark:bg-zinc-500\",\n  timepickerClock: \"relative rounded-[100%] w-[260px] h-[260px] cursor-default my-0 mx-auto bg-[#00000012] dark:bg-zinc-600/50\",\n  timepickerMiddleDot: \"top-1/2 left-1/2 w-[6px] h-[6px] -translate-y-1/2 -translate-x-1/2 rounded-[50%] bg-[#3b71ca] absolute\",\n  timepickerHandPointer: \"bg-[#3b71ca] bottom-1/2 h-2/5 left-[calc(50%-1px)] rtl:!left-auto origin-[center_bottom_0] rtl:!origin-[50%_50%_0] w-[2px] absolute\",\n  timepickerPointerCircle: \"-top-[21px] -left-[15px] w-[4px] border-[14px] border-solid border-[#3b71ca] h-[4px] box-content rounded-[100%] absolute\",\n  timepickerClockInner: \"absolute top-1/2 left-1/2 -translate-y-1/2 -translate-x-1/2 w-[160px] h-[160px] rounded-[100%]\",\n  timepickerFooterWrapper: \"rounded-b-lg flex justify-between items-center w-full h-[56px] px-[12px] bg-white dark:bg-zinc-500\",\n  timepickerFooter: \"w-full flex justify-between\",\n  timepickerFooterButton: \"text-[0.8rem] min-w-[64px] box-border font-medium leading-[40px] rounded-[10px] tracking-[0.1rem] uppercase text-[#3b71ca] dark:text-white border-none bg-transparent transition-[background-color,box-shadow,border] duration-[250ms] ease-[cubic-bezier(0.4,0,0.2,1)] delay-[0ms] outline-none py-0 px-[10px] h-[40px] mb-[10px] hover:bg-[#00000014] focus:bg-[#00000014] focus:outline-none\",\n  timepickerInlineWrapper: \"touch-none opacity-100 z-[1065] inset-0 bg-[#00000066] h-full flex items-center justify-center flex-col rounded-lg\",\n  timepickerInlineContainer: \"flex items-center justify-center flex-col max-h-[calc(100%-64px)] overflow-y-auto shadow-[0_10px_15px_-3px_rgba(0,0,0,0.07),0_4px_6px_-2px_rgba(0,0,0,0.05)]\",\n  timepickerInlineElements: \"flex flex-col min-h-[auto] min-w-[310px] bg-white rounded-[0.6rem] min-[320px]:max-[825px]:landscape:!flex-row min-[320px]:max-[825px]:landscape:rounded-bl-lg min-[320px]:max-[825px]:landscape:min-w-[auto] min-[320px]:max-[825px]:landscape::min-h-[auto] min-[320px]:max-[825px]:landscape:overflow-y-auto justify-around\",\n  timepickerInlineHead: \"bg-[#3b71ca] dark:bg-zinc-700 h-[100px] rounded-t-lg min-[320px]:max-[825px]:landscape:rounded-tr-none min-[320px]:max-[825px]:landscape:rounded-bl-none min-[320px]:max-[825px]:landscape:p-[10px] min-[320px]:max-[825px]:landscape:pr-[10px] min-[320px]:max-[825px]:landscape:h-auto min-[320px]:max-[825px]:landscape:min-h-[305px] flex flex-row items-center justify-center p-0 rounded-b-lg\",\n  timepickerInlineHeadContent: \"min-[320px]:max-[825px]:landscape:flex-col flex w-full justify-evenly items-center\",\n  timepickerInlineHourWrapper: \"relative h-full !opacity-100\",\n  timepickerCurrentMinuteWrapper: \"relative h-full\",\n  timepickerInlineIconUp: \"absolute text-white -top-[35px] opacity-0 hover:opacity-100 transition-all duration-200 ease-[ease] cursor-pointer -translate-x-1/2 -translate-y-1/2 left-1/2 w-[30px] h-[30px] flex justify-center items-center\",\n  timepickerInlineIconSvg: \"h-4 w-4\",\n  timepickerInlineCurrentButton: \"font-light leading-[1.2] tracking-[-0.00833em] text-white border-none bg-transparent p-0 min-[320px]:max-[825px]:landscape:text-5xl min-[320px]:max-[825px]:landscape:font-normal !opacity-100 cursor-pointer focus:bg-[#00000026] hover:outline-none focus:outline-none text-[2.5rem] hover:bg-[unset]\",\n  timepickerInlineIconDown: \"absolute text-white -bottom-[47px] opacity-0 hover:opacity-100 transition-all duration-200 ease-[ease] cursor-pointer -translate-x-1/2 -translate-y-1/2 left-1/2 w-[30px] h-[30px] flex justify-center items-center\",\n  timepickerInlineDot: \"font-light leading-[1.2] tracking-[-0.00833em] opacity-[.54] border-none bg-transparent p-0 text-white min-[320px]:max-[825px]:landscape:text-[3rem] min-[320px]:max-[825px]:landscape:font-normal text-[2.5rem]\",\n  timepickerInlineModeWrapper: \"flex justify-center text-[18px] text-[#ffffff8a] min-[320px]:max-[825px]:landscape:!justify-around min-[320px]:max-[825px]:landscape:!flex-row\",\n  timepickerInlineModeAm: \"hover:bg-[#00000026] hover:outline-none focus:bg-[#00000026] focus:outline-none p-0 bg-transparent border-none text-white opacity-[.54] cursor-pointer mr-2 ml-6\",\n  timepickerInlineModePm: \"hover:bg-[#00000026] hover:outline-none focus:bg-[#00000026] focus:outline-none p-0 bg-transparent border-none text-white opacity-[.54] cursor-pointer\",\n  timepickerInlineSubmitButton: \"hover:bg-[#00000014] focus:bg-[#00000014] focus:outline-none text-[0.8rem] box-border font-medium leading-[40px] tracking-[.1rem] uppercase border-none bg-transparent [transition:background-color_250ms_cubic-bezier(0.4,0,0.2,1)_0ms,box-shadow_250ms_cubic-bezier(0.4,0,0.2,1)_0ms,border_250ms_cubic-bezier(0.4,0,0.2,1)_0ms] outline-none rounded-[100%] h-[48px] min-w-[48px] inline-block ml-[30px] text-white py-1 px-2 mb-0\",\n  timepickerToggleButton: \"h-4 w-4 ml-auto absolute outline-none border-none bg-transparent right-1.5 top-1/2 -translate-x-1/2 -translate-y-1/2 transition-all duration-300 ease-[cubic-bezier(0.25,0.1,0.25,1)] cursor-pointer hover:text-[#3b71ca] focus:text-[#3b71ca] dark:hover:text-[#3b71ca] dark:focus:text-[#3b71ca] dark:text-white\"\n}, sg = {\n  tips: \"string\",\n  tipsActive: \"string\",\n  tipsDisabled: \"string\",\n  transform: \"string\",\n  modal: \"string\",\n  clockAnimation: \"string\",\n  opacity: \"string\",\n  timepickerWrapper: \"string\",\n  timepickerContainer: \"string\",\n  timepickerElements: \"string\",\n  timepickerHead: \"string\",\n  timepickerHeadContent: \"string\",\n  timepickerCurrentWrapper: \"string\",\n  timepickerCurrentButtonWrapper: \"string\",\n  timepickerCurrentButton: \"string\",\n  timepickerDot: \"string\",\n  timepickerModeWrapper: \"string\",\n  timepickerModeAm: \"string\",\n  timepickerModePm: \"string\",\n  timepickerClockWrapper: \"string\",\n  timepickerClock: \"string\",\n  timepickerMiddleDot: \"string\",\n  timepickerHandPointer: \"string\",\n  timepickerPointerCircle: \"string\",\n  timepickerClockInner: \"string\",\n  timepickerFooterWrapper: \"string\",\n  timepickerFooterButton: \"string\",\n  timepickerInlineWrapper: \"string\",\n  timepickerInlineContainer: \"string\",\n  timepickerInlineElements: \"string\",\n  timepickerInlineHead: \"string\",\n  timepickerInlineHeadContent: \"string\",\n  timepickerInlineHourWrapper: \"string\",\n  timepickerCurrentMinuteWrapper: \"string\",\n  timepickerInlineIconUp: \"string\",\n  timepickerInlineIconSvg: \"string\",\n  timepickerInlineCurrentButton: \"string\",\n  timepickerInlineIconDown: \"string\",\n  timepickerInlineDot: \"string\",\n  timepickerInlineModeWrapper: \"string\",\n  timepickerInlineModeAm: \"string\",\n  timepickerInlineModePm: \"string\",\n  timepickerInlineSubmitButton: \"string\",\n  timepickerToggleButton: \"string\"\n};\nclass ng {\n  constructor(t, e = {}, i) {\n    yt(this, \"_toggleAmPm\", (t) => {\n      t === \"PM\" ? (this._isPmEnabled = !0, this._isAmEnabled = !1) : t === \"AM\" && (this._isPmEnabled = !1, this._isAmEnabled = !0);\n    });\n    yt(this, \"_toggleBackgroundColorCircle\", (t) => {\n      if (this._modal.querySelector(`${t}[${H}]`) !== null) {\n        h.addStyle(this._circle, {\n          backgroundColor: \"#1976d2\"\n        });\n        return;\n      }\n      h.addStyle(this._circle, {\n        backgroundColor: \"transparent\"\n      });\n    });\n    yt(this, \"_toggleClassActive\", (t, { textContent: e }, i) => {\n      const n = [...t].find(\n        (o) => Number(o) === Number(e)\n      );\n      return i.forEach((o) => {\n        if (!o.hasAttribute(Yt)) {\n          if (o.textContent === n) {\n            h.addClass(o, this._classes.tipsActive), o.setAttribute(H, \"\");\n            return;\n          }\n          h.removeClass(o, this._classes.tipsActive), o.removeAttribute(H);\n        }\n      });\n    });\n    yt(this, \"_makeMinutesDegrees\", (t, e) => {\n      const { increment: i } = this._options;\n      return t < 0 ? (e = Math.round(360 + t / 6) % 60, t = 360 + Math.round(t / 6) * 6) : (e = Math.round(t / 6) % 60, t = Math.round(t / 6) * 6), i && (t = Math.round(t / 30) * 30, e = Math.round(t / 6) * 6 / 6, e === 60 && (e = \"00\")), t >= 360 && (t = 0), {\n        degrees: t,\n        minute: e,\n        addDegrees: i ? 30 : 6\n      };\n    });\n    yt(this, \"_makeHourDegrees\", (t, e, i) => {\n      if (t)\n        return this._hasTargetInnerClass(t) ? e < 0 ? (i = Math.round(360 + e / 30) % 24, e = 360 + e) : (i = Math.round(e / 30) + 12, i === 12 && (i = \"00\")) : e < 0 ? (i = Math.round(360 + e / 30) % 12, e = 360 + e) : (i = Math.round(e / 30) % 12, (i === 0 || i > 12) && (i = 12)), e >= 360 && (e = 0), {\n          degrees: e,\n          hour: i,\n          addDegrees: 30\n        };\n    });\n    yt(this, \"_makeInnerHoursDegrees\", (t, e) => (t < 0 ? (e = Math.round(360 + t / 30) % 24, t = 360 + t) : (e = Math.round(t / 30) + 12, e === 12 && (e = \"00\")), {\n      degrees: t,\n      hour: e,\n      addDegrees: 30\n    }));\n    yt(this, \"_getAppendClock\", (t = [], e = `[${pe}]`, i) => {\n      let { minTime: n, maxTime: o } = this._options;\n      const { inline: r, format12: a, disablePast: l, disableFuture: p } = this._options;\n      n = Xt(n, l, a), o = Gt(o, p, a);\n      const [u, _, f] = R(\n        o,\n        !1\n      ), [g, m, b] = R(\n        n,\n        !1\n      );\n      !r && a && this._isInvalidTimeFormat && !this._AM.hasAttribute(H) && (h.addClass(this._PM, this._classes.opacity), this._PM.setAttribute(H, \"\"));\n      const v = d.findOne(e), C = 360 / t.length;\n      function w(k) {\n        return k * (Math.PI / 180);\n      }\n      if (v === null)\n        return;\n      const E = (v.offsetWidth - 32) / 2, T = (v.offsetHeight - 32) / 2, A = E - 4;\n      setTimeout(() => {\n        let k;\n        a && (k = d.findOne(\n          `${ms}[${H}]`\n        ).textContent), this._handleDisablingTipsMinTime(\n          k,\n          b,\n          m,\n          g\n        ), this._handleDisablingTipsMaxTime(\n          k,\n          f,\n          _,\n          u\n        );\n      }, 0), [...t].forEach((k, I) => {\n        const O = w(I * C), x = $(\"span\"), L = $(\"span\");\n        L.innerHTML = k, h.addClass(x, this._classes.tips), x.setAttribute(i, \"\");\n        const S = x.offsetWidth, N = x.offsetHeight;\n        return h.addStyle(x, {\n          left: `${E + Math.sin(O) * A - S}px`,\n          bottom: `${T + Math.cos(O) * A - N}px`\n        }), t.includes(\"05\") && x.setAttribute(X, \"\"), t.includes(\"13\") ? L.setAttribute(vs, \"\") : L.setAttribute(bs, \"\"), x.appendChild(L), v.appendChild(x);\n      });\n    });\n    this._element = t, this._element && y.setData(t, Us, this), this._document = document, this._options = this._getConfig(e), this._classes = this._getClasses(i), this._currentTime = null, this._toggleButtonId = rt(\"timepicker-toggle-\"), this.hoursArray = [\n      \"12\",\n      \"1\",\n      \"2\",\n      \"3\",\n      \"4\",\n      \"5\",\n      \"6\",\n      \"7\",\n      \"8\",\n      \"9\",\n      \"10\",\n      \"11\"\n    ], this.innerHours = [\n      \"00\",\n      \"13\",\n      \"14\",\n      \"15\",\n      \"16\",\n      \"17\",\n      \"18\",\n      \"19\",\n      \"20\",\n      \"21\",\n      \"22\",\n      \"23\"\n    ], this.minutesArray = [\n      \"00\",\n      \"05\",\n      \"10\",\n      \"15\",\n      \"20\",\n      \"25\",\n      \"30\",\n      \"35\",\n      \"40\",\n      \"45\",\n      \"50\",\n      \"55\"\n    ], this.input = d.findOne(\"input\", this._element), this.dataWithIcon = t.dataset.withIcon, this.dataToggle = t.dataset.toggle, this.customIcon = d.findOne(\n      Km,\n      this._element\n    ), this._checkToggleButton(), this.inputFormatShow = d.findOne(\n      jm,\n      this._element\n    ), this.inputFormat = this.inputFormatShow === null ? \"\" : Object.values(this.inputFormatShow.dataset)[0], this.elementToggle = d.findOne(\n      Pa,\n      this._element\n    ), this.toggleElement = Object.values(\n      t.querySelector(Pa).dataset\n    )[0], this._hour = null, this._minutes = null, this._AM = null, this._PM = null, this._wrapper = null, this._modal = null, this._hand = null, this._circle = null, this._focusTrap = null, this._popper = null, this._interval = null, this._timeoutInterval = null, this._inputValue = this._options.defaultTime !== \"\" ? this._options.defaultTime : this.input.value, this._options.format24 && (this._options.format12 = !1, this._currentTime = La(this._inputValue)), this._options.format12 && (this._options.format24 = !1, this._currentTime = ve(this._inputValue)), this._options.readOnly && this.input.setAttribute(qm, !0), this.inputFormat === \"true\" && this.inputFormat !== \"\" && (this._options.format12 = !1, this._options.format24 = !0, this._currentTime = La(this._inputValue)), this._animations = !window.matchMedia(\"(prefers-reduced-motion: reduce)\").matches && this._options.animations, this.init(), this._isHours = !0, this._isMinutes = !1, this._isInvalidTimeFormat = !1, this._isMouseMove = !1, this._isInner = !1, this._isAmEnabled = !1, this._isPmEnabled = !1, this._options.format12 && !this._options.defaultTime && (this._isPmEnabled = !0), this._objWithDataOnChange = { degrees: null }, this._scrollBar = new qe();\n  }\n  // Getters\n  static get NAME() {\n    return $i;\n  }\n  // Public\n  init() {\n    const { format12: t, format24: e, enableValidation: i } = this._options;\n    let n, o, r;\n    if (this.input.setAttribute(Qm, \"\"), this._currentTime !== void 0) {\n      const { hours: a, minutes: l, amOrPm: p } = this._currentTime;\n      n = Number(a) < 10 ? 0 : \"\", o = `${n}${Number(a)}:${l}`, r = p, t ? this.input.value = `${o} ${r}` : e && (this.input.value = `${o}`);\n    } else\n      n = \"\", o = \"\", r = \"\", this.input.value = \"\";\n    this.input.value.length > 0 && this.input.value !== \"\" && (this.input.setAttribute(H, \"\"), c.trigger(this.input, \"input\")), !(this._options === null && this._element === null) && (i && this._getValidate(\"keydown change blur focus\"), this._handleOpen(), this._listenToToggleKeydown());\n  }\n  dispose() {\n    this._removeModal(), this._element !== null && y.removeData(this._element, Us), setTimeout(() => {\n      this._element = null, this._options = null, this.input = null, this._focusTrap = null;\n    }, 350), c.off(\n      this._document,\n      \"click\",\n      `[data-te-toggle='${this.toggleElement}']`\n    ), c.off(\n      this._element,\n      \"keydown\",\n      `[data-te-toggle='${this.toggleElement}']`\n    );\n  }\n  update(t = {}) {\n    this._options = this._getConfig({ ...this._options, ...t });\n  }\n  // private\n  _checkToggleButton() {\n    this.customIcon === null && (this.dataWithIcon !== void 0 && (this._options.withIcon = null, this.dataWithIcon === \"true\" && this._appendToggleButton(this._options)), this._options.withIcon && this._appendToggleButton(this._options));\n  }\n  _appendToggleButton() {\n    const t = Rm(\n      this._options,\n      this._toggleButtonId,\n      this._classes\n    );\n    this.input.insertAdjacentHTML(\"afterend\", t);\n  }\n  _getDomElements() {\n    this._hour = d.findOne(`[${gs}]`), this._minutes = d.findOne(`[${eo}]`), this._AM = d.findOne(Fm), this._PM = d.findOne(Ym), this._wrapper = d.findOne(`[${to}]`), this._modal = d.findOne(`[${Za}]`), this._hand = d.findOne(`[${io}]`), this._circle = d.findOne(`[${so}]`), this._clock = d.findOne(`[${pe}]`), this._clockInner = d.findOne(\n      `[${di}]`\n    );\n  }\n  _handlerMaxMinHoursOptions(t, e, i, n, o, r) {\n    if (!e && !i)\n      return !0;\n    const { format24: a, format12: l, disablePast: p, disableFuture: u } = this._options, { _isAmEnabled: _, _isPmEnabled: f } = this, g = r.keyCode, m = r.target.hasAttribute(di) || r.target.hasAttribute(lt) || r.target.hasAttribute(vs);\n    i = Xt(i, p, l), e = Gt(e, u, l), typeof e != \"number\" && (e = R(e, !1)[0]);\n    const b = e !== \"\" ? e * 30 : \"\", v = i !== \"\" ? i * 30 : \"\";\n    t < 0 && (t = 360 + t), t = t === 360 ? 0 : t;\n    const C = () => {\n      const I = document.querySelectorAll(\n        `[${bs}]`\n      ), O = document.querySelectorAll(\n        `[${vs}]`\n      ), x = Wm(this._hour.innerText);\n      let L, S, N;\n      return g === at ? S = 1 : g === z && (S = -1), x === 12 && g === at ? N = 1 : x === 0 && g === at ? N = 13 : x === 0 && g === z ? N = 23 : x === 13 && g === z ? N = 0 : x === 1 && g === z ? N = 12 : N = x + S, I.forEach((P) => {\n        Number(P.textContent) === N && (L = P);\n      }), O.forEach((P) => {\n        Number(P.textContent) === N && (L = P);\n      }), !L.parentElement.hasAttribute(Yt);\n    }, w = () => {\n      const I = i !== \"\" && i > 12 ? (i - 12) * 30 : \"\", O = e !== \"\" && e > 12 ? (e - 12) * 30 : \"\";\n      if (!(I && t < I || O && t > O || e && e < 12))\n        return !0;\n    };\n    if (a && r.type !== \"keydown\" && m)\n      return w();\n    if (r.type === \"keydown\")\n      return C();\n    const E = !o || o === \"PM\" && f || i !== \"\" && o === \"AM\" && _, T = !n || n === \"PM\" && f || e !== \"\" && n === \"AM\" && _, A = () => {\n      const I = v === 360 && l ? 0 : v;\n      if (i) {\n        if (o === \"PM\" && _ || E && t < I)\n          return;\n      } else\n        return !0;\n      return !0;\n    }, k = () => {\n      const I = b === 360 && l ? 0 : b;\n      if (e) {\n        if (n === \"AM\" && f || T && t > I)\n          return;\n      } else\n        return !0;\n      return !0;\n    };\n    return A() && k();\n  }\n  _handleKeyboard() {\n    c.on(this._document, _s, \"\", (t) => {\n      let e, i, n;\n      const {\n        increment: o,\n        maxTime: r,\n        minTime: a,\n        format12: l,\n        disablePast: p,\n        disableFuture: u\n      } = this._options;\n      let _ = R(a, !1)[0], f = R(r, !1)[0];\n      const g = R(a, !1)[2], m = R(r, !1)[2];\n      _ = Xt(_, p, l), f = Gt(f, u, l), typeof f != \"number\" && (f = R(f, !1)[0]);\n      const b = d.findOne(`[${X}]`) === null, v = d.findOne(`[${lt}]`) !== null, C = Number(this._hand.style.transform.replace(/[^\\d-]/g, \"\")), w = d.find(\n        `[${X}]`,\n        this._modal\n      ), E = d.find(\n        `[${K}]`,\n        this._modal\n      ), T = d.find(\n        `[${lt}]`,\n        this._modal\n      );\n      let A = this._makeHourDegrees(t.target, C, e).hour;\n      const { degrees: k, addDegrees: I } = this._makeHourDegrees(\n        t.target,\n        C,\n        e\n      );\n      let { minute: O, degrees: x } = this._makeMinutesDegrees(C, i);\n      const L = this._makeMinutesDegrees(\n        C,\n        i\n      ).addDegrees;\n      let { hour: S } = this._makeInnerHoursDegrees(\n        C,\n        n\n      );\n      if (t.keyCode === Fi) {\n        const N = d.findOne(\n          `[${Gn}]`,\n          this._modal\n        );\n        c.trigger(N, \"click\");\n      } else if (b) {\n        if (v && (t.keyCode === Ve && (this._isInner = !1, h.addStyle(this._hand, {\n          height: \"calc(40% + 1px)\"\n        }), this._hour.textContent = this._setHourOrMinute(\n          A > 12 ? 1 : A\n        ), this._toggleClassActive(this.hoursArray, this._hour, E), this._toggleClassActive(this.innerHours, this._hour, T)), t.keyCode === He && (this._isInner = !0, h.addStyle(this._hand, {\n          height: \"21.5%\"\n        }), this._hour.textContent = this._setHourOrMinute(\n          S >= 24 || S === \"00\" ? 0 : S\n        ), this._toggleClassActive(this.innerHours, this._hour, T), this._toggleClassActive(\n          this.hoursArray,\n          this._hour - 1,\n          E\n        ))), t.keyCode === at) {\n          if (!this._handlerMaxMinHoursOptions(\n            k + 30,\n            f,\n            _,\n            m,\n            g,\n            t\n          ))\n            return;\n          h.addStyle(this._hand, {\n            transform: `rotateZ(${k + I}deg)`\n          }), this._isInner ? (S += 1, S === 24 ? S = 0 : (S === 25 || S === \"001\") && (S = 13), this._hour.textContent = this._setHourOrMinute(S), this._toggleClassActive(this.innerHours, this._hour, T)) : (A += 1, this._hour.textContent = this._setHourOrMinute(\n            A > 12 ? 1 : A\n          ), this._toggleClassActive(this.hoursArray, this._hour, E));\n        }\n        if (t.keyCode === z) {\n          if (!this._handlerMaxMinHoursOptions(\n            k - 30,\n            f,\n            _,\n            m,\n            g,\n            t\n          ))\n            return;\n          h.addStyle(this._hand, {\n            transform: `rotateZ(${k - I}deg)`\n          }), this._isInner ? (S -= 1, S === 12 ? S = 0 : S === -1 && (S = 23), this._hour.textContent = this._setHourOrMinute(S), this._toggleClassActive(this.innerHours, this._hour, T)) : (A -= 1, this._hour.textContent = this._setHourOrMinute(\n            A === 0 ? 12 : A\n          ), this._toggleClassActive(this.hoursArray, this._hour, E));\n        }\n      } else\n        t.keyCode === at && (x += L, h.addStyle(this._hand, {\n          transform: `rotateZ(${x}deg)`\n        }), O += 1, o && (O += 4, O === \"0014\" && (O = 5)), this._minutes.textContent = this._setHourOrMinute(\n          O > 59 ? 0 : O\n        ), this._toggleClassActive(\n          this.minutesArray,\n          this._minutes,\n          w\n        ), this._toggleBackgroundColorCircle(\n          `[${X}]`\n        )), t.keyCode === z && (x -= L, h.addStyle(this._hand, {\n          transform: `rotateZ(${x}deg)`\n        }), o ? O -= 5 : O -= 1, O === -1 ? O = 59 : O === -5 && (O = 55), this._minutes.textContent = this._setHourOrMinute(O), this._toggleClassActive(\n          this.minutesArray,\n          this._minutes,\n          w\n        ), this._toggleBackgroundColorCircle(\n          `[${X}]`\n        ));\n    });\n  }\n  _setActiveClassToTipsOnOpen(t, ...e) {\n    if (!this._isInvalidTimeFormat)\n      if (this._options.format24) {\n        const i = d.find(\n          `[${K}]`,\n          this._modal\n        ), n = d.find(\n          `[${lt}]`,\n          this._modal\n        );\n        this._addActiveClassToTip(i, t), this._addActiveClassToTip(n, t);\n      } else {\n        [...e].filter((n) => (n === \"PM\" ? (h.addClass(this._PM, this._classes.opacity), this._PM.setAttribute(H, \"\")) : n === \"AM\" ? (h.addClass(this._AM, this._classes.opacity), this._AM.setAttribute(H, \"\")) : (h.removeClass(this._AM, this._classes.opacity), h.removeClass(this._PM, this._classes.opacity), this._AM.removeAttribute(H), this._PM.removeAttribute(H)), n));\n        const i = d.find(\n          `[${K}]`,\n          this._modal\n        );\n        this._addActiveClassToTip(i, t);\n      }\n  }\n  _setTipsAndTimesDependOnInputValue(t, e) {\n    const { inline: i, format12: n } = this._options;\n    if (this._isInvalidTimeFormat)\n      this._hour.textContent = \"12\", this._minutes.textContent = \"00\", i || h.addStyle(this._hand, {\n        transform: \"rotateZ(0deg)\"\n      }), n && (h.addClass(this._PM, this._classes.opacity), this._PM.setAttribute(H, \"\"));\n    else {\n      const o = t > 12 ? t * 30 - 360 : t * 30;\n      this._hour.textContent = t, this._minutes.textContent = e, i || (h.addStyle(this._hand, {\n        transform: `rotateZ(${o}deg)`\n      }), h.addStyle(this._circle, {\n        backgroundColor: \"#1976d2\"\n      }), (Number(t) > 12 || t === \"00\") && h.addStyle(this._hand, {\n        height: \"21.5%\"\n      }));\n    }\n  }\n  _listenToToggleKeydown() {\n    c.on(\n      this._element,\n      \"keydown\",\n      `[data-te-toggle='${this.toggleElement}']`,\n      (t) => {\n        t.keyCode === ct && (t.preventDefault(), c.trigger(this.elementToggle, \"click\"));\n      }\n    );\n  }\n  _handleOpen() {\n    const t = this._getContainer();\n    re.on(\n      this._element,\n      \"click\",\n      `[data-te-toggle='${this.toggleElement}']`,\n      (e) => {\n        if (this._options === null)\n          return;\n        const i = h.getDataAttribute(this.input, \"toggle\") !== null ? 200 : 0;\n        setTimeout(() => {\n          h.addStyle(this.elementToggle, {\n            pointerEvents: \"none\"\n          }), this.elementToggle.blur();\n          let n;\n          R(this.input)[0] === \"\" ? n = [\"12\", \"00\", \"PM\"] : n = R(this.input);\n          const { modalID: o, inline: r, format12: a } = this._options, [l, p, u] = n, _ = $(\"div\");\n          if ((Number(l) > 12 || l === \"00\") && (this._isInner = !0), this.input.blur(), e.target.blur(), _.innerHTML = Mm(this._options, this._classes), h.addClass(_, this._classes.modal), _.setAttribute(Za, \"\"), _.setAttribute(\"role\", \"dialog\"), _.setAttribute(\"tabIndex\", \"-1\"), _.setAttribute(\"id\", o), r ? (this._popper = Ce(this.input, _, {\n            placement: \"bottom-start\"\n          }), t.appendChild(_)) : (t.appendChild(_), this._scrollBar.hide()), this._getDomElements(), this._animations ? this._toggleBackdropAnimation() : h.addClass(this._wrapper, this._classes.opacity), this._setActiveClassToTipsOnOpen(l, p, u), this._appendTimes(), this._setActiveClassToTipsOnOpen(l, p, u), this._setTipsAndTimesDependOnInputValue(l, p), this.input.value === \"\") {\n            const f = d.find(\n              `[${K}]`,\n              this._modal\n            );\n            a && (h.addClass(this._PM, this._classes.opacity), this._PM.setAttribute(H, \"\")), this._hour.textContent = \"12\", this._minutes.textContent = \"00\", this._addActiveClassToTip(\n              f,\n              Number(this._hour.textContent)\n            );\n          }\n          if (this._handleSwitchTimeMode(), this._handleOkButton(), this._handleClose(), r)\n            this._handleHoverInlineBtn(), this._handleDocumentClickInline(), this._handleInlineClicks();\n          else {\n            this._handleSwitchHourMinute(), this._handleClockClick(), this._handleKeyboard();\n            const f = document.querySelector(\n              `${fs}[${H}]`\n            );\n            h.addClass(f, this._classes.opacity), h.addStyle(this._hour, {\n              pointerEvents: \"none\"\n            }), h.addStyle(this._minutes, {\n              pointerEvents: \"\"\n            });\n          }\n          this._focusTrap = new Wi(this._wrapper, {\n            event: \"keydown\",\n            condition: ({ key: f }) => f === \"Tab\"\n          }), this._focusTrap.trap();\n        }, i);\n      }\n    );\n  }\n  _handleInlineClicks() {\n    let t, e;\n    const i = (g) => {\n      let m = g;\n      return m > 59 ? m = 0 : m < 0 && (m = 59), m;\n    }, n = (g) => {\n      let m = g;\n      return this._options.format24 ? (m > 24 ? m = 1 : m < 0 && (m = 23), m > 23 && (m = 0)) : (m > 12 ? m = 1 : m < 1 && (m = 12), m > 12 && (m = 1)), m;\n    }, o = (g) => {\n      const m = n(g);\n      this._hour.textContent = this._setHourOrMinute(m);\n    }, r = (g) => {\n      const m = i(g);\n      this._minutes.textContent = this._setHourOrMinute(m);\n    }, a = () => {\n      t = n(t) + 1, o(t);\n    }, l = () => {\n      e = i(e) + 1, r(e);\n    }, p = () => {\n      t = n(t) - 1, o(t);\n    }, u = () => {\n      e = i(e) - 1, r(e);\n    }, _ = () => {\n      clearInterval(this._interval), clearTimeout(this._timeoutInterval);\n    }, f = (g) => {\n      _(), this._timeoutInterval = setTimeout(() => {\n        this._interval = setInterval(g, 100);\n      }, 500);\n    };\n    re.on(\n      this._modal,\n      \"click mousedown mouseup touchstart touchend contextmenu\",\n      `[${Zn}], [${Qn}]`,\n      (g) => {\n        t = Number(this._hour.textContent), e = Number(this._minutes.textContent);\n        const { target: m, type: b } = g, v = b === \"mousedown\" || b === \"touchstart\";\n        m.closest(`[${Zn}]`) ? m.closest(`[${Zn}]`).parentNode.hasAttribute(Xa) ? v ? f(a) : b === \"mouseup\" || b === \"touchend\" || b === \"contextmenu\" ? _() : a() : v ? f(l) : b === \"mouseup\" || b === \"touchend\" || b === \"contextmenu\" ? _() : l() : m.closest(`[${Qn}]`) && (m.closest(`[${Qn}]`).parentNode.hasAttribute(Xa) ? v ? f(p) : b === \"mouseup\" || b === \"touchend\" ? _() : p() : v ? f(u) : b === \"mouseup\" || b === \"touchend\" ? _() : u());\n      }\n    ), c.on(window, _s, (g) => {\n      const m = g.code, b = document.activeElement.hasAttribute(gs), v = document.activeElement.hasAttribute(\n        eo\n      ), C = document.activeElement === document.body;\n      switch (t = Number(this._hour.textContent), e = Number(this._minutes.textContent), m) {\n        case \"ArrowUp\":\n          g.preventDefault(), C || b ? (this._hour.focus(), a()) : v && l();\n          break;\n        case \"ArrowDown\":\n          g.preventDefault(), C || b ? (this._hour.focus(), p()) : v && u();\n          break;\n      }\n    });\n  }\n  _handleClose() {\n    c.on(\n      this._modal,\n      \"click\",\n      `[${to}], [${Gn}], [${Ua}]`,\n      ({ target: t }) => {\n        const { closeModalOnBackdropClick: e } = this._options, i = () => {\n          var n;\n          h.addStyle(this.elementToggle, {\n            pointerEvents: \"auto\"\n          }), this._animations && this._toggleBackdropAnimation(!0), this._removeModal(), (n = this._focusTrap) == null || n.disable(), this._focusTrap = null, this.elementToggle ? this.elementToggle.focus() : this.input && this.input.focus();\n        };\n        if (t.hasAttribute(Ua)) {\n          this._toggleAmPm(\"PM\"), this.input.value = \"\", this.input.removeAttribute(H);\n          let n;\n          R(this.input)[0] === \"\" ? n = [\"12\", \"00\", \"PM\"] : n = R(this.input);\n          const [o, r, a] = n;\n          this._setTipsAndTimesDependOnInputValue(\"12\", \"00\"), this._setActiveClassToTipsOnOpen(o, r, a), this._hour.click();\n        } else\n          (t.hasAttribute(Gn) || t.hasAttribute(qn) || t.hasAttribute(to) && e) && i();\n      }\n    );\n  }\n  showValueInput() {\n    return this.input.value;\n  }\n  _handleOkButton() {\n    re.on(\n      this._modal,\n      \"click\",\n      `[${qn}]`,\n      () => {\n        let { maxTime: t, minTime: e } = this._options;\n        const {\n          format12: i,\n          format24: n,\n          readOnly: o,\n          focusInputAfterApprove: r,\n          disablePast: a,\n          disableFuture: l\n        } = this._options, p = this._document.querySelector(\n          `${ms}[${H}]`\n        ), u = `${this._hour.textContent}:${this._minutes.textContent}`, _ = Number(this._hour.textContent), f = _ === 12 && i ? 0 : _, g = Number(this._minutes.textContent);\n        e = Xt(e, a, i), t = Gt(t, l, i);\n        let [m, b, v] = R(\n          t,\n          !1\n        ), [C, w, E] = R(\n          e,\n          !1\n        );\n        C = C === \"12\" && i ? \"00\" : C, m = m === \"12\" && i ? \"00\" : m;\n        const T = f < Number(C), A = f > Number(m);\n        let k = !0;\n        p && (k = v === p.textContent);\n        let I = !0;\n        p && (I = E === p.textContent);\n        const O = g > b && f === Number(m), x = g < w && f === Number(C);\n        if (this.input.setAttribute(H, \"\"), h.addStyle(this.elementToggle, {\n          pointerEvents: \"auto\"\n        }), t !== \"\") {\n          if (k && (A || O))\n            return;\n          if (v === \"AM\" && p.textContent === \"PM\")\n            return;\n        }\n        e !== \"\" && (I && (T || x) || E === \"PM\" && p.textContent === \"AM\") || Bm(\n          this._options,\n          this.input,\n          this._hour.textContent\n        ) !== void 0 && (this._isInvalidTimeFormat && this.input.removeAttribute(Jn), !o && r && this.input.focus(), h.addStyle(this.elementToggle, {\n          pointerEvents: \"auto\"\n        }), n ? this.input.value = u : p === null ? this.input.value = `${u} PM` : this.input.value = `${u} ${p.textContent}`, this._animations && this._toggleBackdropAnimation(!0), this._removeModal(), c.trigger(this.input, \"input.te.timepicker\"), c.trigger(this.input, \"input\"));\n      }\n    );\n  }\n  _handleHoverInlineBtn() {\n    re.on(\n      this._modal,\n      \"mouseover mouseleave\",\n      `[${Gm}]`,\n      ({ type: t, target: e }) => {\n        const i = d.find(\n          `[${Um}]`,\n          this._modal\n        ), n = d.find(\n          `[${Xm}]`,\n          this._modal\n        ), o = (l, p) => l.forEach((u) => {\n          if (p) {\n            h.addClass(u, this._classes.opacity), u.setAttribute(H, \"\");\n            return;\n          }\n          h.removeClass(u, this._classes.opacity), u.removeAttribute(H);\n        }), a = e.hasAttribute(gs) ? i : n;\n        o(a, t === \"mouseover\");\n      }\n    );\n  }\n  _handleDocumentClickInline() {\n    c.on(document, Ba, ({ target: t }) => {\n      if (this._modal && !this._modal.contains(t) && !t.hasAttribute(zm)) {\n        if (clearInterval(this._interval), h.addStyle(this.elementToggle, {\n          pointerEvents: \"auto\"\n        }), this._removeModal(), !this._animations)\n          return;\n        this._toggleBackdropAnimation(!0);\n      }\n    });\n  }\n  _handleSwitchHourMinute() {\n    Pm(\n      \"click\",\n      fs,\n      this._classes\n    ), c.on(\n      this._modal,\n      \"click\",\n      fs,\n      () => {\n        const { format24: t } = this._options, e = d.find(\n          fs,\n          this._modal\n        ), i = d.find(\n          `[${X}]`,\n          this._modal\n        ), n = d.find(\n          `[${K}]`,\n          this._modal\n        ), o = d.find(\n          `[${lt}]`,\n          this._modal\n        ), r = Number(this._hour.textContent), a = Number(this._minutes.textContent), l = (p, u) => {\n          n.forEach((f) => f.remove()), i.forEach((f) => f.remove()), h.addClass(this._hand, this._classes.transform), setTimeout(() => {\n            h.removeClass(this._hand, this._classes.transform);\n          }, 401), this._getAppendClock(p, `[${pe}]`, u);\n          const _ = () => {\n            const f = d.find(\n              `[${K}]`,\n              this._modal\n            ), g = d.find(\n              `[${X}]`,\n              this._modal\n            );\n            this._addActiveClassToTip(f, r), this._addActiveClassToTip(g, a);\n          };\n          if (!t)\n            setTimeout(() => {\n              _();\n            }, 401);\n          else {\n            const f = d.find(\n              `[${lt}]`,\n              this._modal\n            );\n            setTimeout(() => {\n              this._addActiveClassToTip(f, r), _();\n            }, 401);\n          }\n        };\n        e.forEach((p) => {\n          p.hasAttribute(H) && (p.hasAttribute(eo) ? (h.addClass(this._hand, this._classes.transform), h.addStyle(this._hand, {\n            transform: `rotateZ(${this._minutes.textContent * 6}deg)`,\n            height: \"calc(40% + 1px)\"\n          }), t && o.length > 0 && o.forEach((u) => u.remove()), l(\n            this.minutesArray,\n            X\n          ), this._hour.style.pointerEvents = \"\", this._minutes.style.pointerEvents = \"none\") : p.hasAttribute(gs) && (h.addStyle(this._hand, {\n            transform: `rotateZ(${this._hour.textContent * 30}deg)`\n          }), Number(this._hour.textContent) > 12 ? (h.addStyle(this._hand, {\n            transform: `rotateZ(${this._hour.textContent * 30 - 360}deg)`,\n            height: \"21.5%\"\n          }), Number(this._hour.textContent) > 12 && h.addStyle(this._hand, {\n            height: \"21.5%\"\n          })) : h.addStyle(this._hand, {\n            height: \"calc(40% + 1px)\"\n          }), t && this._getAppendClock(\n            this.innerHours,\n            `[${di}]`,\n            lt\n          ), o.length > 0 && o.forEach((u) => u.remove()), l(\n            this.hoursArray,\n            K\n          ), h.addStyle(this._hour, {\n            pointerEvents: \"none\"\n          }), h.addStyle(this._minutes, {\n            pointerEvents: \"\"\n          })));\n        });\n      }\n    );\n  }\n  _handleDisablingTipsMaxTime(t, e, i, n) {\n    if (!this._options.maxTime && !this._options.disableFuture)\n      return;\n    const o = d.find(\n      `[${K}]`\n    ), r = d.find(\n      `[${lt}]`\n    ), a = d.find(\n      `[${X}]`\n    );\n    if (!e || e === t) {\n      Ma(\n        r,\n        n,\n        this._classes,\n        this._options.format12\n      ), Ma(\n        o,\n        n,\n        this._classes,\n        this._options.format12\n      ), Hm(\n        a,\n        i,\n        n,\n        this._hour.textContent,\n        this._classes,\n        this._options.format12\n      );\n      return;\n    }\n    e === \"AM\" && t === \"PM\" && (o.forEach((l) => {\n      h.addClass(l, this._classes.tipsDisabled), l.setAttribute(Yt, \"\");\n    }), a.forEach((l) => {\n      h.addClass(l, this._classes.tipsDisabled), l.setAttribute(Yt, \"\");\n    }));\n  }\n  _handleDisablingTipsMinTime(t, e, i, n) {\n    if (!this._options.minTime && !this._options.disablePast)\n      return;\n    const o = d.find(\n      `[${K}]`\n    ), r = d.find(\n      `[${lt}]`\n    ), a = d.find(\n      `[${X}]`\n    );\n    !e || e === t ? (Ra(\n      o,\n      n,\n      this._classes,\n      this._options.format12\n    ), Ra(\n      r,\n      n,\n      this._classes,\n      this._options.format12\n    ), Vm(\n      a,\n      i,\n      n,\n      this._hour.textContent,\n      this._classes,\n      this._options.format12\n    )) : e === \"PM\" && t === \"AM\" && (o.forEach((l) => {\n      h.addClass(l, this._classes.tipsDisabled), l.setAttribute(Yt, \"\");\n    }), a.forEach((l) => {\n      h.addClass(l, this._classes.tipsDisabled), l.setAttribute(Yt, \"\");\n    }));\n  }\n  _handleSwitchTimeMode() {\n    c.on(\n      document,\n      \"click\",\n      ms,\n      ({ target: t }) => {\n        let { maxTime: e, minTime: i } = this._options;\n        const { disablePast: n, disableFuture: o, format12: r } = this._options;\n        i = Xt(i, n, r), e = Gt(e, o, r);\n        const [a, l, p] = R(\n          e,\n          !1\n        ), [u, _, f] = R(\n          i,\n          !1\n        ), g = d.find(\n          `[${K}]`\n        ), m = d.find(\n          `[${X}]`\n        );\n        (() => {\n          g.forEach((v) => {\n            h.removeClass(v, this._classes.tipsDisabled), v.removeAttribute(Yt);\n          }), m.forEach((v) => {\n            h.removeClass(v, this._classes.tipsDisabled), v.removeAttribute(Yt);\n          });\n        })(), this._handleDisablingTipsMinTime(\n          t.textContent,\n          f,\n          _,\n          u\n        ), this._handleDisablingTipsMaxTime(\n          t.textContent,\n          p,\n          l,\n          a\n        ), this._toggleAmPm(t.textContent), t.hasAttribute(H) || (d.find(\n          ms\n        ).forEach((C) => {\n          C.hasAttribute(H) && (h.removeClass(C, this._classes.opacity), C.removeAttribute(H));\n        }), h.addClass(t, this._classes.opacity), t.setAttribute(H, \"\"));\n      }\n    );\n  }\n  _handleClockClick() {\n    let { maxTime: t, minTime: e } = this._options;\n    const { disablePast: i, disableFuture: n, format12: o } = this._options;\n    e = Xt(e, i, o), t = Gt(t, n, o);\n    const r = R(t, !1)[2], a = R(e, !1)[2], l = R(t, !1)[0], p = R(e, !1)[0], u = d.findOne(\n      `[${Ga}]`\n    );\n    re.on(\n      document,\n      `${Ha} ${Va} ${Wa} ${Fa} ${Ya} ${za} ${ja} ${Ka}`,\n      \"\",\n      (_) => {\n        ps() || _.preventDefault();\n        const { type: f, target: g } = _, { closeModalOnMinutesClick: m, switchHoursToMinutesOnClick: b } = this._options, v = d.findOne(\n          `[${X}]`,\n          this._modal\n        ) !== null, C = d.findOne(\n          `[${K}]`,\n          this._modal\n        ) !== null, w = d.findOne(\n          `[${lt}]`,\n          this._modal\n        ) !== null, E = d.find(\n          `[${X}]`,\n          this._modal\n        ), T = Na(_, u), A = u.offsetWidth / 2;\n        let k = Math.atan2(T.y - A, T.x - A);\n        if (ps()) {\n          const L = Na(_, u, !0);\n          k = Math.atan2(L.y - A, L.x - A);\n        }\n        let I = null, O = null, x = null;\n        if (f === \"mousedown\" || f === \"mousemove\" || f === \"touchmove\" || f === \"touchstart\")\n          (f === \"mousedown\" || f === \"touchstart\" || f === \"touchmove\") && (this._hasTargetInnerClass(g) || g.hasAttribute(Ga) || g.hasAttribute(pe) || g.hasAttribute(X) || g.hasAttribute(K) || g.hasAttribute(so) || g.hasAttribute(io) || g.hasAttribute(qa) || g.hasAttribute(bs)) && (this._isMouseMove = !0, ps() && _.touches && (I = _.touches[0].clientX, O = _.touches[0].clientY, x = document.elementFromPoint(I, O)));\n        else if (f === \"mouseup\" || f === \"touchend\") {\n          if (this._isMouseMove = !1, this._hasTargetInnerClass(g) || g.hasAttribute(pe) || g.hasAttribute(K) || g.hasAttribute(so) || g.hasAttribute(io) || g.hasAttribute(qa) || g.hasAttribute(bs)) {\n            if ((C || w) && b) {\n              const L = Number(this._hour.textContent) > l || Number(this._hour.textContent) < p;\n              if (this._options.format24 && l !== \"\" && p !== \"\" && L)\n                return;\n              if (this._options.format24 && p !== \"\" && Number(this._hour.textContent) < p)\n                return;\n            }\n            c.trigger(this._minutes, \"click\");\n          }\n          if (v && m) {\n            const L = d.findOne(\n              `[${qn}]`,\n              this._modal\n            );\n            c.trigger(L, \"click\");\n          }\n        }\n        if (v) {\n          let L;\n          const S = Math.trunc(k * 180 / Math.PI) + 90, { degrees: N, minute: P } = this._makeMinutesDegrees(S, L);\n          if (this._handlerMaxMinMinutesOptions(N, P) === void 0)\n            return;\n          const { degrees: tt, minute: et } = this._handlerMaxMinMinutesOptions(N, P);\n          if (this._isMouseMove) {\n            if (h.addStyle(this._hand, {\n              transform: `rotateZ(${tt}deg)`\n            }), et === void 0)\n              return;\n            const U = () => et >= 10 || et === \"00\" ? et : `0${et}`;\n            this._minutes.textContent = U(), this._toggleClassActive(\n              this.minutesArray,\n              this._minutes,\n              E\n            ), this._toggleBackgroundColorCircle(\n              `[${X}]`\n            ), this._objWithDataOnChange.degreesMinutes = tt, this._objWithDataOnChange.minutes = et;\n          }\n        }\n        if (C || w) {\n          let L, S = Math.trunc(k * 180 / Math.PI) + 90;\n          if (S = Math.round(S / 30) * 30, h.addStyle(this._circle, {\n            backgroundColor: \"#1976d2\"\n          }), this._makeHourDegrees(g, S, L) === void 0)\n            return;\n          const N = () => {\n            if (ps() && S && x) {\n              const { degrees: P, hour: tt } = this._makeHourDegrees(x, S, L);\n              return this._handleMoveHand(\n                x,\n                tt,\n                P\n              );\n            } else {\n              const { degrees: P, hour: tt } = this._makeHourDegrees(g, S, L);\n              return this._handleMoveHand(g, tt, P);\n            }\n          };\n          this._objWithDataOnChange.degreesHours = S, this._handlerMaxMinHoursOptions(\n            S,\n            l,\n            p,\n            r,\n            a,\n            _\n          ) && N();\n        }\n        _.stopPropagation();\n      }\n    );\n  }\n  _hasTargetInnerClass(t) {\n    return t.hasAttribute(di) || t.hasAttribute(lt) || t.hasAttribute(vs);\n  }\n  _handleMoveHand(t, e, i) {\n    const n = d.find(\n      `[${K}]`,\n      this._modal\n    ), o = d.find(\n      `[${lt}]`,\n      this._modal\n    );\n    this._isMouseMove && (this._hasTargetInnerClass(t) ? h.addStyle(this._hand, {\n      height: \"21.5%\"\n    }) : h.addStyle(this._hand, {\n      height: \"calc(40% + 1px)\"\n    }), h.addStyle(this._hand, {\n      transform: `rotateZ(${i}deg)`\n    }), this._hour.textContent = e >= 10 || e === \"00\" ? e : `0${e}`, this._toggleClassActive(this.hoursArray, this._hour, n), this._toggleClassActive(this.innerHours, this._hour, o), this._objWithDataOnChange.hour = e >= 10 || e === \"00\" ? e : `0${e}`);\n  }\n  _handlerMaxMinMinutesOptions(t, e) {\n    let { maxTime: i, minTime: n } = this._options;\n    const { format12: o, increment: r, disablePast: a, disableFuture: l } = this._options;\n    n = Xt(n, a, o), i = Gt(i, l, o);\n    const p = R(i, !1)[1], u = R(n, !1)[1], _ = R(i, !1)[0], f = R(n, !1)[0], g = f === \"12\" && o ? \"0\" : f, m = _ === \"12\" && o ? \"0\" : _, b = R(i, !1)[2], v = R(n, !1)[2], C = p !== \"\" ? p * 6 : \"\", w = u !== \"\" ? u * 6 : \"\", E = Number(this._hour.textContent), T = E === 12 && o ? 0 : E;\n    if (!b && !v) {\n      if (i !== \"\" && n !== \"\") {\n        if (Number(m) === T && t > C || Number(g) === T && t < w)\n          return t;\n      } else if (n !== \"\" && T <= Number(g)) {\n        if (t <= w - 6)\n          return t;\n      } else if (i !== \"\" && T >= Number(m) && t >= C + 6)\n        return t;\n    } else {\n      if (n !== \"\") {\n        if (v === \"PM\" && this._isAmEnabled)\n          return;\n        if (v === \"PM\" && this._isPmEnabled) {\n          if (T < Number(g))\n            return;\n          if (T <= Number(g) && t <= w - 6)\n            return t;\n        } else if (v === \"AM\" && this._isAmEnabled) {\n          if (T < Number(g))\n            return;\n          if (T <= Number(g) && t <= w - 6)\n            return t;\n        }\n      }\n      if (i !== \"\") {\n        if (b === \"AM\" && this._isPmEnabled)\n          return;\n        if (b === \"PM\" && this._isPmEnabled) {\n          if (T >= Number(m) && t >= C + 6)\n            return t;\n        } else if (b === \"AM\" && this._isAmEnabled && T >= Number(m) && t >= C + 6)\n          return t;\n      }\n    }\n    return r && (t = Math.round(t / 30) * 30), t < 0 ? t = 360 + t : t >= 360 && (t = 0), {\n      degrees: t,\n      minute: e\n    };\n  }\n  _removeModal() {\n    this._animations ? setTimeout(() => {\n      this._removeModalElements(), this._scrollBar.reset();\n    }, 300) : (this._removeModalElements(), this._scrollBar.reset()), re.off(\n      this._document,\n      `${Ba} ${_s} ${Ha} ${Va} ${Wa} ${Fa} ${Ya} ${za} ${ja} ${Ka}`\n    ), c.off(window, _s);\n  }\n  _removeModalElements() {\n    this._modal && this._modal.remove();\n  }\n  _toggleBackdropAnimation(t = !1) {\n    t ? this._wrapper.classList.add(\"animate-[fade-out_350ms_ease-in-out]\") : (this._wrapper.classList.add(\"animate-[fade-in_350ms_ease-in-out]\"), this._options.inline || h.addClass(this._clock, this._classes.clockAnimation)), setTimeout(() => {\n      this._wrapper.classList.remove(\n        \"animate-[fade-out_350ms_ease-in-out]\",\n        \"animate-[fade-in_350ms_ease-in-out]\"\n      );\n    }, 351);\n  }\n  _addActiveClassToTip(t, e) {\n    t.forEach((i) => {\n      Number(i.textContent) === Number(e) && (h.addClass(i, this._classes.tipsActive), i.setAttribute(H, \"\"));\n    });\n  }\n  _setHourOrMinute(t) {\n    return t < 10 ? `0${t}` : t;\n  }\n  _appendTimes() {\n    const { format24: t } = this._options;\n    if (t) {\n      this._getAppendClock(\n        this.hoursArray,\n        `[${pe}]`,\n        K\n      ), this._getAppendClock(\n        this.innerHours,\n        `[${di}]`,\n        lt\n      );\n      return;\n    }\n    this._getAppendClock(\n      this.hoursArray,\n      `[${pe}]`,\n      K\n    );\n  }\n  _getConfig(t) {\n    const e = h.getDataAttributes(this._element);\n    return t = {\n      ...tg,\n      ...e,\n      ...t\n    }, D($i, t, eg), t;\n  }\n  _getClasses(t) {\n    const e = h.getDataClassAttributes(this._element);\n    return t = {\n      ...ig,\n      ...e,\n      ...t\n    }, D($i, t, sg), t;\n  }\n  _getContainer() {\n    return d.findOne(this._options.container);\n  }\n  _getValidate(t) {\n    const { format24: e, format12: i, appendValidationInfo: n } = this._options;\n    re.on(this.input, t, ({ target: o }) => {\n      if (this._options === null || this.input.value === \"\")\n        return;\n      const r = /^(0?[1-9]|1[012])(:[0-5]\\d) [APap][mM]$/, a = /^([01]\\d|2[0-3])(:[0-5]\\d)$/, l = r.test(o.value);\n      if (a.test(o.value) !== !0 && e || l !== !0 && i) {\n        n && this.input.setAttribute(Jn, \"\"), h.addStyle(o, { marginBottom: 0 }), this._isInvalidTimeFormat = !0;\n        return;\n      }\n      this.input.removeAttribute(Jn), this._isInvalidTimeFormat = !1;\n      const u = d.findOne(\n        `[${Zm}]`\n      );\n      u !== null && u.remove();\n    });\n  }\n  // Static\n  static getInstance(t) {\n    return y.getData(t, Us);\n  }\n  static getOrCreateInstance(t, e = {}) {\n    return this.getInstance(t) || new this(t, typeof e == \"object\" ? e : null);\n  }\n}\nconst og = {\n  threshold: 10,\n  direction: \"all\"\n};\nlet rg = class {\n  constructor(t, e) {\n    this._element = t, this._startPosition = null, this._options = {\n      ...og,\n      ...e\n    };\n  }\n  handleTouchStart(t) {\n    this._startPosition = this._getCoordinates(t);\n  }\n  handleTouchMove(t) {\n    if (!this._startPosition)\n      return;\n    const e = this._getCoordinates(t), i = {\n      x: e.x - this._startPosition.x,\n      y: e.y - this._startPosition.y\n    }, n = this._getDirection(i);\n    if (this._options.direction === \"all\") {\n      if (n.y.value < this._options.threshold && n.x.value < this._options.threshold)\n        return;\n      const r = n.y.value > n.x.value ? n.y.direction : n.x.direction;\n      c.trigger(this._element, `swipe${r}`), c.trigger(this._element, \"swipe\", { direction: r }), this._startPosition = null;\n      return;\n    }\n    const o = this._options.direction === \"left\" || this._options === \"right\" ? \"x\" : \"y\";\n    n[o].direction === this._options.direction && n[o].value > this._options.threshold && (c.trigger(this._element, `swipe${n[o].direction}`), this._startPosition = null);\n  }\n  handleTouchEnd() {\n    this._startPosition = null;\n  }\n  _getCoordinates(t) {\n    const [e] = t.touches;\n    return {\n      x: e.clientX,\n      y: e.clientY\n    };\n  }\n  _getDirection(t) {\n    return {\n      x: {\n        direction: t.x < 0 ? \"left\" : \"right\",\n        value: Math.abs(t.x)\n      },\n      y: {\n        direction: t.y < 0 ? \"up\" : \"down\",\n        value: Math.abs(t.y)\n      }\n    };\n  }\n}, ag = class {\n  constructor(t, e = \"swipe\", i = {}) {\n    this._element = t, this._event = e, this.swipe = new rg(t, i), this._touchStartHandler = this._handleTouchStart.bind(this), this._touchMoveHandler = this._handleTouchMove.bind(this), this._touchEndHandler = this._handleTouchEnd.bind(this);\n  }\n  dispose() {\n    this._element.removeEventListener(\"touchstart\", this._touchStartHandler), this._element.removeEventListener(\"touchmove\", this._touchMoveHandler), window.removeEventListener(\"touchend\", this._touchEndHandler);\n  }\n  init() {\n    this._element.addEventListener(\n      \"touchstart\",\n      (t) => this._handleTouchStart(t)\n    ), this._element.addEventListener(\n      \"touchmove\",\n      (t) => this._handleTouchMove(t)\n    ), window.addEventListener(\"touchend\", (t) => this._handleTouchEnd(t));\n  }\n  _handleTouchStart(t) {\n    this[this._event].handleTouchStart(t);\n  }\n  _handleTouchMove(t) {\n    this[this._event].handleTouchMove(t);\n  }\n  _handleTouchEnd(t) {\n    this[this._event].handleTouchEnd(t);\n  }\n};\nconst Qa = \"sidenav\", Ts = \"te.sidenav\", lg = \"data-te-sidenav-rotate-icon-ref\", no = \"[data-te-sidenav-toggle-ref]\", cg = \"[data-te-collapse-init]\", hg = '[data-te-sidenav-slim=\"true\"]', dg = '[data-te-sidenav-slim=\"false\"]', ug = \"[data-te-sidenav-menu-ref]\", Oe = \"[data-te-sidenav-collapse-ref]\", ui = \"[data-te-sidenav-link-ref]\", pg = F() ? 100 : -100, _g = F() ? -100 : 100, fg = {\n  sidenavAccordion: \"(boolean)\",\n  sidenavBackdrop: \"(boolean)\",\n  sidenavBackdropClass: \"(null|string)\",\n  sidenavCloseOnEsc: \"(boolean)\",\n  sidenavColor: \"(string)\",\n  sidenavContent: \"(null|string)\",\n  sidenavExpandable: \"(boolean)\",\n  sidenavExpandOnHover: \"(boolean)\",\n  sidenavFocusTrap: \"(boolean)\",\n  sidenavHidden: \"(boolean)\",\n  sidenavMode: \"(string)\",\n  sidenavModeBreakpointOver: \"(null|string|number)\",\n  sidenavModeBreakpointSide: \"(null|string|number)\",\n  sidenavModeBreakpointPush: \"(null|string|number)\",\n  sidenavBreakpointSm: \"(number)\",\n  sidenavBreakpointMd: \"(number)\",\n  sidenavBreakpointLg: \"(number)\",\n  sidenavBreakpointXl: \"(number)\",\n  sidenavBreakpoint2xl: \"(number)\",\n  sidenavScrollContainer: \"(null|string)\",\n  sidenavSlim: \"(boolean)\",\n  sidenavSlimCollapsed: \"(boolean)\",\n  sidenavSlimWidth: \"(number)\",\n  sidenavPosition: \"(string)\",\n  sidenavRight: \"(boolean)\",\n  sidenavTransitionDuration: \"(number)\",\n  sidenavWidth: \"(number)\"\n}, mg = {\n  sidenavAccordion: !1,\n  sidenavBackdrop: !0,\n  sidenavBackdropClass: null,\n  sidenavCloseOnEsc: !0,\n  sidenavColor: \"primary\",\n  sidenavContent: null,\n  sidenavExpandable: !0,\n  sidenavExpandOnHover: !1,\n  sidenavFocusTrap: !0,\n  sidenavHidden: !0,\n  sidenavMode: \"over\",\n  sidenavModeBreakpointOver: null,\n  sidenavModeBreakpointSide: null,\n  sidenavModeBreakpointPush: null,\n  sidenavBreakpointSm: 640,\n  sidenavBreakpointMd: 768,\n  sidenavBreakpointLg: 1024,\n  sidenavBreakpointXl: 1280,\n  sidenavBreakpoint2xl: 1536,\n  sidenavScrollContainer: null,\n  sidenavSlim: !1,\n  sidenavSlimCollapsed: !1,\n  sidenavSlimWidth: 77,\n  sidenavPosition: \"fixed\",\n  sidenavRight: !1,\n  sidenavTransitionDuration: 300,\n  sidenavWidth: 240\n};\nclass gi {\n  constructor(t, e = {}) {\n    yt(this, \"_addBackdropOnInit\", () => {\n      this._options.sidenavHidden || (this._backdrop.show(), c.off(this._element, \"transitionend\", this._addBackdropOnInit));\n    });\n    this._element = t, this._options = e, this._ID = rt(\"\"), this._content = null, this._initialContentStyle = null, this._slimCollapsed = !1, this._activeNode = null, this._tempSlim = !1, this._backdrop = this._initializeBackDrop(), this._focusTrap = null, this._perfectScrollbar = null, this._touch = null, this._setModeFromBreakpoints(), this.escHandler = (i) => {\n      i.keyCode === Fi && this.toggler && Nt(this.toggler) && (this._update(!1), c.off(window, \"keydown\", this.escHandler));\n    }, this.hashHandler = () => {\n      this._setActiveElements();\n    }, t && (y.setData(t, Ts, this), this._setup()), this.options.sidenavBackdrop && !this.options.sidenavHidden && this.options.sidenavMode === \"over\" && c.on(this._element, \"transitionend\", this._addBackdropOnInit), this._didInit = !1, this._init();\n  }\n  // Getters\n  static get NAME() {\n    return Qa;\n  }\n  get container() {\n    if (this.options.sidenavPosition === \"fixed\")\n      return d.findOne(\"body\");\n    const t = (e) => !e.parentNode || e.parentNode === document ? e : e.parentNode.style.position === \"relative\" || e.parentNode.classList.contains(\"relative\") ? e.parentNode : t(e.parentNode);\n    return t(this._element);\n  }\n  get isVisible() {\n    let t = 0, e = window.innerWidth;\n    if (this.options.sidenavPosition !== \"fixed\") {\n      const n = this.container.getBoundingClientRect();\n      t = n.x, e = n.x + n.width;\n    }\n    const { x: i } = this._element.getBoundingClientRect();\n    return this.options.sidenavRight ? Math.abs(i - e) > 10 : Math.abs(i - t) < 10;\n  }\n  get links() {\n    return d.find(ui, this._element);\n  }\n  get navigation() {\n    return d.find(ug, this._element);\n  }\n  get options() {\n    const t = {\n      ...mg,\n      ...h.getDataAttributes(this._element),\n      ...this._options\n    };\n    return D(Qa, t, fg), t;\n  }\n  get sidenavStyle() {\n    return {\n      width: `${this.width}px`,\n      height: this.options.sidenavPosition === \"fixed\" ? \"100vh\" : \"100%\",\n      position: this.options.sidenavPosition,\n      transition: `all ${this.transitionDuration} linear`\n    };\n  }\n  get toggler() {\n    return d.find(no).find(\n      (e) => {\n        const i = h.getDataAttribute(e, \"target\");\n        return d.findOne(i) === this._element;\n      }\n    );\n  }\n  get transitionDuration() {\n    return `${this.options.sidenavTransitionDuration / 1e3}s`;\n  }\n  get translation() {\n    return this.options.sidenavRight ? _g : pg;\n  }\n  get width() {\n    return this._slimCollapsed ? this.options.sidenavSlimWidth : this.options.sidenavWidth;\n  }\n  get isBackdropVisible() {\n    return !!this._backdrop._element;\n  }\n  // Public\n  changeMode(t) {\n    this._setMode(t);\n  }\n  dispose() {\n    c.off(window, \"keydown\", this.escHandler), this.options.sidenavBackdrop && this._backdrop.dispose(), c.off(window, \"hashchange\", this.hashHandler), this._touch.dispose(), y.removeData(this._element, Ts), this._element = null;\n  }\n  hide() {\n    this._emitEvents(!1), this._update(!1), this._options.sidenavBackdrop && this.isBackdropVisible && this._backdrop.hide();\n  }\n  show() {\n    this._emitEvents(!0), this._update(!0), this._options.sidenavBackdrop && this._options.sidenavMode === \"over\" && this._backdrop.show();\n  }\n  toggle() {\n    this._emitEvents(!this.isVisible), this._update(!this.isVisible);\n  }\n  toggleSlim() {\n    this._setSlim(!this._slimCollapsed);\n  }\n  update(t) {\n    this._options = t, this._setup();\n  }\n  getBreakpoint(t) {\n    return this._transformBreakpointValuesToObject()[t];\n  }\n  // Private\n  _init() {\n    this._didInit || (c.on(\n      document,\n      \"click\",\n      no,\n      gi.toggleSidenav()\n    ), this._didInit = !0);\n  }\n  _transformBreakpointValuesToObject() {\n    return {\n      sm: this.options.sidenavBreakpointSm,\n      md: this.options.sidenavBreakpointMd,\n      lg: this.options.sidenavBreakpointLg,\n      xl: this.options.sidenavBreakpointXl,\n      \"2xl\": this.options.sidenavBreakpoint2xl\n    };\n  }\n  _setModeFromBreakpoints() {\n    const t = window.innerWidth, e = this._transformBreakpointValuesToObject();\n    if (t === void 0 || !e)\n      return;\n    const i = typeof this.options.sidenavModeBreakpointOver == \"number\" ? t - this.options.sidenavModeBreakpointOver : t - e[this.options.sidenavModeBreakpointOver], n = typeof this.options.sidenavModeBreakpointSide == \"number\" ? t - this.options.sidenavModeBreakpointSide : t - e[this.options.sidenavModeBreakpointSide], o = typeof this.options.sidenavModeBreakpointPush == \"number\" ? t - this.options.sidenavModeBreakpointPush : t - e[this.options.sidenavModeBreakpointPush], r = (l, p) => l - p < 0 ? -1 : p - l < 0 ? 1 : 0, a = [i, n, o].filter((l) => l != null && l >= 0).sort(r)[0];\n    i > 0 && i === a ? (this._options.sidenavMode = \"over\", this._options.sidenavHidden = !0) : n > 0 && n === a ? this._options.sidenavMode = \"side\" : o > 0 && o === a && (this._options.sidenavMode = \"push\");\n  }\n  _collapseItems() {\n    this.navigation.forEach((t) => {\n      d.find(Oe, t).forEach((i) => {\n        Zt.getInstance(i).hide();\n      });\n    });\n  }\n  _getOffsetValue(t, { index: e, property: i, offsets: n }) {\n    const o = this._getPxValue(\n      this._initialContentStyle[e][n[i].property]\n    ), r = t ? n[i].value : 0;\n    return o + r;\n  }\n  _getProperty(...t) {\n    return t.map((e, i) => i === 0 ? e : e[0].toUpperCase().concat(e.slice(1))).join(\"\");\n  }\n  _getPxValue(t) {\n    return t ? parseFloat(t) : 0;\n  }\n  _handleSwipe(t, e) {\n    e && this._slimCollapsed && this.options.sidenavSlim && this.options.sidenavExpandable ? this.toggleSlim() : e || (this._slimCollapsed || !this.options.sidenavSlim || !this.options.sidenavExpandable ? this.toggler && Nt(this.toggler) && this.toggle() : this.toggleSlim());\n  }\n  _isActive(t, e) {\n    return e ? e === t : t.attributes.href ? new URL(t, window.location.href).href === window.location.href : !1;\n  }\n  _isAllToBeCollapsed() {\n    return d.find(\n      cg,\n      this._element\n    ).filter(\n      (i) => i.getAttribute(\"aria-expanded\") === \"true\"\n    ).length === 0;\n  }\n  _isAllCollapsed() {\n    return d.find(Oe, this._element).filter(\n      (t) => Nt(t)\n    ).length === 0;\n  }\n  _initializeBackDrop() {\n    if (!this.options.sidenavBackdrop)\n      return;\n    const t = this.options.sidenavBackdropClass ? this.options.sidenavBackdropClass.split(\" \") : this.options.sidenavPosition ? [\n      \"opacity-50\",\n      \"transition-all\",\n      \"duration-300\",\n      \"ease-in-out\",\n      this.options.sidenavPosition,\n      \"top-0\",\n      \"left-0\",\n      \"z-50\",\n      \"bg-black/10\",\n      \"dark:bg-black-60\",\n      \"w-full\",\n      \"h-full\",\n      this._element.id\n    ] : null;\n    return new hr({\n      isVisible: this.options.sidenavBackdrop,\n      isAnimated: !0,\n      rootElement: this._element.parentNode,\n      backdropClasses: t,\n      clickCallback: () => this.hide()\n    });\n  }\n  _updateBackdrop(t) {\n    if (this.options.sidenavMode === \"over\") {\n      t ? this._backdrop.show() : this.isBackdropVisible && this._backdrop.hide();\n      return;\n    }\n    this.isBackdropVisible && this._backdrop.hide();\n  }\n  _setup() {\n    this._setupTouch(), this.options.sidenavFocusTrap && this._setupFocusTrap(), this._setupCollapse(), this.options.sidenavSlim && this._setupSlim(), this._setupInitialStyling(), this._setupScrolling(), this.options.sidenavContent && this._setupContent(), this._setupActiveState(), this._setupRippleEffect(), this.options.sidenavHidden || this._updateOffsets(!0, !0), this.options.sidenavMode === \"over\" && this._setTabindex(!0);\n  }\n  _setupActiveState() {\n    this._setActiveElements(), this.links.forEach((t) => {\n      c.on(t, \"click\", () => this._setActiveElements(t)), c.on(t, \"keydown\", (e) => {\n        e.keyCode === ct && this._setActiveElements(t);\n      });\n    }), c.on(window, \"hashchange\", this.hashHandler);\n  }\n  _setupCollapse() {\n    this.navigation.forEach((t, e) => {\n      d.find(Oe, t).forEach(\n        (n, o) => this._setupCollapseList({ list: n, index: o, menu: t, menuIndex: e })\n      );\n    });\n  }\n  _generateCollpaseID(t, e) {\n    return `sidenav-collapse-${this._ID}-${e}-${t}`;\n  }\n  _setupCollapseList({ list: t, index: e, menu: i, menuIndex: n }) {\n    const o = this._generateCollpaseID(e, n);\n    t.setAttribute(\"id\", o), t.setAttribute(\"data-te-collapse-item\", \"\");\n    const [r] = d.prev(t, ui);\n    h.setDataAttribute(r, \"collapse-init\", \"\"), r.setAttribute(\"href\", `#${o}`), r.setAttribute(\"role\", \"button\");\n    const a = Zt.getInstance(t) || new Zt(t, {\n      toggle: !1,\n      parent: this.options.sidenavAccordion ? i : t\n    });\n    (t.dataset.teSidenavStateShow === \"\" || t.dataset.teCollapseShow === \"\") && this._rotateArrow(r, !1), c.on(r, \"click\", (l) => {\n      this._toggleCategory(l, a, t), this._tempSlim && this._isAllToBeCollapsed() && (this._setSlim(!0), this._tempSlim = !1), this.options.sidenavMode === \"over\" && this._focusTrap && this._focusTrap.update();\n    }), c.on(\n      t,\n      \"show.te.collapse\",\n      () => this._rotateArrow(r, !1)\n    ), c.on(\n      t,\n      \"hide.te.collapse\",\n      () => this._rotateArrow(r, !0)\n    ), c.on(t, \"shown.te.collapse\", () => {\n      this.options.sidenavMode === \"over\" && this._focusTrap && this._focusTrap.update();\n    }), c.on(t, \"hidden.te.collapse\", () => {\n      this._tempSlim && this._isAllCollapsed() && (this._setSlim(!0), this._tempSlim = !1), this.options.sidenavMode === \"over\" && this._focusTrap && this._focusTrap.update();\n    });\n  }\n  _setupContent() {\n    this._content = d.find(this.options.sidenavContent), this._content.forEach((t) => {\n      const e = [\n        \"!p\",\n        \"!m\",\n        \"!px\",\n        \"!pl\",\n        \"!pr\",\n        \"!mx\",\n        \"!ml\",\n        \"!mr\",\n        \"!-p\",\n        \"!-m\",\n        \"!-px\",\n        \"!-pl\",\n        \"!-pr\",\n        \"!-mx\",\n        \"!-ml\",\n        \"!-mr\"\n      ];\n      [...t.classList].filter(\n        (n) => e.findIndex((o) => n.includes(o)) >= 0\n      ).forEach((n) => t.classList.remove(n));\n    }), this._initialContentStyle = this._content.map((t) => {\n      const { paddingLeft: e, paddingRight: i, marginLeft: n, marginRight: o, transition: r } = window.getComputedStyle(t);\n      return { paddingLeft: e, paddingRight: i, marginLeft: n, marginRight: o, transition: r };\n    });\n  }\n  _setupFocusTrap() {\n    this._focusTrap = new Wi(\n      this._element,\n      {\n        event: \"keydown\",\n        condition: (t) => t.keyCode === Pi,\n        onlyVisible: !0\n      },\n      this.toggler\n    );\n  }\n  _setupInitialStyling() {\n    this._setColor(), h.style(this._element, this.sidenavStyle);\n  }\n  _setupScrolling() {\n    let t = this._element;\n    if (this.options.sidenavScrollContainer) {\n      t = d.findOne(\n        this.options.sidenavScrollContainer,\n        this._element\n      );\n      const i = Kh(t.parentNode.children).filter(\n        (n) => n !== t\n      ).reduce((n, o) => n + o.clientHeight, 0);\n      h.style(t, {\n        maxHeight: `calc(100% - ${i}px)`,\n        position: \"relative\"\n      });\n    }\n    this._perfectScrollbar = new mh(t, {\n      suppressScrollX: !0,\n      handlers: [\"click-rail\", \"drag-thumb\", \"wheel\", \"touch\"]\n    });\n  }\n  _setupSlim() {\n    this._slimCollapsed = this.options.sidenavSlimCollapsed, this._toggleSlimDisplay(this._slimCollapsed), this.options.sidenavExpandOnHover && (this._element.addEventListener(\"mouseenter\", () => {\n      this._slimCollapsed && this._setSlim(!1);\n    }), this._element.addEventListener(\"mouseleave\", () => {\n      this._slimCollapsed || this._setSlim(!0);\n    }));\n  }\n  _setupRippleEffect() {\n    this.links.forEach((t) => {\n      let e = Ze.getInstance(t), i = this.options.sidenavColor;\n      if (e && e._options.sidenavColor !== this.options.sidenavColor)\n        e.dispose();\n      else if (e)\n        return;\n      (localStorage.theme === \"dark\" || !(\"theme\" in localStorage) && window.matchMedia(\"(prefers-color-scheme: dark)\").matches) && (i = \"white\"), e = new Ze(t, { rippleColor: i });\n    });\n  }\n  _setupTouch() {\n    this._touch = new ag(this._element, \"swipe\", { threshold: 20 }), this._touch.init(), c.on(\n      this._element,\n      \"swipeleft\",\n      (t) => this._handleSwipe(t, this.options.sidenavRight)\n    ), c.on(\n      this._element,\n      \"swiperight\",\n      (t) => this._handleSwipe(t, !this.options.sidenavRight)\n    );\n  }\n  _setActive(t, e) {\n    t.setAttribute(\"data-te-sidebar-state-active\", \"\"), this._activeNode && t.removeAttribute(\"data-te-sidebar-state-active\"), this._activeNode = t;\n    const [i] = d.parents(\n      this._activeNode,\n      Oe\n    );\n    if (!i) {\n      this._setActiveCategory();\n      return;\n    }\n    const [n] = d.prev(i, ui);\n    this._setActiveCategory(n), !e && !this._slimCollapsed && Zt.getInstance(i).show();\n  }\n  _setActiveCategory(t) {\n    this.navigation.forEach((e) => {\n      d.find(Oe, e).forEach((n) => {\n        const [o] = d.prev(n, ui);\n        o !== t ? o.removeAttribute(\"data-te-sidenav-state-active\") : o.setAttribute(\"data-te-sidenav-state-active\", \"\");\n      });\n    });\n  }\n  _setActiveElements(t) {\n    this.navigation.forEach((e) => {\n      d.find(ui, e).filter((n) => d.next(n, Oe).length === 0).forEach((n) => {\n        this._isActive(n, t) && n !== this._activeNode && this._setActive(n, t);\n      });\n    }), t && this._updateFocus(this.isVisible);\n  }\n  _setColor() {\n    const t = [\n      \"primary\",\n      \"secondary\",\n      \"success\",\n      \"info\",\n      \"warning\",\n      \"danger\",\n      \"light\",\n      \"dark\"\n    ], { sidenavColor: e } = this.options, i = t.includes(e) ? e : \"primary\";\n    t.forEach((n) => {\n      this._element.classList.remove(`sidenav-${n}`);\n    }), h.addClass(this._element, `sidenav-${i}`);\n  }\n  _setContentOffsets(t, e, i) {\n    this._content.forEach((n, o) => {\n      const r = this._getOffsetValue(t, {\n        index: o,\n        property: \"padding\",\n        offsets: e\n      }), a = this._getOffsetValue(t, {\n        index: o,\n        property: \"margin\",\n        offsets: e\n      }), l = {};\n      if (i || (l.transition = `all ${this.transitionDuration} linear`), l[e.padding.property] = `${r}px`, l[e.margin.property] = `${a}px`, h.style(n, l), !!t) {\n        if (i) {\n          h.style(n, {\n            transition: this._initialContentStyle[o].transition\n          });\n          return;\n        }\n        c.on(n, \"transitionend\", () => {\n          h.style(n, {\n            transition: this._initialContentStyle[o].transition\n          });\n        });\n      }\n    });\n  }\n  _setMode(t) {\n    this.options.sidenavMode !== t && (this._options.sidenavMode = t, this._update(this.isVisible));\n  }\n  _setSlim(t) {\n    const e = t ? [\"collapse\", \"collapsed\"] : [\"expand\", \"expanded\"];\n    this._triggerEvents(...e), t && this._collapseItems(), this._slimCollapsed = t, this._toggleSlimDisplay(t), h.style(this._element, { width: `${this.width}px` }), this._updateOffsets(this.isVisible);\n  }\n  _setTabindex(t) {\n    this.links.forEach((e) => {\n      e.tabIndex = t ? 0 : -1;\n    });\n  }\n  _emitEvents(t) {\n    const e = t ? [\"show\", \"shown\"] : [\"hide\", \"hidden\"];\n    this._triggerEvents(...e);\n  }\n  _rotateArrow(t, e) {\n    const [i] = d.children(t, `[${lg}]`);\n    i && (e ? h.removeClass(i, \"rotate-180\") : h.addClass(i, \"rotate-180\"));\n  }\n  _toggleCategory(t, e) {\n    t.preventDefault(), e.toggle(), this._slimCollapsed && this.options.sidenavExpandable && (this._tempSlim = !0, this._setSlim(!1));\n  }\n  _toggleSlimDisplay(t) {\n    const e = d.find(\n      hg,\n      this._element\n    ), i = d.find(\n      dg,\n      this._element\n    ), n = () => {\n      e.forEach((o) => {\n        h.style(o, {\n          display: this._slimCollapsed ? \"unset\" : \"none\"\n        });\n      }), i.forEach((o) => {\n        h.style(o, {\n          display: this._slimCollapsed ? \"none\" : \"unset\"\n        });\n      });\n    };\n    t ? setTimeout(\n      () => n(),\n      this.options.sidenavTransitionDuration\n    ) : n();\n  }\n  async _triggerEvents(t, e) {\n    c.trigger(this._element, `${t}.te.sidenav`), e && await setTimeout(() => {\n      c.trigger(this._element, `${e}.te.sidenav`);\n    }, this.options.sidenavTransitionDuration + 5);\n  }\n  _isiPhone() {\n    return /iPhone|iPod/i.test(navigator.userAgent);\n  }\n  _update(t) {\n    t && this._isiPhone() && h.addClass(this._element, \"ps--scrolling-y\"), this.toggler && this._updateTogglerAria(t), this._updateDisplay(t), this.options.sidenavBackdrop && this._updateBackdrop(t), this._updateOffsets(t), t && this.options.sidenavCloseOnEsc && this.options.sidenavMode !== \"side\" && c.on(window, \"keydown\", this.escHandler), this.options.sidenavFocusTrap && this._updateFocus(t);\n  }\n  _updateDisplay(t) {\n    const e = t ? 0 : this.translation;\n    h.style(this._element, {\n      transform: `translateX(${e}%)`\n    });\n  }\n  _updateFocus(t) {\n    if (this._setTabindex(t), this.options.sidenavMode === \"over\" && this.options.sidenavFocusTrap) {\n      if (t) {\n        this._focusTrap.trap();\n        return;\n      }\n      this._focusTrap.disable();\n    }\n    this._focusTrap.disable();\n  }\n  _updateOffsets(t, e = !1) {\n    const [i, n] = this.options.sidenavRight ? [\"right\", \"left\"] : [\"left\", \"right\"], o = {\n      property: this._getProperty(\"padding\", i),\n      value: this.options.sidenavMode === \"over\" ? 0 : this.width\n    }, r = {\n      property: this._getProperty(\"margin\", n),\n      value: this.options.sidenavMode === \"push\" ? -1 * this.width : 0\n    };\n    c.trigger(this._element, \"update.te.sidenav\", {\n      margin: r,\n      padding: o\n    }), this._content && (this._content.className = \"\", this._setContentOffsets(t, { padding: o, margin: r }, e));\n  }\n  _updateTogglerAria(t) {\n    this.toggler.setAttribute(\"aria-expanded\", t);\n  }\n  // Static\n  static toggleSidenav() {\n    return function(t) {\n      const e = d.closest(t.target, no), i = h.getDataAttributes(e).target;\n      d.find(i).forEach((n) => {\n        (gi.getInstance(n) || new gi(n)).toggle();\n      });\n    };\n  }\n  static jQueryInterface(t, e) {\n    return this.each(function() {\n      let i = y.getData(this, Ts);\n      const n = typeof t == \"object\" && t;\n      if (!(!i && /dispose/.test(t)) && (i || (i = new gi(this, n)), typeof t == \"string\")) {\n        if (typeof i[t] > \"u\")\n          throw new TypeError(`No method named \"${t}\"`);\n        i[t](e);\n      }\n    });\n  }\n  static getInstance(t) {\n    return y.getData(t, Ts);\n  }\n  static getOrCreateInstance(t, e = {}) {\n    return this.getInstance(t) || new this(t, typeof e == \"object\" ? e : null);\n  }\n}\nconst Ho = \"stepper\", Xs = \"te.stepper\", pn = `.${Xs}`, Yi = `data-te-${Ho}`, bi = \"horizontal\", xt = \"vertical\", gg = {\n  stepperType: \"string\",\n  stepperLinear: \"boolean\",\n  stepperNoEditable: \"boolean\",\n  stepperActive: \"string\",\n  stepperCompleted: \"string\",\n  stepperInvalid: \"string\",\n  stepperDisabled: \"string\",\n  stepperVerticalBreakpoint: \"number\",\n  stepperMobileBreakpoint: \"number\",\n  stepperMobileBarBreakpoint: \"number\"\n}, bg = {\n  stepperType: bi,\n  stepperLinear: !1,\n  stepperNoEditable: !1,\n  stepperActive: \"\",\n  stepperCompleted: \"\",\n  stepperInvalid: \"\",\n  stepperDisabled: \"\",\n  stepperVerticalBreakpoint: 0,\n  stepperMobileBreakpoint: 0,\n  stepperMobileBarBreakpoint: 4\n}, Ja = `mousedown${pn}`, tl = `keydown${pn}`, vg = `keyup${pn}`, el = `resize${pn}`, jt = `[${Yi}-step-ref]`, G = `[${Yi}-head-ref]`, il = `[${Yi}-head-text-ref]`, Es = `[${Yi}-head-icon-ref]`, st = `[${Yi}-content-ref]`;\nclass XC {\n  constructor(t, e) {\n    this._element = t, this._options = this._getConfig(e), this._elementHeight = 0, this._steps = d.find(`${jt}`, this._element), this._currentView = \"\", this._activeStepIndex = 0, this._verticalStepperStyles = [], this._element && (y.setData(t, Xs, this), this._init());\n  }\n  // Getters\n  static get NAME() {\n    return Ho;\n  }\n  get activeStep() {\n    return this._steps[this._activeStepIndex];\n  }\n  get activeStepIndex() {\n    return this._activeStepIndex;\n  }\n  // Public\n  dispose() {\n    this._steps.forEach((t) => {\n      c.off(t, Ja), c.off(t, tl);\n    }), c.off(window, el), y.removeData(this._element, Xs), this._element = null;\n  }\n  changeStep(t) {\n    this._toggleStep(t);\n  }\n  nextStep() {\n    this._toggleStep(this._activeStepIndex + 1);\n  }\n  previousStep() {\n    this._toggleStep(this._activeStepIndex - 1);\n  }\n  // Private\n  _init() {\n    const t = d.find(`${jt}`, this._element)[this._activeStepIndex].setAttribute(\"data-te\", \"active-step\"), e = d.find(\n      `${il}`,\n      this._element\n    ), i = d.find(\n      `${Es}`,\n      this._element\n    );\n    switch (t ? (this._activeStepIndex = this._steps.indexOf(t), this._toggleStepClass(\n      this._activeStepIndex,\n      \"add\",\n      this._options.stepperActive\n    ), e[this._activeStepIndex].classList.add(\"font-medium\"), i[this._activeStepIndex].classList.add(\"!bg-primary-100\"), i[this._activeStepIndex].classList.add(\"!text-primary-700\")) : (e[this._activeStepIndex].classList.add(\"font-medium\"), i[this._activeStepIndex].classList.add(\"!bg-primary-100\"), i[this._activeStepIndex].classList.add(\"!text-primary-700\"), this._toggleStepClass(\n      this._activeStepIndex,\n      \"add\",\n      this._options.stepperActive\n    )), this._bindMouseDown(), this._bindKeysNavigation(), this._options.stepperType) {\n      case xt:\n        this._toggleVertical();\n        break;\n      default:\n        this._toggleHorizontal();\n        break;\n    }\n    (this._options.stepperVerticalBreakpoint || this._options.stepperMobileBreakpoint) && this._toggleStepperView(), this._bindResize();\n  }\n  _getConfig(t) {\n    const e = h.getDataAttributes(this._element);\n    return t = {\n      ...bg,\n      ...e,\n      ...t\n    }, D(Ho, t, gg), t;\n  }\n  _bindMouseDown() {\n    this._steps.forEach((t) => {\n      const e = d.findOne(`${G}`, t);\n      c.on(e, Ja, (i) => {\n        const n = d.parents(i.target, `${jt}`)[0], o = this._steps.indexOf(n);\n        i.preventDefault(), this._toggleStep(o);\n      });\n    });\n  }\n  _bindResize() {\n    c.on(window, el, () => {\n      this._currentView === xt && this._setSingleStepHeight(this.activeStep), this._currentView === bi && this._setHeight(this.activeStep), (this._options.stepperVerticalBreakpoint || this._options.stepperMobileBreakpoint) && this._toggleStepperView();\n    });\n  }\n  _toggleStepperView() {\n    const t = this._options.stepperVerticalBreakpoint < window.innerWidth, e = this._options.stepperVerticalBreakpoint > window.innerWidth, i = this._options.stepperMobileBreakpoint > window.innerWidth;\n    t && this._currentView !== bi && this._toggleHorizontal(), e && !i && this._currentView !== xt && (this._steps.forEach((n) => {\n      const o = d.findOne(`${st}`, n);\n      this._resetStepperHeight(), this._showElement(o);\n    }), this._toggleVertical());\n  }\n  _toggleStep(t) {\n    this._activeStepIndex !== t && (this._options.stepperNoEditable && this._toggleDisabled(), this._showElement(\n      d.findOne(`${st}`, this._steps[t])\n    ), this._toggleActive(t), t > this._activeStepIndex && this._toggleCompleted(this._activeStepIndex), this._currentView === bi ? this._animateHorizontalStep(t) : (this._animateVerticalStep(t), this._setSingleStepHeight(this._steps[t])), this._toggleStepTabIndex(\n      d.findOne(`${G}`, this.activeStep),\n      d.findOne(`${G}`, this._steps[t])\n    ), this._activeStepIndex = t, this._steps[this._activeStepIndex].setAttribute(\"data-te\", \"active-step\"), this._steps.forEach((e, i) => {\n      e[this._activeStepIndex] !== i && e.removeAttribute(\"data-te\");\n    }));\n  }\n  _resetStepperHeight() {\n    this._element.style.height = \"\";\n  }\n  _setStepsHeight() {\n    this._steps.forEach((t) => {\n      const e = d.findOne(`${st}`, t), i = window.getComputedStyle(e);\n      this._verticalStepperStyles.push({\n        paddingTop: parseFloat(i.paddingTop),\n        paddingBottom: parseFloat(i.paddingBottom)\n      });\n      const n = e.scrollHeight;\n      e.style.height = `${n}px`;\n    });\n  }\n  _setSingleStepHeight(t) {\n    const e = d.findOne(`${st}`, t), i = this.activeStep === t, n = this._steps.indexOf(t);\n    let o;\n    i ? (e.style.height = \"\", o = e.scrollHeight) : o = e.scrollHeight + this._verticalStepperStyles[n].paddingTop + this._verticalStepperStyles[n].paddingBottom, e.style.height = `${o}px`;\n  }\n  _toggleVertical() {\n    this._currentView = xt, this._setStepsHeight(), this._hideInactiveSteps();\n  }\n  _toggleHorizontal() {\n    this._currentView = bi, this._setHeight(this.activeStep), this._hideInactiveSteps();\n  }\n  _toggleStepperClass() {\n    d.findOne(\n      \"[data-te-stepper-type]\",\n      this._element\n    ) !== null && this._steps.forEach((e) => {\n      d.findOne(`${st}`, e).classList.remove(\"!my-0\"), d.findOne(`${st}`, e).classList.remove(\"!py-0\"), d.findOne(`${st}`, e).classList.remove(\"!h-0\");\n    });\n  }\n  _toggleStepClass(t, e, i) {\n    i && this._steps[t].classList[e](i);\n  }\n  _bindKeysNavigation() {\n    this._toggleStepTabIndex(\n      !1,\n      d.findOne(`${G}`, this.activeStep)\n    ), this._steps.forEach((t) => {\n      const e = d.findOne(`${G}`, t);\n      c.on(e, tl, (i) => {\n        const n = d.parents(\n          i.currentTarget,\n          `${jt}`\n        )[0], o = d.next(n, `${jt}`)[0], r = d.prev(n, `${jt}`)[0], a = d.findOne(\n          `${G}`,\n          n\n        ), l = d.findOne(\n          `${G}`,\n          this.activeStep\n        );\n        let p = null, u = null;\n        if (o && (p = d.findOne(`${G}`, o)), r && (u = d.findOne(`${G}`, r)), i.keyCode === He && this._currentView !== xt && (u ? (this._toggleStepTabIndex(a, u), this._toggleOutlineStyles(a, u), u.focus()) : p && (this._toggleStepTabIndex(a, p), this._toggleOutlineStyles(a, p), p.focus())), i.keyCode === Ve && this._currentView !== xt && (p ? (this._toggleStepTabIndex(a, p), this._toggleOutlineStyles(a, p), p.focus()) : u && (this._toggleStepTabIndex(a, u), this._toggleOutlineStyles(a, u), u.focus())), i.keyCode === z && this._currentView === xt && (i.preventDefault(), p && (this._toggleStepTabIndex(a, p), this._toggleOutlineStyles(a, p), p.focus())), i.keyCode === at && this._currentView === xt && (i.preventDefault(), u && (this._toggleStepTabIndex(a, u), this._toggleOutlineStyles(a, u), u.focus())), i.keyCode === We) {\n          const _ = d.findOne(\n            `${G}`,\n            this._steps[0]\n          );\n          this._toggleStepTabIndex(a, _), this._toggleOutlineStyles(a, _), _.focus();\n        }\n        if (i.keyCode === Fe) {\n          const _ = this._steps[this._steps.length - 1], f = d.findOne(`${G}`, _);\n          this._toggleStepTabIndex(a, f), this._toggleOutlineStyles(a, f), f.focus();\n        }\n        (i.keyCode === ct || i.keyCode === Ks) && (i.preventDefault(), this.changeStep(this._steps.indexOf(n))), i.keyCode === Pi && (this._toggleStepTabIndex(a, l), this._toggleOutlineStyles(a, !1), l.focus());\n      }), c.on(e, vg, (i) => {\n        const n = d.parents(\n          i.currentTarget,\n          `${jt}`\n        )[0], o = d.findOne(\n          `${G}`,\n          n\n        ), r = d.findOne(\n          `${G}`,\n          this.activeStep\n        );\n        i.keyCode === Pi && (this._toggleStepTabIndex(o, r), this._toggleOutlineStyles(!1, r), r.focus());\n      });\n    });\n  }\n  _toggleStepTabIndex(t, e) {\n    t && t.setAttribute(\"tabIndex\", -1), e && e.setAttribute(\"tabIndex\", 0);\n  }\n  _toggleOutlineStyles(t, e) {\n    t && (t.style.outline = \"\"), e && (e.style.outline = \"revert\");\n  }\n  _toggleDisabled() {\n    const t = d.find(`${G}`, this._element), e = d.find(\n      `${Es}`,\n      this._element\n    );\n    t[this._activeStepIndex].classList.add(\"color-[#858585]\"), t[this._activeStepIndex].classList.add(\"cursor-default\"), e[this._activeStepIndex].classList.add(\"!bg-[#858585]\"), this._toggleStepClass(\n      this._activeStepIndex,\n      \"add\",\n      this._options.stepperDisabled\n    );\n  }\n  _toggleActive(t) {\n    const e = d.find(\n      `${il}`,\n      this._element\n    ), i = d.find(\n      `${Es}`,\n      this._element\n    );\n    e[t].classList.add(\"font-medium\"), i[t].classList.add(\"!bg-primary-100\"), i[t].classList.add(\"!text-primary-700\"), i[t].classList.remove(\"!bg-success-100\"), i[t].classList.remove(\"!text-success-700\"), e[this._activeStepIndex].classList.remove(\"font-medium\"), i[this._activeStepIndex].classList.remove(\"!bg-primary-100\"), i[this._activeStepIndex].classList.remove(\n      \"!text-primary-700\"\n    ), this._toggleStepClass(t, \"add\", this._options.stepperActive), this._toggleStepClass(\n      this._activeStepIndex,\n      \"remove\",\n      this._options.stepperActive\n    );\n  }\n  _toggleCompleted(t) {\n    const e = d.find(\n      `${Es}`,\n      this._element\n    );\n    e[t].classList.add(\"!bg-success-100\"), e[t].classList.add(\"!text-success-700\"), e[t].classList.remove(\"!bg-danger-100\"), e[t].classList.remove(\"!text-danger-700\"), this._toggleStepClass(t, \"add\", this._options.stepperCompleted), this._toggleStepClass(t, \"remove\", this._options.stepperInvalid);\n  }\n  _hideInactiveSteps() {\n    this._steps.forEach((t) => {\n      t.getAttribute(\"data-te\") || this._hideElement(d.findOne(`${st}`, t));\n    });\n  }\n  _setHeight(t) {\n    const e = d.findOne(`${st}`, t), i = getComputedStyle(e), n = d.findOne(`${G}`, t), o = getComputedStyle(n), r = e.offsetHeight + parseFloat(i.marginTop) + parseFloat(i.marginBottom), a = n.offsetHeight + parseFloat(o.marginTop) + parseFloat(o.marginBottom);\n    this._element.style.height = `${a + r}px`;\n  }\n  _hideElement(t) {\n    !d.parents(\n      t,\n      `${jt}`\n    )[0].getAttribute(\"data-te\") && this._currentView !== xt || (t.classList.add(\"!my-0\"), t.classList.add(\"!py-0\"), t.classList.add(\"!h-0\"));\n  }\n  _showElement(t) {\n    this._currentView === xt ? (t.classList.remove(\"!my-0\"), t.classList.remove(\"!py-0\"), t.classList.remove(\"!h-0\")) : t.style.display = \"block\";\n  }\n  _animateHorizontalStep(t) {\n    const e = t > this._activeStepIndex, i = d.findOne(\n      `${st}`,\n      this._steps[t]\n    ), n = d.findOne(\n      `${st}`,\n      this.activeStep\n    );\n    let o, r;\n    this._steps.forEach((u, _) => {\n      const f = d.findOne(`${st}`, u);\n      _ !== t && _ !== this._activeStepIndex && this._hideElement(f);\n    });\n    const a = \"translate-x-[150%]\", l = \"-translate-x-[150%]\", p = \"translate-0\";\n    e ? (r = l, o = p, i.classList.remove(\"translate-x-[150%]\"), i.classList.remove(\"-translate-x-[150%]\")) : (r = a, o = p, i.classList.remove(\"-translate-x-[150%]\"), i.classList.remove(\"translate-x-[150%]\")), n.classList.add(r), i.classList.add(o), this._setHeight(this._steps[t]);\n  }\n  _animateVerticalStep(t) {\n    const e = d.findOne(\n      `${st}`,\n      this._steps[t]\n    ), i = d.findOne(\n      `${st}`,\n      this.activeStep\n    );\n    this._hideElement(i), this._showElement(e);\n  }\n  static getInstance(t) {\n    return y.getData(t, Xs);\n  }\n  static getOrCreateInstance(t, e = {}) {\n    return this.getInstance(t) || new this(t, typeof e == \"object\" ? e : null);\n  }\n}\nconst sl = \"data-te-input-state-active\", Cs = \"data-te-input-selected\", nl = \"data-te-input-multiple-active\", ol = \"[data-te-form-check-input]\";\nclass rl {\n  constructor(t, e, i, n, o, r, a, l, p, u, _) {\n    this.id = t, this.nativeOption = e, this.multiple = i, this.value = n, this.label = o, this.selected = r, this.disabled = a, this.hidden = l, this.secondaryText = p, this.groupId = u, this.icon = _, this.node = null, this.active = !1;\n  }\n  select() {\n    this.multiple ? this._selectMultiple() : this._selectSingle();\n  }\n  _selectSingle() {\n    this.selected || (this.node.setAttribute(Cs, \"\"), this.node.setAttribute(\"aria-selected\", !0), this.selected = !0, this.nativeOption && (this.nativeOption.selected = !0));\n  }\n  _selectMultiple() {\n    if (!this.selected) {\n      const t = d.findOne(\n        ol,\n        this.node\n      );\n      t.checked = !0, this.node.setAttribute(Cs, \"\"), this.node.setAttribute(\"aria-selected\", !0), this.selected = !0, this.nativeOption && (this.nativeOption.selected = !0);\n    }\n  }\n  deselect() {\n    this.multiple ? this._deselectMultiple() : this._deselectSingle();\n  }\n  _deselectSingle() {\n    this.selected && (this.node.removeAttribute(Cs), this.node.setAttribute(\"aria-selected\", !1), this.selected = !1, this.nativeOption && (this.nativeOption.selected = !1));\n  }\n  _deselectMultiple() {\n    if (this.selected) {\n      const t = d.findOne(\n        ol,\n        this.node\n      );\n      t.checked = !1, this.node.removeAttribute(Cs), this.node.setAttribute(\"aria-selected\", !1), this.selected = !1, this.nativeOption && (this.nativeOption.selected = !1);\n    }\n  }\n  setNode(t) {\n    this.node = t;\n  }\n  setActiveStyles() {\n    if (!this.active) {\n      if (this.multiple) {\n        this.node.setAttribute(nl, \"\");\n        return;\n      }\n      this.active = !0, this.node.setAttribute(sl, \"\");\n    }\n  }\n  removeActiveStyles() {\n    this.active && (this.active = !1, this.node.removeAttribute(sl)), this.multiple && this.node.removeAttribute(nl);\n  }\n}\nclass Tg {\n  constructor(t = !1) {\n    this._multiple = t, this._selections = [];\n  }\n  select(t) {\n    this._multiple ? this._selections.push(t) : this._selections = [t];\n  }\n  deselect(t) {\n    if (this._multiple) {\n      const e = this._selections.findIndex(\n        (i) => t === i\n      );\n      this._selections.splice(e, 1);\n    } else\n      this._selections = [];\n  }\n  clear() {\n    this._selections = [];\n  }\n  get selection() {\n    return this._selections[0];\n  }\n  get selections() {\n    return this._selections;\n  }\n  get label() {\n    return this._selections[0] && this.selection.label;\n  }\n  get labels() {\n    return this._selections.map((t) => t.label).join(\", \");\n  }\n  get value() {\n    return this.selections[0] && this.selection.value;\n  }\n  get values() {\n    return this._selections.map((t) => t.value);\n  }\n}\nfunction Vo(s) {\n  return s.filter((t) => !t.disabled).every((t) => t.selected);\n}\nconst Eg = \"data-te-select-form-outline-ref\", Cg = \"data-te-select-wrapper-ref\", Ag = \"data-te-select-input-ref\", yg = \"data-te-select-clear-btn-ref\", wg = \"data-te-select-dropdown-container-ref\", kg = \"data-te-select-dropdown-ref\", xg = \"data-te-select-options-wrapper-ref\", Og = \"data-te-select-options-list-ref\", Sg = \"data-te-select-input-filter-ref\", Jc = \"data-te-select-option-ref\", Ig = \"data-te-select-option-all-ref\", Dg = \"data-te-select-option-text-ref\", $g = \"data-te-form-check-input\", Lg = \"data-te-select-option-group-ref\", Ng = \"data-te-select-option-group-label-ref\", th = \"data-te-select-selected\", Mg = `\n<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"1.5\" stroke=\"currentColor\">\n  <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M19.5 8.25l-7.5 7.5-7.5-7.5\" />\n</svg>\n`, Rg = (s) => {\n  s.code === \"Tab\" || s.code === \"Esc\" || s.preventDefault();\n};\nfunction As(s, t, e, i, n) {\n  t.selectSize === \"default\" && h.addClass(s, e), t.selectSize === \"sm\" && h.addClass(s, i), t.selectSize === \"lg\" && h.addClass(s, n);\n}\nfunction Pg(s, t, e, i, n) {\n  const o = document.createElement(\"div\");\n  o.setAttribute(\"id\", s), o.setAttribute(Cg, \"\");\n  const r = $(\"div\");\n  r.setAttribute(Eg, \"\"), h.addClass(r, i.formOutline);\n  const a = $(\"input\"), l = t.selectFilter ? \"combobox\" : \"listbox\", p = t.multiple ? \"true\" : \"false\", u = t.disabled ? \"true\" : \"false\";\n  a.setAttribute(Ag, \"\"), h.addClass(a, i.selectInput), As(\n    a,\n    t,\n    i.selectInputSizeDefault,\n    i.selectInputSizeSm,\n    i.selectInputSizeLg\n  ), t.selectFormWhite && h.addClass(a, i.selectInputWhite), a.setAttribute(\"type\", \"text\"), a.setAttribute(\"role\", l), a.setAttribute(\"aria-multiselectable\", p), a.setAttribute(\"aria-disabled\", u), a.setAttribute(\"aria-haspopup\", \"true\"), a.setAttribute(\"aria-expanded\", !1), a.name = n, t.tabIndex && a.setAttribute(\"tabIndex\", t.tabIndex), t.disabled && a.setAttribute(\"disabled\", \"\"), t.selectPlaceholder !== \"\" && a.setAttribute(\"placeholder\", t.selectPlaceholder), t.selectValidation ? (h.addStyle(a, {\n    \"pointer-events\": \"none\",\n    \"caret-color\": \"transparent\"\n  }), h.addStyle(r, { cursor: \"pointer\" })) : a.setAttribute(\"readonly\", \"true\"), t.selectValidation && (a.setAttribute(\"required\", \"true\"), a.setAttribute(\"aria-required\", \"true\"), a.addEventListener(\"keydown\", Rg));\n  const _ = $(\"div\");\n  h.addClass(_, i.selectValidationValid);\n  const f = document.createTextNode(\n    `${t.selectValidFeedback}`\n  );\n  _.appendChild(f);\n  const g = $(\"div\");\n  h.addClass(g, i.selectValidationInvalid);\n  const m = document.createTextNode(\n    `${t.selectInvalidFeedback}`\n  );\n  g.appendChild(m);\n  const b = $(\"span\");\n  b.setAttribute(yg, \"\"), h.addClass(b, i.selectClearBtn), As(\n    b,\n    t,\n    i.selectClearBtnDefault,\n    i.selectClearBtnSm,\n    i.selectClearBtnLg\n  ), t.selectFormWhite && h.addClass(b, i.selectClearBtnWhite);\n  const v = document.createTextNode(\"â\");\n  b.appendChild(v), b.setAttribute(\"tabindex\", \"0\");\n  const C = $(\"span\");\n  return h.addClass(C, i.selectArrow), As(\n    C,\n    t,\n    i.selectArrowDefault,\n    i.selectArrowSm,\n    i.selectArrowLg\n  ), t.selectFormWhite && h.addClass(C, i.selectArrowWhite), C.innerHTML = Mg, r.appendChild(a), e && (h.addClass(e, i.selectLabel), As(\n    e,\n    t,\n    i.selectLabelSizeDefault,\n    i.selectLabelSizeSm,\n    i.selectLabelSizeLg\n  ), t.selectFormWhite && h.addClass(e, i.selectLabelWhite), r.appendChild(e)), t.selectValidation && (r.appendChild(_), r.appendChild(g)), t.selectClearButton && r.appendChild(b), r.appendChild(C), o.appendChild(r), o;\n}\nfunction al(s, t, e, i, n, o, r, a) {\n  const l = document.createElement(\"div\");\n  l.setAttribute(wg, \"\"), h.addClass(l, a.selectDropdownContainer), l.setAttribute(\"id\", `${s}`), l.style.width = `${e}px`;\n  const p = document.createElement(\"div\");\n  p.setAttribute(\"tabindex\", 0), p.setAttribute(kg, \"\"), h.addClass(p, a.dropdown);\n  const u = $(\"div\");\n  u.setAttribute(xg, \"\"), h.addClass(u, a.optionsWrapper), h.addClass(u, a.optionsWrapperScrollbar), u.style.maxHeight = `${i}px`;\n  const _ = eh(\n    o,\n    n,\n    t,\n    a\n  );\n  return u.appendChild(_), t.selectFilter && p.appendChild(\n    Bg(t.selectSearchPlaceholder, a)\n  ), p.appendChild(u), r && p.appendChild(r), l.appendChild(p), l;\n}\nfunction eh(s, t, e, i) {\n  const n = $(\"div\");\n  n.setAttribute(Og, \"\"), h.addClass(n, i.optionsList);\n  let o;\n  return e.multiple ? o = Vg(\n    s,\n    t,\n    e,\n    i\n  ) : o = Hg(s, e, i), o.forEach((r) => {\n    n.appendChild(r);\n  }), n;\n}\nfunction Bg(s, t) {\n  const e = $(\"div\");\n  h.addClass(e, t.inputGroup);\n  const i = $(\"input\");\n  return i.setAttribute(Sg, \"\"), h.addClass(i, t.selectFilterInput), i.placeholder = s, i.setAttribute(\"role\", \"searchbox\"), i.setAttribute(\"type\", \"text\"), e.appendChild(i), e;\n}\nfunction Hg(s, t, e) {\n  return ih(s, t, e);\n}\nfunction Vg(s, t, e, i) {\n  let n = null;\n  e.selectAll && (n = Wg(\n    t,\n    s,\n    e,\n    i\n  ));\n  const o = ih(s, e, i);\n  return n ? [n, ...o] : o;\n}\nfunction ih(s, t, e) {\n  const i = [];\n  return s.forEach((n) => {\n    if (Object.prototype.hasOwnProperty.call(\n      n,\n      \"options\"\n    )) {\n      const r = Kg(n, t, e);\n      i.push(r);\n    } else\n      i.push(sh(n, t, e));\n  }), i;\n}\nfunction Wg(s, t, e, i) {\n  const n = Vo(t), o = $(\"div\");\n  return o.setAttribute(Jc, \"\"), h.addClass(o, i.selectOption), o.setAttribute(Ig, \"\"), h.addStyle(o, {\n    height: `${e.selectOptionHeight}px`\n  }), o.setAttribute(\"role\", \"option\"), o.setAttribute(\"aria-selected\", n), n && o.setAttribute(th, \"\"), o.appendChild(nh(s, e, i)), s.setNode(o), o;\n}\nfunction sh(s, t, e) {\n  if (s.node)\n    return s.node;\n  const i = $(\"div\");\n  return i.setAttribute(Jc, \"\"), h.addClass(i, e.selectOption), h.addStyle(i, {\n    height: `${t.selectOptionHeight}px`\n  }), h.setDataAttribute(i, \"id\", s.id), i.setAttribute(\"role\", \"option\"), i.setAttribute(\"aria-selected\", s.selected), i.setAttribute(\"aria-disabled\", s.disabled), s.selected && i.setAttribute(th, \"\"), s.disabled && i.setAttribute(\"data-te-select-option-disabled\", !0), s.hidden && h.addClass(i, \"hidden\"), i.appendChild(nh(s, t, e)), s.icon && i.appendChild(jg(s, e)), s.setNode(i), i;\n}\nfunction nh(s, t, e) {\n  const i = $(\"span\");\n  i.setAttribute(Dg, \"\"), h.addClass(i, e.selectOptionText);\n  const n = document.createTextNode(s.label);\n  return t.multiple && i.appendChild(Yg(s, e)), i.appendChild(n), (s.secondaryText || typeof s.secondaryText == \"number\") && i.appendChild(\n    Fg(s.secondaryText, e)\n  ), i;\n}\nfunction Fg(s, t) {\n  const e = $(\"span\");\n  h.addClass(e, t.selectOptionSecondaryText);\n  const i = document.createTextNode(s);\n  return e.appendChild(i), e;\n}\nfunction Yg(s, t) {\n  const e = $(\"input\");\n  e.setAttribute(\"type\", \"checkbox\"), h.addClass(e, t.formCheckInput), e.setAttribute($g, \"\");\n  const i = $(\"label\");\n  return s.selected && e.setAttribute(\"checked\", !0), s.disabled && e.setAttribute(\"disabled\", !0), e.appendChild(i), e;\n}\nfunction jg(s, t) {\n  const e = $(\"span\"), i = $(\"img\");\n  return h.addClass(i, t.selectOptionIcon), i.src = s.icon, e.appendChild(i), e;\n}\nfunction Kg(s, t, e) {\n  const i = $(\"div\");\n  i.setAttribute(Lg, \"\"), h.addClass(i, e.selectOptionGroup), i.setAttribute(\"role\", \"group\"), i.setAttribute(\"id\", s.id), s.hidden && h.addClass(i, \"hidden\");\n  const n = $(\"label\");\n  return n.setAttribute(Ng, \"\"), h.addClass(n, e.selectOptionGroupLabel), h.addStyle(n, { height: `${t.selectOptionHeight}px` }), n.setAttribute(\"for\", s.id), n.textContent = s.label, i.appendChild(n), s.options.forEach((o) => {\n    i.appendChild(sh(o, t, e));\n  }), i;\n}\nfunction zg(s, t) {\n  const e = $(\"div\");\n  return e.innerHTML = s, h.addClass(e, t.selectLabel), h.addClass(e, t.selectFakeValue), e;\n}\nconst oo = \"select\", vi = \"te.select\", ji = `.${vi}`, Ug = `close${ji}`, Xg = `open${ji}`, ll = `optionSelect${ji}`, cl = `optionDeselect${ji}`, Gg = `valueChange${ji}`, qg = \"change\", hl = \"data-te-select-init\", oh = \"data-te-select-no-results-ref\", dl = \"data-te-select-open\", q = \"data-te-input-state-active\", Kt = \"data-te-input-focused\", ro = \"data-te-input-disabled\", Zg = \"data-te-select-option-group-label-ref\", Qg = \"data-te-select-option-all-ref\", pi = \"data-te-select-selected\", Jg = \"[data-te-select-label-ref]\", ul = \"[data-te-select-input-ref]\", tb = \"[data-te-select-input-filter-ref]\", eb = \"[data-te-select-dropdown-ref]\", ib = \"[data-te-select-options-wrapper-ref]\", pl = \"[data-te-select-options-list-ref]\", sb = \"[data-te-select-option-ref]\", nb = \"[data-te-select-clear-btn-ref]\", ob = \"[data-te-select-custom-content-ref]\", rb = `[${oh}]`, _l = \"[data-te-select-form-outline-ref]\", ab = \"[data-te-select-toggle]\", ao = \"[data-te-input-notch-ref]\", lb = 200, cb = {\n  selectAutoSelect: !1,\n  selectContainer: \"body\",\n  selectClearButton: !1,\n  disabled: !1,\n  selectDisplayedLabels: 5,\n  selectFormWhite: !1,\n  multiple: !1,\n  selectOptionsSelectedLabel: \"options selected\",\n  selectOptionHeight: 38,\n  selectAll: !0,\n  selectAllLabel: \"Select all\",\n  selectSearchPlaceholder: \"Search...\",\n  selectSize: \"default\",\n  selectVisibleOptions: 5,\n  selectFilter: !1,\n  selectFilterDebounce: 300,\n  selectNoResultText: \"No results\",\n  selectValidation: !1,\n  selectValidFeedback: \"Valid\",\n  selectInvalidFeedback: \"Invalid\",\n  selectPlaceholder: \"\"\n}, hb = {\n  selectAutoSelect: \"boolean\",\n  selectContainer: \"string\",\n  selectClearButton: \"boolean\",\n  disabled: \"boolean\",\n  selectDisplayedLabels: \"number\",\n  selectFormWhite: \"boolean\",\n  multiple: \"boolean\",\n  selectOptionsSelectedLabel: \"string\",\n  selectOptionHeight: \"number\",\n  selectAll: \"boolean\",\n  selectAllLabel: \"string\",\n  selectSearchPlaceholder: \"string\",\n  selectSize: \"string\",\n  selectVisibleOptions: \"number\",\n  selectFilter: \"boolean\",\n  selectFilterDebounce: \"number\",\n  selectNoResultText: \"string\",\n  selectValidation: \"boolean\",\n  selectValidFeedback: \"string\",\n  selectInvalidFeedback: \"string\",\n  selectPlaceholder: \"string\"\n}, db = {\n  dropdown: \"relative outline-none min-w-[100px] m-0 scale-[0.8] opacity-0 bg-white shadow-[0_2px_5px_0_rgba(0,0,0,0.16),_0_2px_10px_0_rgba(0,0,0,0.12)] transition duration-200 motion-reduce:transition-none data-[te-select-open]:scale-100 data-[te-select-open]:opacity-100 dark:bg-zinc-700\",\n  formCheckInput: \"relative float-left mt-[0.15rem] mr-[8px] h-[1.125rem] w-[1.125rem] appearance-none rounded-[0.25rem] border-[0.125rem] border-solid border-neutral-300 dark:border-neutral-600 outline-none before:pointer-events-none before:absolute before:h-[0.875rem] before:w-[0.875rem] before:scale-0 before:rounded-full before:bg-transparent before:opacity-0 before:shadow-[0px_0px_0px_13px_transparent] before:content-[''] checked:border-primary dark:checked:border-primary checked:bg-primary dark:checked:bg-primary checked:before:opacity-[0.16] checked:after:absolute checked:after:ml-[0.25rem] checked:after:-mt-px checked:after:block checked:after:h-[0.8125rem] checked:after:w-[0.375rem] checked:after:rotate-45 checked:after:border-[0.125rem] checked:after:border-t-0 checked:after:border-l-0 checked:after:border-solid checked:after:border-white checked:after:bg-transparent checked:after:content-[''] hover:cursor-pointer hover:before:opacity-[0.04] hover:before:shadow-[0px_0px_0px_13px_rgba(0,0,0,0.6)] focus:shadow-none focus:transition-[border-color_0.2s] focus:before:scale-100 focus:before:opacity-[0.12] focus:before:shadow-[0px_0px_0px_13px_rgba(0,0,0,0.6)] dark:focus:before:shadow-[0px_0px_0px_13px_rgba(255,255,255,0.4)] focus:before:transition-[box-shadow_0.2s,transform_0.2s] focus:after:absolute focus:after:z-[1] focus:after:block focus:after:h-[0.875rem] focus:after:w-[0.875rem] focus:after:rounded-[0.125rem] focus:after:content-[''] checked:focus:before:scale-100 checked:focus:before:shadow-[0px_0px_0px_13px_#3b71ca] dark:checked:focus:before:shadow-[0px_0px_0px_13px_#3b71ca] checked:focus:before:transition-[box-shadow_0.2s,transform_0.2s] checked:focus:after:ml-[0.25rem] checked:focus:after:-mt-px checked:focus:after:h-[0.8125rem] checked:focus:after:w-[0.375rem] checked:focus:after:rotate-45 checked:focus:after:rounded-none checked:focus:after:border-[0.125rem] checked:focus:after:border-t-0 checked:focus:after:border-l-0 checked:focus:after:border-solid checked:focus:after:border-white checked:focus:after:bg-transparent\",\n  formOutline: \"relative\",\n  initialized: \"hidden\",\n  inputGroup: \"flex items-center whitespace-nowrap p-2.5 text-center text-base font-normal leading-[1.6] text-gray-700 dark:bg-zinc-800 dark:text-gray-200 dark:placeholder:text-gray-200\",\n  noResult: \"flex items-center px-4\",\n  optionsList: \"list-none m-0 p-0\",\n  optionsWrapper: \"overflow-y-auto\",\n  optionsWrapperScrollbar: \"[&::-webkit-scrollbar]:w-1 [&::-webkit-scrollbar]:h-1 [&::-webkit-scrollbar-button]:block [&::-webkit-scrollbar-button]:h-0 [&::-webkit-scrollbar-button]:bg-transparent [&::-webkit-scrollbar-track-piece]:bg-transparent [&::-webkit-scrollbar-track-piece]:rounded-none [&::-webkit-scrollbar-track-piece]: [&::-webkit-scrollbar-track-piece]:rounded-l [&::-webkit-scrollbar-thumb]:h-[50px] [&::-webkit-scrollbar-thumb]:bg-[#999] [&::-webkit-scrollbar-thumb]:rounded\",\n  selectArrow: \"absolute right-3 text-[0.8rem] cursor-pointer peer-focus:text-primary peer-data-[te-input-focused]:text-primary group-data-[te-was-validated]/validation:peer-valid:text-green-600 group-data-[te-was-validated]/validation:peer-invalid:text-[rgb(220,76,100)] w-5 h-5\",\n  selectArrowWhite: \"text-gray-50 peer-focus:!text-white peer-data-[te-input-focused]:!text-white\",\n  selectArrowDefault: \"top-2\",\n  selectArrowLg: \"top-[13px]\",\n  selectArrowSm: \"top-1\",\n  selectClearBtn: \"absolute top-2 right-9 text-black cursor-pointer focus:text-primary outline-none dark:text-gray-200\",\n  selectClearBtnWhite: \"!text-gray-50\",\n  selectClearBtnDefault: \"top-2 text-base\",\n  selectClearBtnLg: \"top-[11px] text-base\",\n  selectClearBtnSm: \"top-1 text-[0.8rem]\",\n  selectDropdownContainer: \"z-[1070]\",\n  selectFakeValue: \"transform-none hidden data-[te-input-state-active]:block\",\n  selectFilterInput: \"relative m-0 block w-full min-w-0 flex-auto rounded border border-solid border-gray-300 bg-transparent bg-clip-padding px-3 py-1.5 text-base font-normal text-gray-700 transition duration-300 ease-in-out motion-reduce:transition-none focus:border-primary focus:text-gray-700 focus:shadow-te-primary focus:outline-none dark:text-gray-200 dark:placeholder:text-gray-200\",\n  selectInput: \"peer block min-h-[auto] w-full rounded border-0 bg-transparent outline-none transition-all duration-200 ease-linear focus:placeholder:opacity-100 data-[te-input-state-active]:placeholder:opacity-100 motion-reduce:transition-none dark:text-gray-200 dark:placeholder:text-gray-200 [&:not([data-te-input-placeholder-active])]:placeholder:opacity-0 cursor-pointer data-[te-input-disabled]:bg-[#e9ecef] data-[te-input-disabled]:cursor-default group-data-[te-was-validated]/validation:mb-4 dark:data-[te-input-disabled]:bg-zinc-600\",\n  selectInputWhite: \"!text-gray-50\",\n  selectInputSizeDefault: \"py-[0.32rem] px-3 leading-[1.6]\",\n  selectInputSizeLg: \"py-[0.32rem] px-3 leading-[2.15]\",\n  selectInputSizeSm: \"py-[0.33rem] px-3 text-xs leading-[1.5]\",\n  selectLabel: \"pointer-events-none absolute top-0 left-3 mb-0 max-w-[90%] origin-[0_0] truncate text-gray-500 transition-all duration-200 ease-out peer-focus:scale-[0.8] peer-focus:text-primary peer-data-[te-input-state-active]:scale-[0.8] motion-reduce:transition-none dark:text-gray-200 dark:peer-focus:text-gray-200 data-[te-input-state-active]:scale-[0.8] dark:peer-focus:text-primary\",\n  selectLabelWhite: \"!text-gray-50\",\n  selectLabelSizeDefault: \"pt-[0.37rem] leading-[1.6] peer-focus:-translate-y-[0.9rem] peer-data-[te-input-state-active]:-translate-y-[0.9rem] data-[te-input-state-active]:-translate-y-[0.9rem]\",\n  selectLabelSizeLg: \"pt-[0.37rem] leading-[2.15] peer-focus:-translate-y-[1.15rem] peer-data-[te-input-state-active]:-translate-y-[1.15rem] data-[te-input-state-active]:-translate-y-[1.15rem]\",\n  selectLabelSizeSm: \"pt-[0.37rem] text-xs leading-[1.5] peer-focus:-translate-y-[0.75rem] peer-data-[te-input-state-active]:-translate-y-[0.75rem] data-[te-input-state-active]:-translate-y-[0.75rem]\",\n  selectOption: \"flex flex-row items-center justify-between w-full px-4 truncate text-gray-700 bg-transparent select-none cursor-pointer data-[te-input-multiple-active]:bg-black/5 hover:[&:not([data-te-select-option-disabled])]:bg-black/5 data-[te-input-state-active]:bg-black/5 data-[te-select-option-selected]:data-[te-input-state-active]:bg-black/5 data-[te-select-selected]:data-[te-select-option-disabled]:cursor-default data-[te-select-selected]:data-[te-select-option-disabled]:text-gray-400 data-[te-select-selected]:data-[te-select-option-disabled]:bg-transparent data-[te-select-option-selected]:bg-black/[0.02] data-[te-select-option-disabled]:text-gray-400 data-[te-select-option-disabled]:cursor-default group-data-[te-select-option-group-ref]/opt:pl-7 dark:text-gray-200 dark:hover:[&:not([data-te-select-option-disabled])]:bg-white/30 dark:data-[te-input-state-active]:bg-white/30 dark:data-[te-select-option-selected]:data-[te-input-state-active]:bg-white/30 dark:data-[te-select-option-disabled]:text-gray-400 dark:data-[te-input-multiple-active]:bg-white/30\",\n  selectOptionGroup: \"group/opt\",\n  selectOptionGroupLabel: \"flex flex-row items-center w-full px-4 truncate bg-transparent text-black/50 select-none dark:text-gray-300\",\n  selectOptionIcon: \"w-7 h-7 rounded-full\",\n  selectOptionSecondaryText: \"block text-[0.8rem] text-gray-500 dark:text-gray-300\",\n  selectOptionText: \"group\",\n  selectValidationValid: \"hidden absolute -mt-3 w-auto text-sm text-green-600 cursor-pointer group-data-[te-was-validated]/validation:peer-valid:block\",\n  selectValidationInvalid: \"hidden absolute -mt-3 w-auto text-sm text-[rgb(220,76,100)] cursor-pointer group-data-[te-was-validated]/validation:peer-invalid:block\"\n}, ub = {\n  dropdown: \"string\",\n  formCheckInput: \"string\",\n  formOutline: \"string\",\n  initialized: \"string\",\n  inputGroup: \"string\",\n  noResult: \"string\",\n  optionsList: \"string\",\n  optionsWrapper: \"string\",\n  optionsWrapperScrollbar: \"string\",\n  selectArrow: \"string\",\n  selectArrowDefault: \"string\",\n  selectArrowLg: \"string\",\n  selectArrowSm: \"string\",\n  selectClearBtn: \"string\",\n  selectClearBtnDefault: \"string\",\n  selectClearBtnLg: \"string\",\n  selectClearBtnSm: \"string\",\n  selectDropdownContainer: \"string\",\n  selectFakeValue: \"string\",\n  selectFilterInput: \"string\",\n  selectInput: \"string\",\n  selectInputSizeDefault: \"string\",\n  selectInputSizeLg: \"string\",\n  selectInputSizeSm: \"string\",\n  selectLabel: \"string\",\n  selectLabelSizeDefault: \"string\",\n  selectLabelSizeLg: \"string\",\n  selectLabelSizeSm: \"string\",\n  selectOption: \"string\",\n  selectOptionGroup: \"string\",\n  selectOptionGroupLabel: \"string\",\n  selectOptionIcon: \"string\",\n  selectOptionSecondaryText: \"string\",\n  selectOptionText: \"string\"\n};\nclass _r {\n  constructor(t, e, i) {\n    this._element = t, this._config = this._getConfig(e), this._classes = this._getClasses(i), this._config.selectPlaceholder && !this._config.multiple && this._addPlaceholderOption(), this._optionsToRender = this._getOptionsToRender(t), this._plainOptions = this._getPlainOptions(this._optionsToRender), this._filteredOptionsList = null, this._selectionModel = new Tg(this.multiple), this._activeOptionIndex = -1, this._activeOption = null, this._wrapperId = rt(\"select-wrapper-\"), this._dropdownContainerId = rt(\"select-dropdown-container-\"), this._selectAllId = rt(\"select-all-\"), this._debounceTimeoutId = null, this._dropdownHeight = this._config.selectOptionHeight * this._config.selectVisibleOptions, this._popper = null, this._input = null, this._label = d.next(this._element, Jg)[0], this._notch = null, this._fakeValue = null, this._isFakeValueActive = !1, this._customContent = d.next(\n      t,\n      ob\n    )[0], this._toggleButton = null, this._elementToggle = null, this._wrapper = null, this._inputEl = null, this._dropdownContainer = null, this._container = null, this._selectAllOption = null, this._init(), this._mutationObserver = null, this._isOpen = !1, this._addMutationObserver(), this._element && y.setData(t, vi, this);\n  }\n  static get NAME() {\n    return oo;\n  }\n  get filterInput() {\n    return d.findOne(\n      tb,\n      this._dropdownContainer\n    );\n  }\n  get dropdown() {\n    return d.findOne(eb, this._dropdownContainer);\n  }\n  get optionsList() {\n    return d.findOne(\n      pl,\n      this._dropdownContainer\n    );\n  }\n  get optionsWrapper() {\n    return d.findOne(\n      ib,\n      this._dropdownContainer\n    );\n  }\n  get clearButton() {\n    return d.findOne(nb, this._wrapper);\n  }\n  get options() {\n    return this._filteredOptionsList ? this._filteredOptionsList : this._plainOptions;\n  }\n  get value() {\n    return this.multiple ? this._selectionModel.values : this._selectionModel.value;\n  }\n  get multiple() {\n    return this._config.multiple;\n  }\n  get hasSelectAll() {\n    return this.multiple && this._config.selectAll;\n  }\n  get hasSelection() {\n    return this._selectionModel.selection || this._selectionModel.selections.length > 0;\n  }\n  _getConfig(t) {\n    const e = h.getDataAttributes(this._element);\n    return t = {\n      ...cb,\n      ...e,\n      ...t\n    }, this._element.hasAttribute(\"multiple\") && (t.multiple = !0), this._element.hasAttribute(\"disabled\") && (t.disabled = !0), this._element.tabIndex && (t.tabIndex = this._element.getAttribute(\"tabIndex\")), D(oo, t, hb), t;\n  }\n  _getClasses(t) {\n    const e = h.getDataClassAttributes(this._element);\n    return t = {\n      ...db,\n      ...e,\n      ...t\n    }, D(oo, t, ub), t;\n  }\n  _addPlaceholderOption() {\n    const t = new Option(\"\", \"\", !0, !0);\n    t.hidden = !0, t.selected = !0, this._element.prepend(t);\n  }\n  _getOptionsToRender(t) {\n    const e = [];\n    return t.childNodes.forEach((n) => {\n      if (n.nodeName === \"OPTGROUP\") {\n        const o = {\n          id: rt(\"group-\"),\n          label: n.label,\n          disabled: n.hasAttribute(\"disabled\"),\n          hidden: n.hasAttribute(\"hidden\"),\n          options: []\n        };\n        n.childNodes.forEach((a) => {\n          a.nodeName === \"OPTION\" && o.options.push(\n            this._createOptionObject(a, o)\n          );\n        }), e.push(o);\n      } else\n        n.nodeName === \"OPTION\" && e.push(this._createOptionObject(n));\n    }), e;\n  }\n  _getPlainOptions(t) {\n    if (!d.findOne(\"optgroup\", this._element))\n      return t;\n    const i = [];\n    return t.forEach((n) => {\n      Object.prototype.hasOwnProperty.call(\n        n,\n        \"options\"\n      ) ? n.options.forEach((r) => {\n        i.push(r);\n      }) : i.push(n);\n    }), i;\n  }\n  _createOptionObject(t, e = {}) {\n    const i = rt(\"option-\"), n = e.id ? e.id : null, o = e.disabled ? e.disabled : !1, r = t.selected || t.hasAttribute(pi), a = t.hasAttribute(\"disabled\") || o, l = t.hasAttribute(\"hidden\") || e && e.hidden, p = this.multiple, u = t.value, _ = t.label, f = h.getDataAttribute(\n      t,\n      \"selectSecondaryText\"\n    ), g = h.getDataAttribute(t, \"select-icon\");\n    return new rl(\n      i,\n      t,\n      p,\n      u,\n      _,\n      r,\n      a,\n      l,\n      f,\n      n,\n      g\n    );\n  }\n  _getNavigationOptions() {\n    const t = this.options.filter((e) => !e.hidden);\n    return this.hasSelectAll ? [this._selectAllOption, ...t] : t;\n  }\n  _init() {\n    this._renderMaterialWrapper(), this._wrapper = d.findOne(`#${this._wrapperId}`), this._input = d.findOne(ul, this._wrapper), this._config.disabled && this._input.setAttribute(ro, \"\");\n    const t = this._config.selectContainer;\n    t === \"body\" ? this._container = document.body : this._container = d.findOne(t), this._initOutlineInput(), this._setDefaultSelections(), this._updateInputValue(), this._appendFakeValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility(), this._bindComponentEvents(), this.hasSelectAll && (this._selectAllOption = this._createSelectAllOption()), this._dropdownContainer = al(\n      this._dropdownContainerId,\n      this._config,\n      this._input.offsetWidth,\n      this._dropdownHeight,\n      this._selectAllOption,\n      this._optionsToRender,\n      this._customContent,\n      this._classes\n    ), this._setFirstActiveOption(), this._listenToFocusChange();\n  }\n  _renderMaterialWrapper() {\n    const t = Pg(\n      this._wrapperId,\n      this._config,\n      this._label,\n      this._classes,\n      this._element.name\n    );\n    this._element.parentNode.insertBefore(t, this._element), h.addClass(this._element, this._classes.initialized), t.appendChild(this._element);\n  }\n  _initOutlineInput() {\n    const t = d.findOne(\n      _l,\n      this._wrapper\n    );\n    new V(\n      t,\n      {\n        inputFormWhite: this._config.selectFormWhite\n      },\n      this._classes\n    ).init(), this._notch = d.findOne(ao, this._wrapper);\n  }\n  _bindComponentEvents() {\n    this._listenToComponentKeydown(), this._listenToWrapperClick(), this._listenToClearBtnClick(), this._listenToClearBtnKeydown();\n  }\n  _setDefaultSelections() {\n    this.options.forEach((t) => {\n      t.selected && this._selectionModel.select(t);\n    });\n  }\n  _listenToComponentKeydown() {\n    c.on(this._wrapper, \"keydown\", this._handleKeydown.bind(this));\n  }\n  _handleKeydown(t) {\n    this._isOpen && !this._config.selectFilter ? this._handleOpenKeydown(t) : this._handleClosedKeydown(t);\n  }\n  _handleOpenKeydown(t) {\n    const e = t.keyCode, i = e === Fi || e === at && t.altKey || e === Pi;\n    if (e === Pi && this._config.selectAutoSelect && !this.multiple && this._handleAutoSelection(this._activeOption), i) {\n      this.close(), this._input.focus();\n      return;\n    }\n    switch (e) {\n      case z:\n        this._setNextOptionActive(), this._scrollToOption(this._activeOption);\n        break;\n      case at:\n        this._setPreviousOptionActive(), this._scrollToOption(this._activeOption);\n        break;\n      case We:\n        this._setFirstOptionActive(), this._scrollToOption(this._activeOption);\n        break;\n      case Fe:\n        this._setLastOptionActive(), this._scrollToOption(this._activeOption);\n        break;\n      case ct:\n        t.preventDefault(), this._activeOption && (this.hasSelectAll && this._activeOptionIndex === 0 ? this._handleSelectAll() : this._handleSelection(this._activeOption));\n        return;\n      default:\n        return;\n    }\n    t.preventDefault();\n  }\n  _handleClosedKeydown(t) {\n    const e = t.keyCode;\n    if (e === ct && t.preventDefault(), (e === ct || e === z && t.altKey || e === z && this.multiple) && this.open(), this.multiple)\n      switch (e) {\n        case z:\n          this.open();\n          break;\n        case at:\n          this.open();\n          break;\n        default:\n          return;\n      }\n    else\n      switch (e) {\n        case z:\n          this._setNextOptionActive(), this._handleSelection(this._activeOption);\n          break;\n        case at:\n          this._setPreviousOptionActive(), this._handleSelection(this._activeOption);\n          break;\n        case We:\n          this._setFirstOptionActive(), this._handleSelection(this._activeOption);\n          break;\n        case Fe:\n          this._setLastOptionActive(), this._handleSelection(this._activeOption);\n          break;\n        default:\n          return;\n      }\n    t.preventDefault();\n  }\n  _scrollToOption(t) {\n    if (!t)\n      return;\n    let e;\n    const i = this.options.filter((u) => !u.hidden);\n    this.hasSelectAll ? e = i.indexOf(t) + 1 : e = i.indexOf(t);\n    const n = this._getNumberOfGroupsBeforeOption(e), o = e + n, r = this.optionsWrapper, a = r.offsetHeight, l = this._config.selectOptionHeight, p = r.scrollTop;\n    if (e > -1) {\n      const u = o * l, _ = u + l > p + a;\n      u < p ? r.scrollTop = u : _ ? r.scrollTop = u - a + l : r.scrollTop = p;\n    }\n  }\n  _getNumberOfGroupsBeforeOption(t) {\n    const e = this.options.filter((r) => !r.hidden), i = this._optionsToRender.filter((r) => !r.hidden), n = this.hasSelectAll ? t - 1 : t;\n    let o = 0;\n    for (let r = 0; r <= n; r++)\n      e[r].groupId && i[o] && i[o].id && e[r].groupId === i[o].id && o++;\n    return o;\n  }\n  _setNextOptionActive() {\n    let t = this._activeOptionIndex + 1;\n    const e = this._getNavigationOptions();\n    if (e[t]) {\n      for (; e[t].disabled; )\n        if (t += 1, !e[t])\n          return;\n      this._updateActiveOption(e[t], t);\n    }\n  }\n  _setPreviousOptionActive() {\n    let t = this._activeOptionIndex - 1;\n    const e = this._getNavigationOptions();\n    if (e[t]) {\n      for (; e[t].disabled; )\n        if (t -= 1, !e[t])\n          return;\n      this._updateActiveOption(e[t], t);\n    }\n  }\n  _setFirstOptionActive() {\n    const e = this._getNavigationOptions();\n    this._updateActiveOption(e[0], 0);\n  }\n  _setLastOptionActive() {\n    const t = this._getNavigationOptions(), e = t.length - 1;\n    this._updateActiveOption(t[e], e);\n  }\n  _updateActiveOption(t, e) {\n    const i = this._activeOption;\n    i && i.removeActiveStyles(), t.setActiveStyles(), this._activeOptionIndex = e, this._activeOption = t;\n  }\n  _listenToWrapperClick() {\n    c.on(this._wrapper, \"click\", () => {\n      this.toggle();\n    });\n  }\n  _listenToClearBtnClick() {\n    c.on(this.clearButton, \"click\", (t) => {\n      t.preventDefault(), t.stopPropagation(), this._handleClear();\n    });\n  }\n  _listenToClearBtnKeydown() {\n    c.on(this.clearButton, \"keydown\", (t) => {\n      t.keyCode === ct && (this._handleClear(), t.preventDefault(), t.stopPropagation());\n    });\n  }\n  _handleClear() {\n    if (this.multiple)\n      this._selectionModel.clear(), this._deselectAllOptions(this.options), this.hasSelectAll && this._updateSelectAllState();\n    else {\n      const t = this._selectionModel.selection;\n      this._selectionModel.clear(), t.deselect();\n    }\n    this._fakeValue.innerHTML = \"\", this._updateInputValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility(), this._emitValueChangeEvent(null), this._emitNativeChangeEvent();\n  }\n  _listenToOptionsClick() {\n    c.on(this.optionsWrapper, \"click\", (t) => {\n      if (t.target.hasAttribute(\n        Zg\n      ))\n        return;\n      const i = t.target.nodeName === \"DIV\" ? t.target : d.closest(t.target, sb);\n      if (i.hasAttribute(Qg)) {\n        this._handleSelectAll();\n        return;\n      }\n      const o = i.dataset.teId, r = this.options.find((a) => a.id === o);\n      r && !r.disabled && this._handleSelection(r);\n    });\n  }\n  _handleSelectAll() {\n    this._selectAllOption.selected ? (this._deselectAllOptions(this.options), this._selectAllOption.deselect()) : (this._selectAllOptions(this.options), this._selectAllOption.select()), this._updateInputValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility(), this._emitValueChangeEvent(this.value), this._emitNativeChangeEvent();\n  }\n  _selectAllOptions(t) {\n    t.forEach((e) => {\n      !e.selected && !e.disabled && (this._selectionModel.select(e), e.select());\n    });\n  }\n  _deselectAllOptions(t) {\n    t.forEach((e) => {\n      e.selected && !e.disabled && (this._selectionModel.deselect(e), e.deselect());\n    });\n  }\n  _handleSelection(t) {\n    this.multiple ? (this._handleMultiSelection(t), this.hasSelectAll && this._updateSelectAllState()) : this._handleSingleSelection(t), this._updateInputValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility();\n  }\n  _handleAutoSelection(t) {\n    this._singleOptionSelect(t), this._updateInputValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility();\n  }\n  _handleSingleSelection(t) {\n    this._singleOptionSelect(t), this.close(), this._input.focus();\n  }\n  _singleOptionSelect(t) {\n    const e = this._selectionModel.selections[0];\n    e && e !== t && (this._selectionModel.deselect(e), e.deselect(), e.node.setAttribute(pi, !1), c.trigger(this._element, cl, {\n      value: e.value\n    })), (!e || e && t !== e) && (this._selectionModel.select(t), t.select(), t.node.setAttribute(pi, !0), c.trigger(this._element, ll, {\n      value: t.value\n    }), this._emitValueChangeEvent(this.value), this._emitNativeChangeEvent());\n  }\n  _handleMultiSelection(t) {\n    t.selected ? (this._selectionModel.deselect(t), t.deselect(), t.node.setAttribute(pi, !1), c.trigger(this._element, cl, {\n      value: t.value\n    })) : (this._selectionModel.select(t), t.select(), t.node.setAttribute(pi, !0), c.trigger(this._element, ll, {\n      value: t.value\n    })), this._emitValueChangeEvent(this.value), this._emitNativeChangeEvent();\n  }\n  _emitValueChangeEvent(t) {\n    c.trigger(this._element, Gg, { value: t });\n  }\n  _emitNativeChangeEvent() {\n    c.trigger(this._element, qg);\n  }\n  _updateInputValue() {\n    const t = this.multiple ? this._selectionModel.labels : this._selectionModel.label;\n    let e;\n    this.multiple && this._config.selectDisplayedLabels !== -1 && this._selectionModel.selections.length > this._config.selectDisplayedLabels ? e = `${this._selectionModel.selections.length} ${this._config.selectOptionsSelectedLabel}` : e = t, !this.multiple && !this._isSelectionValid(this._selectionModel.selection) ? this._input.value = \"\" : this._isLabelEmpty(this._selectionModel.selection) ? this._input.value = \" \" : e ? this._input.value = e : this.multiple || !this._optionsToRender[0] ? this._input.value = \"\" : this._input.value = this._optionsToRender[0].label;\n  }\n  _isSelectionValid(t) {\n    return !(t && (t.disabled || t.value === \"\"));\n  }\n  _isLabelEmpty(t) {\n    return !!(t && t.label === \"\");\n  }\n  _appendFakeValue() {\n    if (!this._selectionModel.selection || this._selectionModel._multiple)\n      return;\n    const t = this._selectionModel.selection.label;\n    this._fakeValue = zg(t, this._classes), d.findOne(\n      _l,\n      this._wrapper\n    ).appendChild(this._fakeValue);\n  }\n  _updateLabelPosition() {\n    const t = this._element.hasAttribute(hl), e = this._input.value !== \"\";\n    this._label && (t && (e || this._isOpen || this._isFakeValueActive) ? (this._label.setAttribute(q, \"\"), this._notch.setAttribute(q, \"\")) : (this._label.removeAttribute(q), this._notch.removeAttribute(q, \"\")));\n  }\n  _updateLabelPositionWhileClosing() {\n    this._label && (this._input.value !== \"\" || this._isFakeValueActive ? (this._label.setAttribute(q, \"\"), this._notch.setAttribute(q, \"\")) : (this._label.removeAttribute(q), this._notch.removeAttribute(q)));\n  }\n  _updateFakeLabelPosition() {\n    this._fakeValue && (this._input.value === \"\" && this._fakeValue.innerHTML !== \"\" && !this._config.selectPlaceholder ? (this._isFakeValueActive = !0, this._fakeValue.setAttribute(q, \"\")) : (this._isFakeValueActive = !1, this._fakeValue.removeAttribute(q)));\n  }\n  _updateClearButtonVisibility() {\n    if (!this.clearButton)\n      return;\n    this._selectionModel.selection || this._selectionModel.selections.length > 0 ? h.addStyle(this.clearButton, { display: \"block\" }) : h.addStyle(this.clearButton, { display: \"none\" });\n  }\n  _updateSelectAllState() {\n    const t = this._selectAllOption.selected, e = Vo(this.options);\n    !e && t ? this._selectAllOption.deselect() : e && !t && this._selectAllOption.select();\n  }\n  toggle() {\n    this._isOpen ? this.close() : this.open();\n  }\n  open() {\n    const t = this._config.disabled, e = c.trigger(this._element, Xg);\n    this._isOpen || t || e.defaultPrevented || (this._openDropdown(), this._updateDropdownWidth(), this._setFirstActiveOption(), this._scrollToOption(this._activeOption), this._config.selectFilter && (setTimeout(() => {\n      this.filterInput.focus();\n    }, 0), this._listenToSelectSearch(), this._listenToDropdownKeydown()), this._listenToOptionsClick(), this._listenToOutsideClick(), this._listenToWindowResize(), this._isOpen = !0, this._updateLabelPosition(), this._setInputActiveStyles());\n  }\n  _openDropdown() {\n    this._popper = Ce(this._input, this._dropdownContainer, {\n      placement: \"bottom-start\",\n      modifiers: [\n        {\n          name: \"offset\",\n          options: {\n            offset: [0, 1]\n          }\n        }\n      ]\n    }), this._container.appendChild(this._dropdownContainer), setTimeout(() => {\n      this.dropdown.setAttribute(dl, \"\");\n    }, 0);\n  }\n  _updateDropdownWidth() {\n    const t = this._input.offsetWidth;\n    h.addStyle(this._dropdownContainer, { width: `${t}px` });\n  }\n  _setFirstActiveOption() {\n    const t = this._getNavigationOptions(), e = this._activeOption;\n    e && e.removeActiveStyles();\n    const i = this.multiple ? this._selectionModel.selections[0] : this._selectionModel.selection;\n    i ? (this._activeOption = i, i.setActiveStyles(), this._activeOptionIndex = t.findIndex(\n      (n) => n === i\n    )) : (this._activeOption = null, this._activeOptionIndex = -1);\n  }\n  _setInputActiveStyles() {\n    this._input.setAttribute(Kt, \"\"), d.findOne(ao, this._wrapper).setAttribute(\n      Kt,\n      \"\"\n    );\n  }\n  _listenToWindowResize() {\n    c.on(window, \"resize\", this._handleWindowResize.bind(this));\n  }\n  _handleWindowResize() {\n    this._dropdownContainer && this._updateDropdownWidth();\n  }\n  _listenToSelectSearch() {\n    this.filterInput.addEventListener(\"input\", (t) => {\n      const e = t.target.value, i = this._config.selectFilterDebounce;\n      this._debounceFilter(e, i);\n    });\n  }\n  _debounceFilter(t, e) {\n    this._debounceTimeoutId && clearTimeout(this._debounceTimeoutId), this._debounceTimeoutId = setTimeout(() => {\n      this._filterOptions(t);\n    }, e);\n  }\n  _filterOptions(t) {\n    const e = [];\n    this._optionsToRender.forEach((o) => {\n      const r = Object.prototype.hasOwnProperty.call(\n        o,\n        \"options\"\n      ), a = !r && o.label.toLowerCase().includes(t.toLowerCase()), l = {};\n      r && (l.label = o.label, l.options = this._filter(t, o.options), l.options.length > 0 && e.push(l)), a && e.push(o);\n    });\n    const i = this._config.selectNoResultText !== \"\", n = e.length !== 0;\n    if (n)\n      this._updateOptionsListTemplate(e), this._popper.forceUpdate(), this._filteredOptionsList = this._getPlainOptions(e), this.hasSelectAll && this._updateSelectAllState(), this._setFirstActiveOption();\n    else if (!n && i) {\n      const o = this._getNoResultTemplate();\n      this.optionsWrapper.innerHTML = o;\n    }\n  }\n  _updateOptionsListTemplate(t) {\n    const e = d.findOne(pl, this._dropdownContainer) || d.findOne(rb, this._dropdownContainer), i = eh(\n      t,\n      this._selectAllOption,\n      this._config,\n      this._classes\n    );\n    this.optionsWrapper.removeChild(e), this.optionsWrapper.appendChild(i);\n  }\n  _getNoResultTemplate() {\n    return `<div class=\"${this._classes.noResult}\" ${oh} style=\"height: ${this._config.selectOptionHeight}px\">${this._config.selectNoResultText}</div>`;\n  }\n  _filter(t, e) {\n    const i = t.toLowerCase();\n    return e.filter(\n      (n) => n.label.toLowerCase().includes(i)\n    );\n  }\n  _listenToDropdownKeydown() {\n    c.on(\n      this.dropdown,\n      \"keydown\",\n      this._handleOpenKeydown.bind(this)\n    );\n  }\n  _listenToOutsideClick() {\n    this._outsideClick = this._handleOutSideClick.bind(this), c.on(document, \"click\", this._outsideClick);\n  }\n  _listenToFocusChange(t = !0) {\n    if (t === !1) {\n      c.off(\n        this._input,\n        \"focus\",\n        () => this._notch.setAttribute(Kt, \"\")\n      ), c.off(\n        this._input,\n        \"blur\",\n        () => this._notch.removeAttribute(Kt)\n      );\n      return;\n    }\n    c.on(\n      this._input,\n      \"focus\",\n      () => this._notch.setAttribute(Kt, \"\")\n    ), c.on(\n      this._input,\n      \"blur\",\n      () => this._notch.removeAttribute(Kt)\n    );\n  }\n  _handleOutSideClick(t) {\n    const e = this._wrapper && this._wrapper.contains(t.target), i = t.target === this._dropdownContainer, n = this._dropdownContainer && this._dropdownContainer.contains(t.target);\n    let o;\n    this._toggleButton || (this._elementToggle = d.find(ab)), this._elementToggle && this._elementToggle.forEach((r) => {\n      const a = h.getDataAttribute(\n        r,\n        \"select-toggle\"\n      );\n      (a === this._element.id || this._element.classList.contains(a)) && (this._toggleButton = r, o = this._toggleButton.contains(t.target));\n    }), !e && !i && !n && !o && this.close();\n  }\n  close() {\n    const t = c.trigger(this._element, Ug);\n    !this._isOpen || t.defaultPrevented || (this._config.selectFilter && this.hasSelectAll && (this._resetFilterState(), this._updateOptionsListTemplate(this._optionsToRender), this._config.multiple && this._updateSelectAllState()), this._removeDropdownEvents(), this.dropdown.removeAttribute(dl), setTimeout(() => {\n      this._input.removeAttribute(Kt), this._input.blur(), d.findOne(ao, this._wrapper).removeAttribute(\n        Kt\n      ), this._label && !this.hasSelection && (this._label.removeAttribute(q), this._notch.setAttribute(q, \"\"), this._input.removeAttribute(q), this._notch.removeAttribute(q)), this._updateLabelPositionWhileClosing();\n    }, 0), setTimeout(() => {\n      this._container && this._dropdownContainer.parentNode === this._container && this._container.removeChild(this._dropdownContainer), this._popper.destroy(), this._isOpen = !1, c.off(this.dropdown, \"transitionend\");\n    }, lb));\n  }\n  _resetFilterState() {\n    this.filterInput.value = \"\", this._filteredOptionsList = null;\n  }\n  _removeDropdownEvents() {\n    c.off(document, \"click\", this._outsideClick), this._config.selectFilter && c.off(this.dropdown, \"keydown\"), c.off(this.optionsWrapper, \"click\");\n  }\n  _addMutationObserver() {\n    this._mutationObserver = new MutationObserver(() => {\n      this._wrapper && (this._updateSelections(), this._updateDisabledState());\n    }), this._observeMutationObserver();\n  }\n  _updateSelections() {\n    this._optionsToRender = this._getOptionsToRender(this._element), this._plainOptions = this._getPlainOptions(this._optionsToRender), this._selectionModel.clear(), this._setDefaultSelections(), this._updateInputValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility(), this.hasSelectAll && this._updateSelectAllState();\n    const t = this._config.filter && this.filterInput && this.filterInput.value;\n    this._isOpen && !t ? (this._updateOptionsListTemplate(this._optionsToRender), this._setFirstActiveOption()) : this._isOpen && t ? (this._filterOptions(this.filterInput.value), this._setFirstActiveOption()) : this._dropdownContainer = al(\n      this._dropdownContainerId,\n      this._config,\n      this._input.offsetWidth,\n      this._dropdownHeight,\n      this._selectAllOption,\n      this._optionsToRender,\n      this._customContent,\n      this._classes\n    );\n  }\n  _updateDisabledState() {\n    const t = d.findOne(ul, this._wrapper);\n    this._element.hasAttribute(\"disabled\") ? (this._config.disabled = !0, t.setAttribute(\"disabled\", \"\"), t.setAttribute(ro, \"\")) : (this._config.disabled = !1, t.removeAttribute(\"disabled\"), t.removeAttribute(ro));\n  }\n  _observeMutationObserver() {\n    this._mutationObserver && this._mutationObserver.observe(this._element, {\n      attributes: !0,\n      childList: !0,\n      characterData: !0,\n      subtree: !0\n    });\n  }\n  _disconnectMutationObserver() {\n    this.mutationObserver && (this._mutationObserver.disconnect(), this._mutationObserver = null);\n  }\n  _createSelectAllOption() {\n    const t = this._selectAllId, e = null, i = !0, n = \"select-all\", o = this._config.selectAllLabel, r = Vo(this.options), a = !1, l = !1, p = null, u = null, _ = null;\n    return new rl(\n      t,\n      e,\n      i,\n      n,\n      o,\n      r,\n      a,\n      l,\n      p,\n      u,\n      _\n    );\n  }\n  dispose() {\n    this._removeComponentEvents(), this._destroyMaterialSelect(), this._listenToFocusChange(!1), y.removeData(this._element, vi);\n  }\n  _removeComponentEvents() {\n    c.off(this.input, \"click\"), c.off(this.wrapper, this._handleKeydown.bind(this)), c.off(this.clearButton, \"click\"), c.off(this.clearButton, \"keydown\"), c.off(window, \"resize\", this._handleWindowResize.bind(this));\n  }\n  _destroyMaterialSelect() {\n    this._isOpen && this.close(), this._destroyMaterialTemplate();\n  }\n  _destroyMaterialTemplate() {\n    const t = this._wrapper.parentNode, e = d.find(\"label\", this._wrapper);\n    t.appendChild(this._element), e.forEach((i) => {\n      t.appendChild(i);\n    }), e.forEach((i) => {\n      i.removeAttribute(q);\n    }), h.removeClass(this._element, this._classes.initialized), this._element.removeAttribute(hl), t.removeChild(this._wrapper);\n  }\n  setValue(t) {\n    this.options.filter((i) => i.selected).forEach((i) => i.nativeOption.selected = !1), Array.isArray(t) ? t.forEach((i) => {\n      this._selectByValue(i);\n    }) : this._selectByValue(t), this._updateSelections();\n  }\n  _selectByValue(t) {\n    const e = this.options.find(\n      (i) => i.value === t\n    );\n    return e ? (e.nativeOption.selected = !0, !0) : !1;\n  }\n  static jQueryInterface(t, e) {\n    return this.each(function() {\n      let i = y.getData(this, vi);\n      const n = typeof t == \"object\" && t;\n      if (!(!i && /dispose/.test(t)) && (i || (i = new _r(this, n)), typeof t == \"string\")) {\n        if (typeof i[t] > \"u\")\n          throw new TypeError(`No method named \"${t}\"`);\n        i[t](e);\n      }\n    });\n  }\n  static getInstance(t) {\n    return y.getData(t, vi);\n  }\n  static getOrCreateInstance(t, e = {}) {\n    return this.getInstance(t) || new this(t, typeof e == \"object\" ? e : null);\n  }\n}\nconst pb = ({ inputID: s, labelText: t }, e) => `<div data-te-chips-input-wrapper data-te-input-wrapper-init class=\"${e.chipsInputWrapper}\">\n      <input\n          type=\"text\"\n          class=\"${e.chipsInput}\"\n          id=\"${s}\"\n          placeholder=\"Example label\" />\n        <label\n          for=\"${s}\"\n          class=\"${e.chipsLabel}\"\n          >${t}\n        </label>\n      </div>\n    </div>`, _b = ({ text: s, iconSVG: t }, e) => `<div data-te-chip-init data-te-ripple-init class=\"${e.chipElement}\">\n    <span data-te-chip-text>${s}</span> \n      <span data-te-chip-close class=\"${e.chipCloseIcon}\">\n        ${t}\n      </span>\n  </div>`, Gs = \"chip\", fb = `te.${Gs}`, rh = \"data-te-chip-close\", lo = `[${rh}]`, mb = \"delete.te.chips\", gb = \"select.te.chip\", bb = '<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"1.5\" stroke=\"currentColor\" class=\"w-3 h-3\"> <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M6 18L18 6M6 6l12 12\" /></svg>', vb = {\n  text: \"string\",\n  closeIcon: \"boolean\",\n  img: \"object\",\n  iconSVG: \"string\"\n}, Tb = {\n  text: \"\",\n  closeIcon: !1,\n  img: { path: \"\", alt: \"\" },\n  iconSVG: bb\n}, Eb = {\n  icon: \"float-right pl-[8px] text-[16px] opacity-[.53] cursor-pointer fill-[#afafaf] hover:text-[#8b8b8b] transition-all duration-200 ease-in-out\",\n  chipElement: \"flex justify-between items-center h-[32px] leading-loose py-[5px] px-[12px] mr-4 my-[5px] text-[13px] font-normal text-[#4f4f4f] cursor-pointer bg-[#eceff1] dark:text-white dark:bg-neutral-600 rounded-[16px] transition-[opacity] duration-300 ease-linear [word-wrap: break-word] shadow-none normal-case hover:!shadow-none active:bg-[#cacfd1] inline-block font-medium leading-normal text-[#4f4f4f] text-center no-underline align-middle cursor-pointer select-none border-[.125rem] border-solid border-transparent py-1.5 px-3 text-xs rounded\",\n  chipCloseIcon: \"w-4 float-right pl-[8px] text-[16px] opacity-[.53] cursor-pointer fill-[#afafaf] hover:fill-[#8b8b8b] dark:fill-gray-400 dark:hover:fill-gray-100 transition-all duration-200 ease-in-out\"\n}, Cb = {\n  icon: \"string\",\n  chipElement: \"string\",\n  chipCloseIcon: \"string\"\n};\nclass _i {\n  constructor(t, e = {}, i) {\n    this._element = t, this._options = this._getConfig(e), this._classes = this._getClasses(i);\n  }\n  // Getters\n  static get NAME() {\n    return Gs;\n  }\n  // Public\n  init() {\n    this._appendCloseIcon(), this._handleDelete(), this._handleTextChip(), this._handleClickOnChip();\n  }\n  dispose() {\n    this._element = null, this._options = null, c.off(this._element, \"click\");\n  }\n  appendChip() {\n    const { text: t, closeIcon: e, iconSVG: i } = this._options;\n    return _b({ text: t, closeIcon: e, iconSVG: i }, this._classes);\n  }\n  // Private\n  _appendCloseIcon(t = this._element) {\n    if (!(d.find(lo, this._element).length > 0) && this._options.closeIcon) {\n      const e = $(\"span\");\n      e.classList = this._classes.icon, e.setAttribute(rh), e.innerHTML = this._options.iconSVG, t.insertAdjacentElement(\"beforeend\", e);\n    }\n  }\n  _handleClickOnChip() {\n    c.on(this._element, \"click\", (t) => {\n      const { textContent: e } = t.target, i = {};\n      i.tag = e.trim(), c.trigger(gb, { event: t, obj: i });\n    });\n  }\n  _handleDelete() {\n    d.find(\n      lo,\n      this._element\n    ).length !== 0 && c.on(this._element, \"click\", lo, () => {\n      c.trigger(this._element, mb), this._element.remove();\n    });\n  }\n  _handleTextChip() {\n    this._element.innerText === \"\" && (this._element.innerText = this._options.text);\n  }\n  _getConfig(t) {\n    const e = {\n      ...Tb,\n      ...h.getDataAttributes(this._element),\n      ...t\n    };\n    return D(Gs, e, vb), e;\n  }\n  _getClasses(t) {\n    const e = h.getDataClassAttributes(this._element);\n    return t = {\n      ...Eb,\n      ...e,\n      ...t\n    }, D(Gs, t, Cb), t;\n  }\n  static getInstance(t) {\n    return y.getData(t, fb);\n  }\n  static getOrCreateInstance(t, e = {}) {\n    return this.getInstance(t) || new this(t, typeof e == \"object\" ? e : null);\n  }\n}\nconst Li = \"chips\", Ki = `data-te-${Li}`, fl = `te.${Li}`, Ab = `${Ki}-input-init`, mt = `${Ki}-active`, ml = `${Ki}-initial`, ah = `${Ki}-placeholder`, yb = `${Ki}-input-wrapper`, Wo = \"data-te-chip-init\", lh = \"data-te-chip-close\", ch = \"data-te-chip-text\", wb = `[${mt}]`, Fo = `[${Wo}]`, kb = `${Fo}${wb}`, co = `[${lh}]`, xb = `[${yb}]`, Ob = `[${ch}]`, Sb = `[${ah}]`, Ib = \"data-te-input-notch-leading-ref\", Db = \"data-te-input-notch-middle-ref\", $b = `[${Ib}]`, Lb = `[${Db}]`, Se = \"data-te-input-state-active\", ho = \"[data-te-input-notch-ref]\", Nb = \"add.te.chips\", Mb = \"arrowDown.te.chips\", Rb = \"arrowLeft.te.chips\", Pb = \"arrowRight.te.chips\", Bb = \"arrowUp.te.chips\", gl = \"delete.te.chips\", bl = \"select.te.chips\", Hb = {\n  inputID: \"string\",\n  parentSelector: \"string\",\n  initialValues: \"array\",\n  editable: \"boolean\",\n  labelText: \"string\",\n  inputClasses: \"object\",\n  inputOptions: \"object\"\n}, Vb = {\n  inputID: rt(\"chips-input-\"),\n  parentSelector: \"\",\n  initialValues: [{ tag: \"init1\" }, { tag: \"init2\" }],\n  editable: !1,\n  labelText: \"Example label\",\n  inputClasses: {},\n  inputOptions: {}\n}, Wb = {\n  opacity: \"opacity-0\",\n  inputWrapperPadding: \"p-[5px]\",\n  transition: \"transition-all duration-300 ease-[cubic-bezier(0.25,0.1,0.25,1)]\",\n  contentEditable: \"outline-none !border-[3px] !border-solid !border-[#b2b3b4]\",\n  chipsInputWrapper: \"relative flex items-center flex-wrap transition-all duration-300 ease-[cubic-bezier(0.25,0.1,0.25,1)]\",\n  chipsInput: \"peer block min-h-[auto] w-[150px] rounded border-0 bg-transparent py-[0.32rem] px-3 leading-[1.6] outline-none transition-all duration-200 ease-linear focus:placeholder:opacity-100 data-[te-input-state-active]:placeholder:opacity-100 motion-reduce:transition-none dark:text-gray-200 dark:placeholder:text-gray-200 [&:not([data-te-input-placeholder-active])]:placeholder:opacity-0\",\n  chipsLabel: \"pointer-events-none absolute top-0 left-3 mb-0 max-w-[90%] origin-[0_0] truncate pt-[0.37rem] leading-[1.6] text-gray-500 transition-all duration-200 ease-out peer-focus:-translate-y-[0.9rem] peer-focus:scale-[0.8] peer-focus:text-primary peer-data-[te-input-state-active]:-translate-y-[0.9rem] peer-data-[te-input-state-active]:scale-[0.8] motion-reduce:transition-none dark:text-gray-200 dark:peer-focus:text-gray-200\"\n}, Fb = {\n  opacity: \"string\",\n  inputWrapperPadding: \"string\",\n  transition: \"string\",\n  contentEditable: \"string\",\n  chipsInputWrapper: \"string\",\n  chipsInput: \"string\",\n  chipsLabel: \"string\"\n};\nclass GC extends _i {\n  constructor(e, i = {}, n) {\n    super(e, i);\n    yt(this, \"_handleBlurInput\", ({ target: e }) => {\n      e.value.length > 0 && this._handleCreateChip(e, e.value), this.allChips.length > 0 ? (e.setAttribute(mt, \"\"), this.input.setAttribute(Se, \"\"), d.findOne(\n        ho,\n        this.input.parentNode\n      ).setAttribute(Se, \"\"), this.chipsInputWrapper.classList.add(\n        ...this._classes.inputWrapperPadding.split(\" \")\n      )) : (e.removeAttribute(mt), this.input.removeAttribute(Se), d.findOne(\n        ho,\n        this.input.parentNode\n      ).removeAttribute(Se), this.chipsInputWrapper.classList.remove(\n        ...this._classes.inputWrapperPadding.split(\" \")\n      )), this.allChips.forEach((i) => i.removeAttribute(mt));\n    });\n    this._element = e, this._inputInstance = null, this._element && y.setData(e, fl, this), this._options = this._getConfig(i), this._classes = this._getClasses(n), this.numberClicks = 0, this.init();\n  }\n  // Getters\n  static get NAME() {\n    return Li;\n  }\n  get activeChip() {\n    return d.findOne(kb, this._element);\n  }\n  get input() {\n    return d.findOne(\"input\", this._element);\n  }\n  get allChips() {\n    return d.find(Fo, this._element);\n  }\n  get chipsInputWrapper() {\n    return d.findOne(xb, this._element);\n  }\n  // Public\n  init() {\n    this._setChipsClass(), this._appendInputToElement(ah), this._handleInitialValue(), this._handleInputText(), this._handleKeyboard(), this._handleChipsOnSelect(), this._handleEditable(), this._handleChipsFocus(), this._handleClicksOnChips(), this._inputInstance._getLabelWidth(), this._inputInstance._applyNotch();\n  }\n  dispose() {\n    this._element = null, this._options = null;\n  }\n  // Private\n  _getNotchData() {\n    this._notchMiddle = d.findOne(\n      Lb,\n      this._element\n    ), this._notchLeading = d.findOne(\n      $b,\n      this._element\n    );\n  }\n  _setChipsClass() {\n    this._element.setAttribute(Ab, \"\");\n  }\n  _handleDeleteEvents(e) {\n    const [i] = this.allChips.slice(-1);\n    if (this.activeChip === null)\n      i.remove(), this._handleEvents(e, gl);\n    else {\n      const n = this.allChips.findIndex((a) => a === this.activeChip), o = this._handleActiveChipAfterRemove(n), r = [];\n      if (this.activeChip === null)\n        return;\n      this.activeChip.remove(), this._handleEvents(e, gl), this.numberClicks = n, o.setAttribute(mt, \"\"), this.allChips.forEach((a) => {\n        a.hasAttribute(mt) && (r.push(a), r.length > 1 && this.allChips.forEach((l) => l.remove()));\n      });\n    }\n  }\n  _handleUpEvents(e) {\n    this.numberClicks += 1, this.numberClicks === this.allChips.length + 1 && (this.numberClicks = 0), this._handleRightKeyboardArrow(this.numberClicks), this._handleEvents(e, Pb), this._handleEvents(e, Bb);\n  }\n  _handleDownEvents(e) {\n    this.numberClicks -= 1, this.numberClicks <= 0 && (this.numberClicks = this.allChips.length), this._handleLeftKeyboardArrow(this.numberClicks), this._handleEvents(e, Rb), this._handleEvents(e, Mb);\n  }\n  _keyboardEvents(e) {\n    const { target: i, keyCode: n, ctrlKey: o } = e;\n    i.value.length > 0 || this.allChips.length === 0 || (n === Nf || n === Mf ? this._handleDeleteEvents(e) : n === Ve || n === at ? this._handleUpEvents(e) : n === He || n === z ? this._handleDownEvents(e) : n === 65 && o && this._handleAddActiveClass());\n  }\n  _handleKeyboard() {\n    c.on(\n      this.input,\n      \"keydown\",\n      (e) => this._keyboardEvents(e)\n    );\n  }\n  _handleEditable() {\n    const { editable: e } = this._options;\n    e && this.allChips.forEach((i) => {\n      c.on(i, \"dblclick\", (n) => {\n        const o = d.findOne(co, i);\n        i.classList.add(...this._classes.contentEditable.split(\" \")), i.contentEditable = !0, i.focus(), setTimeout(() => {\n          h.addStyle(o, { display: \"none\" });\n        }, 200), o.classList.add(...this._classes.opacity.split(\" \")), n.target.textContent, c.trigger(i, bl, {\n          event: n,\n          allChips: this.allChips\n        });\n      }), c.on(document, \"click\", ({ target: n }) => {\n        const o = d.findOne(co, i), r = d.findOne(Ob, i), a = n === i, l = i && i.contains(n);\n        !a && !l && (i.contentEditable = !1, i.classList.remove(...this._classes.contentEditable.split(\" \")), r.textContent !== \"\" && setTimeout(() => {\n          h.addStyle(o, { display: \"block\" }), o.classList.remove(...this._classes.opacity.split(\" \"));\n        }, 160)), r.textContent === \"\" && (setTimeout(() => {\n          i.classList.add(...this._classes.opacity.split(\" \"));\n        }, 200), setTimeout(() => {\n          i.remove();\n        }, 300));\n      });\n    });\n  }\n  _handleRemoveActiveClass() {\n    this.allChips.forEach((e) => e.removeAttribute(mt));\n  }\n  _handleAddActiveClass() {\n    this.allChips.forEach((e) => e.setAttribute(mt, \"\"));\n  }\n  _handleRightKeyboardArrow(e) {\n    this._handleRemoveActiveClass(), e === 0 && (e = 1), this._handleAddActiveClassWithKebyboard(e);\n  }\n  _handleLeftKeyboardArrow(e) {\n    this._handleRemoveActiveClass(), this._handleAddActiveClassWithKebyboard(e);\n  }\n  _handleActiveChipAfterRemove(e) {\n    const i = e === 0 ? 1 : e - 1;\n    return this.allChips[i];\n  }\n  _handleClicksOnChips() {\n    c.on(this._element, \"click\", () => {\n      this.allChips.length === 0 && (this.chipsInputWrapper.classList.remove(\n        ...this._classes.inputWrapperPadding.split(\" \")\n      ), this.input.removeAttribute(mt));\n    });\n  }\n  _handleTextContent() {\n    const e = [];\n    return this.allChips.forEach((i) => e.push({ tag: i.textContent.trim() })), e;\n  }\n  _handleEvents(e, i) {\n    const n = this._handleTextContent(), o = this.allChips.filter(\n      (r) => r.hasAttribute(mt) && r\n    );\n    c.trigger(this._element, i, {\n      event: e,\n      allChips: this.allChips,\n      arrOfObjects: n,\n      active: o,\n      activeObj: {\n        tag: o.length <= 0 ? \"\" : o[0].textContent.trim()\n      }\n    });\n  }\n  _handleChipsFocus() {\n    c.on(this._element, \"click\", ({ target: { attributes: e } }) => {\n      const i = [...e];\n      i.includes(Wo) || i.includes(lh) || i.includes(ch) || this.input.focus();\n    });\n  }\n  _handleInitialValue() {\n    if (this._appendInputToElement(ml), this._element.hasAttribute(ml)) {\n      const { initialValues: e } = this._options;\n      e.forEach(\n        ({ tag: i }) => this._handleCreateChip(this.input, i)\n      ), d.findOne(\n        ho,\n        this.input.parentNode\n      ).setAttribute(Se, \"\"), this.input.setAttribute(mt, \"\"), this.input.setAttribute(Se, \"\");\n    }\n    this.allChips.length > 0 && (this.chipsInputWrapper.classList.add(\n      ...this._classes.inputWrapperPadding.split(\" \")\n    ), this.chipsInputWrapper.classList.add(\n      ...this._classes.transition.split(\" \")\n    ));\n  }\n  _handleKeysInputToElement(e) {\n    const { keyCode: i, target: n } = e;\n    if (n.hasAttribute(Wo)) {\n      const o = d.findOne(co, n);\n      i === ct && (n.contentEditable = !1, n.classList.remove(...this._classes.contentEditable.split(\" \")), n.textContent !== \"\" ? setTimeout(() => {\n        h.addStyle(o, { display: \"block\" }), o.classList.remove(...this._classes.opacity.split(\" \"));\n      }, 160) : n.textContent === \"\" && (setTimeout(() => {\n        n.classList.add(...this._classes.opacity.split(\" \"));\n      }, 200), setTimeout(() => {\n        n.remove();\n      }, 300)));\n      return;\n    }\n    if (i === ct) {\n      if (n.value === \"\")\n        return;\n      this._handleCreateChip(n, n.value), this._handleRemoveActiveClass(), this.numberClicks = this.allChips.length + 1, this._handleEvents(e, Nb);\n    }\n    this.allChips.length > 0 ? (this.chipsInputWrapper.classList.add(\n      ...this._classes.inputWrapperPadding.split(\" \")\n    ), this.chipsInputWrapper.classList.add(\n      ...this._classes.transition.split(\" \")\n    )) : this.chipsInputWrapper.classList.remove(\n      ...this._classes.inputWrapperPadding.split(\" \")\n    );\n  }\n  _handleInputText() {\n    const e = d.findOne(\n      Sb,\n      this._element\n    );\n    c.on(\n      this._element,\n      \"keyup\",\n      e,\n      (i) => this._handleKeysInputToElement(i)\n    ), c.on(this.input, \"blur\", (i) => this._handleBlurInput(i));\n  }\n  _appendInputToElement(e) {\n    if (!this._element.hasAttribute(e))\n      return;\n    const i = pb(this._options, this._classes);\n    this._element.insertAdjacentHTML(\"beforeend\", i);\n    const n = d.findOne(\n      \"[data-te-chips-input-wrapper]\",\n      this._element\n    );\n    this._inputInstance = new V(\n      n,\n      this._options.inputOptions,\n      this._options.inputClasses\n    );\n  }\n  _handleCreateChip(e, i) {\n    const n = $(\"div\"), o = _i.getInstance(n), r = new _i(o, { text: i }, this._classes);\n    this._options.parentSelector !== \"\" ? document.querySelector(this._options.parentSelector).insertAdjacentHTML(\"beforeend\", r.appendChip()) : e.insertAdjacentHTML(\"beforebegin\", r.appendChip()), e.value = \"\", d.find(Fo).forEach((a) => {\n      let l = _i.getInstance(a);\n      return l || (l = new _i(a, {}, this._classes)), l.init();\n    }), this._handleEditable();\n  }\n  _handleChipsOnSelect() {\n    this.allChips.forEach((e) => {\n      c.on(this._element, \"click\", (i) => {\n        c.trigger(e, bl, {\n          event: i,\n          allChips: this.allChips\n        });\n      });\n    });\n  }\n  _handleAddActiveClassWithKebyboard(e) {\n    let i;\n    this.allChips[e - 1] === void 0 ? i = this.allChips[e - 2] : i = this.allChips[e - 1], i.setAttribute(mt);\n  }\n  _getConfig(e) {\n    const i = {\n      ...Vb,\n      ...h.getDataAttributes(this._element),\n      ...e\n    };\n    return D(Li, i, Hb), i;\n  }\n  _getClasses(e) {\n    const i = h.getDataClassAttributes(this._element);\n    return e = {\n      ...Wb,\n      ...i,\n      ...e\n    }, D(Li, e, Fb), e;\n  }\n  static getInstance(e) {\n    return y.getData(e, fl);\n  }\n  static getOrCreateInstance(e, i = {}) {\n    return this.getInstance(e) || new this(e, typeof i == \"object\" ? i : null);\n  }\n}\nconst zt = {\n  plugins: {\n    legend: {\n      labels: {\n        color: \"rgb(102,102,102)\"\n      }\n    }\n  }\n}, Ti = {\n  line: {\n    options: {\n      ...zt,\n      elements: {\n        line: {\n          backgroundColor: \"rgba(59, 112, 202, 0.0)\",\n          borderColor: \"rgb(59, 112, 202)\",\n          borderWidth: 2,\n          tension: 0\n        },\n        point: {\n          borderColor: \"rgb(59, 112, 202)\",\n          backgroundColor: \"rgb(59, 112, 202)\"\n        }\n      },\n      responsive: !0,\n      legend: {\n        display: !0\n      },\n      tooltips: {\n        intersect: !1,\n        mode: \"index\"\n      },\n      datasets: {\n        borderColor: \"red\"\n      },\n      scales: {\n        x: {\n          stacked: !0,\n          grid: {\n            display: !1\n          },\n          ticks: {\n            fontColor: \"rgba(0,0,0, 0.5)\"\n          }\n        },\n        y: {\n          stacked: !1,\n          grid: {\n            borderDash: [2],\n            drawBorder: !1,\n            zeroLineColor: \"rgba(0,0,0,0)\",\n            zeroLineBorderDash: [2],\n            zeroLineBorderDashOffset: [2]\n          },\n          ticks: {\n            fontColor: \"rgba(0,0,0, 0.5)\"\n          }\n        }\n      }\n    }\n  },\n  bar: {\n    options: {\n      ...zt,\n      backgroundColor: \"rgb(59, 112, 202)\",\n      borderWidth: 0,\n      responsive: !0,\n      legend: {\n        display: !0\n      },\n      tooltips: {\n        intersect: !1,\n        mode: \"index\"\n      },\n      scales: {\n        x: {\n          stacked: !0,\n          grid: {\n            display: !1\n          },\n          ticks: {\n            fontColor: \"rgba(0,0,0, 0.5)\"\n          }\n        },\n        y: {\n          stacked: !0,\n          grid: {\n            borderDash: [2],\n            drawBorder: !1,\n            zeroLineColor: \"rgba(0,0,0,0)\",\n            zeroLineBorderDash: [2],\n            zeroLineBorderDashOffset: [2]\n          },\n          ticks: {\n            fontColor: \"rgba(0,0,0, 0.5)\"\n          }\n        }\n      }\n    }\n  },\n  pie: {\n    options: {\n      ...zt,\n      elements: {\n        arc: { backgroundColor: \"rgb(59, 112, 202)\" }\n      },\n      responsive: !0,\n      legend: {\n        display: !0\n      }\n    }\n  },\n  doughnut: {\n    options: {\n      ...zt,\n      elements: {\n        arc: { backgroundColor: \"rgb(59, 112, 202)\" }\n      },\n      responsive: !0,\n      legend: {\n        display: !0\n      }\n    }\n  },\n  polarArea: {\n    options: {\n      ...zt,\n      elements: {\n        arc: { backgroundColor: \"rgba(59, 112, 202, 0.5)\" }\n      },\n      responsive: !0,\n      legend: {\n        display: !0\n      }\n    }\n  },\n  radar: {\n    options: {\n      ...zt,\n      elements: {\n        line: {\n          backgroundColor: \"rgba(59, 112, 202, 0.5)\",\n          borderColor: \"rgb(59, 112, 202)\",\n          borderWidth: 2\n        },\n        point: {\n          borderColor: \"rgb(59, 112, 202)\",\n          backgroundColor: \"rgb(59, 112, 202)\"\n        }\n      },\n      responsive: !0,\n      legend: {\n        display: !0\n      }\n    }\n  },\n  scatter: {\n    options: {\n      ...zt,\n      elements: {\n        line: {\n          backgroundColor: \"rgba(59, 112, 202, 0.5)\",\n          borderColor: \"rgb(59, 112, 202)\",\n          borderWidth: 2,\n          tension: 0\n        },\n        point: {\n          borderColor: \"rgb(59, 112, 202)\",\n          backgroundColor: \"rgba(59, 112, 202, 0.5)\"\n        }\n      },\n      responsive: !0,\n      legend: {\n        display: !0\n      },\n      tooltips: {\n        intersect: !1,\n        mode: \"index\"\n      },\n      datasets: {\n        borderColor: \"red\"\n      },\n      scales: {\n        x: {\n          stacked: !0,\n          grid: {\n            display: !1\n          },\n          ticks: {\n            fontColor: \"rgba(0,0,0, 0.5)\"\n          }\n        },\n        y: {\n          stacked: !1,\n          grid: {\n            borderDash: [2],\n            drawBorder: !1,\n            zeroLineColor: \"rgba(0,0,0,0)\",\n            zeroLineBorderDash: [2],\n            zeroLineBorderDashOffset: [2]\n          },\n          ticks: {\n            fontColor: \"rgba(0,0,0, 0.5)\"\n          }\n        }\n      }\n    }\n  },\n  bubble: {\n    options: {\n      ...zt,\n      elements: {\n        point: {\n          borderColor: \"rgb(59, 112, 202)\",\n          backgroundColor: \"rgba(59, 112, 202, 0.5)\"\n        }\n      },\n      responsive: !0,\n      legend: {\n        display: !0\n      },\n      scales: {\n        x: {\n          grid: {\n            display: !1\n          },\n          ticks: {\n            fontColor: \"rgba(0,0,0, 0.5)\"\n          }\n        },\n        y: {\n          grid: {\n            borderDash: [2],\n            drawBorder: !1,\n            zeroLineColor: \"rgba(0,0,0,0)\",\n            zeroLineBorderDash: [2],\n            zeroLineBorderDashOffset: [2]\n          },\n          ticks: {\n            fontColor: \"rgba(0,0,0, 0.5)\"\n          }\n        }\n      }\n    }\n  }\n};\nvar Yb = function(t) {\n  return jb(t) && !Kb(t);\n};\nfunction jb(s) {\n  return !!s && typeof s == \"object\";\n}\nfunction Kb(s) {\n  var t = Object.prototype.toString.call(s);\n  return t === \"[object RegExp]\" || t === \"[object Date]\" || Xb(s);\n}\nvar zb = typeof Symbol == \"function\" && Symbol.for, Ub = zb ? Symbol.for(\"react.element\") : 60103;\nfunction Xb(s) {\n  return s.$$typeof === Ub;\n}\nfunction Gb(s) {\n  return Array.isArray(s) ? [] : {};\n}\nfunction Bi(s, t) {\n  return t.clone !== !1 && t.isMergeableObject(s) ? Qe(Gb(s), s, t) : s;\n}\nfunction qb(s, t, e) {\n  return s.concat(t).map(function(i) {\n    return Bi(i, e);\n  });\n}\nfunction Zb(s, t) {\n  if (!t.customMerge)\n    return Qe;\n  var e = t.customMerge(s);\n  return typeof e == \"function\" ? e : Qe;\n}\nfunction Qb(s) {\n  return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(s).filter(function(t) {\n    return Object.propertyIsEnumerable.call(s, t);\n  }) : [];\n}\nfunction vl(s) {\n  return Object.keys(s).concat(Qb(s));\n}\nfunction hh(s, t) {\n  try {\n    return t in s;\n  } catch {\n    return !1;\n  }\n}\nfunction Jb(s, t) {\n  return hh(s, t) && !(Object.hasOwnProperty.call(s, t) && Object.propertyIsEnumerable.call(s, t));\n}\nfunction tv(s, t, e) {\n  var i = {};\n  return e.isMergeableObject(s) && vl(s).forEach(function(n) {\n    i[n] = Bi(s[n], e);\n  }), vl(t).forEach(function(n) {\n    Jb(s, n) || (hh(s, n) && e.isMergeableObject(t[n]) ? i[n] = Zb(n, e)(s[n], t[n], e) : i[n] = Bi(t[n], e));\n  }), i;\n}\nfunction Qe(s, t, e) {\n  e = e || {}, e.arrayMerge = e.arrayMerge || qb, e.isMergeableObject = e.isMergeableObject || Yb, e.cloneUnlessOtherwiseSpecified = Bi;\n  var i = Array.isArray(t), n = Array.isArray(s), o = i === n;\n  return o ? i ? e.arrayMerge(s, t, e) : tv(s, t, e) : Bi(t, e);\n}\nQe.all = function(t, e) {\n  if (!Array.isArray(t))\n    throw new Error(\"first argument should be an array\");\n  return t.reduce(function(i, n) {\n    return Qe(i, n, e);\n  }, {});\n};\nvar ev = Qe, Yo = ev;\nconst Tl = \"chart\", ys = \"te.chart\", iv = \"chart\", uo = (s, t, e) => {\n  const i = (n, o, r) => {\n    const a = n.slice();\n    return o.forEach((l, p) => {\n      typeof a[p] > \"u\" ? a[p] = r.cloneUnlessOtherwiseSpecified(\n        l,\n        r\n      ) : r.isMergeableObject(l) ? a[p] = Yo(n[p], l, r) : n.indexOf(l) === -1 && a.push(l);\n    }), a;\n  };\n  return Yo(e[t], s, {\n    arrayMerge: i\n  });\n}, sv = {\n  darkTicksColor: \"#fff\",\n  darkLabelColor: \"#fff\",\n  darkGridLinesColor: \"#555\",\n  darkmodeOff: \"undefined\",\n  darkMode: null,\n  darkBgColor: \"#262626\",\n  darkBgColorLight: \"#fff\",\n  options: null\n}, nv = {\n  darkTicksColor: \"string\",\n  darkLabelColor: \"string\",\n  darkGridLinesColor: \"string\",\n  darkmodeOff: \"(string|null)\",\n  darkMode: \"(string|null)\",\n  darkBgColor: \"string\",\n  darkBgColorLight: \"string\",\n  options: \"(object|null)\"\n};\nclass dh {\n  constructor(t, e, i = {}, n = {}) {\n    this._waitForCharts(t, e, i, n);\n  }\n  async _getChartjs() {\n    const {\n      Chart: t,\n      ArcElement: e,\n      LineElement: i,\n      BarElement: n,\n      PointElement: o,\n      BarController: r,\n      BubbleController: a,\n      DoughnutController: l,\n      LineController: p,\n      PieController: u,\n      PolarAreaController: _,\n      RadarController: f,\n      ScatterController: g,\n      CategoryScale: m,\n      LinearScale: b,\n      LogarithmicScale: v,\n      RadialLinearScale: C,\n      TimeScale: w,\n      TimeSeriesScale: E,\n      Decimation: T,\n      Filler: A,\n      Legend: k,\n      Title: I,\n      Tooltip: O,\n      SubTitle: x\n    } = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_tw-elements_dist_js_chart_es_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./chart.es.js */ \"(app-pages-browser)/./node_modules/tw-elements/dist/js/chart.es.js\")).then((L) => L.f);\n    return t.register(\n      e,\n      i,\n      n,\n      o,\n      r,\n      a,\n      l,\n      p,\n      u,\n      _,\n      f,\n      g,\n      m,\n      b,\n      v,\n      C,\n      w,\n      E,\n      T,\n      A,\n      k,\n      I,\n      O,\n      x\n    ), t;\n  }\n  async _getChartDataLabels() {\n    return await __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_tw-elements_dist_js_chartjs-plugin-datalabels_es_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./chartjs-plugin-datalabels.es.js */ \"(app-pages-browser)/./node_modules/tw-elements/dist/js/chartjs-plugin-datalabels.es.js\"));\n  }\n  async _waitForCharts(t, e, i = {}, n = {}) {\n    if (this._Chartjs = await this._getChartjs(), this._ChartDataLabels = await this._getChartDataLabels(), this._element = t, this._data = e, this._options = i, this._type = e.type, this._canvas = null, this._chart = null, this._darkOptions = this._getDarkConfig(n), this._darkModeClassContainer = document.querySelector(\"html\"), this._prevConfig = null, this._observer = null, this._element && (y.setData(t, ys, this), h.addClass(this._element, iv), this._chartConstructor()), this._darkOptions.darkmodeOff !== null) {\n      const o = this._darkOptions.darkMode === \"dark\" ? \"dark\" : this._darkOptions.darkMode === \"light\" ? \"light\" : this.systemColorMode;\n      this._handleMode(o), this._observer = new MutationObserver(this._observerCallback.bind(this)), this._observer.observe(this._darkModeClassContainer, {\n        attributes: !0\n      });\n    }\n  }\n  // Getters\n  static get NAME() {\n    return Tl;\n  }\n  get systemColorMode() {\n    return localStorage.theme || (this._darkModeClassContainer.classList.contains(\"dark\") ? \"dark\" : \"light\");\n  }\n  // Public\n  dispose() {\n    this._observer.disconnect(), y.removeData(this._element, ys), this._element = null;\n  }\n  update(t, e) {\n    t && (this._data = { ...this._data, ...t }, this._chart.data = this._data);\n    const i = Object.prototype.hasOwnProperty.call(\n      e,\n      \"options\"\n    ) ? e : { options: { ...e } };\n    this._options = Yo(this._options, i), this._chart.options = uo(\n      this._options,\n      this._type,\n      Ti\n    ).options, this._chart.update();\n  }\n  setTheme(t) {\n    t !== \"dark\" && t !== \"light\" || !this._data || this._handleMode(t);\n  }\n  // Private\n  _getDarkConfig(t) {\n    let e = {};\n    const i = h.getDataAttributes(this._element);\n    Object.keys(i).forEach(\n      (p) => p.startsWith(\"dark\") && (e[p] = i[p])\n    ), e = {\n      ...sv,\n      ...e\n    };\n    const n = {\n      y: {\n        ticks: {\n          color: e.darkTicksColor\n        },\n        grid: {\n          color: e.darkGridLinesColor\n        }\n      },\n      x: {\n        ticks: {\n          color: e.darkTicksColor\n        },\n        grid: {\n          color: e.darkGridLinesColor\n        }\n      }\n    }, o = {\n      r: {\n        ticks: {\n          color: e.darkTicksColor,\n          backdropColor: e.darkBgColor\n        },\n        grid: {\n          color: e.darkGridLinesColor\n        },\n        pointLabels: {\n          color: e.darkTicksColor\n        }\n      }\n    }, l = {\n      scales: [\"pie\", \"doughnut\", \"polarArea\", \"radar\"].includes(this._type) ? [\"polarArea\", \"radar\"].includes(this._type) ? o : {} : n,\n      plugins: {\n        legend: {\n          labels: {\n            color: e.darkLabelColor\n          }\n        }\n      }\n    };\n    return t = {\n      ...e,\n      options: {\n        ...l\n      },\n      ...t\n    }, D(Tl, t, nv), t;\n  }\n  _chartConstructor() {\n    if (this._data) {\n      this._createCanvas();\n      const t = uo(this._options, this._type, Ti), e = [];\n      t.dataLabelsPlugin && e.push(this._ChartDataLabels.default), this._prevConfig = t, this._chart = new this._Chartjs(this._canvas, {\n        ...this._data,\n        ...t,\n        plugins: e\n      });\n    }\n  }\n  _createCanvas() {\n    this._canvas || (this._element.nodeName === \"CANVAS\" ? this._canvas = this._element : (this._canvas = $(\"canvas\"), this._element.appendChild(this._canvas)));\n  }\n  _handleMode(t) {\n    t === \"dark\" ? (this._changeDatasetBorderColor(), this.update(null, this._darkOptions.options)) : (this._changeDatasetBorderColor(!1), this._prevConfig && this.update(null, this._prevConfig));\n  }\n  _observerCallback(t) {\n    for (const e of t)\n      e.type === \"attributes\" && this._handleMode(this.systemColorMode);\n  }\n  _changeDatasetBorderColor(t = !0) {\n    [...this._data.data.datasets].forEach(\n      (e) => [\"pie\", \"doughnut\", \"polarArea\"].includes(this._type) && (e.borderColor = t ? this._darkOptions.darkBgColor : this._darkOptions.darkBgColorLight)\n    );\n  }\n  static jQueryInterface(t, e, i) {\n    return this.each(function() {\n      let n = y.getData(this, ys);\n      if (!(!n && /dispose/.test(t))) {\n        if (!n) {\n          const o = e ? uo(e, i, Ti) : Ti[i];\n          n = new dh(this, {\n            ...t,\n            ...o\n          });\n        }\n        if (typeof t == \"string\") {\n          if (typeof n[t] > \"u\")\n            throw new TypeError(`No method named \"${t}\"`);\n          n[t](e, i);\n        }\n      }\n    });\n  }\n  static getInstance(t) {\n    return y.getData(t, ys);\n  }\n  static getOrCreateInstance(t, e = {}) {\n    return this.getInstance(t) || new this(t, typeof e == \"object\" ? e : null);\n  }\n}\n/*!\n * perfect-scrollbar v1.5.3\n * Copyright 2021 Hyunje Jun, MDBootstrap and Contributors\n * Licensed under MIT\n */\nfunction Lt(s) {\n  return getComputedStyle(s);\n}\nfunction ot(s, t) {\n  for (var e in t) {\n    var i = t[e];\n    typeof i == \"number\" && (i = i + \"px\"), s.style[e] = i;\n  }\n  return s;\n}\nfunction ws(s) {\n  var t = document.createElement(\"div\");\n  return t.className = s, t;\n}\nvar El = typeof Element < \"u\" && (Element.prototype.matches || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector);\nfunction Qt(s, t) {\n  if (!El)\n    throw new Error(\"No element matching method supported\");\n  return El.call(s, t);\n}\nfunction Pe(s) {\n  s.remove ? s.remove() : s.parentNode && s.parentNode.removeChild(s);\n}\nfunction Cl(s, t) {\n  return Array.prototype.filter.call(\n    s.children,\n    function(e) {\n      return Qt(e, t);\n    }\n  );\n}\nvar j = {\n  main: \"ps\",\n  rtl: \"ps__rtl\",\n  element: {\n    thumb: function(s) {\n      return \"ps__thumb-\" + s;\n    },\n    rail: function(s) {\n      return \"ps__rail-\" + s;\n    },\n    consuming: \"ps__child--consume\"\n  },\n  state: {\n    focus: \"ps--focus\",\n    clicking: \"ps--clicking\",\n    active: function(s) {\n      return \"ps--active-\" + s;\n    },\n    scrolling: function(s) {\n      return \"ps--scrolling-\" + s;\n    }\n  }\n}, uh = { x: null, y: null };\nfunction ph(s, t) {\n  var e = s.element.classList, i = j.state.scrolling(t);\n  e.contains(i) ? clearTimeout(uh[t]) : e.add(i);\n}\nfunction _h(s, t) {\n  uh[t] = setTimeout(\n    function() {\n      return s.isAlive && s.element.classList.remove(j.state.scrolling(t));\n    },\n    s.settings.scrollingThreshold\n  );\n}\nfunction ov(s, t) {\n  ph(s, t), _h(s, t);\n}\nvar zi = function(t) {\n  this.element = t, this.handlers = {};\n}, fh = { isEmpty: { configurable: !0 } };\nzi.prototype.bind = function(t, e) {\n  typeof this.handlers[t] > \"u\" && (this.handlers[t] = []), this.handlers[t].push(e), this.element.addEventListener(t, e, !1);\n};\nzi.prototype.unbind = function(t, e) {\n  var i = this;\n  this.handlers[t] = this.handlers[t].filter(function(n) {\n    return e && n !== e ? !0 : (i.element.removeEventListener(t, n, !1), !1);\n  });\n};\nzi.prototype.unbindAll = function() {\n  for (var t in this.handlers)\n    this.unbind(t);\n};\nfh.isEmpty.get = function() {\n  var s = this;\n  return Object.keys(this.handlers).every(\n    function(t) {\n      return s.handlers[t].length === 0;\n    }\n  );\n};\nObject.defineProperties(zi.prototype, fh);\nvar si = function() {\n  this.eventElements = [];\n};\nsi.prototype.eventElement = function(t) {\n  var e = this.eventElements.filter(function(i) {\n    return i.element === t;\n  })[0];\n  return e || (e = new zi(t), this.eventElements.push(e)), e;\n};\nsi.prototype.bind = function(t, e, i) {\n  this.eventElement(t).bind(e, i);\n};\nsi.prototype.unbind = function(t, e, i) {\n  var n = this.eventElement(t);\n  n.unbind(e, i), n.isEmpty && this.eventElements.splice(this.eventElements.indexOf(n), 1);\n};\nsi.prototype.unbindAll = function() {\n  this.eventElements.forEach(function(t) {\n    return t.unbindAll();\n  }), this.eventElements = [];\n};\nsi.prototype.once = function(t, e, i) {\n  var n = this.eventElement(t), o = function(r) {\n    n.unbind(e, o), i(r);\n  };\n  n.bind(e, o);\n};\nfunction ks(s) {\n  if (typeof window.CustomEvent == \"function\")\n    return new CustomEvent(s);\n  var t = document.createEvent(\"CustomEvent\");\n  return t.initCustomEvent(s, !1, !1, void 0), t;\n}\nfunction on(s, t, e, i, n) {\n  i === void 0 && (i = !0), n === void 0 && (n = !1);\n  var o;\n  if (t === \"top\")\n    o = [\n      \"contentHeight\",\n      \"containerHeight\",\n      \"scrollTop\",\n      \"y\",\n      \"up\",\n      \"down\"\n    ];\n  else if (t === \"left\")\n    o = [\n      \"contentWidth\",\n      \"containerWidth\",\n      \"scrollLeft\",\n      \"x\",\n      \"left\",\n      \"right\"\n    ];\n  else\n    throw new Error(\"A proper axis should be provided\");\n  rv(s, e, o, i, n);\n}\nfunction rv(s, t, e, i, n) {\n  var o = e[0], r = e[1], a = e[2], l = e[3], p = e[4], u = e[5];\n  i === void 0 && (i = !0), n === void 0 && (n = !1);\n  var _ = s.element;\n  s.reach[l] = null, _[a] < 1 && (s.reach[l] = \"start\"), _[a] > s[o] - s[r] - 1 && (s.reach[l] = \"end\"), t && (_.dispatchEvent(ks(\"ps-scroll-\" + l)), t < 0 ? _.dispatchEvent(ks(\"ps-scroll-\" + p)) : t > 0 && _.dispatchEvent(ks(\"ps-scroll-\" + u)), i && ov(s, l)), s.reach[l] && (t || n) && _.dispatchEvent(ks(\"ps-\" + l + \"-reach-\" + s.reach[l]));\n}\nfunction W(s) {\n  return parseInt(s, 10) || 0;\n}\nfunction av(s) {\n  return Qt(s, \"input,[contenteditable]\") || Qt(s, \"select,[contenteditable]\") || Qt(s, \"textarea,[contenteditable]\") || Qt(s, \"button,[contenteditable]\");\n}\nfunction lv(s) {\n  var t = Lt(s);\n  return W(t.width) + W(t.paddingLeft) + W(t.paddingRight) + W(t.borderLeftWidth) + W(t.borderRightWidth);\n}\nvar Ne = {\n  isWebKit: typeof document < \"u\" && \"WebkitAppearance\" in document.documentElement.style,\n  supportsTouch: typeof window < \"u\" && (\"ontouchstart\" in window || \"maxTouchPoints\" in window.navigator && window.navigator.maxTouchPoints > 0 || window.DocumentTouch && document instanceof window.DocumentTouch),\n  supportsIePointer: typeof navigator < \"u\" && navigator.msMaxTouchPoints,\n  isChrome: typeof navigator < \"u\" && /Chrome/i.test(navigator && navigator.userAgent)\n};\nfunction Bt(s) {\n  var t = s.element, e = Math.floor(t.scrollTop), i = t.getBoundingClientRect();\n  s.containerWidth = Math.round(i.width), s.containerHeight = Math.round(i.height), s.contentWidth = t.scrollWidth, s.contentHeight = t.scrollHeight, t.contains(s.scrollbarXRail) || (Cl(t, j.element.rail(\"x\")).forEach(\n    function(n) {\n      return Pe(n);\n    }\n  ), t.appendChild(s.scrollbarXRail)), t.contains(s.scrollbarYRail) || (Cl(t, j.element.rail(\"y\")).forEach(\n    function(n) {\n      return Pe(n);\n    }\n  ), t.appendChild(s.scrollbarYRail)), !s.settings.suppressScrollX && s.containerWidth + s.settings.scrollXMarginOffset < s.contentWidth ? (s.scrollbarXActive = !0, s.railXWidth = s.containerWidth - s.railXMarginWidth, s.railXRatio = s.containerWidth / s.railXWidth, s.scrollbarXWidth = Al(\n    s,\n    W(s.railXWidth * s.containerWidth / s.contentWidth)\n  ), s.scrollbarXLeft = W(\n    (s.negativeScrollAdjustment + t.scrollLeft) * (s.railXWidth - s.scrollbarXWidth) / (s.contentWidth - s.containerWidth)\n  )) : s.scrollbarXActive = !1, !s.settings.suppressScrollY && s.containerHeight + s.settings.scrollYMarginOffset < s.contentHeight ? (s.scrollbarYActive = !0, s.railYHeight = s.containerHeight - s.railYMarginHeight, s.railYRatio = s.containerHeight / s.railYHeight, s.scrollbarYHeight = Al(\n    s,\n    W(s.railYHeight * s.containerHeight / s.contentHeight)\n  ), s.scrollbarYTop = W(\n    e * (s.railYHeight - s.scrollbarYHeight) / (s.contentHeight - s.containerHeight)\n  )) : s.scrollbarYActive = !1, s.scrollbarXLeft >= s.railXWidth - s.scrollbarXWidth && (s.scrollbarXLeft = s.railXWidth - s.scrollbarXWidth), s.scrollbarYTop >= s.railYHeight - s.scrollbarYHeight && (s.scrollbarYTop = s.railYHeight - s.scrollbarYHeight), cv(t, s), s.scrollbarXActive ? t.classList.add(j.state.active(\"x\")) : (t.classList.remove(j.state.active(\"x\")), s.scrollbarXWidth = 0, s.scrollbarXLeft = 0, t.scrollLeft = s.isRtl === !0 ? s.contentWidth : 0), s.scrollbarYActive ? t.classList.add(j.state.active(\"y\")) : (t.classList.remove(j.state.active(\"y\")), s.scrollbarYHeight = 0, s.scrollbarYTop = 0, t.scrollTop = 0);\n}\nfunction Al(s, t) {\n  return s.settings.minScrollbarLength && (t = Math.max(t, s.settings.minScrollbarLength)), s.settings.maxScrollbarLength && (t = Math.min(t, s.settings.maxScrollbarLength)), t;\n}\nfunction cv(s, t) {\n  var e = { width: t.railXWidth }, i = Math.floor(s.scrollTop);\n  t.isRtl ? e.left = t.negativeScrollAdjustment + s.scrollLeft + t.containerWidth - t.contentWidth : e.left = s.scrollLeft, t.isScrollbarXUsingBottom ? e.bottom = t.scrollbarXBottom - i : e.top = t.scrollbarXTop + i, ot(t.scrollbarXRail, e);\n  var n = { top: i, height: t.railYHeight };\n  t.isScrollbarYUsingRight ? t.isRtl ? n.right = t.contentWidth - (t.negativeScrollAdjustment + s.scrollLeft) - t.scrollbarYRight - t.scrollbarYOuterWidth - 9 : n.right = t.scrollbarYRight - s.scrollLeft : t.isRtl ? n.left = t.negativeScrollAdjustment + s.scrollLeft + t.containerWidth * 2 - t.contentWidth - t.scrollbarYLeft - t.scrollbarYOuterWidth : n.left = t.scrollbarYLeft + s.scrollLeft, ot(t.scrollbarYRail, n), ot(t.scrollbarX, {\n    left: t.scrollbarXLeft,\n    width: t.scrollbarXWidth - t.railBorderXWidth\n  }), ot(t.scrollbarY, {\n    top: t.scrollbarYTop,\n    height: t.scrollbarYHeight - t.railBorderYWidth\n  });\n}\nfunction hv(s) {\n  s.element, s.event.bind(s.scrollbarY, \"mousedown\", function(t) {\n    return t.stopPropagation();\n  }), s.event.bind(s.scrollbarYRail, \"mousedown\", function(t) {\n    var e = t.pageY - window.pageYOffset - s.scrollbarYRail.getBoundingClientRect().top, i = e > s.scrollbarYTop ? 1 : -1;\n    s.element.scrollTop += i * s.containerHeight, Bt(s), t.stopPropagation();\n  }), s.event.bind(s.scrollbarX, \"mousedown\", function(t) {\n    return t.stopPropagation();\n  }), s.event.bind(s.scrollbarXRail, \"mousedown\", function(t) {\n    var e = t.pageX - window.pageXOffset - s.scrollbarXRail.getBoundingClientRect().left, i = e > s.scrollbarXLeft ? 1 : -1;\n    s.element.scrollLeft += i * s.containerWidth, Bt(s), t.stopPropagation();\n  });\n}\nfunction dv(s) {\n  yl(s, [\n    \"containerWidth\",\n    \"contentWidth\",\n    \"pageX\",\n    \"railXWidth\",\n    \"scrollbarX\",\n    \"scrollbarXWidth\",\n    \"scrollLeft\",\n    \"x\",\n    \"scrollbarXRail\"\n  ]), yl(s, [\n    \"containerHeight\",\n    \"contentHeight\",\n    \"pageY\",\n    \"railYHeight\",\n    \"scrollbarY\",\n    \"scrollbarYHeight\",\n    \"scrollTop\",\n    \"y\",\n    \"scrollbarYRail\"\n  ]);\n}\nfunction yl(s, t) {\n  var e = t[0], i = t[1], n = t[2], o = t[3], r = t[4], a = t[5], l = t[6], p = t[7], u = t[8], _ = s.element, f = null, g = null, m = null;\n  function b(w) {\n    w.touches && w.touches[0] && (w[n] = w.touches[0].pageY), _[l] = f + m * (w[n] - g), ph(s, p), Bt(s), w.stopPropagation(), w.type.startsWith(\"touch\") && w.changedTouches.length > 1 && w.preventDefault();\n  }\n  function v() {\n    _h(s, p), s[u].classList.remove(j.state.clicking), s.event.unbind(s.ownerDocument, \"mousemove\", b);\n  }\n  function C(w, E) {\n    f = _[l], E && w.touches && (w[n] = w.touches[0].pageY), g = w[n], m = (s[i] - s[e]) / (s[o] - s[a]), E ? s.event.bind(s.ownerDocument, \"touchmove\", b) : (s.event.bind(s.ownerDocument, \"mousemove\", b), s.event.once(s.ownerDocument, \"mouseup\", v), w.preventDefault()), s[u].classList.add(j.state.clicking), w.stopPropagation();\n  }\n  s.event.bind(s[r], \"mousedown\", function(w) {\n    C(w);\n  }), s.event.bind(s[r], \"touchstart\", function(w) {\n    C(w, !0);\n  });\n}\nfunction uv(s) {\n  var t = s.element, e = function() {\n    return Qt(t, \":hover\");\n  }, i = function() {\n    return Qt(s.scrollbarX, \":focus\") || Qt(s.scrollbarY, \":focus\");\n  };\n  function n(o, r) {\n    var a = Math.floor(t.scrollTop);\n    if (o === 0) {\n      if (!s.scrollbarYActive)\n        return !1;\n      if (a === 0 && r > 0 || a >= s.contentHeight - s.containerHeight && r < 0)\n        return !s.settings.wheelPropagation;\n    }\n    var l = t.scrollLeft;\n    if (r === 0) {\n      if (!s.scrollbarXActive)\n        return !1;\n      if (l === 0 && o < 0 || l >= s.contentWidth - s.containerWidth && o > 0)\n        return !s.settings.wheelPropagation;\n    }\n    return !0;\n  }\n  s.event.bind(s.ownerDocument, \"keydown\", function(o) {\n    if (!(o.isDefaultPrevented && o.isDefaultPrevented() || o.defaultPrevented) && !(!e() && !i())) {\n      var r = document.activeElement ? document.activeElement : s.ownerDocument.activeElement;\n      if (r) {\n        if (r.tagName === \"IFRAME\")\n          r = r.contentDocument.activeElement;\n        else\n          for (; r.shadowRoot; )\n            r = r.shadowRoot.activeElement;\n        if (av(r))\n          return;\n      }\n      var a = 0, l = 0;\n      switch (o.which) {\n        case 37:\n          o.metaKey ? a = -s.contentWidth : o.altKey ? a = -s.containerWidth : a = -30;\n          break;\n        case 38:\n          o.metaKey ? l = s.contentHeight : o.altKey ? l = s.containerHeight : l = 30;\n          break;\n        case 39:\n          o.metaKey ? a = s.contentWidth : o.altKey ? a = s.containerWidth : a = 30;\n          break;\n        case 40:\n          o.metaKey ? l = -s.contentHeight : o.altKey ? l = -s.containerHeight : l = -30;\n          break;\n        case 32:\n          o.shiftKey ? l = s.containerHeight : l = -s.containerHeight;\n          break;\n        case 33:\n          l = s.containerHeight;\n          break;\n        case 34:\n          l = -s.containerHeight;\n          break;\n        case 36:\n          l = s.contentHeight;\n          break;\n        case 35:\n          l = -s.contentHeight;\n          break;\n        default:\n          return;\n      }\n      s.settings.suppressScrollX && a !== 0 || s.settings.suppressScrollY && l !== 0 || (t.scrollTop -= l, t.scrollLeft += a, Bt(s), n(a, l) && o.preventDefault());\n    }\n  });\n}\nfunction pv(s) {\n  var t = s.element;\n  function e(r, a) {\n    var l = Math.floor(t.scrollTop), p = t.scrollTop === 0, u = l + t.offsetHeight === t.scrollHeight, _ = t.scrollLeft === 0, f = t.scrollLeft + t.offsetWidth === t.scrollWidth, g;\n    return Math.abs(a) > Math.abs(r) ? g = p || u : g = _ || f, g ? !s.settings.wheelPropagation : !0;\n  }\n  function i(r) {\n    var a = r.deltaX, l = -1 * r.deltaY;\n    return (typeof a > \"u\" || typeof l > \"u\") && (a = -1 * r.wheelDeltaX / 6, l = r.wheelDeltaY / 6), r.deltaMode && r.deltaMode === 1 && (a *= 10, l *= 10), a !== a && l !== l && (a = 0, l = r.wheelDelta), r.shiftKey ? [-l, -a] : [a, l];\n  }\n  function n(r, a, l) {\n    if (!Ne.isWebKit && t.querySelector(\"select:focus\"))\n      return !0;\n    if (!t.contains(r))\n      return !1;\n    for (var p = r; p && p !== t; ) {\n      if (p.classList.contains(j.element.consuming))\n        return !0;\n      var u = Lt(p);\n      if (l && u.overflowY.match(/(scroll|auto)/)) {\n        var _ = p.scrollHeight - p.clientHeight;\n        if (_ > 0 && (p.scrollTop > 0 && l < 0 || p.scrollTop < _ && l > 0))\n          return !0;\n      }\n      if (a && u.overflowX.match(/(scroll|auto)/)) {\n        var f = p.scrollWidth - p.clientWidth;\n        if (f > 0 && (p.scrollLeft > 0 && a < 0 || p.scrollLeft < f && a > 0))\n          return !0;\n      }\n      p = p.parentNode;\n    }\n    return !1;\n  }\n  function o(r) {\n    var a = i(r), l = a[0], p = a[1];\n    if (!n(r.target, l, p)) {\n      var u = !1;\n      s.settings.useBothWheelAxes ? s.scrollbarYActive && !s.scrollbarXActive ? (p ? t.scrollTop -= p * s.settings.wheelSpeed : t.scrollTop += l * s.settings.wheelSpeed, u = !0) : s.scrollbarXActive && !s.scrollbarYActive && (l ? t.scrollLeft += l * s.settings.wheelSpeed : t.scrollLeft -= p * s.settings.wheelSpeed, u = !0) : (t.scrollTop -= p * s.settings.wheelSpeed, t.scrollLeft += l * s.settings.wheelSpeed), Bt(s), u = u || e(l, p), u && !r.ctrlKey && (r.stopPropagation(), r.preventDefault());\n    }\n  }\n  typeof window.onwheel < \"u\" ? s.event.bind(t, \"wheel\", o) : typeof window.onmousewheel < \"u\" && s.event.bind(t, \"mousewheel\", o);\n}\nfunction _v(s) {\n  if (!Ne.supportsTouch && !Ne.supportsIePointer)\n    return;\n  var t = s.element;\n  function e(m, b) {\n    var v = Math.floor(t.scrollTop), C = t.scrollLeft, w = Math.abs(m), E = Math.abs(b);\n    if (E > w) {\n      if (b < 0 && v === s.contentHeight - s.containerHeight || b > 0 && v === 0)\n        return window.scrollY === 0 && b > 0 && Ne.isChrome;\n    } else if (w > E && (m < 0 && C === s.contentWidth - s.containerWidth || m > 0 && C === 0))\n      return !0;\n    return !0;\n  }\n  function i(m, b) {\n    t.scrollTop -= b, t.scrollLeft -= m, Bt(s);\n  }\n  var n = {}, o = 0, r = {}, a = null;\n  function l(m) {\n    return m.targetTouches ? m.targetTouches[0] : m;\n  }\n  function p(m) {\n    return m.pointerType && m.pointerType === \"pen\" && m.buttons === 0 ? !1 : !!(m.targetTouches && m.targetTouches.length === 1 || m.pointerType && m.pointerType !== \"mouse\" && m.pointerType !== m.MSPOINTER_TYPE_MOUSE);\n  }\n  function u(m) {\n    if (p(m)) {\n      var b = l(m);\n      n.pageX = b.pageX, n.pageY = b.pageY, o = (/* @__PURE__ */ new Date()).getTime(), a !== null && clearInterval(a);\n    }\n  }\n  function _(m, b, v) {\n    if (!t.contains(m))\n      return !1;\n    for (var C = m; C && C !== t; ) {\n      if (C.classList.contains(j.element.consuming))\n        return !0;\n      var w = Lt(C);\n      if (v && w.overflowY.match(/(scroll|auto)/)) {\n        var E = C.scrollHeight - C.clientHeight;\n        if (E > 0 && (C.scrollTop > 0 && v < 0 || C.scrollTop < E && v > 0))\n          return !0;\n      }\n      if (b && w.overflowX.match(/(scroll|auto)/)) {\n        var T = C.scrollWidth - C.clientWidth;\n        if (T > 0 && (C.scrollLeft > 0 && b < 0 || C.scrollLeft < T && b > 0))\n          return !0;\n      }\n      C = C.parentNode;\n    }\n    return !1;\n  }\n  function f(m) {\n    if (p(m)) {\n      var b = l(m), v = { pageX: b.pageX, pageY: b.pageY }, C = v.pageX - n.pageX, w = v.pageY - n.pageY;\n      if (_(m.target, C, w))\n        return;\n      i(C, w), n = v;\n      var E = (/* @__PURE__ */ new Date()).getTime(), T = E - o;\n      T > 0 && (r.x = C / T, r.y = w / T, o = E), e(C, w) && m.preventDefault();\n    }\n  }\n  function g() {\n    s.settings.swipeEasing && (clearInterval(a), a = setInterval(function() {\n      if (s.isInitialized) {\n        clearInterval(a);\n        return;\n      }\n      if (!r.x && !r.y) {\n        clearInterval(a);\n        return;\n      }\n      if (Math.abs(r.x) < 0.01 && Math.abs(r.y) < 0.01) {\n        clearInterval(a);\n        return;\n      }\n      if (!s.element) {\n        clearInterval(a);\n        return;\n      }\n      i(r.x * 30, r.y * 30), r.x *= 0.8, r.y *= 0.8;\n    }, 10));\n  }\n  Ne.supportsTouch ? (s.event.bind(t, \"touchstart\", u), s.event.bind(t, \"touchmove\", f), s.event.bind(t, \"touchend\", g)) : Ne.supportsIePointer && (window.PointerEvent ? (s.event.bind(t, \"pointerdown\", u), s.event.bind(t, \"pointermove\", f), s.event.bind(t, \"pointerup\", g)) : window.MSPointerEvent && (s.event.bind(t, \"MSPointerDown\", u), s.event.bind(t, \"MSPointerMove\", f), s.event.bind(t, \"MSPointerUp\", g)));\n}\nvar fv = function() {\n  return {\n    handlers: [\"click-rail\", \"drag-thumb\", \"keyboard\", \"wheel\", \"touch\"],\n    maxScrollbarLength: null,\n    minScrollbarLength: null,\n    scrollingThreshold: 1e3,\n    scrollXMarginOffset: 0,\n    scrollYMarginOffset: 0,\n    suppressScrollX: !1,\n    suppressScrollY: !1,\n    swipeEasing: !0,\n    useBothWheelAxes: !1,\n    wheelPropagation: !0,\n    wheelSpeed: 1\n  };\n}, mv = {\n  \"click-rail\": hv,\n  \"drag-thumb\": dv,\n  keyboard: uv,\n  wheel: pv,\n  touch: _v\n}, Ui = function(t, e) {\n  var i = this;\n  if (e === void 0 && (e = {}), typeof t == \"string\" && (t = document.querySelector(t)), !t || !t.nodeName)\n    throw new Error(\"no element is specified to initialize PerfectScrollbar\");\n  this.element = t, t.classList.add(j.main), this.settings = fv();\n  for (var n in e)\n    this.settings[n] = e[n];\n  this.containerWidth = null, this.containerHeight = null, this.contentWidth = null, this.contentHeight = null;\n  var o = function() {\n    return t.classList.add(j.state.focus);\n  }, r = function() {\n    return t.classList.remove(j.state.focus);\n  };\n  this.isRtl = Lt(t).direction === \"rtl\", this.isRtl === !0 && t.classList.add(j.rtl), this.isNegativeScroll = function() {\n    var p = t.scrollLeft, u = null;\n    return t.scrollLeft = -1, u = t.scrollLeft < 0, t.scrollLeft = p, u;\n  }(), this.negativeScrollAdjustment = this.isNegativeScroll ? t.scrollWidth - t.clientWidth : 0, this.event = new si(), this.ownerDocument = t.ownerDocument || document, this.scrollbarXRail = ws(j.element.rail(\"x\")), t.appendChild(this.scrollbarXRail), this.scrollbarX = ws(j.element.thumb(\"x\")), this.scrollbarXRail.appendChild(this.scrollbarX), this.scrollbarX.setAttribute(\"tabindex\", 0), this.event.bind(this.scrollbarX, \"focus\", o), this.event.bind(this.scrollbarX, \"blur\", r), this.scrollbarXActive = null, this.scrollbarXWidth = null, this.scrollbarXLeft = null;\n  var a = Lt(this.scrollbarXRail);\n  this.scrollbarXBottom = parseInt(a.bottom, 10), isNaN(this.scrollbarXBottom) ? (this.isScrollbarXUsingBottom = !1, this.scrollbarXTop = W(a.top)) : this.isScrollbarXUsingBottom = !0, this.railBorderXWidth = W(a.borderLeftWidth) + W(a.borderRightWidth), ot(this.scrollbarXRail, { display: \"block\" }), this.railXMarginWidth = W(a.marginLeft) + W(a.marginRight), ot(this.scrollbarXRail, { display: \"\" }), this.railXWidth = null, this.railXRatio = null, this.scrollbarYRail = ws(j.element.rail(\"y\")), t.appendChild(this.scrollbarYRail), this.scrollbarY = ws(j.element.thumb(\"y\")), this.scrollbarYRail.appendChild(this.scrollbarY), this.scrollbarY.setAttribute(\"tabindex\", 0), this.event.bind(this.scrollbarY, \"focus\", o), this.event.bind(this.scrollbarY, \"blur\", r), this.scrollbarYActive = null, this.scrollbarYHeight = null, this.scrollbarYTop = null;\n  var l = Lt(this.scrollbarYRail);\n  this.scrollbarYRight = parseInt(l.right, 10), isNaN(this.scrollbarYRight) ? (this.isScrollbarYUsingRight = !1, this.scrollbarYLeft = W(l.left)) : this.isScrollbarYUsingRight = !0, this.scrollbarYOuterWidth = this.isRtl ? lv(this.scrollbarY) : null, this.railBorderYWidth = W(l.borderTopWidth) + W(l.borderBottomWidth), ot(this.scrollbarYRail, { display: \"block\" }), this.railYMarginHeight = W(l.marginTop) + W(l.marginBottom), ot(this.scrollbarYRail, { display: \"\" }), this.railYHeight = null, this.railYRatio = null, this.reach = {\n    x: t.scrollLeft <= 0 ? \"start\" : t.scrollLeft >= this.contentWidth - this.containerWidth ? \"end\" : null,\n    y: t.scrollTop <= 0 ? \"start\" : t.scrollTop >= this.contentHeight - this.containerHeight ? \"end\" : null\n  }, this.isAlive = !0, this.settings.handlers.forEach(function(p) {\n    return mv[p](i);\n  }), this.lastScrollTop = Math.floor(t.scrollTop), this.lastScrollLeft = t.scrollLeft, this.event.bind(this.element, \"scroll\", function(p) {\n    return i.onScroll(p);\n  }), Bt(this);\n};\nUi.prototype.update = function() {\n  this.isAlive && (this.negativeScrollAdjustment = this.isNegativeScroll ? this.element.scrollWidth - this.element.clientWidth : 0, ot(this.scrollbarXRail, { display: \"block\" }), ot(this.scrollbarYRail, { display: \"block\" }), this.railXMarginWidth = W(Lt(this.scrollbarXRail).marginLeft) + W(Lt(this.scrollbarXRail).marginRight), this.railYMarginHeight = W(Lt(this.scrollbarYRail).marginTop) + W(Lt(this.scrollbarYRail).marginBottom), ot(this.scrollbarXRail, { display: \"none\" }), ot(this.scrollbarYRail, { display: \"none\" }), Bt(this), on(this, \"top\", 0, !1, !0), on(this, \"left\", 0, !1, !0), ot(this.scrollbarXRail, { display: \"\" }), ot(this.scrollbarYRail, { display: \"\" }));\n};\nUi.prototype.onScroll = function(t) {\n  this.isAlive && (Bt(this), on(this, \"top\", this.element.scrollTop - this.lastScrollTop), on(\n    this,\n    \"left\",\n    this.element.scrollLeft - this.lastScrollLeft\n  ), this.lastScrollTop = Math.floor(this.element.scrollTop), this.lastScrollLeft = this.element.scrollLeft);\n};\nUi.prototype.destroy = function() {\n  this.isAlive && (this.event.unbindAll(), Pe(this.scrollbarX), Pe(this.scrollbarY), Pe(this.scrollbarXRail), Pe(this.scrollbarYRail), this.removePsClasses(), this.element = null, this.scrollbarX = null, this.scrollbarY = null, this.scrollbarXRail = null, this.scrollbarYRail = null, this.isAlive = !1);\n};\nUi.prototype.removePsClasses = function() {\n  this.element.className = this.element.className.split(\" \").filter(function(t) {\n    return !t.match(/^ps([-_].+|)$/);\n  }).join(\" \");\n};\nconst po = \"perfectScrollbar\", gv = \"perfect-scrollbar\", xs = \"te.perfectScrollbar\", Ot = \"te\", St = \"ps\", _o = [\n  { te: `scrollX.${Ot}.${St}`, ps: \"ps-scroll-x\" },\n  { te: `scrollY.${Ot}.${St}`, ps: \"ps-scroll-y\" },\n  { te: `scrollUp.${Ot}.${St}`, ps: \"ps-scroll-up\" },\n  { te: `scrollDown.${Ot}.${St}`, ps: \"ps-scroll-down\" },\n  { te: `scrollLeft.${Ot}.${St}`, ps: \"ps-scroll-left\" },\n  { te: `scrollRight.${Ot}.${St}`, ps: \"ps-scroll-right\" },\n  { te: `scrollXEnd.${Ot}.${St}`, ps: \"ps-x-reach-end\" },\n  { te: `scrollYEnd.${Ot}.${St}`, ps: \"ps-y-reach-end\" },\n  { te: `scrollXStart.${Ot}.${St}`, ps: \"ps-x-reach-start\" },\n  { te: `scrollYStart.${Ot}.${St}`, ps: \"ps-y-reach-start\" }\n], bv = {\n  handlers: [\"click-rail\", \"drag-thumb\", \"keyboard\", \"wheel\", \"touch\"],\n  wheelSpeed: 1,\n  wheelPropagation: !0,\n  swipeEasing: !0,\n  minScrollbarLength: null,\n  maxScrollbarLength: null,\n  scrollingThreshold: 1e3,\n  useBothWheelAxes: !1,\n  suppressScrollX: !1,\n  suppressScrollY: !1,\n  scrollXMarginOffset: 0,\n  scrollYMarginOffset: 0,\n  positionRight: !0\n}, vv = {\n  handlers: \"(string|array)\",\n  wheelSpeed: \"number\",\n  wheelPropagation: \"boolean\",\n  swipeEasing: \"boolean\",\n  minScrollbarLength: \"(number|null)\",\n  maxScrollbarLength: \"(number|null)\",\n  scrollingThreshold: \"number\",\n  useBothWheelAxes: \"boolean\",\n  suppressScrollX: \"boolean\",\n  suppressScrollY: \"boolean\",\n  scrollXMarginOffset: \"number\",\n  scrollYMarginOffset: \"number\",\n  positionRight: \"boolean\"\n}, Tv = {\n  ps: \"group/ps overflow-hidden [overflow-anchor:none] touch-none\",\n  railX: \"group/x absolute bottom-0 h-[0.9375rem] hidden opacity-0 transition-[background-color,_opacity] duration-200 ease-linear motion-reduce:transition-none z-[1035] group-[&.ps--active-x]/ps:block group-hover/ps:opacity-60 group-focus/ps:opacity-60 group-[&.ps--scrolling-x]/ps:opacity-60 hover:!opacity-90 focus:!opacity-90 [&.ps--clicking]:!opacity-90 outline-none\",\n  railXColors: \"group-[&.ps--active-x]/ps:bg-transparent hover:!bg-[#eee] focus:!bg-[#eee] [&.ps--clicking]:!bg-[#eee] dark:hover:!bg-[#555] dark:focus:!bg-[#555] dark:[&.ps--clicking]:!bg-[#555]\",\n  railXThumb: \"absolute bottom-0.5 rounded-md h-1.5 group-focus/ps:opacity-100 group-active/ps:opacity-100 [transition:background-color_.2s_linear,_height_.2s_ease-in-out] group-hover/x:h-[11px] group-focus/x:h-[0.6875rem] group-[&.ps--clicking]/x:bg-[#999] group-[&.ps--clicking]/x:h-[11px] outline-none\",\n  railXThumbColors: \"bg-[#aaa] group-hover/x:bg-[#999] group-focus/x:bg-[#999]\",\n  railY: \"group/y absolute right-0 w-[0.9375rem] hidden opacity-0 transition-[background-color,_opacity] duration-200 ease-linear motion-reduce:transition-none z-[1035] group-[&.ps--active-y]/ps:block group-hover/ps:opacity-60 group-focus/ps:opacity-60 group-[&.ps--scrolling-y]/ps:opacity-60 hover:!opacity-90 focus:!opacity-90 [&.ps--clicking]:!opacity-90 outline-none\",\n  railYColors: \"group-[&.ps--active-y]/ps:bg-transparent hover:!bg-[#eee] focus:!bg-[#eee] [&.ps--clicking]:!bg-[#eee] dark:hover:!bg-[#555] dark:focus:!bg-[#555] dark:[&.ps--clicking]:!bg-[#555]\",\n  railYThumb: \"absolute right-0.5 rounded-md w-1.5 group-focus/ps:opacity-100 group-active/ps:opacity-100 [transition:background-color_.2s_linear,_width_.2s_ease-in-out,_opacity] group-hover/y:w-[11px] group-focus/y:w-[0.6875rem] group-[&.ps--clicking]/y:w-[11px] outline-none\",\n  railYThumbColors: \"bg-[#aaa] group-hover/y:bg-[#999] group-focus/y:bg-[#999] group-[&.ps--clicking]/y:bg-[#999]\"\n}, Ev = {\n  ps: \"string\",\n  railX: \"string\",\n  railXColors: \"string\",\n  railXThumb: \"string\",\n  railXThumbColors: \"string\",\n  railY: \"string\",\n  railYColors: \"string\",\n  railYThumb: \"string\",\n  railYThumbColors: \"string\"\n};\nclass fr {\n  constructor(t, e = {}, i = {}) {\n    this._element = t, this._options = this._getConfig(e), this._classes = this._getClasses(i), this.perfectScrollbar = null, this._observer = null, this._psClasses = [\n      {\n        ps: \"ps__rail-x\",\n        te: this._classes.railX,\n        teColor: this._classes.railXColors\n      },\n      {\n        ps: \"ps__rail-y\",\n        te: this._classes.railY,\n        teColor: this._classes.railYColors\n      },\n      {\n        ps: \"ps__thumb-x\",\n        te: this._classes.railXThumb,\n        teColor: this._classes.railXThumbColors\n      },\n      {\n        ps: \"ps__thumb-y\",\n        te: this._classes.railYThumb,\n        teColor: this._classes.railYThumbColors\n      }\n    ], this._element && (y.setData(t, xs, this), h.addClass(this._element, gv)), this.init();\n  }\n  // Getters\n  static get NAME() {\n    return po;\n  }\n  get railX() {\n    return d.findOne(\".ps__rail-x\", this._element);\n  }\n  get railY() {\n    return d.findOne(\".ps__rail-y\", this._element);\n  }\n  _getConfig(t) {\n    const e = h.getDataAttributes(this._element);\n    return e.handlers !== void 0 && (e.handlers = e.handlers.split(\" \")), t = {\n      ...bv,\n      ...e,\n      ...t\n    }, D(po, t, vv), t;\n  }\n  _getClasses(t) {\n    const e = h.getDataClassAttributes(this._element);\n    return t = {\n      ...Tv,\n      ...e,\n      ...t\n    }, D(po, t, Ev), t;\n  }\n  // Public\n  dispose() {\n    this._options.positionRight && this._observer.disconnect(), y.removeData(this._element, xs), this._element = null, this._dataAttrOptions = null, this._options = null, this.perfectScrollbar.destroy(), this.removeEvent(_o), this.perfectScrollbar = null;\n  }\n  init() {\n    if (this.perfectScrollbar = new Ui(this._element, this._options), this._addPerfectScrollbarStyles(), this._updateScrollPosition(), this.perfectScrollbar.update(), this._initEvents(_o), this._options.positionRight) {\n      this._observer = new ResizeObserver(() => {\n        setTimeout(() => {\n          this._updateScrollPosition();\n        }, 100);\n      });\n      const t = {\n        attributes: !0,\n        attributeFilter: [\"class\", \"className\"]\n      };\n      this._observer.observe(this._element, t);\n    }\n  }\n  _updateScrollPosition() {\n    const t = getComputedStyle(this._element).getPropertyValue(\"height\"), e = getComputedStyle(this._element).getPropertyValue(\"width\");\n    this.railX && (this.railX.style.transform = `translateY(calc(-100% + ${this._canTransform(t) ? t : \"0px\"}))`), this.railY && (this.railY.style.transform = `translateX(calc(-100% + ${this._canTransform(e) ? e : \"0px\"}))`);\n  }\n  _canTransform(t) {\n    return t && t.includes(\"px\");\n  }\n  update() {\n    return this.perfectScrollbar.update();\n  }\n  _initEvents(t = []) {\n    t.forEach(\n      ({ ps: e, te: i }) => c.on(\n        this._element,\n        e,\n        (n) => c.trigger(this._element, i, { e: n })\n      )\n    );\n  }\n  _addPerfectScrollbarStyles() {\n    this._psClasses.forEach((t) => {\n      const e = d.findOne(`.${t.ps}`, this._element);\n      h.addClass(e, t.te), h.addClass(e, t.teColor);\n    }), h.addClass(this._element, this._classes.ps), h.removeClass(this._element, \"ps\");\n  }\n  removeEvent(t) {\n    let e = [];\n    typeof t == \"string\" && (e = _o.filter(({ te: i }) => i === t)), e.forEach(({ ps: i, te: n }) => {\n      c.off(this._element, i), c.off(this._element, n);\n    });\n  }\n  // Static\n  static jQueryInterface(t) {\n    return this.each(function() {\n      let e = y.getData(this, xs);\n      const i = typeof t == \"object\" && t;\n      if (!(!e && /dispose|hide/.test(t)) && (e || (e = new fr(this, i)), typeof t == \"string\")) {\n        if (typeof e[t] > \"u\")\n          throw new TypeError(`No method named \"${t}\"`);\n        e[t]();\n      }\n    });\n  }\n  static getInstance(t) {\n    return y.getData(t, xs);\n  }\n  static getOrCreateInstance(t, e = {}) {\n    return this.getInstance(t) || new this(t, typeof e == \"object\" ? e : null);\n  }\n}\nconst mh = fr, Cv = \"data-te-datatable-select-ref\", Av = \"data-te-datatable-pagination-nav-ref\", yv = \"data-te-datatable-pagination-right-ref\", wv = \"data-te-datatable-pagination-left-ref\", kv = \"data-te-datatable-pagination-start-ref\", xv = \"data-te-datatable-pagination-end-ref\", Ov = ({\n  text: s,\n  entries: t,\n  entriesOptions: e,\n  fullPagination: i,\n  rowsText: n,\n  allText: o,\n  paginationStartIconTemplate: r,\n  paginationLeftIconTemplate: a,\n  paginationRightIconTemplate: l,\n  paginationEndIconTemplate: p,\n  classes: u\n}, _, f) => {\n  const g = e.map((m) => m === \"All\" ? `<option value=\"${m}\" ${m === t ? \"selected\" : \"\"}>${o}</option>` : `<option value=\"${m}\" ${m === t ? \"selected\" : \"\"}>${m}</option>`).join(`\n`);\n  return `\n<div class=\"${u.pagination} ${f ? `${u.paginationBordered}` : \"\"} ${u.borderColor} ${u.color}\">\n  <div class=\"${u.selectItemsWrapper}\">  \n    <p class=\"${u.paginationRowsText} ${_ ? `${u.loadingPaginationRowsText}` : \"\"}\">${n}</p>\n    <div class=\"${u.selectWrapper} ${_ ? `${u.loadingPaginationSelectWrapper}` : \"\"}\">\n      <select name=\"entries\"\n        ${_ ? \"disabled\" : \"\"} class=\"select\" ${Cv}>\n        ${g}\n      </select>\n    </div>\n  </div>\n  <div class=\"${u.paginationNav} ${_ ? `${u.loadingPaginationNav}` : \"\"}\" ${Av}>\n  ${s}\n  </div>\n  <div class=\"${u.paginationButtonsWrapper}\">\n    ${i ? `<button data-te-ripple-init data-te-ripple-color=\"dark\" class=\"${u.paginationStartButton}\" ${kv}>\n           ${r}\n          </button>` : \"\"}\n    <button data-te-ripple-init data-te-ripple-color=\"dark\" class=\"${u.paginationLeftButton}\" ${wv}>\n      ${a}\n  </button>\n    <button data-te-ripple-init data-te-ripple-color=\"dark\" class=\"${u.paginationRightButton}\" ${yv}>\n      ${l}\n  </button>\n    ${i ? `<button data-te-ripple-init data-te-ripple-color=\"dark\" class=\"${u.paginationEndButton}\" ${xv}>\n           ${p}\n          </button>` : \"\"}\n  </div>\n</div>\n`;\n}, Sv = \"data-te-datatable-sort-icon-ref\", Iv = \"data-te-datatable-header-checkbox-ref\", Dv = (s, t, e, i, n, o, r, a) => {\n  const l = e ? `\n  <th scope=\"col\">\n    <div class=\"${a.checkboxHeaderWrapper}\">\n      <input\n        class=\"${a.checkboxHeader}\"\n        type=\"checkbox\"\n        value=\"\"\n        ${Iv}\n        />\n    </div>\n  </th>\n  ` : '<th scope=\"col\"></th>', p = s.map((u, _) => {\n    const f = u.fixed ? s.filter((g, m) => g.fixed === u.fixed && m < _).reduce((g, m) => g + m.width, 0) : null;\n    return `<th class=\"${a.column} ${i ? `${a.tableBordered}` : \"\"} ${a.borderColor} ${n ? `${a.sm}` : \"\"} ${u.fixed ? `${a.fixedHeader} ${a.color}` : \"\"} ${o ? `${a.loadingColumn}` : \"\"}\" style=\"${u.fixed ? `${u.fixed === \"right\" ? \"right\" : \"left\"}: ${f}px;` : \"\"}\" scope=\"col\">${u.sort ? `<div class=\"${a.sortIconWrapper}\"><span class=\"${a.sortIcon} ${o ? \"invisible\" : \"\"}\" data-te-sort=\"${u.field}\" ${Sv}>${r}</span>` : \"\"} <span class=\"${u.sort ? \"\" : \"pl-[18px]\"}\">${u.label}</span></div></th>`;\n  });\n  return [t ? l : \"\", ...p].join(`\n`);\n}, $v = \"data-te-datatable-row-ref\", Lv = \"data-te-datatable-row-checkbox-ref\", Nv = \"data-te-datatable-cell-ref\", Mv = ({\n  rows: s,\n  columns: t,\n  noFoundMessage: e,\n  edit: i,\n  selectable: n,\n  loading: o,\n  bordered: r,\n  borderless: a,\n  striped: l,\n  hover: p,\n  sm: u,\n  classes: _\n}) => {\n  const f = s.map((g) => {\n    const m = `\n      <td data-te-field=\"checkbox\" class=\"${r ? `${_.tableBordered} ${_.borderColor}` : \"\"}\">\n        <div class=\"${_.checkboxRowWrapper}\">\n          <input\n            class=\"${_.checkboxRow}\"\n            type=\"checkbox\"\n            value=\"\"\n            data-te-row-index=\"${g.rowIndex}\"  ${Lv}/>\n        </div>\n      </td>`, b = t.map((v, C) => {\n      const w = {};\n      if (v.width && (w[\"min-width\"] = `${v.width - 1}px`, w[\"max-width\"] = `${v.width}px`, w.width = `${v.width}px`), v.fixed) {\n        const T = t.filter((A, k) => A.fixed === v.fixed && k < C).reduce((A, k) => A + k.width, 0);\n        w[v.fixed === \"right\" ? \"right\" : \"left\"] = `${T}px`;\n      }\n      return `<td style=\"${Object.keys(w).map((T) => `${T}: ${w[T]}`).join(\"; \")}\" class=\"${_.rowItem} ${_.borderColor} ${i ? `${_.edit}` : \"\"} ${r ? `${_.tableBordered}` : \"\"} ${u ? `${_.sm}` : \"\"} ${v.fixed ? `${_.fixedHeader} ${_.color}` : \"\"}\" ${Nv} data-te-field=\"${v.field}\" ${i && 'contenteditable=\"true\"'}>${g[v.field]}</td>`;\n    }).join(\"\");\n    return `<tr scope=\"row\" class=\"${_.row} ${_.borderColor} ${_.rowAnimation} ${l ? `${_.striped}` : \"\"} ${a ? `${_.borderless}` : \"\"} ${p ? `${_.hoverRow}` : \"\"}\" data-te-index=\"${g.rowIndex}\" ${$v}>${n ? m : \"\"}${b}</tr>`;\n  });\n  return s.length > 0 || o ? f.join(`\n`) : `<tr class=\"${_.noFoundMessageWrapper} ${_.borderColor}\"><td class=\"${_.noFoundMessage}\">${e}</td></tr>`;\n}, Rv = \"data-te-datatable-inner-ref\", Pv = \"data-te-datatable-header-ref\", wl = ({\n  columns: s,\n  rows: t,\n  noFoundMessage: e,\n  edit: i,\n  multi: n,\n  selectable: o,\n  loading: r,\n  loadingMessage: a,\n  pagination: l,\n  bordered: p,\n  borderless: u,\n  striped: _,\n  hover: f,\n  fixedHeader: g,\n  sm: m,\n  sortIconTemplate: b,\n  classes: v\n}) => {\n  const C = Mv({\n    rows: t,\n    columns: s,\n    noFoundMessage: e,\n    edit: i,\n    loading: r,\n    selectable: o,\n    bordered: p,\n    borderless: u,\n    striped: _,\n    hover: f,\n    sm: m,\n    classes: v\n  }), w = Dv(\n    s,\n    o,\n    n,\n    p,\n    m,\n    r,\n    b,\n    v\n  );\n  return { table: `\n<div class=\"${v.color}\" ${Rv}>\n  <table class=\"${v.table}\">\n    <thead class=\"${v.tableHeader} ${p ? `${v.tableBordered}` : \"\"} ${u ? `${v.borderless}` : \"\"} ${v.borderColor}\" ${Pv}>\n      <tr>\n        ${w}\n      </tr>\n    </thead>\n    <tbody class=\"${g ? `${v.fixedHeaderBody}` : \"\"}\">\n      ${r ? \"\" : C}\n    </tbody>\n  </table>\n</div>\n${r ? `\n  <div class=\"${v.loadingItemsWrapper}\">\n    <div class=\"${v.loadingProgressBarWrapper}\">\n      <div class=\"${v.loadingProgressBar}\"></div>\n    </div>\n  </div>\n<p class=\"${v.loadingMessage}\">${a}</p>\n` : \"\"}\n${l.enable ? Ov(l, r, p) : \"\"}\n  `, rows: C, column: w };\n}, Bv = ({ rows: s, field: t, order: e }) => s.sort((n, o) => {\n  let r = n[t], a = o[t];\n  return typeof r == \"string\" && (r = r.toLowerCase()), typeof a == \"string\" && (a = a.toLowerCase()), r < a ? e === \"desc\" ? 1 : -1 : r > a ? e === \"desc\" ? -1 : 1 : 0;\n}), Hv = (s, t, e) => {\n  if (!t)\n    return s;\n  const i = (n) => {\n    const o = document.createElement(\"div\");\n    return o.innerHTML = n, n = o.textContent || o.innerText || \"\", n.toString().toLowerCase().match(t.toLowerCase());\n  };\n  return s.filter((n) => {\n    if (e && typeof e == \"string\")\n      return i(n[e]);\n    let o = Object.values(n);\n    return e && Array.isArray(e) && (o = Object.keys(n).filter((r) => e.includes(r)).map((r) => n[r])), o.filter((r) => i(r)).length > 0;\n  });\n}, kl = ({ rows: s, entries: t, activePage: e }) => {\n  const i = e * t;\n  return s.slice(i, i + Number(t));\n}, Ni = \"datatable\", ft = `data-te-${Ni}`, Ei = `te.${Ni}`, _n = `.${Ei}`, Vv = `[${ft}-inner-ref]`, fo = `[${ft}-cell-ref]`, Wv = `[${ft}-header-ref]`, Fv = `[${ft}-header-checkbox-ref]`, Yv = `[${ft}-pagination-right-ref]`, jv = `[${ft}-pagination-left-ref]`, Kv = `[${ft}-pagination-start-ref]`, zv = `[${ft}-pagination-end-ref]`, Uv = `[${ft}-pagination-nav-ref]`, Xv = `[${ft}-select-ref]`, mo = `[${ft}-sort-icon-ref]`, fi = `[${ft}-row-ref]`, go = `[${ft}-row-checkbox-ref]`, Gv = `selectRows${_n}`, xl = `render${_n}`, qv = `rowClick${_n}`, Zv = `update${_n}`, Qv = `<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"currentColor\" viewBox=\"0 0 24 24\" stroke-width=\"3\" stroke=\"currentColor\">\n  <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M4.5 10.5L12 3m0 0l7.5 7.5M12 3v18\" />\n</svg>`, Jv = `<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"1.5\" stroke=\"currentColor\" class=\"w-4 h-4\">\n  <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M18.75 19.5l-7.5-7.5 7.5-7.5m-6 15L5.25 12l7.5-7.5\" />\n</svg>`, tT = `<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"1.5\" stroke=\"currentColor\" class=\"w-4 h-4\">\n  <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M15.75 19.5L8.25 12l7.5-7.5\" />\n</svg>`, eT = `<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"1.5\" stroke=\"currentColor\" class=\"w-4 h-4\">\n  <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M8.25 4.5l7.5 7.5-7.5 7.5\" />\n</svg>`, iT = `<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"1.5\" stroke=\"currentColor\" class=\"w-4 h-4\">\n  <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M11.25 4.5l7.5 7.5-7.5 7.5m-6-15l7.5 7.5-7.5 7.5\"/>\n</svg>`, sT = \"border-neutral-200 dark:border-neutral-500\", nT = \"border-none\", oT = \"relative float-left -ml-[1.5rem] mr-[6px] mt-[0.15rem] h-[1.125rem] w-[1.125rem] appearance-none rounded-[0.25rem] border-[0.125rem] border-solid border-neutral-300 outline-none before:pointer-events-none before:absolute before:h-[0.875rem] before:w-[0.875rem] before:scale-0 before:rounded-full before:bg-transparent before:opacity-0 before:shadow-[0px_0px_0px_13px_transparent] before:content-[''] checked:border-primary checked:bg-primary checked:before:opacity-[0.16] checked:after:absolute checked:after:-mt-px checked:after:ml-[0.25rem] checked:after:block checked:after:h-[0.8125rem] checked:after:w-[0.375rem] checked:after:rotate-45 checked:after:border-[0.125rem] checked:after:border-l-0 checked:after:border-t-0 checked:after:border-solid checked:after:border-white checked:after:bg-transparent checked:after:content-[''] hover:cursor-pointer hover:before:opacity-[0.04] hover:before:shadow-[0px_0px_0px_13px_rgba(0,0,0,0.6)] focus:shadow-none focus:transition-[border-color_0.2s] focus:before:scale-100 focus:before:opacity-[0.12] focus:before:shadow-[0px_0px_0px_13px_rgba(0,0,0,0.6)] focus:before:transition-[box-shadow_0.2s,transform_0.2s] focus:after:absolute focus:after:z-[1] focus:after:block focus:after:h-[0.875rem] focus:after:w-[0.875rem] focus:after:rounded-[0.125rem] focus:after:content-[''] checked:focus:before:scale-100 checked:focus:before:shadow-[0px_0px_0px_13px_#3b71ca] checked:focus:before:transition-[box-shadow_0.2s,transform_0.2s] checked:focus:after:-mt-px checked:focus:after:ml-[0.25rem] checked:focus:after:h-[0.8125rem] checked:focus:after:w-[0.375rem] checked:focus:after:rotate-45 checked:focus:after:rounded-none checked:focus:after:border-[0.125rem] checked:focus:after:border-l-0 checked:focus:after:border-t-0 checked:focus:after:border-solid checked:focus:after:border-white checked:focus:after:bg-transparent dark:border-neutral-600 dark:checked:border-primary dark:checked:bg-primary dark:focus:before:shadow-[0px_0px_0px_13px_rgba(255,255,255,0.4)] dark:checked:focus:before:shadow-[0px_0px_0px_13px_#3b71ca] dark:border-neutral-400\", rT = \"mb-[0.125rem] min-h-[1.5rem] pl-[1.5rem] ml-3 flex items-center\", aT = \"relative float-left -ml-[1.5rem] mr-[6px] mt-[0.15rem] h-[1.125rem] w-[1.125rem] appearance-none rounded-[0.25rem] border-[0.125rem] border-solid border-neutral-300 outline-none before:pointer-events-none before:absolute before:h-[0.875rem] before:w-[0.875rem] before:scale-0 before:rounded-full before:bg-transparent before:opacity-0 before:shadow-[0px_0px_0px_13px_transparent] before:content-[''] checked:border-primary checked:bg-primary checked:before:opacity-[0.16] checked:after:absolute checked:after:-mt-px checked:after:ml-[0.25rem] checked:after:block checked:after:h-[0.8125rem] checked:after:w-[0.375rem] checked:after:rotate-45 checked:after:border-[0.125rem] checked:after:border-l-0 checked:after:border-t-0 checked:after:border-solid checked:after:border-white checked:after:bg-transparent checked:after:content-[''] hover:cursor-pointer hover:before:opacity-[0.04] hover:before:shadow-[0px_0px_0px_13px_rgba(0,0,0,0.6)] focus:shadow-none focus:transition-[border-color_0.2s] focus:before:scale-100 focus:before:opacity-[0.12] focus:before:shadow-[0px_0px_0px_13px_rgba(0,0,0,0.6)] focus:before:transition-[box-shadow_0.2s,transform_0.2s] focus:after:absolute focus:after:z-[1] focus:after:block focus:after:h-[0.875rem] focus:after:w-[0.875rem] focus:after:rounded-[0.125rem] focus:after:content-[''] checked:focus:before:scale-100 checked:focus:before:shadow-[0px_0px_0px_13px_#3b71ca] checked:focus:before:transition-[box-shadow_0.2s,transform_0.2s] checked:focus:after:-mt-px checked:focus:after:ml-[0.25rem] checked:focus:after:h-[0.8125rem] checked:focus:after:w-[0.375rem] checked:focus:after:rotate-45 checked:focus:after:rounded-none checked:focus:after:border-[0.125rem] checked:focus:after:border-l-0 checked:focus:after:border-t-0 checked:focus:after:border-solid checked:focus:after:border-white checked:focus:after:bg-transparent dark:border-neutral-600 dark:checked:border-primary dark:checked:bg-primary dark:focus:before:shadow-[0px_0px_0px_13px_rgba(255,255,255,0.4)] dark:checked:focus:before:shadow-[0px_0px_0px_13px_#3b71ca] dark:border-neutral-400\", lT = \"mb-[0.125rem] min-h-[1.5rem] pl-[1.5rem] ml-3 flex items-center\", cT = \"bg-white dark:bg-neutral-800\", hT = \"py-4 pl-1 text-clip overflow-hidden text-[#212529] dark:text-white\", dT = \"focus:outline-none\", uT = \"sticky top-0 z-30\", pT = \"sticky z-10 bg-inherit\", _T = \"hover:bg-neutral-100 dark:hover:bg-neutral-700\", fT = \"pointer-events-none cursor-none text-neutral-400 dark:text-neutral-300\", mT = \"h-[2px] relative w-full overflow-hidden\", gT = \"text-center text-neutral-500 font-ligh text-sm my-4 dark:text-neutral-400\", bT = \"text-neutral-500 dark:text-neutral-300\", vT = \"text-neutral-500 dark:text-neutral-300\", TT = \"pointer-events-none cursor-none\", ET = \"h-full w-[45%] bg-primary-400 dark:bg-primary-600\", CT = \"h-full animate-[progress_3s_ease-in-out_infinite]\", AT = \"pl-2 py-3 font-light text-sm dark:text-neutral-300\", yT = \"border-b\", wT = \"flex md:flex-row justify-end items-center py-2 space-x-4 text-sm flex-col leading-[1.6]\", kT = \"border border-t-0\", xT = \"order-1 my-3 md:order-none md:my-0 md:pr-1\", OT = \"inline-block rounded p-2.5 text-xs font-medium uppercase leading-normal transition duration-150 ease-in-out hover:bg-neutral-100 hover:text-primary-600 focus:text-primary-600 focus:outline-none focus:ring-0 active:text-primary-700 disabled:text-slate-300 disabled:hover:bg-transparent dark:hover:bg-neutral-500 dark:disabled:hover:bg-transparent dark:disabled:text-neutral-600\", ST = \"inline-block rounded p-2.5 font-medium uppercase leading-normal transition duration-150 ease-in-out hover:bg-neutral-100 hover:text-primary-600 focus:text-primary-600 focus:outline-none focus:ring-0 active:text-primary-700 disabled:text-slate-300 disabled:hover:bg-transparent dark:hover:bg-neutral-500 dark:disabled:hover:bg-transparent dark:disabled:text-neutral-600\", IT = \"font-normal order-2 mb-3 md:order-none md:mb-0\", DT = \"inline-block rounded p-2.5 font-medium uppercase leading-normal transition duration-150 ease-in-out hover:bg-neutral-100 hover:text-primary-600 focus:text-primary-600 focus:outline-none focus:ring-0 active:text-primary-700 disabled:text-slate-300 disabled:hover:bg-transparent dark:hover:bg-neutral-500 dark:disabled:hover:bg-transparent dark:disabled:text-neutral-600\", $T = \"font-light\", LT = \"inline-block rounded p-2.5 font-medium uppercase leading-normal transition duration-150 ease-in-out hover:bg-neutral-100 hover:text-primary-600 focus:text-primary-600 focus:outline-none focus:ring-0 active:text-primary-700 disabled:text-slate-300 disabled:hover:bg-transparent dark:hover:bg-neutral-500 dark:disabled:hover:bg-transparent dark:disabled:text-neutral-600\", NT = \"border-b\", MT = \"transition ease-in-out duration-300 motion-reduce:transition-none\", RT = \"whitespace-nowrap text-clip overflow-hidden px-[1.4rem] py-4\", PT = \"relative\", BT = \"!bg-neutral-100 dark:!bg-neutral-600\", HT = \"flex items-center space-x-4 order-3 md:order-none\", VT = \"w-[70px]\", WT = \"!py-2\", FT = \"w-[15px] h-[10px] origin-bottom font-black mr-1 opacity-0 text-neutral-500 group-hover:opacity-100 transition hover:ease-in-out transform ease-linear duration-300 motion-reduce:transition-none dark:text-neutral-400\", YT = \"flex flex-row group\", jT = \"[&:nth-child(odd)]:bg-neutral-50 [&:nth-child(odd)]:dark:bg-neutral-700\", KT = \"border\", zT = \"border-b font-normal px-[1.4rem]\", UT = \"text-left text-sm font-light w-full leading-[1.6]\", XT = {\n  bordered: \"boolean\",\n  borderless: \"boolean\",\n  clickableRows: \"boolean\",\n  defaultValue: \"string\",\n  edit: \"boolean\",\n  entries: \"(number|string)\",\n  entriesOptions: \"array\",\n  fullPagination: \"boolean\",\n  hover: \"boolean\",\n  loading: \"boolean\",\n  loadingMessage: \"string\",\n  maxWidth: \"(null|number|string)\",\n  maxHeight: \"(null|number|string)\",\n  multi: \"boolean\",\n  noFoundMessage: \"string\",\n  pagination: \"boolean\",\n  selectable: \"boolean\",\n  sm: \"boolean\",\n  sortField: \"(null|string)\",\n  sortOrder: \"string\",\n  fixedHeader: \"boolean\",\n  striped: \"boolean\",\n  rowsText: \"string\",\n  ofText: \"string\",\n  allText: \"string\",\n  forceSort: \"boolean\",\n  sortIconTemplate: \"string\",\n  paginationStartIconTemplate: \"string\",\n  paginationEndIconTemplate: \"string\",\n  paginationLeftIconTemplate: \"string\",\n  paginationRightIconTemplate: \"string\"\n}, GT = {\n  bordered: !1,\n  borderless: !1,\n  clickableRows: !1,\n  defaultValue: \"-\",\n  edit: !1,\n  entries: 10,\n  entriesOptions: [10, 25, 50, 200],\n  fixedHeader: !1,\n  fullPagination: !1,\n  hover: !1,\n  loading: !1,\n  loadingMessage: \"Loading results...\",\n  maxWidth: null,\n  maxHeight: null,\n  multi: !1,\n  noFoundMessage: \"No matching results found\",\n  pagination: !0,\n  selectable: !1,\n  sm: !1,\n  sortField: null,\n  sortOrder: \"asc\",\n  striped: !1,\n  rowsText: \"Rows per page:\",\n  ofText: \"of\",\n  allText: \"All\",\n  forceSort: !1,\n  sortIconTemplate: Qv,\n  paginationStartIconTemplate: Jv,\n  paginationEndIconTemplate: iT,\n  paginationLeftIconTemplate: tT,\n  paginationRightIconTemplate: eT\n}, qT = {\n  label: \"string\",\n  field: \"string\",\n  fixed: \"(boolean|string)\",\n  format: \"(function|null)\",\n  width: \"(number|null)\",\n  sort: \"boolean\",\n  columnIndex: \"number\"\n}, ZT = {\n  label: \"\",\n  field: \"\",\n  fixed: !1,\n  format: null,\n  width: null,\n  sort: !0,\n  columnIndex: 0\n}, QT = {\n  table: UT,\n  tableHeader: zT,\n  column: hT,\n  pagination: wT,\n  selectWrapper: VT,\n  scroll: PT,\n  tableBordered: KT,\n  paginationBordered: kT,\n  borderless: nT,\n  checkboxRowWrapper: lT,\n  checkboxRow: aT,\n  checkboxHeaderWrapper: rT,\n  checkboxHeader: oT,\n  row: NT,\n  rowItem: RT,\n  striped: jT,\n  sortIconWrapper: YT,\n  sortIcon: FT,\n  paginationRowsText: $T,\n  paginationNav: IT,\n  paginationButtonsWrapper: xT,\n  hoverRow: _T,\n  borderColor: sT,\n  color: cT,\n  fixedHeader: uT,\n  fixedHeaderBody: pT,\n  selectableRow: BT,\n  rowAnimation: MT,\n  sm: WT,\n  edit: dT,\n  selectItemsWrapper: HT,\n  paginationStartButton: LT,\n  paginationLeftButton: ST,\n  paginationRightButton: DT,\n  paginationEndButton: OT,\n  loadingItemsWrapper: mT,\n  loadingProgressBarWrapper: CT,\n  loadingProgressBar: ET,\n  loadingMessage: gT,\n  loadingPaginationRowsText: vT,\n  loadingPaginationSelectWrapper: TT,\n  loadingPaginationNav: bT,\n  loadingColumn: fT,\n  noFoundMessageWrapper: yT,\n  noFoundMessage: AT\n}, JT = {\n  table: \"string\",\n  tableHeader: \"string\",\n  column: \"string\",\n  pagination: \"string\",\n  selectWrapper: \"string\",\n  scroll: \"string\",\n  tableBordered: \"string\",\n  paginationBordered: \"string\",\n  borderless: \"string\",\n  checkboxRowWrapper: \"string\",\n  checkboxRow: \"string\",\n  checkboxHeaderWrapper: \"string\",\n  checkboxHeader: \"string\",\n  row: \"string\",\n  rowItem: \"string\",\n  striped: \"string\",\n  sortIconWrapper: \"string\",\n  sortIcon: \"string\",\n  paginationRowsText: \"string\",\n  paginationNav: \"string\",\n  paginationButtonsWrapper: \"string\",\n  hoverRow: \"string\",\n  borderColor: \"string\",\n  color: \"string\",\n  fixedHeader: \"string\",\n  fixedHeaderBody: \"string\",\n  selectableRow: \"string\",\n  rowAnimation: \"string\",\n  sm: \"string\",\n  edit: \"string\",\n  selectItemsWrapper: \"string\",\n  paginationStartButton: \"string\",\n  paginationLeftButton: \"string\",\n  paginationRightButton: \"string\",\n  paginationEndButton: \"string\",\n  loadingItemsWrapper: \"string\",\n  loadingProgressBarWrapper: \"string\",\n  loadingProgressBar: \"string\",\n  loadingMessage: \"string\",\n  loadingPaginationRowsText: \"string\",\n  loadingPaginationSelectWrapper: \"string\",\n  loadingPaginationNav: \"string\",\n  loadingColumn: \"string\",\n  noFoundMessageWrapper: \"string\",\n  noFoundMessage: \"string\"\n};\nclass gh {\n  constructor(t, e = {}, i = {}, n = {}) {\n    this._element = t, this._options = this._getOptions(i), this._classes = this._getClasses(n), this._sortReverse = !1, this._activePage = 0, this._search = \"\", this._searchColumn = null, this._paginationLeft = null, this._paginationRight = null, this._paginationStart = null, this._paginationEnd = null, this._select = null, this._selectInstance = null, this._selected = [], this._checkboxes = null, this._headerCheckbox = null, this._rows = this._getRows(e.rows), this._columns = this._getColumns(e.columns), this._element && (y.setData(t, Ei, this), this._perfectScrollbar = null, this._setup());\n  }\n  // Getters\n  static get NAME() {\n    return Ni;\n  }\n  get columns() {\n    return this._columns.map((t, e) => {\n      let i = {\n        ...ZT,\n        field: `field_${e}`,\n        columnIndex: e\n      };\n      return typeof t == \"string\" ? i.label = t : typeof t == \"object\" && (i = {\n        ...i,\n        ...t\n      }), D(\"column\", i, qT), i;\n    });\n  }\n  get rows() {\n    return this._rows.map((t, e) => {\n      const i = {\n        rowIndex: e\n      };\n      return Array.isArray(t) ? this.columns.forEach((n, o) => {\n        t[o] === 0 ? i[n.field] = t[o] : i[n.field] = t[o] || this._options.defaultValue;\n      }) : typeof t == \"object\" && this.columns.forEach((n) => {\n        t[n.field] === 0 ? i[n.field] = t[n.field] : i[n.field] = t[n.field] || this._options.defaultValue;\n      }), i;\n    });\n  }\n  get searchResult() {\n    return Hv(this.rows, this._search, this._searchColumn);\n  }\n  get computedRows() {\n    let t = [...this.searchResult];\n    return this._options.sortOrder && (t = Bv({\n      rows: t,\n      field: this._options.sortField,\n      order: this._options.sortOrder\n    })), this._options.pagination && (this._options.entries === \"All\" ? t = kl({\n      rows: t,\n      entries: t.length,\n      activePage: this._activePage\n    }) : t = kl({\n      rows: t,\n      entries: this._options.entries,\n      activePage: this._activePage\n    })), t;\n  }\n  get pages() {\n    return this._options.entries === \"All\" ? 1 : Math.ceil(this.searchResult.length / this._options.entries);\n  }\n  get navigationText() {\n    const t = this._activePage * this._options.entries;\n    return this.searchResult.length === 0 ? `0 ${this._options.ofText} 0` : this._options.entries === \"All\" ? `1 - ${this.searchResult.length} ${this._options.ofText} ${this.searchResult.length}` : `${t + 1} - ${this.computedRows.length + t} ${this._options.ofText} ${this.searchResult.length}`;\n  }\n  get tableOptions() {\n    return {\n      classes: this._classes,\n      columns: this.columns,\n      rows: this.computedRows,\n      noFoundMessage: this._options.noFoundMessage,\n      edit: this._options.edit,\n      loading: this._options.loading,\n      loaderClass: this._options.loaderClass,\n      loadingMessage: this._options.loadingMessage,\n      selectable: this._options.selectable,\n      multi: this._options.multi,\n      bordered: this._options.bordered,\n      borderless: this._options.borderless,\n      striped: this._options.striped,\n      hover: this._options.hover,\n      fixedHeader: this._options.fixedHeader,\n      sm: this._options.sm,\n      sortIconTemplate: this._options.sortIconTemplate,\n      pagination: {\n        enable: this._options.pagination,\n        text: this.navigationText,\n        entries: this._options.entries,\n        entriesOptions: this._options.entriesOptions,\n        fullPagination: this._options.fullPagination,\n        rowsText: this._options.rowsText,\n        ofText: this._options.ofText,\n        allText: this._options.allText,\n        paginationStartIconTemplate: this._options.paginationStartIconTemplate,\n        paginationLeftIconTemplate: this._options.paginationLeftIconTemplate,\n        paginationRightIconTemplate: this._options.paginationRightIconTemplate,\n        paginationEndIconTemplate: this._options.paginationEndIconTemplate,\n        classes: this._classes\n      },\n      forceSort: this._options.forceSort\n    };\n  }\n  // Public\n  update(t, e = {}) {\n    t && t.rows && (this._rows = t.rows), t && t.columns && (this._columns = t.columns), this._clearClassList(e), this._options = this._getOptions({ ...this._options, ...e }), this._setup(), this._performSort();\n  }\n  dispose() {\n    this._selectInstance && this._selectInstance.dispose(), y.removeData(this._element, Ei), this._removeEventListeners(), this._perfectScrollbar.destroy(), this._element = null;\n  }\n  search(t, e) {\n    this._search = t, this._searchColumn = e, this._activePage = 0, this._options.pagination && this._toggleDisableState(), this._renderRows(), this._options.maxHeight && (this._perfectScrollbar.element.scrollTop = 0, this._perfectScrollbar.update());\n  }\n  sort(t, e = \"asc\") {\n    this._options.sortOrder = e, typeof t == \"string\" ? this._options.sortField = this.columns.find(\n      (n) => n.label === t\n    ).field : this._options.sortField = t.field;\n    const i = d.findOne(\n      `[data-te-sort=\"${this._options.sortField}\"]`,\n      this._element\n    );\n    this._activePage = 0, this._toggleDisableState(), this._renderRows(), this._setActiveSortIcon(i);\n  }\n  setActivePage(t) {\n    t < this.pages && this._changeActivePage(t);\n  }\n  // Private\n  _getClasses(t) {\n    const e = h.getDataClassAttributes(this._element);\n    return t = {\n      ...QT,\n      ...e,\n      ...t\n    }, D(Ni, t, JT), t;\n  }\n  _changeActivePage(t) {\n    this._activePage = t, this._toggleDisableState(), this._renderRows();\n  }\n  _clearClassList(t) {\n    [\"hover\", \"bordered\", \"borderless\", \"sm\", \"striped\"].forEach((e) => {\n      this._options[e] && !t[e] && h.removeDataAttribute(`data-te-${e}`);\n    });\n  }\n  _emitSelectEvent() {\n    c.trigger(this._element, Gv, {\n      selectedRows: this.rows.filter(\n        (t) => this._selected.indexOf(t.rowIndex) !== -1\n      ),\n      selectedIndexes: this._selected,\n      allSelected: this._selected.length === this.rows.length\n    });\n  }\n  _getRows(t = []) {\n    const e = d.findOne(\"tbody\", this._element);\n    return e ? [...d.find(\"tr\", e).map((n) => d.find(\"td\", n).map((o) => o.innerHTML)), ...t] : t;\n  }\n  _getColumns(t = []) {\n    const e = d.findOne(\"thead\", this._element);\n    if (!e)\n      return t;\n    const i = d.findOne(\"tr\", e);\n    return [...d.find(\"th\", i).map((o) => ({\n      label: o.innerHTML,\n      ...h.getDataAttributes(o)\n    })), ...t];\n  }\n  _getCSSValue(t) {\n    return typeof t == \"string\" ? t : `${t}px`;\n  }\n  _getOptions(t) {\n    const e = {\n      ...GT,\n      ...h.getDataAttributes(this._element),\n      ...t\n    };\n    return D(Ni, e, XT), e;\n  }\n  _setActiveRows() {\n    d.find(fi, this._element).forEach((t) => {\n      this._selected.includes(h.getDataAttribute(t, \"index\")) ? h.addClass(t, `active ${this._classes.selectableRow}`) : h.removeClass(t, `active ${this._classes.selectableRow}`);\n    });\n  }\n  _setEntries(t) {\n    this._options = this._getOptions({\n      ...this._options,\n      entries: t.target.value\n    }), this._activePage > this.pages - 1 && (this._activePage = this.pages - 1), this._toggleDisableState(), this._renderRows();\n  }\n  _setSelected() {\n    d.find(go, this._element).forEach(\n      (t) => {\n        const e = h.getDataAttribute(t, \"rowIndex\");\n        t.checked = this._selected.includes(e);\n      }\n    ), this._setActiveRows();\n  }\n  _setActiveSortIcon(t) {\n    d.find(mo, this._element).forEach((e) => {\n      const i = this._options.sortOrder === \"desc\" && e === t ? 180 : 0;\n      h.style(e, {\n        transform: `rotate(${i}deg)`\n      }), e === t && this._options.sortOrder ? h.addClass(e, \"opacity-100\") : h.removeClass(e, \"opacity-100\");\n    });\n  }\n  _setup() {\n    this._renderTable(), this._options.pagination && this._setupPagination(), this._options.edit && this._setupEditable(), this._options.clickableRows && this._setupClickableRows(), this._options.selectable && this._setupSelectable(), this._setupScroll(), this._setupSort();\n  }\n  _setupClickableRows() {\n    d.find(fi, this._element).forEach((t) => {\n      const e = h.getDataAttribute(t, \"index\");\n      h.addClass(t, \"cursor-pointer\"), c.on(t, \"click\", (i) => {\n        d.matches(i.target, go) || c.trigger(this._element, qv, {\n          index: e,\n          row: this.rows[e]\n        });\n      });\n    });\n  }\n  _setupEditable() {\n    d.find(fi, this._element).forEach((t) => {\n      const e = h.getDataAttribute(t, \"index\");\n      d.find(fo, t).forEach((i) => {\n        c.on(i, \"input\", (n) => this._updateRow(n, e));\n      });\n    });\n  }\n  _setupScroll() {\n    const t = d.findOne(Vv, this._element), e = {};\n    if (this._options.maxHeight && (e.maxHeight = this._getCSSValue(this._options.maxHeight)), this._options.maxWidth) {\n      const i = this._getCSSValue(this._options.maxWidth);\n      e.maxWidth = i, h.style(this._element, { maxWidth: i });\n    }\n    if (h.style(t, e), h.addClass(t, `${this._classes.scroll}`), this._options.fixedHeader) {\n      let i = d.find(Wv, this._element);\n      this._options.selectable && (i = i.filter((n, o) => (h.addClass(\n        n,\n        `${this._classes.fixedHeader} ${this._classes.color}`\n      ), o !== 0))), i.forEach((n, o) => {\n        h.addClass(\n          n,\n          `${this._classes.fixedHeader} ${this._classes.color}`\n        ), this.columns[o].fixed && h.addClass(n, \"!z-40\");\n      });\n    }\n    this._perfectScrollbar = new mh(t);\n  }\n  _setupSort() {\n    d.find(mo, this._element).forEach((t) => {\n      const e = h.getDataAttribute(t, \"sort\"), [i] = d.parents(t, \"th\");\n      if (this.columns.sort)\n        h.addClass(i, \"cursor-pointer\");\n      else\n        return;\n      e === this._options.sortField && this._setActiveSortIcon(t), c.on(i, \"click\", () => {\n        this._options.sortField === e && this._options.sortOrder === \"asc\" ? this._options.sortOrder = \"desc\" : this._options.sortField === e && this._options.sortOrder === \"desc\" ? this._options.sortOrder = this._options.forceSort ? \"asc\" : null : this._options.sortOrder = \"asc\", this._options.sortField = e, this._activePage = 0, this._performSort(), this._setActiveSortIcon(t);\n      });\n    });\n  }\n  _performSort() {\n    this._toggleDisableState(), this._renderRows();\n  }\n  _setupSelectable() {\n    this._checkboxes = d.find(go, this._element), this._headerCheckbox = d.findOne(\n      Fv,\n      this._element\n    ), c.on(\n      this._headerCheckbox,\n      \"input\",\n      (t) => this._toggleSelectAll(t)\n    ), this._checkboxes.forEach((t) => {\n      const e = h.getDataAttribute(t, \"rowIndex\");\n      c.on(\n        t,\n        \"input\",\n        (i) => this._toggleSelectRow(i, e)\n      );\n    });\n  }\n  _setupPagination() {\n    this._paginationRight = d.findOne(\n      Yv,\n      this._element\n    ), this._paginationLeft = d.findOne(\n      jv,\n      this._element\n    ), c.on(\n      this._paginationRight,\n      \"click\",\n      () => this._changeActivePage(this._activePage + 1)\n    ), c.on(\n      this._paginationLeft,\n      \"click\",\n      () => this._changeActivePage(this._activePage - 1)\n    ), this._options.fullPagination && (this._paginationStart = d.findOne(\n      Kv,\n      this._element\n    ), this._paginationEnd = d.findOne(\n      zv,\n      this._element\n    ), c.on(\n      this._paginationStart,\n      \"click\",\n      () => this._changeActivePage(0)\n    ), c.on(\n      this._paginationEnd,\n      \"click\",\n      () => this._changeActivePage(this.pages - 1)\n    )), this._toggleDisableState(), this._setupPaginationSelect();\n  }\n  _setupPaginationSelect() {\n    this._select = d.findOne(Xv, this._element), this._selectInstance = new _r(this._select), c.on(\n      this._select,\n      \"valueChange.te.select\",\n      (t) => this._setEntries(t)\n    );\n  }\n  _removeEventListeners() {\n    this._options.pagination && (c.off(this._paginationRight, \"click\"), c.off(this._paginationLeft, \"click\"), c.off(this._select, \"valueChange.te.select\"), this._options.fullPagination && (c.off(this._paginationStart, \"click\"), c.off(this._paginationEnd, \"click\"))), this._options.edit && d.find(fo, this._element).forEach((t) => {\n      c.off(t, \"input\");\n    }), this._options.clickableRows && d.find(fi, this._element).forEach((t) => {\n      c.off(t, \"click\");\n    }), d.find(mo, this._element).forEach((t) => {\n      const [e] = d.parents(t, \"th\");\n      c.off(e, \"click\");\n    }), this._options.selectable && (c.off(this._headerCheckbox, \"input\"), this._checkboxes.forEach((t) => {\n      c.off(t, \"input\");\n    }));\n  }\n  _renderTable() {\n    this._element.innerHTML = wl(this.tableOptions).table, this._formatCells(), c.trigger(this._element, xl);\n  }\n  _renderRows() {\n    const t = d.findOne(\"tbody\", this._element);\n    if (this._options.pagination) {\n      const e = d.findOne(\n        Uv,\n        this._element\n      );\n      e.innerText = this.navigationText;\n    }\n    t.innerHTML = wl(this.tableOptions).rows, this._formatCells(), this._options.edit && this._setupEditable(), this._options.selectable && (this._setupSelectable(), this._setSelected()), this._options.clickableRows && this._setupClickableRows(), c.trigger(this._element, xl);\n  }\n  _formatCells() {\n    d.find(fi, this._element).forEach((e) => {\n      const i = h.getDataAttribute(e, \"index\");\n      d.find(fo, e).forEach((o) => {\n        const r = h.getDataAttribute(o, \"field\"), a = this.columns.find((l) => l.field === r);\n        a && a.format !== null && a.format(o, this.rows[i][r]);\n      });\n    });\n  }\n  _toggleDisableState() {\n    this._options.pagination !== !1 && (this._activePage === 0 || this._options.loading ? (this._paginationLeft.setAttribute(\"disabled\", \"\"), this._options.fullPagination && this._paginationStart.setAttribute(\"disabled\", \"\")) : (this._paginationLeft.removeAttribute(\"disabled\"), this._options.fullPagination && this._paginationStart.removeAttribute(\"disabled\")), this._activePage === this.pages - 1 || this._options.loading || this.pages === 0 ? (this._paginationRight.setAttribute(\"disabled\", \"\"), this._options.fullPagination && this._paginationEnd.setAttribute(\"disabled\", \"\")) : (this._paginationRight.removeAttribute(\"disabled\"), this._options.fullPagination && this._paginationEnd.removeAttribute(\"disabled\")));\n  }\n  _toggleSelectAll(t) {\n    t.target.checked ? this._selected = this.rows.map((e) => e.rowIndex) : this._selected = [], this._setSelected(), this._emitSelectEvent();\n  }\n  _toggleSelectRow(t, e) {\n    t.target.checked ? this._options.multi && !this._selected.includes(e) ? this._selected = [...this._selected, e] : (this._selected = [e], this._checkboxes.forEach((i) => {\n      i !== t.target && (i.checked = !1);\n    })) : this._selected = this._selected.filter((i) => i !== e), this._options.multi && !t.target.checked && (this._headerCheckbox.checked = !1), this._setActiveRows(), this._emitSelectEvent();\n  }\n  _updateRow(t, e) {\n    const i = h.getDataAttribute(t.target, \"field\"), n = t.target.textContent, o = this._rows[e];\n    if (Array.isArray(o)) {\n      const a = this.columns.find((l) => l.field === i).columnIndex;\n      o[a] = n;\n    } else\n      o[i] = n;\n    c.trigger(this._element, Zv, {\n      rows: this._rows,\n      columns: this._columns\n    });\n  }\n  static jQueryInterface(t, e, i) {\n    return this.each(function() {\n      let n = y.getData(this, Ei);\n      const o = typeof t == \"object\" && t;\n      if (!(!n && /dispose/.test(t)) && (n || (n = new gh(this, o, e)), typeof t == \"string\")) {\n        if (typeof n[t] > \"u\")\n          throw new TypeError(`No method named \"${t}\"`);\n        n[t](e, i);\n      }\n    });\n  }\n  static getInstance(t) {\n    return y.getData(t, Ei);\n  }\n  static getOrCreateInstance(t, e = {}) {\n    return this.getInstance(t) || new this(t, typeof e == \"object\" ? e : null);\n  }\n}\nconst Ol = \"rating\", qs = \"te.rating\", tE = \"data-te-rating-init\", eE = \"[data-te-rating-icon-ref]\", ni = `.${qs}`, iE = \"ArrowLeft\", sE = \"ArrowRight\", nE = {\n  tooltip: \"string\",\n  value: \"(string|number)\",\n  readonly: \"boolean\",\n  after: \"string\",\n  before: \"string\",\n  dynamic: \"boolean\",\n  active: \"string\"\n}, oE = {\n  tooltip: \"top\",\n  value: \"\",\n  readonly: !1,\n  after: \"\",\n  before: \"\",\n  dynamic: !1,\n  active: \"fill-current\"\n}, Sl = `onSelect${ni}`, rE = `onHover${ni}`, Il = `keyup${ni}`, Dl = `focusout${ni}`, $l = `keydown${ni}`, Ll = `mousedown${ni}`;\nclass qC {\n  constructor(t, e) {\n    this._element = t, this._icons = d.find(eE, this._element), this._options = this._getConfig(e), this._index = -1, this._savedIndex = null, this._originalClassList = [], this._originalIcons = [], this._fn = {}, this._tooltips = [], this._element && (y.setData(t, qs, this), this._init());\n  }\n  // Getters\n  static get NAME() {\n    return Ol;\n  }\n  dispose() {\n    y.removeData(this._element, qs), this._options.readonly || (c.off(this._element, Il), c.off(this._element, Dl), c.off(this._element, $l), this._element.removeEventListener(\"mouseleave\", this._fn.mouseleave), this._icons.forEach((t, e) => {\n      c.off(t, Ll), t.removeEventListener(\"mouseenter\", this._fn.mouseenter[e]), h.removeClass(t, \"cursor-pointer\");\n    }), this._tooltips.forEach((t) => {\n      t._element.removeAttribute(tE), t.dispose();\n    }), this._icons.removeAttribute(\"tabIndex\")), this._element = null;\n  }\n  // Private\n  _init() {\n    this._options.readonly || (this._bindMouseEnter(), this._bindMouseLeave(), this._bindMouseDown(), this._bindKeyDown(), this._bindKeyUp(), this._bindFocusLost(), this._icons.forEach((t) => {\n      h.addClass(t, \"cursor-pointer\");\n    })), this._options.dynamic && (this._saveOriginalClassList(), this._saveOriginalIcons()), this._setCustomText(), this._setToolTips(), this._options.value && (this._index = this._options.value - 1, this._updateRating(this._index));\n  }\n  _getConfig(t) {\n    const e = h.getDataAttributes(this._element);\n    return t = {\n      ...oE,\n      ...e,\n      ...t\n    }, D(Ol, t, nE), t;\n  }\n  _bindMouseEnter() {\n    this._fn.mouseenter = [], this._icons.forEach((t, e) => {\n      t.addEventListener(\n        \"mouseenter\",\n        // this._fn.mouseenter[i] is needed to create reference and unpin events after call dispose\n        // prettier-ignore\n        this._fn.mouseenter[e] = (i) => {\n          this._index = this._icons.indexOf(i.target), this._updateRating(this._index), this._triggerEvents(t, rE);\n        }\n      );\n    });\n  }\n  _bindMouseLeave() {\n    this._element.addEventListener(\n      \"mouseleave\",\n      // this._fn.mouseleave is needed to create reference and unpin events after call dispose\n      // prettier-ignore\n      this._fn.mouseleave = () => {\n        this._savedIndex !== null ? (this._updateRating(this._savedIndex), this._index = this._savedIndex) : this._options.value ? (this._updateRating(this._options.value - 1), this._index = this._options.value - 1) : (this._index = -1, this._clearRating());\n      }\n    );\n  }\n  _bindMouseDown() {\n    this._icons.forEach((t) => {\n      c.on(t, Ll, () => {\n        this._setElementOutline(\"none\"), this._savedIndex = this._index, this._triggerEvents(t, Sl);\n      });\n    });\n  }\n  _bindKeyDown() {\n    this._element.tabIndex = 0, c.on(\n      this._element,\n      $l,\n      (t) => this._updateAfterKeyDown(t)\n    );\n  }\n  _bindKeyUp() {\n    c.on(\n      this._element,\n      Il,\n      () => this._setElementOutline(\"auto\")\n    );\n  }\n  _bindFocusLost() {\n    c.on(\n      this._element,\n      Dl,\n      () => this._setElementOutline(\"none\")\n    );\n  }\n  _setElementOutline(t) {\n    this._element.style.outline = t;\n  }\n  _triggerEvents(t, e) {\n    c.trigger(t, e, {\n      value: this._index + 1\n    });\n  }\n  _updateAfterKeyDown(t) {\n    const e = this._icons.length - 1, i = this._index;\n    t.key === sE && this._index < e && (this._index += 1), t.key === iE && this._index > -1 && (this._index -= 1), i !== this._index && (this._savedIndex = this._index, this._updateRating(this._savedIndex), this._triggerEvents(this._icons[this._savedIndex], Sl));\n  }\n  _updateRating(t) {\n    this._clearRating(), this._options.dynamic && this._restoreOriginalIcon(t), this._icons.forEach((e, i) => {\n      i <= t && h.addClass(e.querySelector(\"svg\"), this._options.active);\n    });\n  }\n  _clearRating() {\n    this._icons.forEach((t, e) => {\n      const i = t.querySelector(\"svg\");\n      this._options.dynamic && (t.classList = this._originalClassList[e], i.innerHTML = this._originalIcons[e]), h.removeClass(i, this._options.active);\n    });\n  }\n  _setToolTips() {\n    this._icons.forEach((t, e) => {\n      const i = h.getDataAttribute(t, \"toggle\");\n      t.title && !i && (h.setDataAttribute(t, \"toggle\", \"tooltip\"), this._tooltips[e] = new ii(t, {\n        placement: this._options.tooltip\n      }));\n    });\n  }\n  _setCustomText() {\n    this._icons.forEach((t) => {\n      const e = h.getDataAttribute(t, \"after\"), i = h.getDataAttribute(t, \"before\");\n      e && t.insertAdjacentHTML(\"afterEnd\", e), i && t.insertAdjacentHTML(\"beforeBegin\", i);\n    });\n  }\n  _saveOriginalClassList() {\n    this._icons.forEach((t) => {\n      const e = t.classList.value;\n      this._originalClassList.push(e);\n    });\n  }\n  _saveOriginalIcons() {\n    this._icons.forEach((t) => {\n      const e = t.querySelector(\"svg\").innerHTML;\n      this._originalIcons.push(e);\n    });\n  }\n  _restoreOriginalIcon(t) {\n    const e = this._originalClassList[t], i = this._originalIcons[t];\n    this._icons.forEach((n, o) => {\n      if (o <= t) {\n        const r = n.querySelector(\"svg\");\n        r.innerHTML = i, n.classList = e;\n      }\n    });\n  }\n  // Static\n  static getInstance(t) {\n    return y.getData(t, qs);\n  }\n  static getOrCreateInstance(t, e = {}) {\n    return this.getInstance(t) || new this(t, typeof e == \"object\" ? e : null);\n  }\n}\nconst bo = \"popconfirm\", Ci = \"te.popconfirm\", bh = `.${Ci}`, aE = `cancel${bh}`, lE = `confirm${bh}`, cE = \"[data-te-popconfirm-body]\", vo = \"data-te-popconfirm-popover\", hE = \"data-te-popconfirm-modal\", Nl = \"data-te-popconfirm-backdrop\", dE = {\n  popconfirmMode: \"string\",\n  message: \"string\",\n  cancelText: \"(null|string)\",\n  okText: \"(null|string)\",\n  popconfirmIconTemplate: \"string\",\n  cancelLabel: \"(null|string)\",\n  confirmLabel: \"(null|string)\",\n  position: \"(null|string)\"\n}, uE = {\n  popconfirmMode: \"inline\",\n  message: \"Are you sure?\",\n  cancelText: \"Cancel\",\n  okText: \"OK\",\n  popconfirmIconTemplate: \"\",\n  cancelLabel: \"Cancel\",\n  confirmLabel: \"Confirm\",\n  position: \"bottom\"\n}, pE = {\n  backdrop: \"string\",\n  body: \"string\",\n  btnCancel: \"string\",\n  btnConfirm: \"string\",\n  btnsContainer: \"string\",\n  fade: \"string\",\n  icon: \"string\",\n  message: \"string\",\n  messageText: \"string\",\n  modal: \"string\",\n  popover: \"string\"\n}, _E = {\n  backdrop: \"h-full w-full z-[1070] fixed top-0 left-0 bg-[#00000066] flex justify-center items-center\",\n  body: \"p-[1rem] bg-white rounded-[0.5rem] opacity-0 dark:bg-neutral-700\",\n  btnCancel: \"inline-block rounded bg-primary-100 px-4 pb-[5px] pt-[6px] text-xs font-medium uppercase leading-normal text-primary-700 transition duration-150 ease-in-out hover:bg-primary-accent-100 focus:bg-primary-accent-100 focus:outline-none focus:ring-0 active:bg-primary-accent-200\",\n  btnConfirm: \"inline-block rounded bg-primary px-4 pb-[5px] pt-[6px] text-xs font-medium uppercase leading-normal text-white shadow-[0_4px_9px_-4px_#3b71ca] transition duration-150 ease-in-out hover:bg-primary-600 hover:shadow-[0_8px_9px_-4px_rgba(59,113,202,0.3),0_4px_18px_0_rgba(59,113,202,0.2)] focus:bg-primary-600 focus:shadow-[0_8px_9px_-4px_rgba(59,113,202,0.3),0_4px_18px_0_rgba(59,113,202,0.2)] focus:outline-none focus:ring-0 active:bg-primary-700 active:shadow-[0_8px_9px_-4px_rgba(59,113,202,0.3),0_4px_18px_0_rgba(59,113,202,0.2)] dark:shadow-[0_4px_9px_-4px_rgba(59,113,202,0.5)] dark:hover:shadow-[0_8px_9px_-4px_rgba(59,113,202,0.2),0_4px_18px_0_rgba(59,113,202,0.1)] dark:focus:shadow-[0_8px_9px_-4px_rgba(59,113,202,0.2),0_4px_18px_0_rgba(59,113,202,0.1)] dark:active:shadow-[0_8px_9px_-4px_rgba(59,113,202,0.2),0_4px_18px_0_rgba(59,113,202,0.1)]\",\n  btnsContainer: \"flex justify-end space-x-2\",\n  fade: \"transition-opacity duration-[150ms] ease-linear\",\n  icon: \"pr-2\",\n  message: \"flex mb-3\",\n  messageText: \"text-neutral-600 dark:text-white\",\n  modal: \"absolute w-[300px] z-[1080] shadow-sm rounded-[0.5rem]\",\n  popover: \"w-[300px] border-0 rounded-[0.5rem] z-[1080] shadow-sm\"\n};\nclass vh {\n  constructor(t, e, i) {\n    this._element = t, this._options = this._getConfig(e), this._classes = this._getClasses(i), this._popper = null, this._cancelButton = \"\", this._confirmButton = \"\", this._isOpen = !1, this._uid = this._element.id ? `popconfirm-${this._element.id}` : rt(\"popconfirm-\"), t && y.setData(t, Ci, this), this._clickHandler = this.open.bind(this), c.on(this._element, \"click\", this._clickHandler);\n  }\n  // Getters\n  static get NAME() {\n    return bo;\n  }\n  get container() {\n    return d.findOne(`#${this._uid}`);\n  }\n  get popconfirmBody() {\n    return d.findOne(\n      cE,\n      this.container\n    );\n  }\n  // Public\n  dispose() {\n    (this._isOpen || this.container !== null) && this.close(), y.removeData(this._element, Ci), c.off(this._element, \"click\", this._clickHandler), this._element = null;\n  }\n  open() {\n    this._isOpen || (this._options.popconfirmMode === \"inline\" ? this._openPopover(this._getPopoverTemplate()) : this._openModal(this._getModalTemplate()), this._handleCancelButtonClick(), this._handleConfirmButtonClick(), this._listenToEscapeKey(), this._listenToOutsideClick());\n  }\n  close() {\n    if (this._isOpen) {\n      if (this._popper !== null || d.findOne(`[${vo}]`) !== null)\n        c.on(\n          this.popconfirmBody,\n          \"transitionend\",\n          this._handlePopconfirmTransitionEnd.bind(this)\n        ), h.removeClass(this.popconfirmBody, \"opacity-100\");\n      else {\n        const t = d.findOne(\n          `[${Nl}]`\n        );\n        h.removeClass(this.popconfirmBody, \"opacity-100\"), document.body.removeChild(t), this._isOpen = !1;\n      }\n      c.off(document, \"click\", this._handleOutsideClick.bind(this)), c.off(document, \"keydown\", this._handleEscapeKey.bind(this));\n    }\n  }\n  _handlePopconfirmTransitionEnd(t) {\n    if (t.target !== this.popconfirmBody)\n      return;\n    const e = d.findOne(\n      `[${vo}]`\n    );\n    c.off(this.popconfirmBody, \"transitionend\"), this._isOpen && t && t.propertyName === \"opacity\" && (this._popper.destroy(), e && document.body.removeChild(e), this._isOpen = !1);\n  }\n  // Private\n  _getPopoverTemplate() {\n    const t = $(\"div\"), e = this._getPopconfirmTemplate();\n    return t.setAttribute(vo, \"\"), h.addClass(t, this._classes.popover), t.id = this._uid, t.innerHTML = e, t;\n  }\n  _getModalTemplate() {\n    const t = $(\"div\"), e = this._getPopconfirmTemplate();\n    return t.setAttribute(hE, \"\"), h.addClass(t, `${this._classes.modal}`), t.id = this._uid, t.innerHTML = e, t;\n  }\n  _getPopconfirmTemplate() {\n    return `<div data-te-popconfirm-body class=\"${this._classes.body}\">\n      <p class=\"${this._classes.message}\">\n      ${this._options.popconfirmIconTemplate ? `<span class=\"${this._classes.icon}\">${this._options.popconfirmIconTemplate}</span>` : \"\"}\n      <span class=\"${this._classes.messageText}\">${this._options.message}</span>\n      </p>\n      <div class=\"${this._classes.btnsContainer}\">\n      ${this._options.cancelText ? `<button type=\"button\" data-te-ripple-init data-te-ripple-color=\"light\" id=\"popconfirm-button-cancel\" aria-label=\"${this._options.cancelLabel}\"\n        class=\"${this._classes.btnCancel}\">${this._options.cancelText}</button>` : \"\"}\n      <button type=\"button\" data-te-ripple-init data-te-ripple-color=\"light\" id=\"popconfirm-button-confirm\"\n      aria-label=\"${this._options.confirmLabel}\"\n      class=\"${this._classes.btnConfirm}\">${this._options.okText ? this._options.okText : \"Ok\"}</button>\n      </div>\n    </div>`;\n  }\n  _getConfig(t) {\n    return t = {\n      ...uE,\n      ...h.getDataAttributes(this._element),\n      ...t\n    }, D(bo, t, dE), t;\n  }\n  _getClasses(t) {\n    const e = h.getDataClassAttributes(this._element);\n    return t = {\n      ..._E,\n      ...e,\n      ...t\n    }, D(bo, t, pE), t;\n  }\n  _openPopover(t) {\n    this._popper = Ce(this._element, t, {\n      placement: this._translatePositionValue(),\n      modifiers: [\n        {\n          name: \"offset\",\n          options: {\n            offset: [0, 5]\n          }\n        }\n      ]\n    }), document.body.appendChild(t), setTimeout(() => {\n      h.addClass(\n        this.popconfirmBody,\n        `${this._classes.fade} opacity-100`\n      ), this._isOpen = !0;\n    }, 0);\n  }\n  _openModal(t) {\n    const e = $(\"div\");\n    e.setAttribute(Nl, \"\"), h.addClass(e, this._classes.backdrop), document.body.appendChild(e), e.appendChild(t), h.addClass(this.popconfirmBody, \"opacity-100\"), this._isOpen = !0;\n  }\n  _handleCancelButtonClick() {\n    const t = this.container;\n    this._cancelButton = d.findOne(\n      \"#popconfirm-button-cancel\",\n      t\n    ), Ze.getOrCreateInstance(this._cancelButton, { rippleColor: \"light\" }), this._cancelButton !== null && c.on(this._cancelButton, \"click\", () => {\n      this.close(), c.trigger(this._element, aE);\n    });\n  }\n  _handleConfirmButtonClick() {\n    const t = this.container;\n    this._confirmButton = d.findOne(\n      \"#popconfirm-button-confirm\",\n      t\n    ), Ze.getOrCreateInstance(this._confirmButton, { rippleColor: \"light\" }), c.on(this._confirmButton, \"click\", () => {\n      this.close(), c.trigger(this._element, lE);\n    });\n  }\n  _listenToEscapeKey() {\n    c.on(document, \"keydown\", this._handleEscapeKey.bind(this));\n  }\n  _handleEscapeKey(t) {\n    t.keyCode === Fi && this.close();\n  }\n  _listenToOutsideClick() {\n    c.on(document, \"click\", this._handleOutsideClick.bind(this));\n  }\n  _handleOutsideClick(t) {\n    const e = this.container, i = t.target === e, n = e && e.contains(t.target), o = t.target === this._element, r = this._element && this._element.contains(t.target);\n    !i && !n && !o && !r && this.close();\n  }\n  _translatePositionValue() {\n    switch (this._options.position) {\n      case \"top left\":\n        return \"top-end\";\n      case \"top\":\n        return \"top\";\n      case \"top right\":\n        return \"top-start\";\n      case \"bottom left\":\n        return \"bottom-end\";\n      case \"bottom\":\n        return \"bottom\";\n      case \"bottom right\":\n        return \"bottom-start\";\n      case \"left\":\n        return \"left\";\n      case \"left top\":\n        return \"left-end\";\n      case \"left bottom\":\n        return \"left-start\";\n      case \"right\":\n        return \"right\";\n      case \"right top\":\n        return \"right-end\";\n      case \"right bottom\":\n        return \"right-start\";\n      case void 0:\n        return \"bottom\";\n      default:\n        return \"bottom\";\n    }\n  }\n  // Static\n  static jQueryInterface(t, e) {\n    return this.each(function() {\n      const i = y.getData(this, Ci), n = typeof t == \"object\" && t;\n      if (!(!i && /dispose/.test(t))) {\n        if (!i)\n          return new vh(this, n);\n        if (typeof t == \"string\") {\n          if (typeof i[t] > \"u\")\n            throw new TypeError(`No method named \"${t}\"`);\n          i[t](e);\n        }\n      }\n    });\n  }\n  static getInstance(t) {\n    return y.getData(t, Ci);\n  }\n  static getOrCreateInstance(t, e = {}) {\n    return this.getInstance(t) || new this(t, typeof e == \"object\" ? e : null);\n  }\n}\nconst To = \"lightbox\", Ai = \"te.lightbox\", fE = `.${Ai}`, mE = \".data-api\", Ie = `click${fE}${mE}`, Th = \"[data-te-lightbox-init]\", gE = `${Th} img:not([data-te-lightbox-disabled])`, Ml = \"data-te-lightbox-caption\", bE = \"data-te-lightbox-disabled\", It = \"data-te-lightbox-active\", vE = `<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"currentColor\" viewBox=\"0 0 24 24\" stroke-width=\"3\" stroke=\"currentColor\" class=\"w-4 h-4\">\n  <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M19.5 12h-15m0 0l6.75 6.75M4.5 12l6.75-6.75\" />\n</svg>\n`, TE = `<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"currentColor\" viewBox=\"0 0 24 24\" stroke-width=\"3\" stroke=\"currentColor\" class=\"w-4 h-4\">\n  <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M4.5 12h15m0 0l-6.75-6.75M19.5 12l-6.75 6.75\" />\n</svg>\n`, EE = `<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"3\" stroke=\"currentColor\" class=\"w-4 h-4\">\n  <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M3.75 3.75v4.5m0-4.5h4.5m-4.5 0L9 9M3.75 20.25v-4.5m0 4.5h4.5m-4.5 0L9 15M20.25 3.75h-4.5m4.5 0v4.5m0-4.5L15 9m5.25 11.25h-4.5m4.5 0v-4.5m0 4.5L15 15\" />\n</svg>\n`, CE = `<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"3\" stroke=\"currentColor\" class=\"w-4 h-4\">\n  <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M9 9V4.5M9 9H4.5M9 9L3.75 3.75M9 15v4.5M9 15H4.5M9 15l-5.25 5.25M15 9h4.5M15 9V4.5M15 9l5.25-5.25M15 15h4.5M15 15v4.5m0-4.5l5.25 5.25\" />\n</svg>\n`, AE = `<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"3\" stroke=\"currentColor\" class=\"w-4 h-4\">\n  <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607zM10.5 7.5v6m3-3h-6\" />\n</svg>\n`, yE = `<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"3\" stroke=\"currentColor\" class=\"w-4 h-4\">\n<path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607zM13.5 10.5h-6\" />\n</svg>\n`, wE = `<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"3\" stroke=\"currentColor\" class=\"w-4 h-4\">\n  <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M6 18L18 6M6 6l12 12\" />\n</svg>\n`, kE = {\n  container: \"string\",\n  zoomLevel: \"(number|string)\",\n  prevIconTemplate: \"string\",\n  nextIconTemplate: \"string\",\n  showFullscreenIconTemplate: \"string\",\n  hideFullscreenIconTemplate: \"string\",\n  zoomInIconTemplate: \"string\",\n  closeIconTemplate: \"string\",\n  zoomOutIconTemplate: \"string\",\n  spinnerContent: \"string\"\n}, xE = {\n  container: \"body\",\n  zoomLevel: 1,\n  prevIconTemplate: vE,\n  nextIconTemplate: TE,\n  showFullscreenIconTemplate: EE,\n  hideFullscreenIconTemplate: CE,\n  zoomInIconTemplate: AE,\n  zoomOutIconTemplate: yE,\n  closeIconTemplate: wE,\n  spinnerContent: \"Loading...\"\n}, OE = {\n  caption: \"text-white text-ellipsis overflow-hidden whitespace-nowrap mx-[10px] text-center\",\n  captionWrapper: \"fixed left-0 bottom-0 w-full h-[50px] flex justify-center items-center\",\n  closeBtn: \"border-none bg-transparent w-[50px] h-[50px] px-4 text-[#b3b3b3] transition-colors duration-200 ease-in-out hover:text-white focus:text-white motion-reduce:transition-none outline-none\",\n  fullscreenBtn: \"border-none bg-transparent w-[50px] h-[50px] px-4 text-[#b3b3b3] transition-colors duration-200 ease-in-out hover:text-white focus:text-white motion-reduce:transition-none outline-none\",\n  gallery: \"invisible fixed left-0 top-0 w-full h-full z-[1100] pointer-events-none opacity-0 bg-[#000000e6] transition-all duration-[400ms] motion-reduce:transition-none\",\n  galleryContent: \"fixed top-[50px] left-[50px] w-[calc(100%-100px)] h-[calc(100%-100px)]\",\n  galleryCounter: \"flex justify-center items-center px-[10px] mb-0 h-full text-[#b3b3b3]\",\n  img: \"absolute left-0 top-0 w-full max-h-full h-auto cursor-pointer pointer-events-auto\",\n  imgWrapper: \"absolute top-0 left-0 w-full h-full opacity-0 transform scale-[0.25] transition-all duration-[400ms] ease-out pointer-events-none motion-reduce:transition-none motion-reduce:transform-none\",\n  leftTools: \"float-left h-full\",\n  loader: \"fixed left-0 top-0 z-[2] w-full h-full text-neutral-50 opacity-1 flex justify-center items-center pointer-events-none transition-opacity duration-[1000ms] motion-reduce:transition-none\",\n  nextBtn: \"border-none bg-transparent w-full h-[50px] flex justify-center items-center text-[#b3b3b3] transition-colors duration-200 ease-in-out hover:text-white focus:text-white motion-reduce:transition-none outline-none\",\n  nextBtnWrapper: \"fixed right-0 top-0 w-[50px] h-full flex justify-center items-center transition-opacity duration-[400ms] motion-reduce:transition-none\",\n  prevBtn: \"border-none bg-transparent w-full h-[50px] flex justify-center items-center text-[#b3b3b3] transition-colors duration-200 ease-in-out hover:text-white focus:text-white motion-reduce:transition-none outline-none\",\n  prevBtnWrapper: \"fixed left-0 top-0 w-[50px] h-full flex justify-center items-center transition-opacity duration-[400ms] motion-reduce:transition-none\",\n  rightTools: \"float-right\",\n  spinner: \"inline-block h-8 w-8 animate-[spinner-grow_0.75s_linear_infinite] rounded-full bg-current align-[-0.125em] motion-reduce:animate-[spinner-grow_1.5s_linear_infinite]\",\n  spinnerContent: \"!absolute !-m-px !h-px !w-px !overflow-hidden !whitespace-nowrap !border-0 !p-0 ![clip:rect(0,0,0,0)]\",\n  toolbar: \"absolute top-0 left-0 w-full h-[50px] z-20 transition-opacity duration-[400ms] motion-reduce:transition-none\",\n  vertical: \"h-full max-h-full w-auto\",\n  zoomBtn: \"border-none bg-transparent w-[50px] h-[50px] px-4 text-[#b3b3b3] transition-colors duration-200 ease-in-out hover:text-white focus:text-white motion-reduce:transition-none outline-none\"\n}, SE = {\n  caption: \"string\",\n  captionWrapper: \"string\",\n  closeBtn: \"string\",\n  fullscreenBtn: \"string\",\n  gallery: \"string\",\n  galleryContent: \"string\",\n  galleryCounter: \"string\",\n  img: \"string\",\n  imgWrapper: \"string\",\n  leftTools: \"string\",\n  loader: \"string\",\n  nextBtn: \"string\",\n  nextBtnWrapper: \"string\",\n  prevBtn: \"string\",\n  prevBtnWrapper: \"string\",\n  rightTools: \"string\",\n  spinner: \"string\",\n  spinnerContent: \"string\",\n  toolbar: \"string\",\n  vertical: \"string\",\n  zoomBtn: \"string\"\n};\nclass Zs {\n  constructor(t, e = {}, i) {\n    this._element = t, this._options = e, this._classes = this._getClasses(i), this._getContainer(), this._id = `lightbox-${Math.random().toString(36).substr(2, 9)}`, this._activeImg = 0, this._images = [], this._zoom = 1, this._gallery = null, this._galleryToolbar = null, this._galleryContent = null, this._loader = null, this._imgCounter = null, this._animating = !1, this._fullscreen = !1, this._zoomBtn = null, this._fullscreenBtn = null, this._toolsToggleTimer = 0, this._mousedown = !1, this._mousedownPositionX = 0, this._mousedownPositionY = 0, this._originalPositionX = 0, this._originalPositionY = 0, this._positionX = 0, this._positionY = 0, this._zoomTimer = 0, this._tapCounter = 0, this._tapTime = 0, this._rightArrow = null, this._leftArrowWrapper = null, this._rightArrowWrapper = null, this._initiated = !1, this._multitouch = !1, this._touchZoomPosition = [], this._element && (y.setData(t, Ai, this), this.init());\n  }\n  // Getters\n  static get NAME() {\n    return To;\n  }\n  get activeImg() {\n    return this._activeImg;\n  }\n  get currentImg() {\n    return d.findOne(\n      `[${It}]`,\n      this._galleryContent\n    );\n  }\n  get options() {\n    const t = {\n      ...xE,\n      ...h.getDataAttributes(this._element),\n      ...this._options\n    };\n    return D(To, t, kE), t;\n  }\n  // Public\n  init() {\n    this._initiated || (this._appendTemplate(), this._initiated = !0);\n  }\n  open(t = 0) {\n    this._getImages(), this._setActiveImg(t), this._sortImages(), this._triggerEvents(\"open\", \"opened\"), this._loadImages().then((e) => {\n      this._resizeImages(e), this._toggleTemplate(), this._addEvents(), this._focusFullscreenBtn();\n    });\n  }\n  close() {\n    this.reset(), this._removeEvents(), this._toggleTemplate(), this._triggerEvents(\"close\", \"closed\");\n  }\n  slide(t = \"right\") {\n    this._animating === !0 || this._images.length <= 1 || (this._triggerEvents(\"slide\", \"slided\"), this._beforeSlideEvents(), t === \"right\" && this._slideHorizontally(t), t === \"left\" && this._slideHorizontally(t), t === \"first\" && this._slideToTarget(t), t === \"last\" && this._slideToTarget(t), this._afterSlideEvents());\n  }\n  zoomIn() {\n    this._zoom >= 3 || (this._triggerEvents(\"zoomIn\", \"zoomedIn\"), this._zoom += parseFloat(this.options.zoomLevel), h.style(this.currentImg.parentNode, {\n      transform: `scale(${this._zoom})`\n    }), this._updateZoomBtn());\n  }\n  zoomOut() {\n    this._zoom <= 1 || (this._triggerEvents(\"zoomOut\", \"zoomedOut\"), this._zoom -= parseFloat(this.options.zoomLevel), h.style(this.currentImg.parentNode, {\n      transform: `scale(${this._zoom})`\n    }), this._updateZoomBtn(), this._updateImgPosition());\n  }\n  toggleFullscreen() {\n    this._fullscreen === !1 ? (this._fullscreenBtn.setAttribute(It, \"\"), this._fullscreenBtn.innerHTML = this.options.hideFullscreenIconTemplate, this._gallery.requestFullscreen && this._gallery.requestFullscreen(), this._fullscreen = !0) : (this._fullscreenBtn.removeAttribute(It), document.exitFullscreen && document.exitFullscreen(), this._fullscreen = !1);\n  }\n  reset() {\n    this._restoreDefaultFullscreen(), this._restoreDefaultPosition(), this._restoreDefaultZoom(), clearTimeout(this._toolsToggleTimer), clearTimeout(this._doubleTapTimer);\n  }\n  dispose() {\n    c.off(\n      document,\n      Ie,\n      gE,\n      this.toggle\n    ), this._galleryContent && this._removeEvents(), this._gallery && this._gallery.remove(), y.removeData(this._element, Ai), this._element = null;\n  }\n  // Private\n  _getClasses(t) {\n    const e = h.getDataClassAttributes(this._element);\n    return t = {\n      ...OE,\n      ...e,\n      ...t\n    }, D(To, t, SE), t;\n  }\n  _getImages() {\n    const e = d.find(\"img\", this._element).filter(\n      (i) => !i.hasAttribute(bE)\n    );\n    this._images = e;\n  }\n  _getContainer() {\n    this._container = d.findOne(this.options.container);\n  }\n  _setActiveImg(t) {\n    this._activeImg = typeof t == \"number\" ? t : this._images.indexOf(t.target);\n  }\n  _appendTemplate() {\n    this._gallery = $(\"div\"), h.addClass(this._gallery, `${this._classes.gallery}`), this._element.dataset.id = this._id, this._gallery.id = this._id, this._appendLoader(), this._appendToolbar(), this._appendContent(), this._appendArrows(), this._appendCaption(), this._container.append(this._gallery);\n  }\n  _appendToolbar() {\n    this._galleryToolbar = $(\"div\"), this._imgCounter = $(\"p\"), this._fullscreenBtn = $(\"button\"), this._zoomBtn = $(\"button\");\n    const t = $(\"button\"), e = $(\"div\"), i = $(\"div\");\n    h.addClass(this._galleryToolbar, `${this._classes.toolbar}`), h.addClass(this._imgCounter, `${this._classes.galleryCounter}`), h.addClass(this._fullscreenBtn, `${this._classes.fullscreenBtn}`), h.addClass(this._zoomBtn, `${this._classes.zoomInBtn}`), h.addClass(this._zoomBtn, this._classes.zoomBtn), h.addClass(e, `${this._classes.leftTools}`), h.addClass(i, `${this._classes.rightTools}`), h.addClass(t, `${this._classes.closeBtn}`), this._fullscreenBtn.innerHTML = this.options.showFullscreenIconTemplate, t.innerHTML = this.options.closeIconTemplate, this._zoomBtn.innerHTML = this.options.zoomInIconTemplate, this._fullscreenBtn.setAttribute(\"aria-label\", \"Toggle fullscreen\"), this._zoomBtn.setAttribute(\"aria-label\", \"Zoom in\"), t.setAttribute(\"aria-label\", \"Close\"), c.on(\n      this._fullscreenBtn,\n      Ie,\n      () => this.toggleFullscreen()\n    ), c.on(\n      this._zoomBtn,\n      Ie,\n      () => this._toggleZoom()\n    ), c.on(t, Ie, () => this.close()), e.append(this._imgCounter), i.append(this._fullscreenBtn), i.append(this._zoomBtn), i.append(t), this._galleryToolbar.append(e), this._galleryToolbar.append(i), this._gallery.append(this._galleryToolbar);\n  }\n  _appendContent() {\n    this._galleryContent = $(\"div\"), h.addClass(\n      this._galleryContent,\n      `${this._classes.galleryContent}`\n    ), this._gallery.append(this._galleryContent);\n  }\n  _appendLoader() {\n    this._loader = $(\"div\");\n    const t = $(\"div\"), e = $(\"span\");\n    h.addClass(this._loader, `${this._classes.loader}`), h.addClass(t, `${this._classes.spinner}`), h.addClass(e, `${this._classes.spinnerContent}`), t.setAttribute(\"role\", \"status\"), e.innerHTML = this.options.spinnerContent, t.append(e), this._loader.append(t), this._gallery.append(this._loader);\n  }\n  _appendArrows() {\n    this._leftArrowWrapper = $(\"div\"), h.addClass(\n      this._leftArrowWrapper,\n      `${this._classes.prevBtnWrapper}`\n    );\n    const t = $(\"button\");\n    t.setAttribute(\"aria-label\", \"Previous\"), h.addClass(t, `${this._classes.prevBtn}`), c.on(t, Ie, () => this.slide(\"left\")), this._leftArrowWrapper.append(t), this._rightArrowWrapper = $(\"div\"), h.addClass(\n      this._rightArrowWrapper,\n      `${this._classes.nextBtnWrapper}`\n    ), this._rightArrow = $(\"button\"), this._rightArrow.setAttribute(\"aria-label\", \"Next\"), h.addClass(this._rightArrow, `${this._classes.nextBtn}`), c.on(this._rightArrow, Ie, () => this.slide()), this._rightArrowWrapper.append(this._rightArrow), this._rightArrow.innerHTML = this.options.nextIconTemplate, t.innerHTML = this.options.prevIconTemplate, this._getImages(), !(this._images.length <= 1) && (this._gallery.append(this._leftArrowWrapper), this._gallery.append(this._rightArrowWrapper));\n  }\n  _appendCaption() {\n    const t = $(\"div\"), e = $(\"p\");\n    e.setAttribute(Ml, \"\"), h.addClass(t, `${this._classes.captionWrapper}`), h.addClass(e, `${this._classes.caption}`), t.append(e), this._gallery.append(t);\n  }\n  _sortImages() {\n    for (let t = 0; t < this._activeImg; t++)\n      this._images.push(this._images.shift());\n  }\n  async _loadImages() {\n    const t = [], e = [];\n    this._galleryContent.innerHTML = \"\";\n    let i = 0;\n    return this._images.forEach((n, o) => {\n      t.push(\n        new Promise((r) => {\n          const a = new Image(), l = $(\"div\");\n          h.addClass(l, `${this._classes.imgWrapper}`), h.addClass(a, `${this._classes.img}`), this._addImgStyles(a, l, i, o, n), l.append(a), this._galleryContent.append(l), a.onload = r, a.src = n.dataset.teImg || n.src, e.push(a), i += 100;\n        })\n      );\n    }), await Promise.all(t), e;\n  }\n  _addImgStyles(t, e, i, n, o) {\n    t.alt = o.alt, t.draggable = !1, h.style(e, {\n      position: \"absolute\",\n      left: `${i}%`,\n      top: 0\n    }), (o.dataset.teCaption || o.dataset.teCaption === \"\") && (t.dataset.caption = o.dataset.teCaption), i === 0 ? (o.width < o.height && h.addClass(t, `${this._classes.vertical}`), h.style(e, { opacity: 1 }), t.setAttribute(It, \"\")) : t.removeAttribute(It), n === this._images.length - 1 && this._images.length > 1 && h.style(e, { left: \"-100%\" });\n  }\n  _resizeImages(t) {\n    t.forEach((e) => {\n      this._calculateImgSize(e);\n    });\n  }\n  _calculateImgSize(t) {\n    t.width >= t.height ? (t.style.width = \"100%\", t.style.maxWidth = \"100%\", t.style.height = \"auto\", t.style.top = `${(t.parentNode.offsetHeight - t.height) / 2}px`, t.style.left = 0) : (t.style.height = \"100%\", t.style.maxHeight = \"100%\", t.style.width = \"auto\", t.style.left = `${(t.parentNode.offsetWidth - t.width) / 2}px`, t.style.top = 0), t.width >= t.parentNode.offsetWidth && (t.style.width = `${t.parentNode.offsetWidth}px`, t.style.height = \"auto\", t.style.left = 0, t.style.top = `${(t.parentNode.offsetHeight - t.height) / 2}px`), t.height >= t.parentNode.offsetHeight && (t.style.height = `${t.parentNode.offsetHeight}px`, t.style.width = \"auto\", t.style.top = 0, t.style.left = `${(t.parentNode.offsetWidth - t.width) / 2}px`), this._positionX = parseFloat(t.style.left) || 0, this._positionY = parseFloat(t.style.top) || 0;\n  }\n  _onResize() {\n    this._images = d.find(\"img\", this._galleryContent), this._images.forEach((t) => {\n      this._calculateImgSize(t);\n    });\n  }\n  _onFullscreenChange() {\n    (document.webkitIsFullScreen || document.mozFullScreen || document.msFullscreenElement) === void 0 && (this._fullscreen = !1, this._fullscreenBtn.innerHTML = this.options.showFullscreenIconTemplate, this._fullscreenBtn.removeAttribute(It));\n  }\n  _beforeSlideEvents() {\n    this._animationStart(), this._restoreDefaultZoom(), this._restoreDefaultPosition(), this._resetDoubleTap();\n  }\n  _slideHorizontally(t) {\n    this._images = d.find(\"img\", this._galleryContent), this._images.forEach((e) => {\n      let i;\n      t === \"right\" ? (i = parseInt(e.parentNode.style.left, 10) - 100, i < -100 && (i = (this._images.length - 2) * 100)) : (i = parseInt(e.parentNode.style.left, 10) + 100, i === (this._images.length - 1) * 100 && (i = -100)), this._slideImg(e, i);\n    }), this._updateActiveImg(t);\n  }\n  _slideImg(t, e) {\n    e === 0 ? (t.setAttribute(It, \"\"), h.style(t.parentNode, { opacity: 1, transform: \"scale(1)\" })) : (t.removeAttribute(It), h.style(t.parentNode, {\n      opacity: 0,\n      transform: \"scale(0.25)\"\n    })), t.parentNode.style.left = `${e}%`;\n  }\n  _slideToTarget(t) {\n    t === \"first\" && this._activeImg === 0 || t === \"last\" && this._activeImg === this._images.length - 1 || (this.reset(), this._removeEvents(), this._showLoader(), this._getImages(), this._activeImg = t === \"first\" ? 0 : this._images.length - 1, this._sortImages(), h.style(this.currentImg.parentNode, {\n      transform: \"scale(0.25)\",\n      opacity: 0\n    }), setTimeout(() => {\n      this._loadImages().then((e) => {\n        this._resizeImages(e), this._addEvents(), this._updateCaption(), this._hideLoader(), setTimeout(() => {\n          h.style(this.currentImg.parentNode, {\n            transform: \"scale(1)\",\n            opacity: 1\n          });\n        }, 10);\n      });\n    }, 400));\n  }\n  _updateActiveImg(t) {\n    t === \"right\" && (this._activeImg === this._images.length - 1 ? this._activeImg = 0 : this._activeImg++), t === \"left\" && (this._activeImg === 0 ? this._activeImg = this._images.length - 1 : this._activeImg--);\n  }\n  _afterSlideEvents() {\n    this._updateCounter(), this._updateCaption();\n  }\n  _updateCounter() {\n    this._images.length <= 1 || setTimeout(() => {\n      this._imgCounter.innerHTML = `${this._activeImg + 1} / ${this._images.length}`;\n    }, 200);\n  }\n  _updateCaption() {\n    setTimeout(() => {\n      let t = this.currentImg.alt;\n      (this.currentImg.dataset.caption || this.currentImg.dataset.caption === \"\") && (t = this.currentImg.dataset.caption), d.findOne(\n        `[${Ml}]`,\n        this._gallery\n      ).innerHTML = t;\n    }, 200);\n  }\n  _toggleTemplate() {\n    this._gallery.style.visibility === \"visible\" ? (h.style(this.currentImg.parentNode, {\n      transform: \"scale(0.25)\"\n    }), setTimeout(() => {\n      this._hideGallery(), this._enableScroll(), this._showLoader();\n    }, 100)) : (this._showGallery(), this._disableScroll(), this._updateCounter(), this._updateCaption(), this._setToolsToggleTimout(), this._hideLoader());\n  }\n  _showLoader() {\n    h.style(this._loader, { opacity: 1 });\n  }\n  _hideLoader() {\n    h.style(this._loader, { opacity: 0 });\n  }\n  _hideGallery() {\n    h.style(this._gallery, {\n      opacity: 0,\n      pointerEvents: \"none\",\n      visibility: \"hidden\"\n    });\n  }\n  _showGallery() {\n    h.style(this._gallery, {\n      opacity: 1,\n      pointerEvents: \"initial\",\n      visibility: \"visible\"\n    }), setTimeout(() => {\n      h.style(this.currentImg.parentNode, { transform: \"scale(1)\" });\n    }, 50);\n  }\n  _toggleZoom() {\n    this._zoom !== 1 ? this.zoomOut() : this.zoomIn();\n  }\n  _updateZoomBtn() {\n    this._zoom > 1 ? (this._zoomBtn.setAttribute(It, \"\"), this._zoomBtn.setAttribute(\"aria-label\", \"Zoom out\"), this._zoomBtn.innerHTML = this.options.zoomOutIconTemplate) : (this._zoomBtn.removeAttribute(It), this._zoomBtn.setAttribute(\"aria-label\", \"Zoom in\"), this._zoomBtn.innerHTML = this.options.zoomInIconTemplate);\n  }\n  _updateImgPosition() {\n    this._zoom === 1 && this._restoreDefaultPosition();\n  }\n  _addEvents() {\n    const t = d.find(\"img\", this._galleryContent);\n    this._onWindowTouchmove = this._onWindowTouchmove.bind(this), this._onWindowTouchstart = this._onWindowTouchstart.bind(this), this._onImgMousedown = this._onMousedown.bind(this), this._onImgMousemove = this._onMousemove.bind(this), this._onImgWheel = this._onZoom.bind(this), this._onImgMouseup = this._onMouseup.bind(this), this._onImgTouchend = this._onTouchend.bind(this), this._onImgDoubleClick = this._onDoubleClick.bind(this), this._onWindowResize = this._onResize.bind(this), this._onWindowFullscreenChange = this._onFullscreenChange.bind(this), this._onAnyImgAction = this._resetToolsToggler.bind(this), this._onGalleryClick = this._onBackdropClick.bind(this), this._onKeyupEvent = this._onKeyup.bind(this), this._onRightArrowKeydownEvent = this._onRightArrowKeydown.bind(this), this._onFullscreenBtnKeydownEvent = this._onFullscreenBtnKeydown.bind(this), t.forEach((e) => {\n      c.on(e, \"mousedown\", this._onImgMousedown, {\n        passive: !0\n      }), c.on(e, \"touchstart\", this._onImgMousedown, {\n        passive: !0\n      }), c.on(e, \"mousemove\", this._onImgMousemove, {\n        passive: !0\n      }), c.on(e, \"touchmove\", this._onImgMousemove, {\n        passive: !0\n      }), c.on(e, \"wheel\", this._onImgWheel, { passive: !0 }), c.on(e, \"dblclick\", this._onImgDoubleClick, {\n        passive: !0\n      });\n    }), document.addEventListener(\"touchmove\", this._onWindowTouchmove, {\n      passive: !1\n    }), c.on(window, \"touchstart\", this._onWindowTouchstart), c.on(window, \"mouseup\", this._onImgMouseup), c.on(window, \"touchend\", this._onImgTouchend), c.on(window, \"resize\", this._onWindowResize), c.on(window, \"orientationchange\", this._onWindowResize), c.on(window, \"keyup\", this._onKeyupEvent), c.on(window, \"fullscreenchange\", this._onWindowFullscreenChange), c.on(this._gallery, \"mousemove\", this._onAnyImgAction), c.on(this._gallery, \"click\", this._onGalleryClick), c.on(\n      this._rightArrow,\n      \"keydown\",\n      this._onRightArrowKeydownEvent\n    ), c.on(\n      this._fullscreenBtn,\n      \"keydown\",\n      this._onFullscreenBtnKeydownEvent\n    );\n  }\n  _removeEvents() {\n    d.find(\"img\", this._galleryContent).forEach((e) => {\n      c.off(e, \"mousedown\", this._onImgMousedown), c.off(e, \"touchstart\", this._onImgMousedown), c.off(e, \"mousemove\", this._onImgMousemove), c.off(e, \"touchmove\", this._onImgMousemove), c.off(e, \"wheel\", this._onImgWheel), c.off(e, \"dblclick\", this._onImgDoubleClick);\n    }), document.removeEventListener(\"touchmove\", this._onWindowTouchmove, {\n      passive: !1\n    }), c.off(window, \"touchstart\", this._onWindowTouchstart), c.off(window, \"mouseup\", this._onImgMouseup), c.off(window, \"touchend\", this._onImgTouchend), c.off(window, \"resize\", this._onWindowResize), c.off(window, \"orientationchange\", this._onWindowResize), c.off(window, \"keyup\", this._onKeyupEvent), c.off(\n      window,\n      \"fullscreenchange\",\n      this._onWindowFullscreenChange\n    ), c.off(this._gallery, \"mousemove\", this._onAnyImgAction), c.off(this._gallery, \"click\", this._onGalleryClick), c.off(\n      this._rightArrow,\n      \"keydown\",\n      this._onRightArrowKeydownEvent\n    ), c.off(\n      this._fullscreenBtn,\n      \"keydown\",\n      this._onFullscreenBtnKeydownEvent\n    );\n  }\n  _onMousedown(t) {\n    const e = t.touches, i = e ? e[0].clientX : t.clientX, n = e ? e[0].clientY : t.clientY;\n    this._originalPositionX = parseFloat(this.currentImg.style.left) || 0, this._originalPositionY = parseFloat(this.currentImg.style.top) || 0, this._positionX = this._originalPositionX, this._positionY = this._originalPositionY, this._mousedownPositionX = i * (1 / this._zoom) - this._positionX, this._mousedownPositionY = n * (1 / this._zoom) - this._positionY, this._mousedown = !0, t.type === \"touchstart\" && t.touches.length > 1 && (this._multitouch = !0, this._touchZoomPosition = t.touches);\n  }\n  _onMousemove(t) {\n    if (!this._mousedown)\n      return;\n    const e = t.touches, i = e ? e[0].clientX : t.clientX, n = e ? e[0].clientY : t.clientY;\n    if (e && this._resetToolsToggler(), !this._multitouch)\n      if (this._zoom !== 1)\n        this._positionX = i * (1 / this._zoom) - this._mousedownPositionX, this._positionY = n * (1 / this._zoom) - this._mousedownPositionY, h.style(this.currentImg, {\n          left: `${this._positionX}px`,\n          top: `${this._positionY}px`\n        });\n      else {\n        if (this._images.length <= 1)\n          return;\n        this._positionX = i * (1 / this._zoom) - this._mousedownPositionX, h.style(this.currentImg, { left: `${this._positionX}px` });\n      }\n  }\n  _onMouseup(t) {\n    this._mousedown = !1, this._moveImg(t.target);\n  }\n  _onTouchend(t) {\n    this._mousedown = !1, this._multitouch ? t.targetTouches.length === 0 && (this._multitouch = !1, this._touchZoomPosition = []) : this._multitouch || (this._checkDoubleTap(t), this._moveImg(t.target));\n  }\n  _calculateTouchZoom(t) {\n    const e = Math.hypot(\n      this._touchZoomPosition[1].pageX - this._touchZoomPosition[0].pageX,\n      this._touchZoomPosition[1].pageY - this._touchZoomPosition[0].pageY\n    ), i = Math.hypot(\n      t.touches[1].pageX - t.touches[0].pageX,\n      t.touches[1].pageY - t.touches[0].pageY\n    ), n = Math.abs(e - i), o = t.view.screen.width;\n    n > o * 0.03 && (e <= i ? this.zoomIn() : this.zoomOut(), this._touchZoomPosition = t.touches);\n  }\n  _onWindowTouchstart(t) {\n    t.touches.length > 1 && (this._multitouch = !0, this._touchZoomPosition = t.touches);\n  }\n  _onWindowTouchmove(t) {\n    t.preventDefault(), t.type === \"touchmove\" && t.targetTouches.length > 1 && this._calculateTouchZoom(t);\n  }\n  _onRightArrowKeydown(t) {\n    switch (t.keyCode) {\n      case 9:\n        if (t.shiftKey)\n          break;\n        t.preventDefault(), this._focusFullscreenBtn();\n        break;\n    }\n  }\n  _onFullscreenBtnKeydown(t) {\n    switch (t.keyCode) {\n      case 9:\n        if (!t.shiftKey)\n          break;\n        t.preventDefault(), this._focusRightArrow();\n        break;\n    }\n  }\n  _onKeyup(t) {\n    switch (this._resetToolsToggler(), t.keyCode) {\n      case 39:\n        this.slide();\n        break;\n      case 37:\n        this.slide(\"left\");\n        break;\n      case 27:\n        this.close();\n        break;\n      case 36:\n        this.slide(\"first\");\n        break;\n      case 35:\n        this.slide(\"last\");\n        break;\n      case 38:\n        this.zoomIn();\n        break;\n      case 40:\n        this.zoomOut();\n        break;\n    }\n  }\n  _focusFullscreenBtn() {\n    setTimeout(() => {\n      this._fullscreenBtn.focus();\n    }, 100);\n  }\n  _focusRightArrow() {\n    this._rightArrow.focus();\n  }\n  _moveImg(t) {\n    if (this._multitouch || this._zoom !== 1 || t !== this.currentImg || this._images.length <= 1)\n      return;\n    const e = this._positionX - this._originalPositionX;\n    e > 0 ? this.slide(\"left\") : e < 0 && this.slide();\n  }\n  _checkDoubleTap(t) {\n    clearTimeout(this._doubleTapTimer);\n    const i = (/* @__PURE__ */ new Date()).getTime() - this._tapTime;\n    this._tapCounter > 0 && i < 500 ? (this._onDoubleClick(t), this._doubleTapTimer = setTimeout(() => {\n      this._tapTime = (/* @__PURE__ */ new Date()).getTime(), this._tapCounter = 0;\n    }, 300)) : (this._tapCounter++, this._tapTime = (/* @__PURE__ */ new Date()).getTime());\n  }\n  _resetDoubleTap() {\n    this._tapTime = 0, this._tapCounter = 0, clearTimeout(this._doubleTapTimer);\n  }\n  _onDoubleClick(t) {\n    this._multitouch || (t.touches || this._setNewPositionOnZoomIn(t), this._zoom !== 1 ? this._restoreDefaultZoom() : this.zoomIn());\n  }\n  _onZoom(t) {\n    if (t.deltaY > 0)\n      this.zoomOut();\n    else {\n      if (this._zoom >= 3)\n        return;\n      this._setNewPositionOnZoomIn(t), this.zoomIn();\n    }\n  }\n  _onBackdropClick(t) {\n    this._resetToolsToggler(), t.target.tagName === \"DIV\" && this.close();\n  }\n  _setNewPositionOnZoomIn(t) {\n    clearTimeout(this._zoomTimer), this._positionX = window.innerWidth / 2 - t.offsetX - 50, this._positionY = window.innerHeight / 2 - t.offsetY - 50, this.currentImg.style.transition = \"all 0.5s ease-out\", this.currentImg.style.left = `${this._positionX}px`, this.currentImg.style.top = `${this._positionY}px`, this._zoomTimer = setTimeout(() => {\n      this.currentImg.style.transition = \"none\";\n    }, 500);\n  }\n  _resetToolsToggler() {\n    this._showTools(), clearTimeout(this._toolsToggleTimer), this._setToolsToggleTimout();\n  }\n  _setToolsToggleTimout() {\n    this._toolsToggleTimer = setTimeout(() => {\n      this._hideTools(), clearTimeout(this._toolsToggleTimer);\n    }, 4e3);\n  }\n  _hideTools() {\n    h.style(this._galleryToolbar, { opacity: 0 }), h.style(this._leftArrowWrapper, { opacity: 0 }), h.style(this._rightArrowWrapper, { opacity: 0 });\n  }\n  _showTools() {\n    h.style(this._galleryToolbar, { opacity: 1 }), h.style(this._leftArrowWrapper, { opacity: 1 }), h.style(this._rightArrowWrapper, { opacity: 1 });\n  }\n  _disableScroll() {\n    h.addClass(document.body, \"overflow-y-hidden relative\"), document.documentElement.scrollHeight > document.documentElement.clientHeight && h.addClass(document.body, \"md:pr-[17px]\");\n  }\n  _enableScroll() {\n    setTimeout(() => {\n      h.removeClass(document.body, \"overflow-y-hidden relative\"), h.removeClass(document.body, \"md:pr-[17px]\");\n    }, 300);\n  }\n  _animationStart() {\n    this._animating = !0, setTimeout(() => {\n      this._animating = !1;\n    }, 400);\n  }\n  _restoreDefaultZoom() {\n    this._zoom !== 1 && (this._zoom = 1, h.style(this.currentImg.parentNode, {\n      transform: `scale(${this._zoom})`\n    }), this._updateZoomBtn(), this._updateImgPosition());\n  }\n  _restoreDefaultFullscreen() {\n    this._fullscreen && this.toggleFullscreen();\n  }\n  _restoreDefaultPosition() {\n    clearTimeout(this._zoomTimer);\n    const t = this.currentImg;\n    h.style(this.currentImg.parentNode, { left: 0, top: 0 }), h.style(this.currentImg, {\n      transition: \"all 0.5s ease-out\",\n      left: 0,\n      top: 0\n    }), this._calculateImgSize(t), setTimeout(() => {\n      h.style(this.currentImg, { transition: \"none\" });\n    }, 500);\n  }\n  async _triggerEvents(t, e) {\n    c.trigger(this._element, `${t}.te.lightbox`), e && await setTimeout(() => {\n      c.trigger(this._element, `${e}.te.lightbox`);\n    }, 505);\n  }\n  static getInstance(t) {\n    return y.getData(t, Ai);\n  }\n  static getOrCreateInstance(t, e = {}) {\n    return this.getInstance(t) || new this(t, typeof e == \"object\" ? e : null);\n  }\n  static toggle() {\n    return function(t) {\n      const e = d.closest(\n        t.target,\n        `${Th}`\n      );\n      (Zs.getInstance(e) || new Zs(e)).open(t);\n    };\n  }\n  static jQueryInterface(t, e) {\n    return this.each(function() {\n      let i = y.getData(this, Ai);\n      const n = typeof t == \"object\" && t;\n      if (!(!i && /dispose/.test(t)) && (i || (i = new Zs(this, n)), typeof t == \"string\")) {\n        if (typeof i[t] > \"u\")\n          throw new TypeError(`No method named \"${t}\"`);\n        i[t](e);\n      }\n    });\n  }\n}\nconst IE = {\n  isRequired: \"This is required\",\n  isEmail: \"Please enter a valid email address\",\n  isLongerThan: \"This field must be longer than {length} characters\",\n  isShorterThan: \"This field must be shorter than {length} characters\",\n  isChecked: \"This is required\",\n  isPhone: \"Please enter a valid phone number\",\n  isNumber: \"Expected value with type Number\",\n  isString: \"Expected value with type String\",\n  isBoolean: \"Expected value with type Boolean\",\n  isDate: \"Please enter a valid date\",\n  is12hFormat: \"Please enter a valid time in 12h format\",\n  is24hFormat: \"Please enter a valid time in 24h format\"\n}, DE = {\n  isRequired: (s, t) => (s == null ? void 0 : s.trim()) ? !0 : t,\n  isEmail: (s, t) => /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/.test(s) ? !0 : t,\n  isLongerThan: (s, t, e) => s.length > e ? !0 : t.replace(\"{length}\", e),\n  isShorterThan: (s, t, e) => s.length < e ? !0 : t.replace(\"{length}\", e),\n  isChecked: (s) => s ? !0 : \"This is required\",\n  isPhone: (s, t) => s.length === 9 ? !0 : t,\n  isNumber: (s, t) => s && !isNaN(Number(s)) ? !0 : t,\n  isString: (s, t) => typeof s == \"string\" ? !0 : t,\n  isBoolean: (s, t) => typeof s == \"boolean\" ? !0 : t,\n  isDate: (s, t) => {\n    const e = /^([0-9]{1,2})\\/([0-9]{1,2})\\/([0-9]{4})$/;\n    return s.match(e) ? !0 : t;\n  },\n  is12hFormat: (s, t) => {\n    const e = /^(0?[1-9]|1[0-2]):[0-5][0-9] [APap][mM]$/;\n    return s.match(e) ? !0 : t;\n  },\n  is24hFormat: (s, t) => {\n    const e = /^(?:[01]\\d|2[0-3]):[0-5][0-9]$/;\n    return s.match(e) ? !0 : t;\n  }\n}, Eo = \"validation\", jo = \"te.validation\", fn = `.${jo}`, Eh = \"data-te-validate\", Os = \"data-te-validated\", Ss = \"data-te-validation-state\", Is = \"data-te-validation-feedback\", Co = \"data-te-valid-feedback\", Ds = \"data-te-invalid-feedback\", Rl = \"data-te-validation-ruleset\", $E = \"data-te-submit-btn-ref\", LE = `[${Eh}]`, NE = \"[data-te-input-notch-ref] div\", ME = `[${$E}]`, RE = `validated${fn}`, PE = `valid${fn}`, BE = `invalid${fn}`, HE = `changed${fn}`, VE = {\n  validFeedback: \"string\",\n  invalidFeedback: \"string\",\n  disableFeedback: \"boolean\",\n  customRules: \"object\",\n  customErrorMessages: \"object\",\n  activeValidation: \"boolean\",\n  submitCallback: \"(function|null)\"\n}, Pl = {\n  validFeedback: \"Looks good!\",\n  invalidFeedback: \"Something is wrong!\",\n  disableFeedback: !1,\n  customRules: {},\n  customErrorMessages: {},\n  activeValidation: !1,\n  submitCallback: null\n}, WE = {\n  // default notch\n  notchLeadingValid: \"border-[#14a44d] dark:border-[#14a44d] group-data-[te-input-focused]:shadow-[-1px_0_0_#14a44d,_0_1px_0_0_#14a44d,_0_-1px_0_0_#14a44d] group-data-[te-input-focused]:border-[#14a44d]\",\n  notchMiddleValid: \"border-[#14a44d] dark:border-[#14a44d] group-data-[te-input-focused]:shadow-[0_1px_0_0_#14a44d] group-data-[te-input-focused]:border-[#14a44d]\",\n  notchTrailingValid: \"border-[#14a44d] dark:border-[#14a44d] group-data-[te-input-focused]:shadow-[1px_0_0_#14a44d,_0_-1px_0_0_#14a44d,_0_1px_0_0_#14a44d] group-data-[te-input-focused]:border-[#14a44d]\",\n  notchLeadingInvalid: \"border-[#dc4c64] dark:border-[#dc4c64] group-data-[te-input-focused]:shadow-[-1px_0_0_#dc4c64,_0_1px_0_0_#dc4c64,_0_-1px_0_0_#dc4c64] group-data-[te-input-focused]:border-[#dc4c64]\",\n  notchMiddleInvalid: \"border-[#dc4c64] dark:border-[#dc4c64] group-data-[te-input-focused]:shadow-[0_1px_0_0_#dc4c64] group-data-[te-input-focused]:border-[#dc4c64]\",\n  notchTrailingInvalid: \"border-[#dc4c64] dark:border-[#dc4c64] group-data-[te-input-focused]:shadow-[1px_0_0_#dc4c64,_0_-1px_0_0_#dc4c64,_0_1px_0_0_#dc4c64] group-data-[te-input-focused]:border-[#dc4c64]\",\n  // basic inputs\n  basicInputValid: \"!border-[#14a44d] focus:!border-[#14a44d] focus:!shadow-[inset_0_0_0_1px_#14a44d]\",\n  basicInputInvalid: \"!border-[#dc4c64] focus:!border-[#dc4c64] focus:!shadow-[inset_0_0_0_1px_#dc4c64]\",\n  // checkbox\n  checkboxValid: \"checked:!border-[#14a44d] checked:!bg-[#14a44d] checked:after:!bg-[#14a44d]\",\n  checkboxInvalid: \"checked:!border-[#dc4c64] checked:!bg-[#dc4c64] checked:after:!bg-[#dc4c64]\",\n  radioValid: \"checked:!border-[#14a44d] checked:after:!bg-[#14a44d]\",\n  radioInvalid: \"checked:!border-[#dc4c64] checked:after:!bg-[#dc4c64]\",\n  // labels\n  labelValid: \"!text-[#14a44d]\",\n  labelInvalid: \"!text-[#dc4c64]\",\n  // feedback\n  validFeedback: \"absolute top-full left-0 m-1 w-auto text-sm text-[#14a44d] animate-[fade-in_0.3s_both]\",\n  invalidFeedback: \"absolute top-full left-0 m-1 w-auto text-sm text-[#dc4c64] animate-[fade-in_0.3s_both]\",\n  // element validated\n  elementValidated: \"mb-8\"\n}, FE = {\n  notchLeadingValid: \"string\",\n  notchMiddleValid: \"string\",\n  notchTrailingValid: \"string\",\n  notchLeadingInvalid: \"string\",\n  notchMiddleInvalid: \"string\",\n  notchTrailingInvalid: \"string\",\n  basicInputValid: \"string\",\n  basicInputInvalid: \"string\",\n  checkboxValid: \"string\",\n  checkboxInvalid: \"string\",\n  radioValid: \"string\",\n  radioInvalid: \"string\",\n  labelValid: \"string\",\n  labelInvalid: \"string\",\n  validFeedback: \"string\",\n  invalidFeedback: \"string\",\n  elementValidated: \"string\"\n};\nclass Ch extends gt {\n  constructor(t, e, i) {\n    super(t), this._element = t, this._element && y.setData(t, jo, this), this._config = this._getConfig(e), this._classes = this._getClasses(i), this._isValid = !0, this._shouldApplyInputEvents = !0, this._submitCallback = null, this._errorMessages = {\n      ...IE,\n      ...this._config.customErrorMessages\n    }, this._validationElements = this._getValidationElements(), this._validationElements.forEach(({ element: n, input: o }) => {\n      this._createFeedbackWrapper(n, o);\n    }), this._validationObserver = this._watchForValidationChanges(), this._validationObserver.observe(this._element, { attributes: !0 }), this._submitButton = null, this._handleSubmitButton(), this._validationResult = [];\n  }\n  // Getters\n  static get DefaultType() {\n    return VE;\n  }\n  static get Default() {\n    return Pl;\n  }\n  static get NAME() {\n    return Eo;\n  }\n  // Public\n  dispose() {\n    var t;\n    (t = this._validationObserver) == null || t.disconnect(), this._validationObserver = null, this._submitCallback = null, this._element.removeAttribute(Os), this._removeValidationTraces(), this._validationResult = [], this._submitButton && c.off(this._submitButton, \"click\"), this._config.activeValidation && (this._validationElements.forEach((e) => {\n      const { input: i } = e;\n      c.off(i, \"input\");\n    }), this._shouldApplyInputEvents = !0);\n  }\n  // Private\n  _removeValidationTraces() {\n    this._removeFeedbackWrapper(), this._validationElements.forEach(({ element: t, classes: e, initialHTML: i }) => {\n      t.className = e, t.innerHTML = i, t.removeAttribute(Ss), t.removeAttribute(Ds), t.removeAttribute(Co);\n    }), this._validationElements = [];\n  }\n  _getValidationElements() {\n    return d.find(\n      LE,\n      this._element\n    ).map((e) => {\n      const i = d.findOne(\"input\", e) || d.findOne(\"textarea\", e);\n      return {\n        id: i.name || i.id || rt(\"validation-\"),\n        element: e,\n        type: e.getAttribute(Eh),\n        input: i,\n        validFeedback: e.getAttribute(Co),\n        invalidFeedback: e.getAttribute(Ds),\n        classes: e.className,\n        initialHTML: e.innerHTML,\n        ruleset: e.getAttribute(Rl)\n      };\n    });\n  }\n  _createFeedbackWrapper(t, e) {\n    if (t.querySelectorAll(`[${Is}]`).length > 0)\n      return;\n    const i = document.createElement(\"span\");\n    i.setAttribute(Is, \"\"), e.parentNode.appendChild(i);\n  }\n  _removeFeedbackWrapper() {\n    d.find(\n      `[${Is}]`,\n      this._element\n    ).forEach((e) => {\n      e.remove();\n    });\n  }\n  _watchForValidationChanges() {\n    return new MutationObserver((e) => {\n      e.forEach((i) => {\n        const { attributeName: n } = i;\n        n === Os && (this._handleValidation(), this._config.activeValidation && this._shouldApplyInputEvents && this._applyInputEvents());\n      });\n    });\n  }\n  _handleValidation() {\n    this._element.getAttribute(Os) && (this._validationResult = [], this._isValid = !0, this._validationElements.forEach(\n      (t) => this._validateSingleElement(t)\n    ), this._emitEvents(this._isValid), this._submitCallback && this._submitCallback(this._isValid));\n  }\n  _validateSingleElement(t) {\n    var p;\n    const { element: e, type: i, input: n, ruleset: o, id: r } = t;\n    o && this._validateByRuleset(t);\n    const a = e.getAttribute(Ss);\n    if (a !== \"valid\" && a !== \"invalid\")\n      return;\n    const l = a.replace(\n      a.charAt(0),\n      a.charAt(0).toUpperCase()\n    );\n    i === \"input\" && this._restyleNotches(e, l), i === \"basic\" && this._restyleBasicInputs(n, l), (i === \"checkbox\" || i === \"radio\") && this._restyleCheckboxes(n, l, i), this._restyleLabels(e, l), a === \"invalid\" && (this._isValid = !1), this._config.disableFeedback || this._applyFeedback(e, a), c.trigger(this._element, HE, {\n      value: {\n        name: r,\n        result: a,\n        validation: (p = this._validationResult[r]) == null ? void 0 : p.validation\n      }\n    });\n  }\n  _validateByRuleset({ element: t, type: e, invalidFeedback: i, input: n, id: o }) {\n    const r = this._getRuleset(t);\n    if (!r.length)\n      return;\n    const a = e === \"checkbox\" || e === \"radio\" ? n.checked : n.value;\n    let l = \"\", p = [];\n    for (const u of r) {\n      const _ = u.callback(\n        a,\n        this._errorMessages[u.name] || this._config.invalidFeedback,\n        u.parameter\n      );\n      p.push({\n        result: _ === !0,\n        name: u.name,\n        fullName: u.fullName\n      }), typeof _ == \"string\" && !l && (l = _);\n    }\n    if (this._validationResult[o] = { element: t, validation: p }, !l) {\n      t.setAttribute(Ss, \"valid\");\n      return;\n    }\n    t.setAttribute(Ss, \"invalid\"), i || t.setAttribute(Ds, l);\n  }\n  _handleInputChange(t) {\n    this._validateSingleElement(t);\n  }\n  _getRuleset(t) {\n    const i = t.getAttribute(Rl).split(\"|\");\n    let n = [];\n    const o = {\n      ...DE,\n      ...this._config.customRules\n    };\n    return i.forEach((r) => {\n      const a = this._getRuleData(r, o);\n      a.callback ? n.push(a) : console.warn(`Rule ${r} does not exist`);\n    }), n;\n  }\n  _getRuleData(t, e) {\n    const i = t.split(\"(\");\n    return {\n      callback: e[i[0]],\n      parameter: i[1] ? i[1].split(\")\")[0] : null,\n      name: i[0],\n      fullName: t\n    };\n  }\n  _applyFeedback(t, e) {\n    const i = d.findOne(\n      `[${Is}]`,\n      t\n    ), n = t.getAttribute(Co) || this._config.validFeedback, o = t.getAttribute(Ds) || this._config.invalidFeedback;\n    h.addClass(t, this._classes.elementValidated), i.textContent = e === \"valid\" ? n : o, i.className = this._classes[e === \"valid\" ? \"validFeedback\" : \"invalidFeedback\"];\n  }\n  _restyleCheckboxes(t, e, i) {\n    h.removeClass(t, this._classes.checkboxValid), h.removeClass(t, this._classes.checkboxInvalid), h.addClass(t, this._classes[`${i}${e}`]);\n  }\n  _restyleBasicInputs(t, e) {\n    h.removeClass(t, this._classes.basicInputValid), h.removeClass(t, this._classes.basicInputInvalid), h.addClass(t, this._classes[`basicInput${e}`]);\n  }\n  _restyleNotches(t, e) {\n    d.find(NE, t).forEach((n, o) => {\n      let r = o === 0 ? \"notchLeading\" : o === 1 ? \"notchMiddle\" : \"notchTrailing\";\n      n.className = \"\", h.addClass(n, Kc[r]), r += e, h.addClass(n, this._classes[r]);\n    });\n  }\n  _restyleLabels(t, e) {\n    const i = d.find(\"label\", t);\n    i.length && i.forEach((n) => {\n      h.removeClass(n, this._classes.labelValid), h.removeClass(n, this._classes.labelInvalid), h.addClass(n, this._classes[`label${e}`]);\n    });\n  }\n  _emitEvents(t) {\n    if (c.trigger(this._element, RE), t) {\n      c.trigger(this._element, PE, {\n        value: this._validationResult\n      });\n      return;\n    }\n    c.trigger(this._element, BE, {\n      value: this._validationResult\n    });\n  }\n  _applyInputEvents() {\n    this._validationElements.forEach((t) => {\n      const { input: e } = t;\n      c.on(\n        e,\n        \"input\",\n        () => this._handleInputChange(t)\n      );\n    }), this._shouldApplyInputEvents = !1;\n  }\n  _handleSubmitButton() {\n    this._submitButton = d.findOne(\n      ME,\n      this._element\n    ), this._submitButton && c.on(\n      this._submitButton,\n      \"click\",\n      (t) => this._handleSubmitButtonClick(t)\n    );\n  }\n  _handleSubmitButtonClick(t) {\n    if (this._element.setAttribute(Os, !0), this._config.submitCallback) {\n      this._submitCallback = (e) => this._config.submitCallback(t, e);\n      return;\n    }\n  }\n  _getConfig(t) {\n    return t = {\n      ...Pl,\n      ...h.getDataAttributes(this._element),\n      ...typeof t == \"object\" && t ? t : {}\n    }, D(Eo, t, this.constructor.DefaultType), t;\n  }\n  _getClasses(t) {\n    const e = h.getDataClassAttributes(this._element);\n    return t = {\n      ...WE,\n      ...e,\n      ...t\n    }, D(Eo, t, FE), t;\n  }\n  // Static\n  static getInstance(t) {\n    return y.getData(t, jo);\n  }\n  static getOrCreateInstance(t, e = {}) {\n    return this.getInstance(t) || new this(t, typeof e == \"object\" ? e : null);\n  }\n  static jQueryInterface(t) {\n    return this.each(function() {\n      const e = Ch.getOrCreateInstance(this);\n      if (typeof t == \"string\") {\n        if (e[t] === void 0 || t.startsWith(\"_\") || t === \"constructor\")\n          throw new TypeError(`No method named \"${t}\"`);\n        e[t](this);\n      }\n    });\n  }\n}\nclass Xi {\n  _getCoordinates(t) {\n    const [e] = t.touches;\n    return {\n      x: e.clientX,\n      y: e.clientY\n    };\n  }\n  _getDirection({ x: t, y: e }) {\n    return {\n      x: {\n        direction: t < 0 ? \"left\" : \"right\",\n        value: Math.abs(t)\n      },\n      y: {\n        direction: e < 0 ? \"up\" : \"down\",\n        value: Math.abs(e)\n      }\n    };\n  }\n  _getOrigin({ x: t, y: e }, { x: i, y: n }) {\n    return {\n      x: t - i,\n      y: e - n\n    };\n  }\n  _getDistanceBetweenTwoPoints(t, e, i, n) {\n    return Math.hypot(e - t, n - i);\n  }\n  _getMidPoint({ x1: t, x2: e, y1: i, y2: n }) {\n    return {\n      x: (t + e) / 2,\n      y: (i + n) / 2\n    };\n  }\n  _getVectorLength({ x1: t, x2: e, y1: i, y2: n }) {\n    return Math.sqrt((e - t) ** 2 + (n - i) ** 2);\n  }\n  _getRightMostTouch(t) {\n    let e = null;\n    const i = Number.MIN_VALUE;\n    return t.forEach((n) => {\n      n.clientX > i && (e = n);\n    }), e;\n  }\n  _getAngle(t, e, i, n) {\n    return Math.atan2(n - e, i - t);\n  }\n  _getAngularDistance(t, e) {\n    return e - t;\n  }\n  _getCenterXY({ x1: t, x2: e, y1: i, y2: n }) {\n    return {\n      x: t + (e - t) / 2,\n      y: i + (n - i) / 2\n    };\n  }\n  _getPinchTouchOrigin(t) {\n    const [e, i] = t, n = {\n      x1: e.clientX,\n      x2: i.clientX,\n      y1: e.clientY,\n      y2: i.clientY\n    };\n    return [this._getVectorLength(n), this._getCenterXY(n)];\n  }\n  _getPosition({ x1: t, x2: e, y1: i, y2: n }) {\n    return { x1: t, x2: e, y1: i, y2: n };\n  }\n}\nconst Ao = \"press\", YE = \"pressup\", jE = {\n  time: \"number\",\n  pointers: \"number\"\n}, KE = {\n  time: 250,\n  pointers: 1\n};\nclass zE extends Xi {\n  constructor(t, e = {}) {\n    super(), this._element = t, this._options = this._getConfig(e), this._timer = null;\n  }\n  // Getters\n  static get NAME() {\n    return Ao;\n  }\n  handleTouchStart(t) {\n    const { time: e, pointers: i } = this._options;\n    t.touches.length === i && (this._timer = setTimeout(() => {\n      c.trigger(this._element, Ao, { touch: t, time: e }), c.trigger(this._element, YE, { touch: t });\n    }, e));\n  }\n  handleTouchEnd() {\n    clearTimeout(this._timer);\n  }\n  _getConfig(t) {\n    const e = {\n      ...KE,\n      ...h.getDataAttributes(this._element),\n      ...t\n    };\n    return D(Ao, e, jE), e;\n  }\n}\nconst UE = \"swipe\", XE = {\n  threshold: \"number\",\n  direction: \"string\"\n}, GE = {\n  threshold: 10,\n  direction: \"all\"\n};\nclass qE {\n  constructor(t, e) {\n    this._element = t, this._startPosition = null, this._options = this._getConfig(e);\n  }\n  handleTouchStart(t) {\n    this._startPosition = this._getCoordinates(t);\n  }\n  handleTouchMove(t) {\n    if (!this._startPosition)\n      return;\n    const e = this._getCoordinates(t), i = {\n      x: e.x - this._startPosition.x,\n      y: e.y - this._startPosition.y\n    }, n = this._getDirection(i);\n    if (this._options.direction === \"all\") {\n      if (n.y.value < this._options.threshold && n.x.value < this._options.threshold)\n        return;\n      const r = n.y.value > n.x.value ? n.y.direction : n.x.direction;\n      c.trigger(this._element, `swipe${r}`, { touch: t }), c.trigger(this._element, \"swipe\", { touch: t, direction: r }), this._startPosition = null;\n      return;\n    }\n    const o = this._options.direction === \"left\" || this._options === \"right\" ? \"x\" : \"y\";\n    n[o].direction === this._options.direction && n[o].value > this._options.threshold && (c.trigger(this._element, `swipe${n[o].direction}`, {\n      touch: t\n    }), this._startPosition = null);\n  }\n  handleTouchEnd() {\n    this._startPosition = null;\n  }\n  _getCoordinates(t) {\n    const [e] = t.touches;\n    return {\n      x: e.clientX,\n      y: e.clientY\n    };\n  }\n  _getDirection(t) {\n    return {\n      x: {\n        direction: t.x < 0 ? \"left\" : \"right\",\n        value: Math.abs(t.x)\n      },\n      y: {\n        direction: t.y < 0 ? \"up\" : \"down\",\n        value: Math.abs(t.y)\n      }\n    };\n  }\n  _getConfig(t) {\n    const e = {\n      ...GE,\n      ...h.getDataAttributes(this._element),\n      ...t\n    };\n    return D(UE, e, XE), e;\n  }\n}\nconst qt = \"pan\", ZE = `${qt}start`, QE = `${qt}end`, JE = `${qt}move`, t0 = \"left\", e0 = \"right\", i0 = {\n  threshold: \"number\",\n  direction: \"string\",\n  pointers: \"number\"\n}, s0 = {\n  threshold: 20,\n  direction: \"all\",\n  pointers: 1\n};\nclass n0 extends Xi {\n  constructor(t, e = {}) {\n    super(), this._element = t, this._options = this._getConfig(e), this._startTouch = null;\n  }\n  // Getters\n  static get NAME() {\n    return qt;\n  }\n  handleTouchStart(t) {\n    this._startTouch = this._getCoordinates(t), this._movedTouch = t, c.trigger(this._element, ZE, { touch: t });\n  }\n  handleTouchMove(t) {\n    t.type === \"touchmove\" && t.preventDefault();\n    const { threshold: e, direction: i } = this._options, n = this._getCoordinates(t), o = this._getCoordinates(this._movedTouch), r = this._getOrigin(n, this._startTouch), a = this._getOrigin(n, o), l = this._getDirection(r), p = this._getDirection(a), { x: u, y: _ } = l;\n    if (i === \"all\" && (_.value > e || u.value > e)) {\n      const g = _.value > u.value ? _.direction : u.direction;\n      c.trigger(this._element, `${qt}${g}`, { touch: t }), c.trigger(this._element, qt, {\n        ...a,\n        touch: t\n      });\n    }\n    const f = i === t0 || i === e0 ? \"x\" : \"y\";\n    p[f].direction === i && l[f].value > e && c.trigger(this._element, `${qt}${i}`, {\n      touch: t,\n      [f]: n[f] - o[f]\n    }), this._movedTouch = t, c.trigger(this._element, JE, { touch: t });\n  }\n  handleTouchEnd(t) {\n    t.type === \"touchend\" && t.preventDefault(), this._movedTouch = null, this._startTouch = null, c.trigger(this._element, QE, { touch: t });\n  }\n  _getConfig(t) {\n    const e = {\n      ...s0,\n      ...h.getDataAttributes(this._element),\n      ...t\n    };\n    return D(qt, e, i0), e;\n  }\n}\nconst Ye = \"pinch\", o0 = `${Ye}end`, r0 = `${Ye}start`, a0 = `${Ye}move`, l0 = {\n  threshold: \"number\",\n  pointers: \"number\"\n}, c0 = {\n  threshold: 10,\n  pointers: 2\n};\nclass h0 extends Xi {\n  constructor(t, e = {}) {\n    super(), this._element = t, this._options = this._getConfig(e), this._startTouch = null, this._origin = null, this._touch = null, this._math = null, this._ratio = null;\n  }\n  // Getters\n  static get NAME() {\n    return Ye;\n  }\n  get isNumber() {\n    return typeof this._startTouch == \"number\" && typeof this._touch == \"number\" && // eslint-disable-next-line no-restricted-globals\n    !isNaN(this._startTouch) && // eslint-disable-next-line no-restricted-globals\n    !isNaN(this._touch);\n  }\n  handleTouchStart(t) {\n    if (t.touches.length !== this._options.pointers)\n      return;\n    t.type === \"touchstart\" && t.preventDefault();\n    const [e, i] = this._getPinchTouchOrigin(t.touches);\n    this._touch = e, this._origin = i, this._startTouch = this._touch, c.trigger(this._element, r0, {\n      touch: t,\n      ratio: this._ratio,\n      origin: this._origin\n    });\n  }\n  handleTouchMove(t) {\n    const { threshold: e, pointers: i } = this._options;\n    t.touches.length === i && (t.type === \"touchmove\" && t.preventDefault(), this._touch = this._getPinchTouchOrigin(t.touches)[0], this._ratio = this._touch / this._startTouch, this.isNumber && (this._origin.x > e || this._origin.y > e) && (this._startTouch = this._touch, c.trigger(this._element, Ye, {\n      touch: t,\n      ratio: this._ratio,\n      origin: this._origin\n    }), c.trigger(this._element, a0, {\n      touch: t,\n      ratio: this._ratio,\n      origin: this._origin\n    })));\n  }\n  handleTouchEnd(t) {\n    this.isNumber && (this._startTouch = null, c.trigger(this._element, o0, {\n      touch: t,\n      ratio: this._ratio,\n      origin: this._origin\n    }));\n  }\n  _getConfig(t) {\n    const e = {\n      ...c0,\n      ...h.getDataAttributes(this._element),\n      ...t\n    };\n    return D(Ye, e, l0), e;\n  }\n}\nconst yo = \"tap\", d0 = {\n  interval: \"number\",\n  time: \"number\",\n  taps: \"number\",\n  pointers: \"number\"\n}, u0 = {\n  interval: 500,\n  time: 250,\n  taps: 1,\n  pointers: 1\n};\nclass p0 extends Xi {\n  constructor(t, e) {\n    super(), this._element = t, this._options = this._getConfig(e), this._timer = null, this._tapCount = 0;\n  }\n  // Getters\n  static get NAME() {\n    return yo;\n  }\n  handleTouchStart(t) {\n    const { x: e, y: i } = this._getCoordinates(t), { interval: n, taps: o, pointers: r } = this._options;\n    return t.touches.length === r && (this._tapCount += 1, this._tapCount === 1 && (this._timer = setTimeout(() => {\n      this._tapCount = 0;\n    }, n)), this._tapCount === o && (clearTimeout(this._timer), this._tapCount = 0, c.trigger(this._element, yo, {\n      touch: t,\n      origin: {\n        x: e,\n        y: i\n      }\n    }))), t;\n  }\n  handleTouchEnd() {\n  }\n  handleTouchMove() {\n  }\n  _getConfig(t) {\n    const e = {\n      ...u0,\n      ...h.getDataAttributes(this._element),\n      ...t\n    };\n    return D(yo, e, d0), e;\n  }\n}\nconst Mi = \"rotate\", _0 = `${Mi}end`, f0 = `${Mi}start`, m0 = {\n  angle: \"number\",\n  pointers: \"number\"\n}, g0 = {\n  angle: 0,\n  pointers: 2\n};\nclass b0 extends Xi {\n  constructor(t, e) {\n    super(), this._element = t, this._options = this._getConfig(e), this._origin = {};\n  }\n  // Getters\n  static get NAME() {\n    return Mi;\n  }\n  handleTouchStart(t) {\n    t.type === \"touchstart\" && t.preventDefault(), !(t.touches.length < 2) && (this._startTouch = t, this._origin = {}, c.trigger(this._element, f0, { touch: t }));\n  }\n  handleTouchMove(t) {\n    t.type === \"touchmove\" && t.preventDefault();\n    let e, i;\n    const n = t.touches;\n    if (n.length === 1 && this._options.pointers === 1) {\n      const { left: o, top: r, width: a, height: l } = this._element.getBoundingClientRect();\n      e = {\n        x: o + a / 2,\n        y: r + l / 2\n      }, i = n[0];\n    } else if (t.touches.length === 2 && this._options.pointers === 2) {\n      const [o, r] = t.touches, a = {\n        x1: r.clientX,\n        x2: o.clientX,\n        y1: r.clientY,\n        y2: o.clientY\n      };\n      e = this._getMidPoint(a), i = this._getRightMostTouch(t.touches);\n    } else\n      return;\n    this.currentAngle = this._getAngle(\n      e.x,\n      e.y,\n      i.clientX,\n      i.clientY\n    ), this._origin.initialAngle ? (this._origin.change = this._getAngularDistance(\n      this._origin.previousAngle,\n      this.currentAngle\n    ), this._origin.distance += this._origin.change) : (this._origin.initialAngle = this._origin.previousAngle = this.currentAngle, this._origin.distance = this._origin.change = 0), this._origin.previousAngle = this.currentAngle, this.rotate = {\n      currentAngle: this.currentAngle,\n      distance: this._origin.distance,\n      change: this._origin.change\n    }, c.trigger(this._element, Mi, { ...this.rotate, touch: t });\n  }\n  handleTouchEnd(t) {\n    t.type === \"touchend\" && t.preventDefault(), this._origin = {}, c.trigger(this._element, _0, { touch: t });\n  }\n  _getConfig(t) {\n    const e = {\n      ...g0,\n      ...h.getDataAttributes(this._element),\n      ...t\n    };\n    return D(Mi, e, m0), e;\n  }\n}\nconst Ko = \"touch\", wo = `te.${Ko}`, v0 = {\n  event: \"string\"\n}, T0 = {\n  event: \"swipe\"\n};\nclass Ah {\n  constructor(t, e = {}) {\n    this._element = t, this._options = this._getConfig(e), this._event = this._options.event, this.swipe = this._event === \"swipe\" ? new qE(t, e) : null, this.press = this._event === \"press\" ? new zE(t, e) : null, this.pan = this._event === \"pan\" ? new n0(t, e) : null, this.pinch = this._event === \"pinch\" ? new h0(t, e) : null, this.tap = this._event === \"tap\" ? new p0(t, e) : null, this.rotate = this._event === \"rotate\" ? new b0(t, e) : null, this._touchStartHandler = (i) => this._handleTouchStart(i), this._touchMoveHandler = (i) => this._handleTouchMove(i), this._touchEndHandler = (i) => this._handleTouchEnd(i), c.on(this._element, \"touchstart\", this._touchStartHandler), c.on(this._element, \"touchmove\", this._touchMoveHandler), c.on(this._element, \"touchend\", this._touchEndHandler), this._element && y.setData(t, wo, this);\n  }\n  // Getters\n  static get NAME() {\n    return Ko;\n  }\n  dispose() {\n    c.off(this._element, \"touchstart\", this._touchStartHandler), c.off(this._element, \"touchmove\", this._touchMoveHandler), c.off(this._element, \"touchend\", this._touchEndHandler), this.swipe = null, this.press = null, this.pan = null, this.pinch = null, this.tap = null, this.rotate = null;\n  }\n  _getConfig(t) {\n    const e = {\n      ...T0,\n      ...h.getDataAttributes(this._element),\n      ...t\n    };\n    return D(Ko, e, v0), e;\n  }\n  _handleTouchStart(t) {\n    this[this._event].handleTouchStart(t);\n  }\n  _handleTouchMove(t) {\n    this[this._event].handleTouchMove && this[this._event].handleTouchMove(t);\n  }\n  _handleTouchEnd(t) {\n    this[this._event].handleTouchEnd(t);\n  }\n  static jQueryInterface(t) {\n    return this.each(function() {\n      let e = y.getData(this, wo);\n      const i = typeof t == \"object\" && t;\n      if (!(!e && /dispose/.test(t)) && (e || (e = new Ah(this, i)), typeof t == \"string\")) {\n        if (typeof e[t] > \"u\")\n          throw new TypeError(`No method named \"${t}\"`);\n        return e[t];\n      }\n    });\n  }\n  static getInstance(t) {\n    return y.getData(t, wo);\n  }\n  static getOrCreateInstance(t, e = {}) {\n    return this.getInstance(t) || new this(t, typeof e == \"object\" ? e : null);\n  }\n}\nconst zo = \"smoothScroll\", yi = `te.${zo}`, mr = `.${yi}`, E0 = {\n  container: \"string\",\n  offset: \"number\",\n  easing: \"string\",\n  duration: \"number\"\n}, C0 = {\n  container: \"body\",\n  offset: 0,\n  easing: \"linear\",\n  duration: 500\n}, A0 = `scrollStart${mr}`, y0 = `scrollEnd${mr}`, w0 = `scrollCancel${mr}`;\nclass yh {\n  constructor(t, e = {}) {\n    this._element = t, this._options = this._getConfig(e), this._href = this._element.getAttribute(\"href\"), this.isCancel = !1, this._element && (y.setData(t, yi, this), this._setup());\n  }\n  // getters\n  static get NAME() {\n    return zo;\n  }\n  get isWindow() {\n    return this._options.container === \"body\";\n  }\n  get containerToScroll() {\n    return this.isWindow ? document.documentElement : d.findOne(\n      this._options.container,\n      document.documentElement\n    );\n  }\n  get elFromHrefExist() {\n    return !!d.findOne(this._href, this.containerToScroll);\n  }\n  get offsetFromEl() {\n    const t = this.containerToScroll.scrollTop, e = d.findOne(this._href, this.containerToScroll);\n    if (this.isWindow)\n      return h.offset(e).top - this._options.offset + t;\n    const i = e.getBoundingClientRect().y, n = this.containerToScroll.getBoundingClientRect().y;\n    return i - n - this._options.offset + t;\n  }\n  get easingFunction() {\n    const t = this._options.easing, e = `_motion${t[0].toUpperCase()}${t.slice(1)}`;\n    return this[e] ? this[e] : this._motionLinear;\n  }\n  // public\n  dispose() {\n    c.off(this._element, \"click\", this._handleClick), y.removeData(this._element, yi), this._element = null;\n  }\n  cancelScroll() {\n    this.isCancel = !0;\n  }\n  // private\n  _getConfig(t) {\n    const e = {\n      ...C0,\n      ...h.getDataAttributes(this._element),\n      ...t\n    };\n    return D(zo, e, E0), e;\n  }\n  _inViewport() {\n    if (this.isWindow)\n      return !0;\n    const t = this.containerToScroll.getBoundingClientRect();\n    return t.top >= 0 && t.bottom <= (window.innerHeight || document.documentElement.clientHeight);\n  }\n  _setup() {\n    const t = typeof this._href < \"u\", e = this._href.includes(\"#\");\n    t && e && this.elFromHrefExist && (this._scrollOnClickEvent(), this._preventNativeScroll());\n  }\n  _scrollOnClickEvent() {\n    c.on(this._element, \"click\", (t) => {\n      this._handleClick(t);\n    });\n  }\n  _handleClick(t) {\n    t.preventDefault(), this.isCancel = !1, c.trigger(this._element, A0);\n    const e = this.containerToScroll, i = this.containerToScroll.scrollTop, n = this.offsetFromEl, o = 0, r = 1 / this._options.duration, a = 4.25, l = this.easingFunction;\n    this._inViewport() ? this._scrollOnNextTick(\n      e,\n      i,\n      n,\n      o,\n      r,\n      a,\n      l\n    ) : (this._scrollOnNextTick(\n      document.documentElement,\n      document.documentElement.scrollTop,\n      this.containerToScroll.offsetTop,\n      o,\n      r,\n      a,\n      l\n    ), setTimeout(() => {\n      this._scrollOnNextTick(\n        e,\n        i,\n        n,\n        o,\n        r,\n        a,\n        l\n      ), this.isCancel = !1;\n    }, this._options.duration));\n  }\n  _scrollOnNextTick(t, e, i, n, o, r, a) {\n    const l = n < 0, p = n > 1, u = o <= 0;\n    if (l || p || u || this.isCancel) {\n      if (this.isCancel) {\n        this.isInViewport && (this.isCancel = !1), c.trigger(this._element, w0);\n        return;\n      }\n      c.trigger(this._element, y0), t.scrollTop = i;\n      return;\n    }\n    t.scrollTo({\n      top: e - (e - i) * a(n)\n    }), n += o * r, setTimeout(() => {\n      this._scrollOnNextTick(\n        t,\n        e,\n        i,\n        n,\n        o,\n        r,\n        a\n      );\n    });\n  }\n  _preventDefault(t) {\n    t.preventDefault();\n  }\n  _preventNativeScroll() {\n    let t = !1;\n    try {\n      window.addEventListener(\n        \"test\",\n        null,\n        Object.defineProperty({}, \"passive\", {\n          get: () => t = !0\n        })\n      );\n    } catch (n) {\n      this._scrollError = n;\n    }\n    const e = t ? { passive: !1 } : !1, i = \"onwheel\" in $(\"div\") ? \"wheel\" : \"mousewheel\";\n    this.isWindow && (this._deleteScrollOnStart(e, i), this._addScrollOnEnd(e, i), this._addScrollOnCancel(e, i));\n  }\n  _deleteScrollOnStart(t, e) {\n    c.on(this._element, \"scrollStart.te.smoothScroll\", () => {\n      window.addEventListener(e, this._preventDefault, t), window.addEventListener(\"touchmove\", this._preventDefault, t);\n    });\n  }\n  _addScrollOnEnd(t, e) {\n    c.on(this._element, \"scrollEnd.te.smoothScroll\", () => {\n      window.removeEventListener(e, this._preventDefault, t), window.removeEventListener(\"touchmove\", this._preventDefault, t);\n    });\n  }\n  _addScrollOnCancel(t, e) {\n    c.on(this._element, \"scrollCancel.te.smoothScroll\", () => {\n      window.removeEventListener(e, this._preventDefault, t), window.removeEventListener(\"touchmove\", this._preventDefault, t);\n    });\n  }\n  // Motions\n  // Linear\n  _motionLinear(t) {\n    return t;\n  }\n  // Ease-In\n  _motionEaseInQuad(t) {\n    return t * t;\n  }\n  _motionEaseInCubic(t) {\n    return t * t * t;\n  }\n  _motionEaseInQuart(t) {\n    return t * t * t * t;\n  }\n  _motionEaseInQuint(t) {\n    return t * t * t * t * t;\n  }\n  // Ease-In-Out\n  _motionEaseInOutQuad(t) {\n    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n  }\n  _motionEaseInOutCubic(t) {\n    return t /= 0.5, t < 1 ? t * t * t / 2 : (t -= 2, (t * t * t + 2) / 2);\n  }\n  _motionEaseInOutQuart(t) {\n    return t /= 0.5, t < 1 ? 0.5 * t * t * t * t : (t -= 2, -(t * t * t * t - 2) / 2);\n  }\n  _motionEaseInOutQuint(t) {\n    return t /= 0.5, t < 1 ? t * t * t * t * t / 2 : (t -= 2, (t * t * t * t * t + 2) / 2);\n  }\n  // Ease-Out\n  _motionEaseOutQuad(t) {\n    return -t * (t - 2);\n  }\n  _motionEaseOutCubic(t) {\n    return t--, t * t * t + 1;\n  }\n  _motionEaseOutQuart(t) {\n    return t--, -(t * t * t * t - 1);\n  }\n  _motionEaseOutQuint(t) {\n    return t--, t * t * t * t * t + 1;\n  }\n  // static\n  static getInstance(t) {\n    return y.getData(t, yi);\n  }\n  static getOrCreateInstance(t, e = {}) {\n    return this.getInstance(t) || new this(t, typeof e == \"object\" ? e : null);\n  }\n  static jQueryInterface(t) {\n    return this.each(function() {\n      let e = y.getData(this, yi);\n      const i = typeof t == \"object\" && t;\n      if (e || (e = new yh(this, i)), typeof t == \"string\") {\n        if (typeof e[t] > \"u\")\n          throw new TypeError(`No method named \"${t}\"`);\n        e[t](this);\n      }\n    });\n  }\n}\nconst Bl = \"lazyLoad\", $s = \"te.lazyLoad\", k0 = \"[data-te-lazy-load-init]\", Hl = \"data-te-lazy-load\", x0 = \"onLoad.te.lazy\", O0 = \"onError.te.lazy\", Vl = [\"img\", \"video\"], S0 = {\n  lazySrc: \"(string|null)\",\n  lazyDelay: \"number\",\n  lazyAnimation: \"string\",\n  lazyOffset: \"number\",\n  lazyPlaceholder: \"(string|undefined)\",\n  lazyError: \"(string|undefined)\"\n}, I0 = {\n  lazySrc: null,\n  lazyDelay: 500,\n  lazyAnimation: \"[fade-in_1s_ease-in-out]\",\n  lazyOffset: 0\n};\nclass Uo {\n  constructor(t, e) {\n    this._element = t, this._element && y.setData(t, $s, this), this._options = this._getConfig(e), this.scrollHandler = this._scrollHandler.bind(this), this.errorHandler = this._setElementError.bind(this), this._childrenInstances = null, this._init();\n  }\n  // Getters\n  static get NAME() {\n    return Bl;\n  }\n  get offsetValues() {\n    return this._element.getBoundingClientRect();\n  }\n  get inViewport() {\n    if (this.parent) {\n      const t = this.parent.getBoundingClientRect();\n      return t.y > 0 && t.y < window.innerHeight && this.offsetValues.y >= t.y && this.offsetValues.y <= t.y + t.height && this.offsetValues.y <= window.innerHeight;\n    }\n    return this.offsetValues.top + this._options.lazyOffset <= window.innerHeight && this.offsetValues.bottom >= 0;\n  }\n  get parent() {\n    const [t] = d.parents(\n      this._element,\n      k0\n    );\n    return t;\n  }\n  get node() {\n    return this._element.nodeName;\n  }\n  get isContainer() {\n    return !d.matches(this._element, Vl);\n  }\n  // Public\n  dispose() {\n    y.removeData(this._element, $s), this._animation && (this._animation.dispose(), this._animation = null), this._element = null, this._childrenInstances && this._childrenInstances.forEach((t) => t.dispose());\n  }\n  // Private\n  _init() {\n    if (this._element.setAttribute(Hl, \"\"), this.isContainer) {\n      this._setupContainer();\n      return;\n    }\n    this._setupElement();\n  }\n  _setupElement() {\n    c.one(this._element, \"error\", this.errorHandler), this._options.lazyPlaceholder && this._setPlaceholder(), this._animation = new pr(this._element, {\n      animation: `${this._options.lazyAnimation}`,\n      animationStart: \"onLoad\"\n    }), c.one(this._element, \"load\", () => this._scrollHandler()), this.parent && c.on(this.parent, \"scroll\", this.scrollHandler), c.on(window, \"scroll\", this.scrollHandler);\n  }\n  _scrollHandler() {\n    this.inViewport && (this._timeout = setTimeout(() => {\n      this._setSrc(), this._element.removeAttribute(Hl), this._removeAttrs(), this._animation.init();\n    }, this._options.lazyDelay), this.parent && c.off(this.parent, \"scroll\", this.scrollHandler), c.off(window, \"scroll\", this.scrollHandler));\n  }\n  _setElementError() {\n    !this._options.lazyError || this._element.src === this._options.lazyError ? this._element.alt = \"404 not found\" : this._element.setAttribute(\"src\", this._options.lazyError), c.trigger(this._element, O0);\n  }\n  _setSrc() {\n    this._element.setAttribute(\"src\", this._options.lazySrc), c.trigger(this._element, x0);\n  }\n  _setPlaceholder() {\n    this.node === \"IMG\" ? this._element.setAttribute(\"src\", this._options.lazyPlaceholder) : this.node === \"VIDEO\" && this._element.setAttribute(\"poster\", this._options.lazyPlaceholder);\n  }\n  _removeAttrs() {\n    [\"src\", \"delay\", \"animation\", \"placeholder\", \"offset\", \"error\"].forEach(\n      (t) => {\n        h.removeDataAttribute(this._element, `lazy-${t}`);\n      }\n    );\n  }\n  _setupContainer() {\n    this._childrenInstances = d.children(\n      this._element,\n      Vl\n    ).map((t) => new Uo(t, this._options));\n  }\n  _getConfig(t) {\n    const e = {\n      ...I0,\n      ...t,\n      ...h.getDataAttributes(this._element)\n    };\n    return D(Bl, e, S0), e;\n  }\n  // Static\n  static getInstance(t) {\n    return y.getData(t, $s);\n  }\n  static getOrCreateInstance(t, e = {}) {\n    return this.getInstance(t) || new this(t, typeof e == \"object\" ? e : null);\n  }\n  static jQueryInterface(t) {\n    return this.each(function() {\n      let e = y.getData(this, $s);\n      const i = typeof t == \"object\" && t;\n      if (e || (e = new Uo(this, i)), typeof t == \"string\") {\n        if (typeof e[t] > \"u\")\n          throw new TypeError(`No method named \"${t}\"`);\n        e[t](this);\n      }\n    });\n  }\n}\nconst Wl = \"clipboard\", wi = \"te.clipboard\", D0 = `.${wi}`, $0 = {\n  clipboardTarget: null\n}, L0 = {\n  clipboardTarget: \"null|string\"\n}, N0 = `copy${D0}`;\nclass wh {\n  constructor(t, e = {}) {\n    this._element = t, this._options = e, this._element && (y.setData(t, wi, this), this._initCopy = this._initCopy.bind(this), this._setup());\n  }\n  // Getters\n  static get NAME() {\n    return Wl;\n  }\n  get options() {\n    const t = {\n      ...$0,\n      ...h.getDataAttributes(this._element),\n      ...this._options\n    };\n    return D(Wl, t, L0), t;\n  }\n  get clipboardTarget() {\n    return d.findOne(this.options.clipboardTarget);\n  }\n  get copyText() {\n    const t = this.clipboardTarget.hasAttribute(\n      \"data-te-clipboard-text\"\n    ), e = this.clipboardTarget.value, i = this.clipboardTarget.textContent;\n    return t ? this.clipboardTarget.getAttribute(\"data-te-clipboard-text\") : e || i;\n  }\n  // Public\n  dispose() {\n    c.off(this._element, \"click\", this._initCopy), y.removeData(this._element, wi), this._element = null;\n  }\n  // Private\n  _setup() {\n    c.on(this._element, \"click\", this._initCopy);\n  }\n  _initCopy() {\n    const t = this._createNewInput();\n    document.body.appendChild(t), this._selectInput(t), c.trigger(this._element, N0, {\n      copyText: this.copyText\n    }), t.remove();\n  }\n  _createNewInput() {\n    const t = this.clipboardTarget.tagName === \"TEXTAREA\" ? \"textarea\" : \"input\", e = $(t);\n    return e.value = this.copyText, h.addClass(e, \"-left-[9999px] absolute\"), e;\n  }\n  _selectInput(t) {\n    t.select(), t.focus(), t.setSelectionRange(0, 99999), document.execCommand(\"copy\");\n  }\n  // Static\n  static jQueryInterface(t) {\n    return this.each(function() {\n      let e = y.getData(this, wi);\n      const i = typeof t == \"object\" && t;\n      if (e || (e = new wh(this, i)), typeof t == \"string\") {\n        if (typeof e[t] > \"u\")\n          throw new TypeError(`No method named \"${t}\"`);\n        e[t](this);\n      }\n    });\n  }\n  static getInstance(t) {\n    return y.getData(t, wi);\n  }\n  static getOrCreateInstance(t, e = {}) {\n    return this.getInstance(t) || new this(t, typeof e == \"object\" ? e : null);\n  }\n}\nconst Xo = \"infiniteScroll\", Ls = `te.${Xo}`, M0 = {\n  infiniteDirection: \"y\"\n}, R0 = {\n  infiniteDirection: \"string\"\n};\nclass kh {\n  constructor(t, e) {\n    this._element = t, this._element && y.setData(t, Ls, this), this._options = this._getConfig(e), this.scrollHandler = this._scrollHandler.bind(this), this._init();\n  }\n  // Getters\n  static get NAME() {\n    return Xo;\n  }\n  get rect() {\n    return this._element.getBoundingClientRect();\n  }\n  get condition() {\n    return this._element === window ? Math.abs(\n      window.scrollY + window.innerHeight - document.documentElement.scrollHeight\n    ) < 1 : this._options.infiniteDirection === \"x\" ? this.rect.width + this._element.scrollLeft + 10 >= this._element.scrollWidth : Math.ceil(this.rect.height + this._element.scrollTop) >= this._element.scrollHeight;\n  }\n  // Public\n  dispose() {\n    c.off(this._element, \"scroll\", this.scrollHandler), y.removeData(this._element, Ls), this._element = null;\n  }\n  // Private\n  _init() {\n    c.on(this._element, \"scroll\", () => this._scrollHandler());\n  }\n  _scrollHandler() {\n    this.condition && c.trigger(this._element, \"complete.te.infiniteScroll\"), c.off(this._element, \"scroll\", this.scrollHandler);\n  }\n  _getConfig(t) {\n    const e = {\n      ...M0,\n      ...this._element !== window ? h.getDataAttributes(this._element) : {},\n      ...t\n    };\n    return D(Xo, e, R0), e;\n  }\n  // Static\n  static getInstance(t) {\n    return y.getData(t, Ls);\n  }\n  static getOrCreateInstance(t, e = {}) {\n    return this.getInstance(t) || new this(t, typeof e == \"object\" ? e : null);\n  }\n  static jQueryInterface(t) {\n    return this.each(function() {\n      let e = y.getData(this, Ls);\n      const i = typeof t == \"object\" && t;\n      if (e || (e = new kh(this, i)), typeof t == \"string\") {\n        if (typeof e[t] > \"u\")\n          throw new TypeError(`No method named \"${t}\"`);\n        e[t](this);\n      }\n    });\n  }\n}\nfunction P0({ backdropID: s }, t) {\n  const e = $(\"div\");\n  return h.addClass(\n    e,\n    `${t.backdrop} ${t.backdropColor}`\n  ), e.id = s, e;\n}\nconst Ri = \"loadingManagement\", Ns = `te.${Ri}`, B0 = \"[data-te-loading-icon-ref]\", H0 = \"[data-te-loading-text-ref]\", V0 = `show.te.${Ri}`, W0 = {\n  backdrop: \"(null|boolean)\",\n  backdropID: \"(null|string|number)\",\n  delay: \"(null|number)\",\n  loader: \"(null|string|number)\",\n  parentSelector: \"(null|string)\",\n  loadingIcon: \"boolean\",\n  loadingText: \"boolean\",\n  scroll: \"boolean\"\n}, F0 = {\n  backdrop: !0,\n  backdropID: null,\n  delay: 0,\n  loader: \"\",\n  parentSelector: null,\n  scroll: !0,\n  loadingText: !0,\n  loadingIcon: !0\n}, Y0 = {\n  loadingSpinner: \"absolute top-[50%] left-[50%] -translate-x-[50%] -translate-y-[50%] flex flex-col justify-center items-center z-40\",\n  spinnerColor: \"text-primary dark:text-primary-400\",\n  backdrop: \"w-full h-full fixed top-0 left-0 bottom-0 right-0 z-30\",\n  backdropColor: \"bg-[rgba(0,0,0,0.4)]\"\n}, j0 = {\n  loadingSpinner: \"string\",\n  spinnerColor: \"string\",\n  backdrop: \"string\",\n  backdropColor: \"string\"\n};\nclass xh {\n  constructor(t, e = {}, i) {\n    this._element = t, this._options = this._getConfig(e), this._classes = this._getClasses(i), this._element && y.setData(t, Ns, this), this._backdropElement = null, this._parentElement = d.findOne(this._options.parentSelector), this._loadingIcon = d.findOne(\n      B0,\n      this._element\n    ), this._loadingText = d.findOne(\n      H0,\n      this._element\n    ), this.init();\n  }\n  // Getters\n  static get NAME() {\n    return Ri;\n  }\n  // Public\n  init() {\n    const t = this._loadingIcon.cloneNode(!0), e = this._loadingText.cloneNode(!0);\n    this._removeElementsOnStart(), setTimeout(() => {\n      h.addClass(\n        this._element,\n        `${this._classes.loadingSpinner} ${this._classes.spinnerColor}`\n      ), this._setBackdrop(), this._setLoadingIcon(t), this._setLoadingText(e), this._setScrollOption(), c.trigger(this._element, V0);\n    }, this._options.delay);\n  }\n  dispose() {\n    y.removeData(this._element, Ns), h.removeClass(\n      this._element,\n      `${this._classes.loadingSpinner} ${this._classes.spinnerColor}`\n    );\n    const t = this._options.delay;\n    setTimeout(() => {\n      this._removeBackdrop(), this._backdropElement = null, this._element = null, this._options = null;\n    }, t);\n  }\n  // Private\n  _setBackdrop() {\n    const { backdrop: t } = this._options;\n    t && (this._backdropElement = P0(this._options, this._classes), this._parentElement !== null ? (h.addClass(this._element, \"absolute\"), h.addClass(this._parentElement, \"relative\"), h.addClass(this._backdropElement, \"absolute\"), this._parentElement.appendChild(this._backdropElement)) : (h.addClass(this._element, \"!fixed\"), document.body.appendChild(this._backdropElement), document.body.appendChild(this._element)));\n  }\n  _removeBackdrop() {\n    const { backdrop: t } = this._options;\n    t && (this._parentElement !== null ? (h.removeClass(this._element, \"absolute\"), h.removeClass(this._parentElement, \"relative\"), this._backdropElement.remove()) : (this._backdropElement.remove(), this._element.remove()));\n  }\n  _setLoadingIcon(t) {\n    if (!this._options.loadingIcon) {\n      t.remove();\n      return;\n    }\n    this._element.appendChild(t), t.id = this._options.loader;\n  }\n  _setLoadingText(t) {\n    if (!this._options.loadingText) {\n      t.remove();\n      return;\n    }\n    this._element.appendChild(t);\n  }\n  _removeElementsOnStart() {\n    this._element !== null && (this._loadingIcon.remove(), this._loadingText.remove());\n  }\n  _setScrollOption() {\n    if (this._options.scroll) {\n      if (this._parentElement === null) {\n        h.addClass(document.body, \"overflow-auto\");\n        return;\n      }\n      h.addClass(this._parentElement, \"overflow-auto\");\n    } else {\n      if (this._parentElement === null) {\n        h.addClass(document.body, \"overflow-hidden\");\n        return;\n      }\n      h.addClass(this._parentElement, \"overflow-hidden\");\n    }\n  }\n  _getConfig(t) {\n    const e = {\n      ...F0,\n      ...h.getDataAttributes(this._element),\n      ...t\n    };\n    return D(Ri, e, W0), e;\n  }\n  _getClasses(t) {\n    const e = h.getDataClassAttributes(this._element);\n    return t = {\n      ...Y0,\n      ...e,\n      ...t\n    }, D(Ri, t, j0), t;\n  }\n  // Static\n  static getInstance(t) {\n    return y.getData(t, Ns);\n  }\n  static getOrCreateInstance(t, e = {}) {\n    return this.getInstance(t) || new this(t, typeof e == \"object\" ? e : null);\n  }\n  static jQueryInterface(t) {\n    return this.each(function() {\n      let e = y.getData(this, Ns);\n      const i = typeof t == \"object\" && t;\n      if (e || (e = new xh(this, i)), typeof t == \"string\") {\n        if (typeof e[t] > \"u\")\n          throw new TypeError(`No method named \"${t}\"`);\n        e[t](this);\n      }\n    });\n  }\n}\nconst K0 = (s) => {\n  const t = /^(0?[1-9]|1[012])(:[0-5]\\d) [APap][mM]$/, e = /^([0-9]|0[0-9]|1[0-9]|2[0-3]):[0-5][0-9](:[0-5][0-9])?$/;\n  return s.match(t) || s.match(e);\n}, z0 = (s) => s && Object.prototype.toString.call(s) === \"[object Date]\" && !isNaN(s), U0 = (s) => s.getMonth(), X0 = (s) => s.getFullYear(), G0 = (s) => s.match(/[^(dmy)]{1,}/g), q0 = (s, t, e, i) => {\n  let n;\n  e[0] !== e[1] ? n = e[0] + e[1] : n = e[0];\n  const o = new RegExp(`[${n}]`), r = s.split(o), a = t.split(o), l = t.indexOf(\"mmm\") !== -1, p = [];\n  for (let b = 0; b < a.length; b++)\n    a[b].indexOf(\"yy\") !== -1 && (p[0] = { value: r[b], format: a[b] }), a[b].indexOf(\"m\") !== -1 && (p[1] = { value: r[b], format: a[b] }), a[b].indexOf(\"d\") !== -1 && a[b].length <= 2 && (p[2] = { value: r[b], format: a[b] });\n  let u;\n  t.indexOf(\"mmmm\") !== -1 ? u = i.monthsFull : u = i.monthsShort;\n  const _ = Number(p[0].value), f = l ? Z0(p[1].value, u) : Number(p[1].value) - 1, g = Number(p[2].value);\n  return Et(_, f, g);\n}, Z0 = (s, t) => t.findIndex((e) => e === s), Q0 = (s, t, e) => `\n  <button type=\"button\" class=\"${e.pickerIcon}\" data-te-datepicker-toggle-button-ref>\n    ${s}\n  </button>\n  <button type=\"button\" class=\"${e.pickerIcon}\" data-te-timepicker-toggle-button-ref>\n    ${t}\n  </button>\n`, J0 = (s, t) => `\n  <button type=\"button\" class=\"${t.toggleButton}\" data-te-date-timepicker-toggle-ref>\n    ${s} \n  </button>\n`, Qs = \"datetimepicker\", ki = `te.${Qs}`, gr = `.${ki}`, Oh = \"data-te-datepicker-init\", Sh = \"data-te-timepicker-init\", tC = \"data-te-datepicker-header\", eC = \"data-te-datepicker-cancel-button-ref\", iC = \"data-te-datepicker-ok-button-ref\", ko = \"data-te-timepicker-wrapper\", Fl = \"data-te-timepicker-cancel\", sC = \"data-te-timepicker-submit\", nC = \"data-te-timepicker-clear\", Yl = \"data-te-buttons-timepicker\", oC = \"data-te-date-timepicker-toggle-ref\", rC = \"data-te-datepicker-toggle-button-ref\", aC = \"data-te-timepicker-toggle-button-ref\", lC = `[${Sh}]`, cC = `[${Oh}]`, hC = `[${oC}]`, dC = `[${aC}]`, uC = \"[data-te-input-notch-ref]\", pC = \"[data-te-date-timepicker-toggle-ref]\", _C = \"[data-te-timepicker-elements-wrapper]\", fC = \"[data-te-timepicker-clock-wrapper]\", mC = `open${gr}`, gC = `close${gr}`, bC = `datetimeChange${gr}`, jl = \"close.te.datepicker\", Kl = \"input.te.timepicker\", De = $(\"div\"), zl = {\n  inline: !1,\n  toggleButton: !0,\n  container: \"body\",\n  disabled: !1,\n  disablePast: !1,\n  disableFuture: !1,\n  defaultTime: \"\",\n  defaultDate: \"\",\n  timepicker: {},\n  datepicker: {},\n  showFormat: !1,\n  dateTimepickerToggleIconTemplate: `<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" fill=\"currentColor\">\n  <path fill-rule=\"evenodd\" d=\"M6.75 2.25A.75.75 0 017.5 3v1.5h9V3A.75.75 0 0118 3v1.5h.75a3 3 0 013 3v11.25a3 3 0 01-3 3H5.25a3 3 0 01-3-3V7.5a3 3 0 013-3H6V3a.75.75 0 01.75-.75zm13.5 9a1.5 1.5 0 00-1.5-1.5H5.25a1.5 1.5 0 00-1.5 1.5v7.5a1.5 1.5 0 001.5 1.5h13.5a1.5 1.5 0 001.5-1.5v-7.5z\" clip-rule=\"evenodd\" />\n  </svg>`,\n  datepickerToggleIconTemplate: `<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" fill=\"currentColor\">\n  <path fill-rule=\"evenodd\" d=\"M6.75 2.25A.75.75 0 017.5 3v1.5h9V3A.75.75 0 0118 3v1.5h.75a3 3 0 013 3v11.25a3 3 0 01-3 3H5.25a3 3 0 01-3-3V7.5a3 3 0 013-3H6V3a.75.75 0 01.75-.75zm13.5 9a1.5 1.5 0 00-1.5-1.5H5.25a1.5 1.5 0 00-1.5 1.5v7.5a1.5 1.5 0 001.5 1.5h13.5a1.5 1.5 0 001.5-1.5v-7.5z\" clip-rule=\"evenodd\" />\n  </svg>`,\n  timepickerToggleIconTemplate: `<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"1.5\" stroke=\"currentColor\">\n  <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M12 6v6h4.5m4.5 0a9 9 0 11-18 0 9 9 0 0118 0z\" />\n  </svg>`\n}, vC = {\n  inline: \"boolean\",\n  toggleButton: \"boolean\",\n  container: \"string\",\n  disabled: \"boolean\",\n  disablePast: \"boolean\",\n  disableFuture: \"boolean\",\n  defaultTime: \"(string|date|number)\",\n  defaultDate: \"(string|date|number)\",\n  timepicker: \"object\",\n  datepicker: \"object\",\n  showFormat: \"boolean\",\n  dateTimepickerToggleIconTemplate: \"string\",\n  datepickerToggleIconTemplate: \"string\",\n  timepickerToggleIconTemplate: \"string\"\n}, TC = {\n  toggleButton: \"flex items-center justify-content-center [&>svg]:w-5 [&>svg]:h-5 absolute outline-none border-none bg-transparent right-0.5 top-1/2 -translate-x-1/2 -translate-y-1/2 hover:text-primary focus:text-primary dark:hover:text-primary-400 dark:focus:text-primary-400 dark:text-neutral-200\",\n  pickerIcon: \"[&>svg]:w-6 [&>svg]:h-6 [&>svg]:mx-auto [&>svg]:pointer-events-none w-1/2 px-1.5 py-[1px] rounded-[10px] min-h-[40px] cursor-pointer outline-none border-none text-white hover:bg-primary-600 dark:hover:bg-neutral-600\",\n  buttonsContainer: \"flex justify-evenly items-end bg-primary dark:bg-zinc-800 dark:data-[te-buttons-timepicker]:bg-zinc-700\",\n  timepicker: {},\n  datepicker: {}\n}, EC = {\n  toggleButton: \"string\",\n  pickerIcon: \"string\",\n  buttonsContainer: \"string\",\n  timepicker: \"object\",\n  datepicker: \"object\"\n};\nclass Ih {\n  constructor(t, e, i) {\n    this._element = t, this._input = d.findOne(\"input\", this._element), this._options = this._getConfig(e), this._classes = this._getClasses(i), this._timepicker = null, this._datepicker = null, this._dateValue = this._options.defaultDate ? this._options.defaultDate : \"\", this._timeValue = this._options.defaultTime ? this._options.defaultTime : \"\", this._isInvalidTimeFormat = !1, this._format = this._options.datepicker.format ? this._options.datepicker.format : \"dd/mm/yyyy\", this._cancel = !1, this._scrollBar = new qe(), this._element && y.setData(t, ki, this), this._init();\n  }\n  // Getters\n  static get NAME() {\n    return Qs;\n  }\n  get toggleButton() {\n    return d.findOne(hC, this._element);\n  }\n  get notch() {\n    return d.findOne(uC, this._element);\n  }\n  dispose() {\n    c.off(this._element, \"click\", this._openDatePicker), c.off(this._input, \"input\", this._handleInput), c.off(this._element, \"click\"), y.removeData(this._element, ki), this._removeTimePicker(), this._removeDatepicker(), this.toggleButton.remove(), this._options = zl, this._timepicker = null, this._datepicker = null, this._dateValue = null, this._timeValue = null, this._isInvalidTimeFormat = null;\n  }\n  update(t = {}) {\n    const e = this._getConfig({ ...this._options, ...t });\n    this.dispose(), this._options = e, this._init();\n  }\n  // Private\n  _init() {\n    this._addDatepicker(), this._addTimePicker(), this._appendToggleButton(), this._listenToToggleClick(), this._listenToUserInput(), this._disableInput(), this._setInitialDefaultInput(), this._applyFormatPlaceholder(), this._options.disablePast && this._handleTimepickerDisablePast(), this._options.disableFuture && this._handleTimepickerDisableFuture();\n  }\n  _removeDatepicker() {\n    const t = this._element.querySelector(cC);\n    t && t.remove();\n  }\n  _addDatepicker() {\n    const t = $(\"div\");\n    t.id = this._element.id ? `datepicker-${this._element.id}` : rt(\"datepicker-\");\n    const e = '<input type=\"text\">';\n    t.innerHTML = e, t.setAttribute(Oh, \"\"), this._element.appendChild(t), h.addClass(t, \"hidden\");\n    let i = {\n      ...this._options.datepicker,\n      container: this._options.container,\n      disablePast: this._options.disablePast,\n      disableFuture: this._options.disableFuture\n    };\n    (this._options.inline || this._options.datepicker.inline) && (i = { ...i, inline: !0 }), this._datepicker = new Nm(t, i, {\n      ...this._classes.datepicker\n    }), this._datepicker._input.value = this._dateValue;\n  }\n  _removeTimePicker() {\n    const t = this._element.querySelector(lC);\n    t && (t.remove(), this._scrollBar.reset());\n  }\n  _addTimePicker() {\n    const t = $(\"div\");\n    t.id = this._element.id ? `timepicker-${this._element.id}` : rt(\"timepicker-\");\n    const e = '<input type=\"text\">';\n    t.innerHTML = e, t.setAttribute(Sh, \"\"), this._element.appendChild(t), h.addClass(t, \"hidden\");\n    let i = {\n      ...this._options.timepicker,\n      container: this._options.container\n    };\n    (this._options.inline || this._options.timepicker.inline) && (i = { timepickerOptions: i, inline: !0 }), this._timepicker = new ng(t, i, {\n      ...this._classes.timepicker\n    }), this._timepicker.input.value = this._timeValue;\n  }\n  _addIconButtons() {\n    if (h.addClass(De, this._classes.buttonsContainer), De.innerHTML = Q0(\n      this._options.datepickerToggleIconTemplate,\n      this._options.timepickerToggleIconTemplate,\n      this._classes\n    ), De.removeAttribute(Yl), !(this._options.inline || this._options.datepicker.inline)) {\n      if (this._scrollBar.hide(), this._datepicker._isOpen)\n        d.findOne(\n          `[${tC}]`,\n          document.body\n        ).appendChild(De);\n      else if (this._timepicker._modal && !this._options.timepicker.inline) {\n        const t = d.findOne(\n          _C,\n          document.body\n        ), e = d.findOne(\n          fC,\n          document.body\n        );\n        De.setAttribute(Yl, \"\"), t.insertBefore(De, e);\n      }\n    }\n  }\n  _enableOrDisableToggleButton() {\n    this._options.disabled ? (this.toggleButton.disabled = !0, h.addClass(this.toggleButton, \"pointer-events-none\")) : (this.toggleButton.disabled = !1, h.removeClass(this.toggleButton, \"pointer-events-none\"));\n  }\n  _appendToggleButton() {\n    this._options.toggleButton && (this._element.insertAdjacentHTML(\n      \"beforeend\",\n      J0(\n        this._options.dateTimepickerToggleIconTemplate,\n        this._classes\n      )\n    ), this._enableOrDisableToggleButton());\n  }\n  _applyFormatPlaceholder() {\n    this._options.showFormat && (this._input.placeholder = this._format);\n  }\n  _listenToCancelClick() {\n    const t = d.findOne(\n      `[${eC}]`,\n      document.body\n    );\n    c.one(t, \"mousedown\", () => {\n      this._cancel = !0, this._scrollBar.reset(), c.off(t, \"mousedown\");\n    });\n  }\n  _listenToToggleClick() {\n    c.on(this._element, \"click\", pC, (t) => {\n      t.preventDefault(), this._openDatePicker();\n    });\n  }\n  _listenToUserInput() {\n    c.on(this._input, \"input\", (t) => {\n      this._handleInput(t.target.value);\n    });\n  }\n  _disableInput() {\n    this._options.disabled && (this._input.disabled = \"true\");\n  }\n  _getConfig(t) {\n    const e = h.getDataAttributes(this._element);\n    return t = {\n      ...zl,\n      ...e,\n      ...t\n    }, D(Qs, t, vC), t;\n  }\n  _getClasses(t) {\n    const e = h.getDataClassAttributes(this._element);\n    return t = {\n      ...TC,\n      ...e,\n      ...t\n    }, D(Qs, t, EC), t;\n  }\n  _handleInput(t) {\n    const e = t.split(\", \"), i = G0(this._format), n = e[0], o = e[1] || \"\", r = q0(\n      n,\n      this._format,\n      i,\n      this._datepicker._options\n    );\n    e.length === 2 && (z0(r) && K0(o) ? (this._dateValue = n, this._timeValue = o, this._datepicker._input.value = this._dateValue, this._datepicker._activeDate = this._dateValue, this._datepicker._selectedYear = X0(r), this._datepicker._selectedMonth = U0(r), this._datepicker._headerDate = r, this._timepicker.input.value = this._timeValue, this._timepicker._isInvalidTimeFormat = !1) : (this._datepicker._activeDate = /* @__PURE__ */ new Date(), this._datepicker._selectedDate = null, this._datepicker._selectedMonth = null, this._datepicker._selectedYear = null, this._datepicker._headerDate = null, this._datepicker._headerMonth = null, this._datepicker._headerYear = null, this._timepicker._isInvalidTimeFormat = !0));\n  }\n  _openDatePicker() {\n    if (c.trigger(this._element, mC).defaultPrevented)\n      return;\n    this._datepicker.open(), this._options.inline || this._scrollBar.hide(), (this._options.inline || this._options.datepicker.inline) && this._openDropdownDate(), this._addIconButtons(), this._listenToCancelClick(), this._options.inline && this._datepicker._isOpen && h.addClass(this.toggleButton, \"pointer-events-none\"), c.one(this._datepicker._element, jl, () => {\n      if (this._dateValue = this._datepicker._input.value, this._updateInputValue(), this._cancel) {\n        this._cancel = !1;\n        return;\n      }\n      c.on(this._datepicker.container, \"click\", (i) => {\n        !this._datepicker._selectedDate && i.target.hasAttribute(iC) || this._openTimePicker();\n      }), setTimeout(() => {\n        d.findOne(\n          `[${ko}]`,\n          document.body\n        ) || this._scrollBar.reset();\n      }, 10), this._options.inline && h.removeClass(this.toggleButton, \"pointer-events-none\");\n    });\n    const e = d.findOne(\n      dC,\n      document.body\n    );\n    c.on(e, \"click\", () => {\n      this._datepicker.close(), this._scrollBar.hide(), c.trigger(this._datepicker._element, jl);\n    });\n  }\n  _handleTimepickerDisablePast() {\n    const t = /* @__PURE__ */ new Date();\n    t.setHours(0, 0, 0, 0), c.on(\n      this._datepicker._element,\n      \"dateChange.te.datepicker\",\n      () => {\n        this._datepicker._selectedDate.getTime() === t.getTime() ? this._timepicker.update({ disablePast: !0 }) : this._timepicker.update({ disablePast: !1 });\n      }\n    );\n  }\n  _handleTimepickerDisableFuture() {\n    const t = /* @__PURE__ */ new Date();\n    t.setHours(0, 0, 0, 0), c.on(\n      this._datepicker._element,\n      \"dateChange.te.datepicker\",\n      () => {\n        this._datepicker._selectedDate.getTime() === t.getTime() ? this._timepicker.update({ disableFuture: !0 }) : this._timepicker.update({ disableFuture: !1 });\n      }\n    );\n  }\n  _handleEscapeKey() {\n    c.one(document.body, \"keyup\", () => {\n      setTimeout(() => {\n        d.findOne(\n          `[${ko}]`,\n          document.body\n        ) || this._scrollBar.reset();\n      }, 250);\n    });\n  }\n  _handleCancelButton() {\n    const t = d.findOne(\n      `[${Fl}]`,\n      document.body\n    );\n    c.one(t, \"mousedown\", () => {\n      this._scrollBar.reset();\n    });\n  }\n  _openDropdownDate() {\n    const t = this._datepicker._popper;\n    t.state.elements.reference = this._input, this._scrollBar.reset();\n  }\n  _openTimePicker() {\n    c.trigger(this._timepicker.elementToggle, \"click\"), setTimeout(() => {\n      if (this._addIconButtons(), (this._options.inline || this._options.timepicker.inline) && this._openDropdownTime(), this._timepicker._modal) {\n        const t = d.findOne(\n          `[${Fl}]`,\n          document.body\n        );\n        this._handleEscapeKey(), this._handleCancelButton(), c.on(this._timepicker._modal, \"click\", (e) => {\n          (e.target.hasAttribute(ko) || e.target.hasAttribute(sC)) && setTimeout(() => {\n            this._scrollBar.reset();\n          }, 200), e.target.hasAttribute(nC) && c.trigger(\n            this._timepicker._element,\n            Kl\n          ), e.target.hasAttribute(rC) && (c.trigger(t, \"click\"), setTimeout(() => {\n            this._openDatePicker(), this._scrollBar.hide();\n          }, 200));\n        });\n      }\n    }), c.one(this._timepicker._element, Kl, () => {\n      this._timeValue = this._timepicker.input.value, this._updateInputValue(), c.trigger(this._element, gC);\n    });\n  }\n  _openDropdownTime() {\n    const t = this._timepicker._popper;\n    t.state.elements.reference = this._input, t.update(), this._scrollBar.reset();\n  }\n  _setInitialDefaultInput() {\n    (this._options.defaultDate || this._options.defaultTime) && this._updateInputValue();\n  }\n  _updateInputValue() {\n    this._timeValue && this._dateValue && (this._input.value = `${this._dateValue}, ${this._timeValue}`, c.trigger(\n      this._element,\n      bC\n    ).defaultPrevented) || (c.trigger(this._input, \"focus\"), this.notch && this.notch.removeAttribute(\"data-te-input-focused\"));\n  }\n  // static\n  static jQueryInterface(t, e) {\n    return this.each(function() {\n      let i = y.getData(this, ki);\n      const n = typeof t == \"object\" && t;\n      if (!(!i && /dispose/.test(t)) && (i || (i = new Ih(this, n)), typeof t == \"string\")) {\n        if (typeof i[t] > \"u\")\n          throw new TypeError(`No method named \"${t}\"`);\n        i[t](e);\n      }\n    });\n  }\n  static getInstance(t) {\n    return y.getData(t, ki);\n  }\n  static getOrCreateInstance(t, e = {}) {\n    return this.getInstance(t) || new this(t, typeof e == \"object\" ? e : null);\n  }\n}\nconst Js = \"sticky\", xi = `te.${Js}`, Dh = `.${xi}`, CC = `active${Dh}`, AC = `inactive${Dh}`, yC = {\n  stickyAnimationSticky: \"\",\n  stickyAnimationUnsticky: \"\",\n  stickyBoundary: !1,\n  stickyDelay: 0,\n  stickyDirection: \"down\",\n  stickyMedia: 0,\n  stickyOffset: 0,\n  stickyPosition: \"top\",\n  stickyZIndex: 100\n}, wC = {\n  stickyAnimationSticky: \"string\",\n  stickyAnimationUnsticky: \"string\",\n  stickyBoundary: \"(boolean|string)\",\n  stickyDelay: \"number\",\n  stickyDirection: \"string\",\n  stickyMedia: \"number\",\n  stickyOffset: \"number\",\n  stickyPosition: \"string\",\n  stickyZIndex: \"(string|number)\"\n}, kC = {\n  stickyActive: \"\"\n}, xC = {\n  stickyActive: \"string\"\n};\nclass $h {\n  constructor(t, e, i) {\n    this._element = t, this._hiddenElement = null, this._elementPositionStyles = {}, this._scrollDirection = \"\", this._isSticked = !1, this._elementOffsetTop = null, this._scrollTop = 0, this._pushPoint = \"\", this._manuallyDeactivated = !1, this._element && (this._options = this._getConfig(e), this._classes = this._getClasses(i), y.setData(t, xi, this), this._init());\n  }\n  // Getters\n  static get NAME() {\n    return Js;\n  }\n  // Public\n  dispose() {\n    const { stickyAnimationUnsticky: t } = this._options;\n    let { animationDuration: e } = getComputedStyle(this._element);\n    e = t !== \"\" ? parseFloat(e) * 1e3 : 0, this._disableSticky(), setTimeout(() => {\n      y.removeData(this._element, xi), this._element = null, this._options = null, this._hiddenElement = null, this._elementPositionStyles = null, this._scrollDirection = null, this._isSticked = null, this._elementOffsetTop = null, this._scrollTop = null, this._pushPoint = null, this._manuallyDeactivated = null;\n    }, e);\n  }\n  active() {\n    this._isSticked || (this._createHiddenElement(), this._enableSticky(), this._changeBoundaryPosition(), this._isSticked = !0, this._manuallyDeactivated = !1);\n  }\n  inactive() {\n    this._isSticked && (this._disableSticky(), this._isSticked = !1, this._manuallyDeactivated = !0);\n  }\n  // Private\n  _init() {\n    this._userActivityListener();\n  }\n  _userActivityListener() {\n    c.on(window, \"resize\", () => {\n      this._updateElementPosition(), this._updateElementOffset();\n    }), c.on(window, \"scroll\", () => {\n      if (!this._element || window.innerWidth <= this._options.stickyMedia || this._manuallyDeactivated)\n        return;\n      const t = document.documentElement, { stickyDirection: e } = this._options, i = window.pageYOffset || t.scrollTop;\n      this._updateElementOffset(), this._updatePushPoint(), this._updateScrollDirection(i), this._clearInProgressAnimations();\n      const n = [this._scrollDirection, \"both\"].includes(\n        e\n      ), o = this._pushPoint <= i, r = o && !this._isSticked && n, a = (!o || !n) && this._isSticked;\n      r && (this._createHiddenElement(), this._enableSticky(), this._changeBoundaryPosition(), this._isSticked = !0), a && (this._disableSticky(), this._isSticked = !1), this._isSticked && (this._updatePosition({ styles: this._elementPositionStyles }), this._changeBoundaryPosition()), this._scrollTop = i <= 0 ? 0 : i;\n    });\n  }\n  _updatePushPoint() {\n    this._options.stickyPosition === \"top\" ? this._pushPoint = this._elementOffsetTop - this._options.stickyDelay : this._pushPoint = this._elementOffsetTop + this._element.height - document.body.scrollHeight + this._options.stickyDelay;\n  }\n  _updateElementOffset() {\n    this._hiddenElement ? this._elementOffsetTop = this._hiddenElement.offsetTop : this._elementOffsetTop = this._element.offsetTop, this._options.stickyAnimationUnsticky && (this._elementOffsetTop += this._element.height || 0);\n  }\n  _updateElementPosition() {\n    if (this._hiddenElement) {\n      const { left: t } = this._hiddenElement.getBoundingClientRect();\n      this._elementPositionStyles = {\n        left: `${t}px`\n      };\n    } else\n      this._elementPositionStyles = {};\n    this._setStyle(this._element, this._elementPositionStyles);\n  }\n  _updateScrollDirection(t) {\n    t > this._scrollTop ? this._scrollDirection = \"down\" : this._scrollDirection = \"up\";\n  }\n  _clearInProgressAnimations() {\n    const t = this._scrollDirection === \"up\", e = this._element.classList.contains(\n      this._options.stickyAnimationUnsticky\n    ), i = window.scrollY <= this._elementOffsetTop - this._element.height;\n    t && e && i && (this._removeUnstickyAnimation(), this._resetStyles(), this._removeHiddenElement());\n  }\n  _enableSticky() {\n    const {\n      stickyAnimationSticky: t,\n      stickyAnimationUnsticky: e,\n      stickyOffset: i,\n      stickyPosition: n,\n      stickyZIndex: o\n    } = this._options, { height: r, left: a, width: l } = this._element.getBoundingClientRect();\n    t !== \"\" && this._toggleClass(\n      t,\n      e,\n      this._element\n    ), this._toggleClass(this._classes.stickyActive, \"\", this._element), this._setStyle(this._element, {\n      top: n === \"top\" && `${0 + i}px`,\n      bottom: n === \"bottom\" && `${0 + i}px`,\n      height: `${r}px`,\n      width: `${l}px`,\n      left: `${a}px`,\n      zIndex: `${o}`,\n      position: \"fixed\"\n    }), this._hiddenElement.hidden = !1, c.trigger(this._element, CC);\n  }\n  _changeBoundaryPosition() {\n    const { stickyPosition: t, stickyBoundary: e, stickyOffset: i } = this._options, { height: n } = this._element.getBoundingClientRect(), o = {\n      height: this._element.parentElement.getBoundingClientRect().height,\n      ...this._getOffset(this._element.parentElement)\n    };\n    let r;\n    const a = d.findOne(e);\n    a ? r = this._getOffset(a).top - n - i : r = o.height + o[t] - n - i;\n    const l = t === \"top\", p = t === \"bottom\", u = e, _ = r < 0, f = r > o.height - n;\n    let g;\n    l && (_ && u ? g = { top: `${i + r}px` } : g = { top: `${i + 0}px` }), p && (_ && u ? g = { bottom: `${i + r}px` } : f && u ? g = { bottom: `${i + o.bottom}px` } : g = { bottom: `${i + 0}px` }), this._setStyle(this._element, g);\n  }\n  _disableSticky() {\n    const { stickyAnimationUnsticky: t, stickyAnimationSticky: e } = this._options;\n    let { animationDuration: i } = getComputedStyle(this._element);\n    i = t !== \"\" ? parseFloat(i) * 1e3 : 0, this._options.stickyAnimationUnsticky !== \"\" && this._toggleClass(\n      t,\n      e,\n      this._element\n    ), setTimeout(() => {\n      this._element.classList.contains(e) || (this._removeUnstickyAnimation(), this._resetStyles(), this._removeHiddenElement(), this._toggleClass(\"\", this._classes.stickyActive, this._element), c.trigger(this._element, AC));\n    }, i);\n  }\n  _createHiddenElement() {\n    this._hiddenElement || (this._hiddenElement = this._copyElement(this._element));\n  }\n  _removeHiddenElement() {\n    this._hiddenElement && (this._hiddenElement.remove(), this._hiddenElement = null);\n  }\n  _removeUnstickyAnimation() {\n    this._toggleClass(\"\", this._options.stickyAnimationUnsticky, this._element);\n  }\n  _resetStyles() {\n    this._setStyle(this._element, {\n      top: null,\n      bottom: null,\n      position: null,\n      left: null,\n      zIndex: null,\n      width: null,\n      height: null\n    });\n  }\n  _updatePosition({ styles: t }) {\n    this._setStyle(this._element, t);\n  }\n  _toggleClass(t, e, i) {\n    t && h.addClass(i, t), e && h.removeClass(i, e);\n  }\n  _getOffset(t) {\n    const e = h.offset(t), i = t.getBoundingClientRect(), n = e.left === 0 && e.top === 0 ? 0 : window.innerHeight - i.bottom;\n    return {\n      ...e,\n      bottom: n\n    };\n  }\n  _copyElement(t) {\n    const { height: e, width: i } = t.getBoundingClientRect(), n = t.cloneNode(!1);\n    return n.hidden = !0, this._setStyle(n, {\n      height: `${e}px`,\n      width: `${i}px`,\n      opacity: \"0\"\n    }), t.parentElement.insertBefore(n, t), n;\n  }\n  _getConfig(t = {}) {\n    const e = h.getDataAttributes(this._element);\n    return t = {\n      ...yC,\n      ...e,\n      ...t\n    }, D(Js, t, wC), t;\n  }\n  _getClasses(t) {\n    const e = h.getDataClassAttributes(this._element);\n    return t = {\n      ...kC,\n      ...e,\n      ...t\n    }, D(Js, t, xC), t;\n  }\n  _setStyle(t, e) {\n    Object.keys(e).forEach((i) => {\n      t.style[i] = e[i];\n    });\n  }\n  static jQueryInterface(t, e) {\n    return this.each(function() {\n      let i = y.getData(this, xi);\n      const n = typeof t == \"object\" && t;\n      if (!(!i && /dispose|hide/.test(t)) && (i || (i = new $h(this, n)), typeof t == \"string\")) {\n        if (typeof i[t] > \"u\")\n          throw new TypeError(`No method named \"${t}\"`);\n        i[t](e);\n      }\n    });\n  }\n  static getInstance(t) {\n    return y.getData(t, xi);\n  }\n  static getOrCreateInstance(t, e = {}) {\n    return this.getInstance(t) || new this(t, typeof e == \"object\" ? e : null);\n  }\n}\nconst OC = (s) => {\n  Zl(() => {\n    const t = ql();\n    if (t) {\n      const e = s.NAME, i = t.fn[e];\n      t.fn[e] = s.jQueryInterface, t.fn[e].Constructor = s, t.fn[e].noConflict = () => (t.fn[e] = i, s.jQueryInterface);\n    }\n  });\n}, SC = (s, t) => {\n  c.on(\n    document,\n    `click.te.${s.NAME}`,\n    t,\n    function(e) {\n      e.preventDefault(), s.getOrCreateInstance(this).toggle();\n    }\n  );\n}, IC = (s, t) => {\n  c.on(\n    document,\n    `click.te.${s.NAME}.data-api`,\n    t,\n    function(e) {\n      if ([\"A\", \"AREA\"].includes(this.tagName) && e.preventDefault(), ge(this))\n        return;\n      s.getOrCreateInstance(this).show();\n    }\n  );\n}, DC = (s, t) => {\n  c.on(\n    document,\n    `click.te.${s.NAME}.data-api`,\n    t,\n    function(e) {\n      const i = Jt(this);\n      if ([\"A\", \"AREA\"].includes(this.tagName) && e.preventDefault(), ge(this))\n        return;\n      c.one(i, s.EVENT_HIDDEN, () => {\n        Nt(this) && this.focus();\n      });\n      const n = d.findOne(s.OPEN_SELECTOR);\n      n && n !== i && s.getInstance(n).hide(), s.getOrCreateInstance(i).toggle(this);\n    }\n  );\n}, $C = (s, t) => {\n  c.on(\n    document,\n    `click.te.${s.NAME}`,\n    t,\n    (e) => {\n      e.preventDefault();\n      const i = e.target.closest(t);\n      s.getOrCreateInstance(i).toggle();\n    }\n  );\n}, LC = (s, t) => {\n  c.on(\n    document,\n    `click.te.${s.NAME}`,\n    t,\n    function(e) {\n      const i = Jt(this);\n      [\"A\", \"AREA\"].includes(this.tagName) && e.preventDefault(), c.one(i, s.EVENT_SHOW, (r) => {\n        r.defaultPrevented || c.one(i, s.EVENT_HIDDEN, () => {\n          Nt(this) && this.focus();\n        });\n      });\n      const n = d.findOne(\n        `[${s.OPEN_SELECTOR}=\"true\"]`\n      );\n      n && s.getInstance(n).hide(), s.getOrCreateInstance(i).toggle(this);\n    }\n  );\n}, NC = (s, t) => {\n  c.one(\n    document,\n    \"mousedown\",\n    t,\n    s.autoInitial(new s())\n  );\n}, MC = (s, t) => {\n  c.on(\n    document,\n    `click.te.${s.NAME}.data-api`,\n    t,\n    function(e) {\n      (e.target.tagName === \"A\" || e.delegateTarget && e.delegateTarget.tagName === \"A\") && e.preventDefault();\n      const i = qo(this);\n      d.find(i).forEach((o) => {\n        s.getOrCreateInstance(o, { toggle: !1 }).toggle();\n      });\n    }\n  );\n}, RC = (s, t) => {\n  [].slice.call(\n    document.querySelectorAll(t)\n  ).map(function(i) {\n    return new s(i);\n  });\n}, PC = (s, t) => {\n  [].slice.call(\n    document.querySelectorAll(t)\n  ).map(function(i) {\n    return new s(i);\n  });\n}, BC = (s, t) => {\n  d.find(t).forEach((e) => {\n    new s(e);\n  }), c.on(\n    document,\n    `click.te.${s.NAME}.data-api`,\n    `${t} img:not([data-te-lightbox-disabled])`,\n    s.toggle()\n  );\n}, HC = (s, t) => {\n  const e = (o) => o[0] === \"{\" && o[o.length - 1] === \"}\" || o[0] === \"[\" && o[o.length - 1] === \"]\", i = (o) => typeof o != \"string\" ? o : e(o) ? JSON.parse(o.replace(/'/g, '\"')) : o, n = (o) => {\n    const r = {};\n    return Object.keys(o).forEach((a) => {\n      if (a.match(/dataset.*/)) {\n        const l = a.slice(7, 8).toLowerCase().concat(a.slice(8));\n        r[l] = i(o[a]);\n      }\n    }), r;\n  };\n  d.find(t).forEach((o) => {\n    if (h.getDataAttribute(o, \"chart\") !== \"bubble\" && h.getDataAttribute(o, \"chart\") !== \"scatter\") {\n      const r = h.getDataAttributes(o), a = {\n        data: {\n          datasets: [n(r)]\n        }\n      };\n      return r.chart && (a.type = r.chart), r.labels && (a.data.labels = JSON.parse(r.labels.replace(/'/g, '\"'))), new s(o, {\n        ...a,\n        ...Ti[a.type]\n      });\n    }\n    return null;\n  });\n};\nclass VC {\n  constructor() {\n    this.inits = [];\n  }\n  get initialized() {\n    return this.inits;\n  }\n  isInited(t) {\n    return this.inits.includes(t);\n  }\n  add(t) {\n    this.isInited(t) || this.inits.push(t);\n  }\n}\nconst Go = new VC(), Oi = {\n  alert: {\n    name: \"Alert\",\n    selector: \"[data-te-alert-init]\",\n    isToggler: !1\n  },\n  animation: {\n    name: \"Animate\",\n    selector: \"[data-te-animation-init]\",\n    isToggler: !1\n  },\n  carousel: {\n    name: \"Carousel\",\n    selector: \"[data-te-carousel-init]\",\n    isToggler: !1\n  },\n  chips: {\n    name: \"ChipsInput\",\n    selector: \"[data-te-chips-input-init]\",\n    isToggler: !1\n  },\n  chip: {\n    name: \"Chip\",\n    selector: \"[data-te-chip-init]\",\n    isToggler: !1,\n    onInit: \"init\"\n  },\n  datepicker: {\n    name: \"Datepicker\",\n    selector: \"[data-te-datepicker-init]\",\n    isToggler: !1\n  },\n  datetimepicker: {\n    name: \"Datetimepicker\",\n    selector: \"[data-te-date-timepicker-init]\",\n    isToggler: !1\n  },\n  input: {\n    name: \"Input\",\n    selector: \"[data-te-input-wrapper-init]\",\n    isToggler: !1\n  },\n  perfectScrollbar: {\n    name: \"PerfectScrollbar\",\n    selector: \"[data-te-perfect-scrollbar-init]\",\n    isToggler: !1\n  },\n  rating: {\n    name: \"Rating\",\n    selector: \"[data-te-rating-init]\",\n    isToggler: !1\n  },\n  scrollspy: {\n    name: \"ScrollSpy\",\n    selector: \"[data-te-spy='scroll']\",\n    isToggler: !1\n  },\n  select: {\n    name: \"Select\",\n    selector: \"[data-te-select-init]\",\n    isToggler: !1\n  },\n  sidenav: {\n    name: \"Sidenav\",\n    selector: \"[data-te-sidenav-init]\",\n    isToggler: !1\n  },\n  stepper: {\n    name: \"Stepper\",\n    selector: \"[data-te-stepper-init]\",\n    isToggler: !1\n  },\n  timepicker: {\n    name: \"Timepicker\",\n    selector: \"[data-te-timepicker-init]\",\n    isToggler: !1\n  },\n  toast: {\n    name: \"Toast\",\n    selector: \"[data-te-toast-init]\",\n    isToggler: !1\n  },\n  datatable: {\n    name: \"Datatable\",\n    selector: \"[data-te-datatable-init]\"\n  },\n  popconfirm: {\n    name: \"Popconfirm\",\n    selector: \"[data-te-toggle='popconfirm']\"\n  },\n  validation: {\n    name: \"Validation\",\n    selector: \"[data-te-validation-init]\"\n  },\n  smoothScroll: {\n    name: \"SmoothScroll\",\n    selector: \"a[data-te-smooth-scroll-init]\"\n  },\n  lazyLoad: {\n    name: \"LazyLoad\",\n    selector: \"[data-te-lazy-load-init]\"\n  },\n  clipboard: {\n    name: \"Clipboard\",\n    selector: \"[data-te-clipboard-init]\"\n  },\n  infiniteScroll: {\n    name: \"InfiniteScroll\",\n    selector: \"[data-te-infinite-scroll-init]\"\n  },\n  loadingManagement: {\n    name: \"LoadingManagement\",\n    selector: \"[data-te-loading-management-init]\"\n  },\n  sticky: {\n    name: \"Sticky\",\n    selector: \"[data-te-sticky-init]\"\n  },\n  // advancedInits\n  chart: {\n    name: \"Chart\",\n    selector: \"[data-te-chart]\",\n    isToggler: !1,\n    advanced: HC\n  },\n  // togglers\n  button: {\n    name: \"Button\",\n    selector: \"[data-te-toggle='button']\",\n    isToggler: !0,\n    callback: $C\n  },\n  collapse: {\n    name: \"Collapse\",\n    selector: \"[data-te-collapse-init]\",\n    isToggler: !0,\n    callback: MC\n  },\n  dropdown: {\n    name: \"Dropdown\",\n    selector: \"[data-te-dropdown-toggle-ref]\",\n    isToggler: !0,\n    callback: SC\n  },\n  modal: {\n    name: \"Modal\",\n    selector: \"[data-te-toggle='modal']\",\n    isToggler: !0,\n    callback: LC\n  },\n  ripple: {\n    name: \"Ripple\",\n    selector: \"[data-te-ripple-init]\",\n    isToggler: !0,\n    callback: NC\n  },\n  offcanvas: {\n    name: \"Offcanvas\",\n    selector: \"[data-te-offcanvas-toggle]\",\n    isToggler: !0,\n    callback: DC\n  },\n  tab: {\n    name: \"Tab\",\n    selector: \"[data-te-toggle='tab'], [data-te-toggle='pill'], [data-te-toggle='list']\",\n    isToggler: !0,\n    callback: IC\n  },\n  tooltip: {\n    name: \"Tooltip\",\n    selector: \"[data-te-toggle='tooltip']\",\n    isToggler: !1,\n    callback: RC\n  },\n  popover: {\n    name: \"Popover\",\n    selector: \"[data-te-toggle='popover']\",\n    isToggler: !0,\n    callback: PC\n  },\n  lightbox: {\n    name: \"Lightbox\",\n    selector: \"[data-te-lightbox-init]\",\n    isToggler: !0,\n    callback: BC\n  },\n  touch: {\n    name: \"Touch\",\n    selector: \"[data-te-touch-init]\"\n  }\n}, WC = (s) => Oi[s.NAME] || null, FC = (s, t) => {\n  if (!s || !t.allowReinits && Go.isInited(s.NAME))\n    return;\n  Go.add(s.NAME);\n  const e = WC(s), i = (e == null ? void 0 : e.isToggler) || !1;\n  if (OC(s), e != null && e.advanced) {\n    e == null || e.advanced(s, e == null ? void 0 : e.selector);\n    return;\n  }\n  if (i) {\n    e == null || e.callback(s, e == null ? void 0 : e.selector);\n    return;\n  }\n  d.find(e == null ? void 0 : e.selector).forEach((n) => {\n    let o = s.getInstance(n);\n    o || (o = new s(n), e != null && e.onInit && o[e.onInit]());\n  });\n}, YC = (s, t) => {\n  s.forEach((e) => FC(e, t));\n}, jC = {\n  allowReinits: !1,\n  checkOtherImports: !1\n}, ZC = (s, t = {}) => {\n  t = { ...jC, ...t };\n  const e = Object.keys(Oi).map((i) => {\n    if (!!document.querySelector(Oi[i].selector)) {\n      const o = s[Oi[i].name];\n      return !o && !Go.isInited(i) && t.checkOtherImports && console.warn(\n        `Please import ${Oi[i].name} from \"tw-elements\" package and add it to a object parameter inside \"initTE\" function`\n      ), o;\n    }\n  });\n  YC(e, t);\n};\n\n//# sourceMappingURL=tw-elements.es.min.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90dy1lbGVtZW50cy9kaXN0L2pzL3R3LWVsZW1lbnRzLmVzLm1pbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEY7QUFDNUY7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDBEQUEwRDtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUMsdUVBQXVFLEVBQUUsTUFBTTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELGdCQUFnQjtBQUN0RTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsUUFBUSw0Q0FBNEM7QUFDcEQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCLFlBQVksRUFBRSxtQkFBbUIsRUFBRSx1QkFBdUIsRUFBRTtBQUN2RjtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNELFVBQVUsWUFBWTtBQUN0QjtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLEVBQUUsSUFBSSxLQUFLO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVksS0FBSyxpQkFBaUI7QUFDakQsNkJBQTZCLEtBQUs7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDJCQUEyQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBLE9BQU8sSUFBSTtBQUNYO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDhDQUE4QztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDJDQUEyQztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixZQUFZO0FBQ3ZDO0FBQ0EseUJBQXlCLFlBQVk7QUFDckM7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsc0NBQXNDO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyx5RUFBeUUscUNBQXFDO0FBQ2pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyw0Q0FBNEM7QUFDL0M7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsMEJBQTBCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSCw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUssMEdBQTBHLGNBQWM7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU8sV0FBVyxRQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsd0NBQXdDO0FBQzNDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUdBQXFHO0FBQ3JHO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLHdNQUF3TTtBQUMzTTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrSEFBK0gsR0FBRztBQUNsSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsY0FBYztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixHQUFHO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLHdCQUF3QixFQUFFLDBFQUEwRSxFQUFFO0FBQ3RHO0FBQ0E7QUFDQSxvRkFBb0YsRUFBRTtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxHQUFHO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTix3RkFBd0YsR0FBRztBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxhQUFhO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxFQUFFO0FBQ2xEO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsR0FBRztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxjQUFjLEdBQUcsd0JBQXdCLEdBQUcsaUJBQWlCLEdBQUcsZUFBZSxHQUFHLGdCQUFnQixHQUFHLGlCQUFpQixHQUFHLHdCQUF3QixHQUFHLDBCQUEwQixHQUFHLDBCQUEwQixHQUFHLDRCQUE0QixHQUFHO0FBQzlPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSw0WEFBNFgsR0FBRztBQUMvWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDBDQUEwQztBQUN0RDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRixFQUFFLG9GQUFvRixFQUFFO0FBQ3pLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELEVBQUU7QUFDcEQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscU5BQXFOO0FBQ3JOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsR0FBRztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsQ0FBQztBQUNELGVBQWUsR0FBRztBQUNsQixtQkFBbUIsR0FBRztBQUN0QixlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLEdBQUc7QUFDcEIsdUJBQXVCLEdBQUc7QUFDMUIsaUJBQWlCLEdBQUc7QUFDcEIscUJBQXFCLEdBQUc7QUFDeEIsdUJBQXVCLEdBQUc7QUFDMUIsMkJBQTJCLEdBQUc7QUFDOUIsMkJBQTJCLEdBQUc7QUFDOUIsQ0FBQyxtR0FBbUcsR0FBRztBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0c7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHNCQUFzQjtBQUMvQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDRCQUE0QixHQUFHLHlCQUF5QjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw0QkFBNEI7QUFDNUM7QUFDQTtBQUNB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bUIsR0FBRyxzQkFBc0IsR0FBRyxhQUFhLEdBQUcsYUFBYSxHQUFHLGFBQWEsR0FBRztBQUN6ZjtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsRUFBRTtBQUNoQztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtB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TDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDLHNCQUFzQixrQkFBa0I7QUFDeEMseUJBQXlCLHNCQUFzQixJQUFJLFFBQVE7QUFDM0Q7QUFDQSxzQkFBc0IsaUJB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLEVBQUUseUJBQXlCLEVBQUU7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNE1BQTRNLEdBQUcsa0NBQWtDLEdBQUcsZUFBZSxHQUFHLHFCQUFxQixHQUFHLGdCQUFnQixHQUFHLEVBQUUsR0FBRyxxSkFBcUosR0FBRyxhQUFhLEdBQUc7QUFDOWQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxHQUFHLElBQUkscUJBQXFCO0FBQ3RDO0FBQ0EsVUFBVSxHQUFHLElBQUkscUJBQXFCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixzQ0FBc0Msd0JBQXdCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsS0FBSyxJQUFJLE1BQU0sRUFBRSxFQUFFO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHFCQUFxQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw4REFBOEQ7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxTQUFTO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxJQUFJLEdBQUcsSUFBSSxHQUFHLEVBQUU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxzQ0FBc0MsRUFBRTtBQUN4QztBQUNBO0FBQ0EsdUJBQXVCLDhEQUE4RDtBQUNyRjtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1EQUFtRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1EQUFtRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsNENBQTRDLEVBQUUsZ0JBQWdCO0FBQy9IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLDRDQUE0QyxFQUFFLGdCQUFnQjtBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsZ0JBQWdCO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxnQkFBZ0I7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHNCQUFzQixJQUFJLG9CQUFvQjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsc0JBQXNCLElBQUksb0JBQW9CO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCw0Q0FBNEMsRUFBRSxnQkFBZ0I7QUFDMUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRJQUE0SSxnQkFBZ0I7QUFDNUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBJQUEwSSxzQkFBc0IsSUFBSSxvQkFBb0I7QUFDeEw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLEdBQUc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsRUFBRTtBQUMvQixvQkFBb0IsY0FBYztBQUNsQyw2Q0FBNkMsMkJBQTJCLHlDQUF5QywyQkFBMkIsNkRBQTZELDJCQUEyQjtBQUNwTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHdCQUF3QixFQUFFLFdBQVcsb0JBQW9CO0FBQ3pELG9CQUFvQixzQkFBc0I7QUFDMUMsc0JBQXNCLHFCQUFxQjtBQUMzQyxtQkFBbUIsRUFBRSxXQUFXLGlCQUFpQix5QkFBeUIsWUFBWTtBQUN0RixzQkFBc0Isd0JBQXdCO0FBQzlDLDBCQUEwQiwyQkFBMkI7QUFDckQsNkJBQTZCLGlDQUFpQztBQUM5RCwrQ0FBK0MsMEJBQTBCO0FBQ3pFO0FBQ0EsNkNBQTZDLGdCQUFnQjtBQUM3RCwyQkFBMkIsaUNBQWlDO0FBQzVELDZDQUE2QywwQkFBMEI7QUFDdkU7QUFDQTtBQUNBLGNBQWMsd0JBQXdCLHdCQUF3QjtBQUM5RCxpREFBaUQsbUJBQW1CLHdGQUF3RixFQUFFO0FBQzlKLG1DQUFtQyxtQkFBbUIsd0ZBQXdGLEVBQUU7QUFDaEo7QUFDQTtBQUNBO0FBQ0EsUUFBUSxxQkFBcUIsRUFBRSxXQUFXLHlCQUF5QjtBQUNuRSwwQkFBMEIsa0JBQWtCO0FBQzVDLDZCQUE2QixzQkFBc0I7QUFDbkQsNEJBQTRCLHdCQUF3QjtBQUNwRCw4QkFBOEIsMEJBQTBCO0FBQ3hEO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRSxXQUFXLDBCQUEwQjtBQUN0RCxvQkFBb0IsbUJBQW1CO0FBQ3ZDLFVBQVUsb0NBQW9DLHlCQUF5Qiw4REFBOEQsRUFBRTtBQUN2SSx1Q0FBdUMseUJBQXlCLCtEQUErRCxFQUFFO0FBQ2pJLHVDQUF1Qyx5QkFBeUIsK0RBQStELEVBQUU7QUFDakk7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLEVBQUUsV0FBVywwQkFBMEI7QUFDaEUsc0JBQXNCLDRCQUE0QjtBQUNsRCx3QkFBd0IsMkJBQTJCO0FBQ25ELHFCQUFxQixFQUFFLFdBQVcsdUJBQXVCO0FBQ3pEO0FBQ0Esd0JBQXdCLDhCQUE4QjtBQUN0RCw0QkFBNEIsMkJBQTJCO0FBQ3ZELCtCQUErQiw4QkFBOEI7QUFDN0QsaUNBQWlDLHlCQUF5QjtBQUMxRCxtQ0FBbUMsMEJBQTBCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsZ0NBQWdDO0FBQ2pGLGlDQUFpQywyQkFBMkI7QUFDNUQsbUNBQW1DLDBCQUEwQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0Msc0JBQXNCO0FBQ3JFLDZCQUE2QixpQ0FBaUM7QUFDOUQsK0JBQStCLHlCQUF5QjtBQUN4RCxpQ0FBaUMsMEJBQTBCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsZ0NBQWdDO0FBQy9FLCtCQUErQiwyQkFBMkI7QUFDMUQsaUNBQWlDLDBCQUEwQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix3QkFBd0IsOEJBQThCO0FBQ3RFLHFEQUFxRCx5QkFBeUIsd0ZBQXdGLEVBQUU7QUFDeEssdUNBQXVDLHlCQUF5Qix3RkFBd0YsRUFBRTtBQUMxSixxREFBcUQsK0JBQStCLCtEQUErRCxFQUFFO0FBQ3JKO0FBQ0EsZ0JBQWdCLHNCQUFzQiwrQkFBK0IsK0RBQStELEVBQUU7QUFDdEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELFVBQVUsYUFBYTtBQUN2QjtBQUNBLGdCQUFnQixFQUFFLHNDQUFzQyx5QkFBeUI7QUFDakYsTUFBTTtBQUNOO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsNkxBQTZMLEVBQUU7QUFDL0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0Esc0dBQXNHLFVBQVU7QUFDaEg7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0Q0FBNEMsV0FBVztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDLFdBQVcsb0NBQW9DO0FBQ2hELFVBQVUsa0JBQWtCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsWUFBWSxFQUFFLEdBQUcsYUFBYSxFQUFFLE1BQU07QUFDdEMsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixZQUFZLEdBQUcsZUFBZSxFQUFFLGFBQWE7QUFDbkUsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixZQUFZLEdBQUcsZUFBZSxFQUFFLGFBQWE7QUFDbkUsQ0FBQyxVQUFVLHVFQUF1RTtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUMsb0dBQW9HLEdBQUcsdUNBQXVDLEdBQUcsWUFBWSxHQUFHLGtDQUFrQyxHQUFHLEVBQUUsR0FBRyxrQkFBa0IsR0FBRyxFQUFFLEdBQUcsb0JBQW9CLEdBQUcsRUFBRSxHQUFHLGtCQUFrQixHQUFHLEVBQUUsR0FBRyxvQkFBb0IsR0FBRyxFQUFFLEdBQUcscUJBQXFCLEdBQUcsRUFBRSxHQUFHLG9CQUFvQixHQUFHLEVBQUUsR0FBRyxvQkFBb0IsR0FBRyxFQUFFLEdBQUcsbUJBQW1CLEdBQUcsRUFBRSxHQUFHLHFCQUFxQixHQUFHLEVBQUUsR0FBRyxZQUFZLEVBQUUsZ0JBQWdCLEVBQUUsZ0JBQWdCLEVBQUUsc0JBQXNCLEVBQUUscUJBQXFCLEVBQUUsdUJBQXVCLEVBQUUsMEJBQTBCLEVBQUUsa0JBQWtCLEVBQUUsaUJBQWlCLEVBQUUsa0JBQWtCLEVBQUUsZ0JBQWdCLEVBQUUsbUJBQW1CLEVBQUUscUJBQXFCLEVBQUUsNEJBQTRCLEVBQUUsOEJBQThCLEVBQUUsNkJBQTZCLEVBQUUsMkNBQTJDLEVBQUUsNEJBQTRCLEVBQUUsc0JBQXNCLEVBQUUsbUJBQW1CLEVBQUUsa0JBQWtCLEVBQUUsaUJBQWlCLEVBQUUsaUJBQWlCLEVBQUUsdUJBQXVCLEVBQUUsbUJBQW1CLEVBQUUseUJBQXlCLEVBQUUsZ0JBQWdCLEVBQUUsa0JBQWtCLEVBQUUsdUJBQXVCLEVBQUUscUJBQXFCLEVBQUUsd0JBQXdCLEVBQUUsc0JBQXNCLEVBQUUsOEJBQThCLEVBQUUsc0JBQXNCLEVBQUUsd0JBQXdCLEVBQUUsa0JBQWtCLEVBQUU7QUFDenhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHVDQUF1QyxFQUFFLEdBQUcsRUFBRTtBQUM5QztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCx5Q0FBeUMsZ0JBQWdCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsY0FBYyxlQUFlO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsaURBQWlELEdBQUc7QUFDcEQsWUFBWSx5QkFBeUI7QUFDckMsY0FBYywyREFBMkQ7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEdBQUcsR0FBRyxFQUFFO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0JBQXdCO0FBQzNDLHFCQUFxQix3QkFBd0I7QUFDN0MsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdxQ0FBZ3FDLGVBQWU7QUFDL3FDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnREFBZ0Q7QUFDNUQ7QUFDQTtBQUNBLGNBQWMsa0NBQWtDO0FBQ2hELDBDQUEwQyxFQUFFLEVBQUUsVUFBVSxHQUFHLEVBQUUsb0NBQW9DLEdBQUcsRUFBRSxFQUFFLGdDQUFnQyxFQUFFO0FBQzFJLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDBCQUEwQixtQkFBbUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG1CQUFtQjtBQUM3QztBQUNBO0FBQ0EsZUFBZTtBQUNmLHNDQUFzQyx3QkFBd0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixHQUFHLG1DQUFtQyxHQUFHLHVGQUF1RixHQUFHLGlDQUFpQyxHQUFHLGdDQUFnQyxHQUFHLGtDQUFrQyxHQUFHLGlDQUFpQyxHQUFHO0FBQ2xULFVBQVUsR0FBRztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZEQUE2RCxtQkFBbUIsbUNBQW1DO0FBQy9IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEdBQUc7QUFDZjtBQUNBLFlBQVksR0FBRztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsRUFBRSxnQ0FBZ0MsR0FBRztBQUNuRSxZQUFZLEVBQUU7QUFDZDtBQUNBO0FBQ0EsWUFBWSxFQUFFO0FBQ2Q7QUFDQTtBQUNBLFlBQVksR0FBRztBQUNmO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNEJBQTRCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx3QkFBd0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsR0FBRztBQUNqQjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsTUFBTTtBQUN4QyxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxNQUFNO0FBQ3hDLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxnQ0FBZ0MsRUFBRTtBQUNsQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxFQUFFO0FBQ2hCO0FBQ0EsZ0NBQWdDLEVBQUU7QUFDbEMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxFQUFFO0FBQ2hCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLEVBQUU7QUFDaEI7QUFDQTtBQUNBLGNBQWMsR0FBRztBQUNqQjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLGNBQWMsRUFBRTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlCQUF5QjtBQUNyQztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLEVBQUU7QUFDaEMsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixtQkFBbUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsbUJBQW1CO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxrQkFBa0IscUNBQXFDO0FBQ3ZEO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxrQkFBa0IsRUFBRTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsR0FBRyxHQUFHLEVBQUU7QUFDekI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixRQUFRO0FBQ2xDLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxHQUFHLE1BQU0sR0FBRztBQUN0QjtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQyxzQkFBc0IsR0FBRyxvQkFBb0IsR0FBRyx3TkFBd04sR0FBRyxzQkFBc0IsR0FBRztBQUNwUztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxHQUFHLE1BQU0sR0FBRyxNQUFNLEdBQUc7QUFDL0IsU0FBUyxXQUFXO0FBQ3BCLGdCQUFnQiwrQkFBK0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLEdBQUc7QUFDYjtBQUNBLGNBQWMseUJBQXlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLGFBQWEsR0FBRyxHQUFHLEVBQUU7QUFDckIsa0JBQWtCLHVCQUF1QixHQUFHLDBCQUEwQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGlFQUFpRSxHQUFHLDRCQUE0QixHQUFHLEVBQUUsY0FBYztBQUM1SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsR0FBRztBQUNiLFNBQVMsb0JBQW9CO0FBQzdCO0FBQ0EsY0FBYyxHQUFHO0FBQ2pCO0FBQ0E7QUFDQSxjQUFjLEdBQUc7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixXQUFXO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLGNBQWMsRUFBRTtBQUNoQjtBQUNBO0FBQ0EsY0FBYyxFQUFFO0FBQ2hCO0FBQ0E7QUFDQSxjQUFjLEdBQUc7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG9DQUFvQyxHQUFHO0FBQ2xEO0FBQ0E7QUFDQSxrQkFBa0IsRUFBRTtBQUNwQjtBQUNBO0FBQ0Esa0JBQWtCLEVBQUU7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGtCQUFrQixHQUFHO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDhCQUE4QjtBQUNoRTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsNEJBQTRCO0FBQzlELFdBQVc7QUFDWCxrQ0FBa0Msa0NBQWtDO0FBQ3BFO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0EsZ0JBQWdCLEdBQUc7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsRUFBRTtBQUNaO0FBQ0EsVUFBVSxHQUFHO0FBQ2I7QUFDQSxVQUFVLEVBQUU7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsRUFBRTtBQUNaO0FBQ0EsVUFBVSxHQUFHO0FBQ2I7QUFDQSxVQUFVLEVBQUU7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsV0FBVztBQUNwQixjQUFjLHlCQUF5QjtBQUN2QyxnQkFBZ0IsZ0RBQWdEO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLEVBQUU7QUFDaEI7QUFDQSxjQUFjLEVBQUU7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx5QkFBeUI7QUFDbkMsWUFBWSxnREFBZ0Q7QUFDNUQ7QUFDQTtBQUNBLFVBQVUsR0FBRztBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLEdBQUc7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQixPQUFPLDhEQUE4RDtBQUMxRyxjQUFjLEVBQUU7QUFDaEI7QUFDQTtBQUNBLGNBQWMsRUFBRTtBQUNoQjtBQUNBO0FBQ0EsY0FBYyxHQUFHO0FBQ2pCO0FBQ0E7QUFDQSxjQUFjLEVBQUU7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixHQUFHO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELHdCQUF3QjtBQUNsRjtBQUNBO0FBQ0Esa0JBQWtCLDBCQUEwQjtBQUM1QztBQUNBO0FBQ0Esb0NBQW9DLEdBQUc7QUFDdkMsYUFBYTtBQUNiO0FBQ0EsK0RBQStELEdBQUc7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixFQUFFO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix1QkFBdUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxzQkFBc0IsdUJBQXVCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsRUFBRTtBQUNaO0FBQ0E7QUFDQSxVQUFVLEdBQUc7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTCw0QkFBNEIsRUFBRTtBQUM5QixLQUFLLDREQUE0RCxFQUFFLHNMQUFzTCxFQUFFO0FBQzNQO0FBQ0E7QUFDQSxVQUFVLHlCQUF5QjtBQUNuQyxZQUFZLDhEQUE4RDtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsU0FBUyxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxHQUFHO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHdCQUF3QixFQUFFO0FBQzFCO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsWUFBWSxHQUFHO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsWUFBWSxHQUFHO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxHQUFHO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9EQUFvRDtBQUNoRSw0QkFBNEIsV0FBVztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxpQkFBaUI7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEdBQUc7QUFDZjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxFQUFFLHdDQUF3QyxjQUFjO0FBQy9GO0FBQ0E7QUFDQTtBQUNBLDRIQUE0SCxlQUFlO0FBQzNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxnQkFBZ0I7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsbUNBQW1DLFVBQVU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1SkFBdUosd0NBQXdDLEVBQUUsd0NBQXdDO0FBQ3pPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrSEFBa0gsa0JBQWtCLG1DQUFtQyxpQkFBaUI7QUFDeEw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsVUFBVSxFQUFFLEtBQUs7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix1QkFBdUIsSUFBSSxJQUFJLGlCQUFpQixnQ0FBZ0MsTUFBTSxnQ0FBZ0M7QUFDaEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsU0FBUztBQUN4RTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFFBQVE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sUUFBUSx1UEFBdUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbVRBQTJDO0FBQzVEO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixxQkFBcUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsY0FBYyxXQUFXO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLG9JQUFvSTtBQUNwSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELEVBQUU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLFNBQVM7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLFNBQVMsV0FBVztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakM7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsY0FBYztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZ0NBQWdDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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R0FBRyxnQ0FBZ0MsR0FBRyxnQ0FBZ0MsR0FBRyx3QkFBd0IsR0FBRywyQkFBMkIsR0FBRyxxQkFBcUIsR0FBRyx1Q0FBdUMsR0FBRyxpQkFBaUIsR0FBRyxtQkFBbUIsR0FBRyxpQkFBaUIsR0FBRztBQUN0akI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxFQUFFO0FBQ3BEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsOEdBQThHLEdBQUc7QUFDakg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtCQUFrQixHQUFHLGtCQUFrQixHQUFHLGdCQUFnQixHQUFHLG1CQUFtQixHQUFHLGtCQUFrQixHQUFHLG9CQUFvQixHQUFHO0FBQ2hJO0FBQ0E7QUFDQSxvTkFBb047QUFDcE47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELEdBQUcsaUJBQWlCLEdBQUcsa0JBQWtCLEdBQUc7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdPQUF3TyxpQkFBaUI7QUFDelA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFVBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsR0FBRztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsR0FBRztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsR0FBRztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELG9CQUFvQjtBQUN4RTtBQUNBO0FBQ0Esa0RBQWtELG1CQUFtQjtBQUNyRSxrQkFBa0Isc0JBQXNCO0FBQ3hDLFFBQVEsdURBQXVELG1CQUFtQixJQUFJLHFDQUFxQztBQUMzSCxxQkFBcUIsMEJBQTBCLElBQUksc0JBQXNCO0FBQ3pFO0FBQ0Esb0JBQW9CLDRCQUE0QjtBQUNoRCxRQUFRLCtJQUErSSwwQkFBMEI7QUFDakwsaUJBQWlCLHdCQUF3QixJQUFJLHlCQUF5QjtBQUN0RTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0MsZUFBZSx5QkFBeUIsSUFBSSxtREFBbUQ7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFdBQVcsb0JBQW9CO0FBQy9CO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHNCQUFzQjtBQUMxRTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsc0JBQXNCO0FBQzNFO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELEVBQUU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxHQUFHLGtDQUFrQyxHQUFHLEVBQUUsR0FBRywyQ0FBMkMsSUFBSTtBQUNoSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qiw0SEFBNEgsd0NBQXdDO0FBQ3BLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxHQUFHO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixXQUFXO0FBQ3JDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsV0FBVztBQUNyQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxzQkFBc0I7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msc0JBQXNCLG9DQUFvQyw2QkFBNkIsdUNBQXVDLDRCQUE0QixpQ0FBaUMsd0JBQXdCLHVFQUF1RSx3QkFBd0IscUJBQXFCLHlCQUF5QixxQkFBcUIsdUJBQXVCO0FBQ3BiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsNkJBQTZCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MscUJBQXFCLHFCQUFxQixzQkFBc0IscUJBQXFCLDZCQUE2QjtBQUNsSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsNkJBQTZCO0FBQ3RDO0FBQ0E7QUFDQSwrREFBK0Qsc0JBQXNCO0FBQ3JGO0FBQ0EsU0FBUyw2QkFBNkI7QUFDdEMsNEhBQTRILHNCQUFzQjtBQUNsSjtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsNkJBQTZCLHFCQUFxQixzQkFBc0I7QUFDckg7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIseUJBQXlCLHFCQUFxQixrQkFBa0I7QUFDM0YsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCO0FBQ0EsS0FBSyx1SkFBdUosdUJBQXVCLGlCQUFpQixZQUFZLDZIQUE2SCxlQUFlO0FBQzVWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx3SEFBd0gsMkNBQTJDLHlIQUF5SCx5Q0FBeUMsa0ZBQWtGLHlCQUF5QixpRUFBaUUsMkNBQTJDLG9FQUFvRSwwQkFBMEIsZ0VBQWdFLHlDQUF5QztBQUNudUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsK0RBQStELG1DQUFtQztBQUNsRztBQUNBO0FBQ0EsS0FBSyxpQ0FBaUMsRUFBRTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHFCQUFxQixJQUFJLG9CQUFvQjtBQUNuRixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksR0FBRztBQUNmO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDRCQUE0QixZQUFZO0FBQ3hDO0FBQ0E7QUFDQSw0QkFBNEIsWUFBWTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDRDQUE0Qyx1QkFBdUI7QUFDbkUsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU8sd0NBQXdDLGFBQWE7QUFDNUQ7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0JBQWdCO0FBQ25DLGtCQUFrQixnQkFBZ0I7QUFDbEMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRyxTQUFTLGdCQUFnQixLQUFLO0FBQ3BJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ1BBQWdQLGdCQUFnQixvQ0FBb0MsZ0JBQWdCO0FBQ3BUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxvQ0FBb0MsWUFBWSxxQ0FBcUMsWUFBWSxzQ0FBc0MsWUFBWTtBQUNuSjtBQUNBO0FBQ0Esb0NBQW9DLFlBQVkscUNBQXFDLFlBQVksc0NBQXNDLFlBQVk7QUFDbko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFdBQVc7QUFDckMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGlCQUFpQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsaUNBQWlDLG9CQUFvQjtBQUNyRCxLQUFLO0FBQ0w7QUFDQTtBQUNBLGdDQUFnQyxFQUFFO0FBQ2xDLGtDQUFrQyxFQUFFO0FBQ3BDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxFQUFFO0FBQ3BEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxRQUFRO0FBQ3pELG1EQUFtRCxRQUFRO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxrRUFBa0UsR0FBRztBQUNyRSw2REFBNkQsT0FBTztBQUNwRSw4REFBOEQsT0FBTztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsSUFBSSxVQUFVLElBQUksVUFBVSxFQUFFO0FBQ3JEO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0RBQW9ELEdBQUcsc1FBQXNRLEdBQUcsbURBQW1ELEdBQUcscUJBQXFCLEdBQUcsZ0JBQWdCLEdBQUcsa0JBQWtCLEdBQUcsa0JBQWtCLEdBQUc7QUFDNWM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssZ0dBQWdHLHNCQUFzQjtBQUMzSDtBQUNBLEtBQUssbUhBQW1ILGdCQUFnQjtBQUN4STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFdBQVc7QUFDekI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLHdDQUF3QztBQUMvRztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLCtCQUErQixHQUFHO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsR0FBRztBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1EQUFtRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsdUJBQXVCLDBEQUEwRDtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxzQ0FBc0MsMkJBQTJCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsR0FBRztBQUN2RCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxHQUFHO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1JQUFtSSxFQUFFLEVBQUUsRUFBRTtBQUN6STtBQUNBO0FBQ0EsaUpBQWlKLEVBQUU7QUFDbko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9JQUFvSSxFQUFFO0FBQ3RJLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGNBQWMsV0FBVztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsRUFBRTtBQUNwRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZLElBQUksWUFBWTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDRCQUE0QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDRCQUE0QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw0QkFBNEI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw0QkFBNEI7QUFDN0MsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVCQUF1QjtBQUNuQztBQUNBLHFDQUFxQyxtQkFBbUIsa0NBQWtDLFVBQVU7QUFDcEcsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLEVBQUUsS0FBSyxVQUFVLHVDQUF1Qyx3QkFBd0I7QUFDdkg7QUFDQTtBQUNBO0FBQ0EsNEhBQTRILGVBQWU7QUFDM0k7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLEdBQUcsZ0JBQWdCLEdBQUcsY0FBYyxHQUFHO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUdBQXFHLFVBQVU7QUFDL0c7QUFDQTtBQUNBO0FBQ0EsWUFBWSw2QkFBNkIsdU5BQXVOLGFBQWE7QUFDN1E7QUFDQTtBQUNBLGtDQUFrQyxHQUFHLEVBQUUsRUFBRSxLQUFLLFVBQVU7QUFDeEQ7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsMEVBQTBFLEdBQUcsRUFBRSxFQUFFO0FBQ2pGO0FBQ0E7QUFDQSxLQUFLLHdEQUF3RCxVQUFVO0FBQ3ZFO0FBQ0E7QUFDQSxrSUFBa0ksVUFBVTtBQUM1STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixHQUFHLGNBQWMsR0FBRyxnQkFBZ0IsR0FBRztBQUNuRTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFlBQVksNEJBQTRCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGFBQWEsNkJBQTZCLG9DQUFvQztBQUMxRjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixHQUFHLGNBQWMsR0FBRztBQUNqRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNIQUFzSCxpQ0FBaUMsVUFBVTtBQUNqSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHVDQUF1QztBQUNyRDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxpQ0FBaUMsMEJBQTBCO0FBQ2hFO0FBQ0E7QUFDQSxrRUFBa0UsaUNBQWlDLFVBQVU7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsR0FBRztBQUNsQztBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxFQUFFO0FBQ3BEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLEdBQUcsWUFBWSxHQUFHO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxxQkFBcUIsR0FBRyxvQkFBb0IsR0FBRyx1QkFBdUIsR0FBRztBQUMxRTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELG1CQUFtQixFQUFFLFdBQVc7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELEVBQUU7QUFDcEQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw0QkFBNEI7QUFDaEQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsRUFBRTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxFQUFFO0FBQ3BEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHNEQUFzRCxHQUFHO0FBQ3pEO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQyxjQUFjLEdBQUc7QUFDbEI7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsRUFBRTtBQUNwRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxHQUFHO0FBQzNDO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztB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O0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDLGlCQUFpQjtBQUNsQixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsWUFBWTtBQUNyQztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUF3Q0U7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHctZWxlbWVudHMvZGlzdC9qcy90dy1lbGVtZW50cy5lcy5taW4uanM/OTI0OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiogVGFpbHdpbmQgRWxlbWVudHMgMS4wLjBcbiogXG4qIFRhaWx3aW5kIEVsZW1lbnRzIGlzIGFuIG9wZW4tc291cmNlIFVJIGtpdCBvZiBhZHZhbmNlZCBjb21wb25lbnRzIGZvciBUYWlsd2luZENTUy5cbiogQ29weXJpZ2h0IMKpIDIwMjMgTURCb290c3RyYXAuY29tXG4qIFxuKiBVbmxlc3MgYSBjdXN0b20sIGluZGl2aWR1YWxseSBhc3NpZ25lZCBsaWNlbnNlIGhhcyBiZWVuIGdyYW50ZWQsIHRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEFmZmVybyBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuKiBJbiBhZGRpdGlvbiwgYSBjdXN0b20gbGljZW5zZSBtYXkgYmUgYXZhaWxhYmxlIHVwb24gcmVxdWVzdCwgc3ViamVjdCB0byB0aGUgdGVybXMgYW5kIGNvbmRpdGlvbnMgb2YgdGhhdCBsaWNlbnNlLiBQbGVhc2UgY29udGFjdCB0YWlsd2luZEBtZGJvb3RzdHJhcC5jb20gZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gb2J0YWluaW5nIGEgY3VzdG9tIGxpY2Vuc2UuXG4qIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEFmZmVybyBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4qIFxuKi9cbnZhciBIaCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBWaCA9IChzLCB0LCBlKSA9PiB0IGluIHMgPyBIaChzLCB0LCB7IGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAsIHZhbHVlOiBlIH0pIDogc1t0XSA9IGU7XG52YXIgeXQgPSAocywgdCwgZSkgPT4gKFZoKHMsIHR5cGVvZiB0ICE9IFwic3ltYm9sXCIgPyB0ICsgXCJcIiA6IHQsIGUpLCBlKTtcbmNvbnN0IFRuID0gKCgpID0+IHtcbiAgY29uc3QgcyA9IHt9O1xuICBsZXQgdCA9IDE7XG4gIHJldHVybiB7XG4gICAgc2V0KGUsIGksIG4pIHtcbiAgICAgIHR5cGVvZiBlW2ldID4gXCJ1XCIgJiYgKGVbaV0gPSB7XG4gICAgICAgIGtleTogaSxcbiAgICAgICAgaWQ6IHRcbiAgICAgIH0sIHQrKyksIHNbZVtpXS5pZF0gPSBuO1xuICAgIH0sXG4gICAgZ2V0KGUsIGkpIHtcbiAgICAgIGlmICghZSB8fCB0eXBlb2YgZVtpXSA+IFwidVwiKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGNvbnN0IG4gPSBlW2ldO1xuICAgICAgcmV0dXJuIG4ua2V5ID09PSBpID8gc1tuLmlkXSA6IG51bGw7XG4gICAgfSxcbiAgICBkZWxldGUoZSwgaSkge1xuICAgICAgaWYgKHR5cGVvZiBlW2ldID4gXCJ1XCIpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IG4gPSBlW2ldO1xuICAgICAgbi5rZXkgPT09IGkgJiYgKGRlbGV0ZSBzW24uaWRdLCBkZWxldGUgZVtpXSk7XG4gICAgfVxuICB9O1xufSkoKSwgeSA9IHtcbiAgc2V0RGF0YShzLCB0LCBlKSB7XG4gICAgVG4uc2V0KHMsIHQsIGUpO1xuICB9LFxuICBnZXREYXRhKHMsIHQpIHtcbiAgICByZXR1cm4gVG4uZ2V0KHMsIHQpO1xuICB9LFxuICByZW1vdmVEYXRhKHMsIHQpIHtcbiAgICBUbi5kZWxldGUocywgdCk7XG4gIH1cbn0sIFdoID0gMWU2LCBGaCA9IDFlMywgeG8gPSBcInRyYW5zaXRpb25lbmRcIiwgWWggPSAocykgPT4gcyA9PSBudWxsID8gYCR7c31gIDoge30udG9TdHJpbmcuY2FsbChzKS5tYXRjaCgvXFxzKFthLXpdKykvaSlbMV0udG9Mb3dlckNhc2UoKSwgcnQgPSAocykgPT4ge1xuICBkb1xuICAgIHMgKz0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogV2gpO1xuICB3aGlsZSAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQocykpO1xuICByZXR1cm4gcztcbn0sIFVsID0gKHMpID0+IHtcbiAgbGV0IHQgPSBzLmdldEF0dHJpYnV0ZShcImRhdGEtdGUtdGFyZ2V0XCIpO1xuICBpZiAoIXQgfHwgdCA9PT0gXCIjXCIpIHtcbiAgICBsZXQgZSA9IHMuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKTtcbiAgICBpZiAoIWUgfHwgIWUuaW5jbHVkZXMoXCIjXCIpICYmICFlLnN0YXJ0c1dpdGgoXCIuXCIpKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgZS5pbmNsdWRlcyhcIiNcIikgJiYgIWUuc3RhcnRzV2l0aChcIiNcIikgJiYgKGUgPSBgIyR7ZS5zcGxpdChcIiNcIilbMV19YCksIHQgPSBlICYmIGUgIT09IFwiI1wiID8gZS50cmltKCkgOiBudWxsO1xuICB9XG4gIHJldHVybiB0O1xufSwgcW8gPSAocykgPT4ge1xuICBjb25zdCB0ID0gVWwocyk7XG4gIHJldHVybiB0ICYmIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodCkgPyB0IDogbnVsbDtcbn0sIEp0ID0gKHMpID0+IHtcbiAgY29uc3QgdCA9IFVsKHMpO1xuICByZXR1cm4gdCA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodCkgOiBudWxsO1xufSwgamggPSAocykgPT4ge1xuICBpZiAoIXMpXG4gICAgcmV0dXJuIDA7XG4gIGxldCB7IHRyYW5zaXRpb25EdXJhdGlvbjogdCwgdHJhbnNpdGlvbkRlbGF5OiBlIH0gPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShzKTtcbiAgY29uc3QgaSA9IE51bWJlci5wYXJzZUZsb2F0KHQpLCBuID0gTnVtYmVyLnBhcnNlRmxvYXQoZSk7XG4gIHJldHVybiAhaSAmJiAhbiA/IDAgOiAodCA9IHQuc3BsaXQoXCIsXCIpWzBdLCBlID0gZS5zcGxpdChcIixcIilbMF0sIChOdW1iZXIucGFyc2VGbG9hdCh0KSArIE51bWJlci5wYXJzZUZsb2F0KGUpKSAqIEZoKTtcbn0sIFhsID0gKHMpID0+IHtcbiAgcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCh4bykpO1xufSwgamUgPSAocykgPT4gIXMgfHwgdHlwZW9mIHMgIT0gXCJvYmplY3RcIiA/ICExIDogKHR5cGVvZiBzLmpxdWVyeSA8IFwidVwiICYmIChzID0gc1swXSksIHR5cGVvZiBzLm5vZGVUeXBlIDwgXCJ1XCIpLCB0ZSA9IChzKSA9PiBqZShzKSA/IHMuanF1ZXJ5ID8gc1swXSA6IHMgOiB0eXBlb2YgcyA9PSBcInN0cmluZ1wiICYmIHMubGVuZ3RoID4gMCA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IocykgOiBudWxsLCBEID0gKHMsIHQsIGUpID0+IHtcbiAgT2JqZWN0LmtleXMoZSkuZm9yRWFjaCgoaSkgPT4ge1xuICAgIGNvbnN0IG4gPSBlW2ldLCBvID0gdFtpXSwgciA9IG8gJiYgamUobykgPyBcImVsZW1lbnRcIiA6IFloKG8pO1xuICAgIGlmICghbmV3IFJlZ0V4cChuKS50ZXN0KHIpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgJHtzLnRvVXBwZXJDYXNlKCl9OiBPcHRpb24gXCIke2l9XCIgcHJvdmlkZWQgdHlwZSBcIiR7cn1cIiBidXQgZXhwZWN0ZWQgdHlwZSBcIiR7bn1cIi5gXG4gICAgICApO1xuICB9KTtcbn0sIE50ID0gKHMpID0+IHtcbiAgaWYgKCFzIHx8IHMuZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuICExO1xuICBpZiAocy5zdHlsZSAmJiBzLnBhcmVudE5vZGUgJiYgcy5wYXJlbnROb2RlLnN0eWxlKSB7XG4gICAgY29uc3QgdCA9IGdldENvbXB1dGVkU3R5bGUocyksIGUgPSBnZXRDb21wdXRlZFN0eWxlKHMucGFyZW50Tm9kZSk7XG4gICAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUocykuZ2V0UHJvcGVydHlWYWx1ZShcInZpc2liaWxpdHlcIikgPT09IFwidmlzaWJsZVwiIHx8IHQuZGlzcGxheSAhPT0gXCJub25lXCIgJiYgZS5kaXNwbGF5ICE9PSBcIm5vbmVcIiAmJiB0LnZpc2liaWxpdHkgIT09IFwiaGlkZGVuXCI7XG4gIH1cbiAgcmV0dXJuICExO1xufSwgZ2UgPSAocykgPT4gIXMgfHwgcy5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUgfHwgcy5jbGFzc0xpc3QuY29udGFpbnMoXCJkaXNhYmxlZFwiKSA/ICEwIDogdHlwZW9mIHMuZGlzYWJsZWQgPCBcInVcIiA/IHMuZGlzYWJsZWQgOiBzLmhhc0F0dHJpYnV0ZShcImRpc2FibGVkXCIpICYmIHMuZ2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIikgIT09IFwiZmFsc2VcIiwgR2wgPSAocykgPT4ge1xuICBpZiAoIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hdHRhY2hTaGFkb3cpXG4gICAgcmV0dXJuIG51bGw7XG4gIGlmICh0eXBlb2Ygcy5nZXRSb290Tm9kZSA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBjb25zdCB0ID0gcy5nZXRSb290Tm9kZSgpO1xuICAgIHJldHVybiB0IGluc3RhbmNlb2YgU2hhZG93Um9vdCA/IHQgOiBudWxsO1xuICB9XG4gIHJldHVybiBzIGluc3RhbmNlb2YgU2hhZG93Um9vdCA/IHMgOiBzLnBhcmVudE5vZGUgPyBHbChzLnBhcmVudE5vZGUpIDogbnVsbDtcbn0sIHRuID0gKCkgPT4gZnVuY3Rpb24oKSB7XG59LCBKZSA9IChzKSA9PiB7XG4gIHMub2Zmc2V0SGVpZ2h0O1xufSwgcWwgPSAoKSA9PiB7XG4gIGNvbnN0IHsgalF1ZXJ5OiBzIH0gPSB3aW5kb3c7XG4gIHJldHVybiBzICYmICFkb2N1bWVudC5ib2R5Lmhhc0F0dHJpYnV0ZShcImRhdGEtdGUtbm8tanF1ZXJ5XCIpID8gcyA6IG51bGw7XG59LCBFbiA9IFtdLCBabCA9IChzKSA9PiB7XG4gIGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwibG9hZGluZ1wiID8gKEVuLmxlbmd0aCB8fCBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCAoKSA9PiB7XG4gICAgRW4uZm9yRWFjaCgodCkgPT4gdCgpKTtcbiAgfSksIEVuLnB1c2gocykpIDogcygpO1xufSwgRiA9ICgpID0+IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kaXIgPT09IFwicnRsXCIsIEtoID0gKHMpID0+IEFycmF5LmZyb20ocyksICQgPSAocykgPT4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChzKSwgbWUgPSAocykgPT4ge1xuICB0eXBlb2YgcyA9PSBcImZ1bmN0aW9uXCIgJiYgcygpO1xufSwgUWwgPSAocywgdCwgZSA9ICEwKSA9PiB7XG4gIGlmICghZSkge1xuICAgIG1lKHMpO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBpID0gNSwgbiA9IGpoKHQpICsgaTtcbiAgbGV0IG8gPSAhMTtcbiAgY29uc3QgciA9ICh7IHRhcmdldDogYSB9KSA9PiB7XG4gICAgYSA9PT0gdCAmJiAobyA9ICEwLCB0LnJlbW92ZUV2ZW50TGlzdGVuZXIoeG8sIHIpLCBtZShzKSk7XG4gIH07XG4gIHQuYWRkRXZlbnRMaXN0ZW5lcih4bywgciksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIG8gfHwgWGwodCk7XG4gIH0sIG4pO1xufSwgSmwgPSAocywgdCwgZSwgaSkgPT4ge1xuICBsZXQgbiA9IHMuaW5kZXhPZih0KTtcbiAgaWYgKG4gPT09IC0xKVxuICAgIHJldHVybiBzWyFlICYmIGkgPyBzLmxlbmd0aCAtIDEgOiAwXTtcbiAgY29uc3QgbyA9IHMubGVuZ3RoO1xuICByZXR1cm4gbiArPSBlID8gMSA6IC0xLCBpICYmIChuID0gKG4gKyBvKSAlIG8pLCBzW01hdGgubWF4KDAsIE1hdGgubWluKG4sIG8gLSAxKSldO1xufSwgemggPSAvW14uXSooPz1cXC4uKilcXC58LiovLCBVaCA9IC9cXC4uKi8sIFhoID0gLzo6XFxkKyQvLCBDbiA9IHt9O1xubGV0IHhyID0gMTtcbmNvbnN0IEdoID0ge1xuICBtb3VzZWVudGVyOiBcIm1vdXNlb3ZlclwiLFxuICBtb3VzZWxlYXZlOiBcIm1vdXNlb3V0XCJcbn0sIHFoID0gL14obW91c2VlbnRlcnxtb3VzZWxlYXZlKS9pLCB0YyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcbiAgXCJjbGlja1wiLFxuICBcImRibGNsaWNrXCIsXG4gIFwibW91c2V1cFwiLFxuICBcIm1vdXNlZG93blwiLFxuICBcImNvbnRleHRtZW51XCIsXG4gIFwibW91c2V3aGVlbFwiLFxuICBcIkRPTU1vdXNlU2Nyb2xsXCIsXG4gIFwibW91c2VvdmVyXCIsXG4gIFwibW91c2VvdXRcIixcbiAgXCJtb3VzZW1vdmVcIixcbiAgXCJzZWxlY3RzdGFydFwiLFxuICBcInNlbGVjdGVuZFwiLFxuICBcImtleWRvd25cIixcbiAgXCJrZXlwcmVzc1wiLFxuICBcImtleXVwXCIsXG4gIFwib3JpZW50YXRpb25jaGFuZ2VcIixcbiAgXCJ0b3VjaHN0YXJ0XCIsXG4gIFwidG91Y2htb3ZlXCIsXG4gIFwidG91Y2hlbmRcIixcbiAgXCJ0b3VjaGNhbmNlbFwiLFxuICBcInBvaW50ZXJkb3duXCIsXG4gIFwicG9pbnRlcm1vdmVcIixcbiAgXCJwb2ludGVydXBcIixcbiAgXCJwb2ludGVybGVhdmVcIixcbiAgXCJwb2ludGVyY2FuY2VsXCIsXG4gIFwiZ2VzdHVyZXN0YXJ0XCIsXG4gIFwiZ2VzdHVyZWNoYW5nZVwiLFxuICBcImdlc3R1cmVlbmRcIixcbiAgXCJmb2N1c1wiLFxuICBcImJsdXJcIixcbiAgXCJjaGFuZ2VcIixcbiAgXCJyZXNldFwiLFxuICBcInNlbGVjdFwiLFxuICBcInN1Ym1pdFwiLFxuICBcImZvY3VzaW5cIixcbiAgXCJmb2N1c291dFwiLFxuICBcImxvYWRcIixcbiAgXCJ1bmxvYWRcIixcbiAgXCJiZWZvcmV1bmxvYWRcIixcbiAgXCJyZXNpemVcIixcbiAgXCJtb3ZlXCIsXG4gIFwiRE9NQ29udGVudExvYWRlZFwiLFxuICBcInJlYWR5c3RhdGVjaGFuZ2VcIixcbiAgXCJlcnJvclwiLFxuICBcImFib3J0XCIsXG4gIFwic2Nyb2xsXCJcbl0pO1xuZnVuY3Rpb24gZWMocywgdCkge1xuICByZXR1cm4gdCAmJiBgJHt0fTo6JHt4cisrfWAgfHwgcy51aWRFdmVudCB8fCB4cisrO1xufVxuZnVuY3Rpb24gaWMocykge1xuICBjb25zdCB0ID0gZWMocyk7XG4gIHJldHVybiBzLnVpZEV2ZW50ID0gdCwgQ25bdF0gPSBDblt0XSB8fCB7fSwgQ25bdF07XG59XG5mdW5jdGlvbiBaaChzLCB0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBlKGkpIHtcbiAgICByZXR1cm4gaS5kZWxlZ2F0ZVRhcmdldCA9IHMsIGUub25lT2ZmICYmIGMub2ZmKHMsIGkudHlwZSwgdCksIHQuYXBwbHkocywgW2ldKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIFFoKHMsIHQsIGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGkobikge1xuICAgIGNvbnN0IG8gPSBzLnF1ZXJ5U2VsZWN0b3JBbGwodCk7XG4gICAgZm9yIChsZXQgeyB0YXJnZXQ6IHIgfSA9IG47IHIgJiYgciAhPT0gdGhpczsgciA9IHIucGFyZW50Tm9kZSlcbiAgICAgIGZvciAobGV0IGEgPSBvLmxlbmd0aDsgYS0tOyBcIlwiKVxuICAgICAgICBpZiAob1thXSA9PT0gcilcbiAgICAgICAgICByZXR1cm4gbi5kZWxlZ2F0ZVRhcmdldCA9IHIsIGkub25lT2ZmICYmIGMub2ZmKHMsIG4udHlwZSwgZSksIGUuYXBwbHkociwgW25dKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcbn1cbmZ1bmN0aW9uIHNjKHMsIHQsIGUgPSBudWxsKSB7XG4gIGNvbnN0IGkgPSBPYmplY3Qua2V5cyhzKTtcbiAgZm9yIChsZXQgbiA9IDAsIG8gPSBpLmxlbmd0aDsgbiA8IG87IG4rKykge1xuICAgIGNvbnN0IHIgPSBzW2lbbl1dO1xuICAgIGlmIChyLm9yaWdpbmFsSGFuZGxlciA9PT0gdCAmJiByLmRlbGVnYXRpb25TZWxlY3RvciA9PT0gZSlcbiAgICAgIHJldHVybiByO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gbmMocywgdCwgZSkge1xuICBjb25zdCBpID0gdHlwZW9mIHQgPT0gXCJzdHJpbmdcIiwgbiA9IGkgPyBlIDogdDtcbiAgbGV0IG8gPSBvYyhzKTtcbiAgcmV0dXJuIHRjLmhhcyhvKSB8fCAobyA9IHMpLCBbaSwgbiwgb107XG59XG5mdW5jdGlvbiBPcihzLCB0LCBlLCBpLCBuKSB7XG4gIGlmICh0eXBlb2YgdCAhPSBcInN0cmluZ1wiIHx8ICFzKVxuICAgIHJldHVybjtcbiAgaWYgKGUgfHwgKGUgPSBpLCBpID0gbnVsbCksIHFoLnRlc3QodCkpIHtcbiAgICBjb25zdCBnID0gKG0pID0+IGZ1bmN0aW9uKGIpIHtcbiAgICAgIGlmICghYi5yZWxhdGVkVGFyZ2V0IHx8IGIucmVsYXRlZFRhcmdldCAhPT0gYi5kZWxlZ2F0ZVRhcmdldCAmJiAhYi5kZWxlZ2F0ZVRhcmdldC5jb250YWlucyhiLnJlbGF0ZWRUYXJnZXQpKVxuICAgICAgICByZXR1cm4gbS5jYWxsKHRoaXMsIGIpO1xuICAgIH07XG4gICAgaSA/IGkgPSBnKGkpIDogZSA9IGcoZSk7XG4gIH1cbiAgY29uc3QgW28sIHIsIGFdID0gbmMoXG4gICAgdCxcbiAgICBlLFxuICAgIGlcbiAgKSwgbCA9IGljKHMpLCBwID0gbFthXSB8fCAobFthXSA9IHt9KSwgdSA9IHNjKFxuICAgIHAsXG4gICAgcixcbiAgICBvID8gZSA6IG51bGxcbiAgKTtcbiAgaWYgKHUpIHtcbiAgICB1Lm9uZU9mZiA9IHUub25lT2ZmICYmIG47XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IF8gPSBlYyhcbiAgICByLFxuICAgIHQucmVwbGFjZSh6aCwgXCJcIilcbiAgKSwgZiA9IG8gPyBRaChzLCBlLCBpKSA6IFpoKHMsIGUpO1xuICBmLmRlbGVnYXRpb25TZWxlY3RvciA9IG8gPyBlIDogbnVsbCwgZi5vcmlnaW5hbEhhbmRsZXIgPSByLCBmLm9uZU9mZiA9IG4sIGYudWlkRXZlbnQgPSBfLCBwW19dID0gZiwgcy5hZGRFdmVudExpc3RlbmVyKGEsIGYsIG8pO1xufVxuZnVuY3Rpb24gT28ocywgdCwgZSwgaSwgbikge1xuICBjb25zdCBvID0gc2ModFtlXSwgaSwgbik7XG4gIG8gJiYgKHMucmVtb3ZlRXZlbnRMaXN0ZW5lcihlLCBvLCAhIW4pLCBkZWxldGUgdFtlXVtvLnVpZEV2ZW50XSk7XG59XG5mdW5jdGlvbiBKaChzLCB0LCBlLCBpKSB7XG4gIGNvbnN0IG4gPSB0W2VdIHx8IHt9O1xuICBPYmplY3Qua2V5cyhuKS5mb3JFYWNoKChvKSA9PiB7XG4gICAgaWYgKG8uaW5jbHVkZXMoaSkpIHtcbiAgICAgIGNvbnN0IHIgPSBuW29dO1xuICAgICAgT28oXG4gICAgICAgIHMsXG4gICAgICAgIHQsXG4gICAgICAgIGUsXG4gICAgICAgIHIub3JpZ2luYWxIYW5kbGVyLFxuICAgICAgICByLmRlbGVnYXRpb25TZWxlY3RvclxuICAgICAgKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gb2Mocykge1xuICByZXR1cm4gcyA9IHMucmVwbGFjZShVaCwgXCJcIiksIEdoW3NdIHx8IHM7XG59XG5jb25zdCBjID0ge1xuICBvbihzLCB0LCBlLCBpKSB7XG4gICAgT3IocywgdCwgZSwgaSwgITEpO1xuICB9LFxuICBvbmUocywgdCwgZSwgaSkge1xuICAgIE9yKHMsIHQsIGUsIGksICEwKTtcbiAgfSxcbiAgb2ZmKHMsIHQsIGUsIGkpIHtcbiAgICBpZiAodHlwZW9mIHQgIT0gXCJzdHJpbmdcIiB8fCAhcylcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBbbiwgbywgcl0gPSBuYyhcbiAgICAgIHQsXG4gICAgICBlLFxuICAgICAgaVxuICAgICksIGEgPSByICE9PSB0LCBsID0gaWMocyksIHAgPSB0LnN0YXJ0c1dpdGgoXCIuXCIpO1xuICAgIGlmICh0eXBlb2YgbyA8IFwidVwiKSB7XG4gICAgICBpZiAoIWwgfHwgIWxbcl0pXG4gICAgICAgIHJldHVybjtcbiAgICAgIE9vKFxuICAgICAgICBzLFxuICAgICAgICBsLFxuICAgICAgICByLFxuICAgICAgICBvLFxuICAgICAgICBuID8gZSA6IG51bGxcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHAgJiYgT2JqZWN0LmtleXMobCkuZm9yRWFjaCgoXykgPT4ge1xuICAgICAgSmgoXG4gICAgICAgIHMsXG4gICAgICAgIGwsXG4gICAgICAgIF8sXG4gICAgICAgIHQuc2xpY2UoMSlcbiAgICAgICk7XG4gICAgfSk7XG4gICAgY29uc3QgdSA9IGxbcl0gfHwge307XG4gICAgT2JqZWN0LmtleXModSkuZm9yRWFjaCgoXykgPT4ge1xuICAgICAgY29uc3QgZiA9IF8ucmVwbGFjZShYaCwgXCJcIik7XG4gICAgICBpZiAoIWEgfHwgdC5pbmNsdWRlcyhmKSkge1xuICAgICAgICBjb25zdCBnID0gdVtfXTtcbiAgICAgICAgT28oXG4gICAgICAgICAgcyxcbiAgICAgICAgICBsLFxuICAgICAgICAgIHIsXG4gICAgICAgICAgZy5vcmlnaW5hbEhhbmRsZXIsXG4gICAgICAgICAgZy5kZWxlZ2F0aW9uU2VsZWN0b3JcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcbiAgdHJpZ2dlcihzLCB0LCBlKSB7XG4gICAgaWYgKHR5cGVvZiB0ICE9IFwic3RyaW5nXCIgfHwgIXMpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBpID0gcWwoKSwgbiA9IG9jKHQpLCBvID0gdCAhPT0gbiwgciA9IHRjLmhhcyhuKTtcbiAgICBsZXQgYSwgbCA9ICEwLCBwID0gITAsIHUgPSAhMSwgXyA9IG51bGw7XG4gICAgcmV0dXJuIG8gJiYgaSAmJiAoYSA9IGkuRXZlbnQodCwgZSksIGkocykudHJpZ2dlcihhKSwgbCA9ICFhLmlzUHJvcGFnYXRpb25TdG9wcGVkKCksIHAgPSAhYS5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpLCB1ID0gYS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSksIHIgPyAoXyA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiSFRNTEV2ZW50c1wiKSwgXy5pbml0RXZlbnQobiwgbCwgITApKSA6IF8gPSBuZXcgQ3VzdG9tRXZlbnQodCwge1xuICAgICAgYnViYmxlczogbCxcbiAgICAgIGNhbmNlbGFibGU6ICEwXG4gICAgfSksIHR5cGVvZiBlIDwgXCJ1XCIgJiYgT2JqZWN0LmtleXMoZSkuZm9yRWFjaCgoZikgPT4ge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF8sIGYsIHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBlW2ZdO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KSwgdSAmJiBfLnByZXZlbnREZWZhdWx0KCksIHAgJiYgcy5kaXNwYXRjaEV2ZW50KF8pLCBfLmRlZmF1bHRQcmV2ZW50ZWQgJiYgdHlwZW9mIGEgPCBcInVcIiAmJiBhLnByZXZlbnREZWZhdWx0KCksIF87XG4gIH1cbn0sIHJlID0ge1xuICBvbihzLCB0LCBlLCBpKSB7XG4gICAgY29uc3QgbiA9IHQuc3BsaXQoXCIgXCIpO1xuICAgIGZvciAobGV0IG8gPSAwOyBvIDwgbi5sZW5ndGg7IG8rKylcbiAgICAgIGMub24ocywgbltvXSwgZSwgaSk7XG4gIH0sXG4gIG9mZihzLCB0LCBlLCBpKSB7XG4gICAgY29uc3QgbiA9IHQuc3BsaXQoXCIgXCIpO1xuICAgIGZvciAobGV0IG8gPSAwOyBvIDwgbi5sZW5ndGg7IG8rKylcbiAgICAgIGMub2ZmKHMsIG5bb10sIGUsIGkpO1xuICB9XG59LCB0ZCA9IFwiNS4xLjNcIjtcbmNsYXNzIGd0IHtcbiAgY29uc3RydWN0b3IodCkge1xuICAgIHQgPSB0ZSh0KSwgdCAmJiAodGhpcy5fZWxlbWVudCA9IHQsIHkuc2V0RGF0YSh0aGlzLl9lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLkRBVEFfS0VZLCB0aGlzKSk7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB5LnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5EQVRBX0tFWSksIGMub2ZmKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuRVZFTlRfS0VZKSwgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcykuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgdGhpc1t0XSA9IG51bGw7XG4gICAgfSk7XG4gIH1cbiAgX3F1ZXVlQ2FsbGJhY2sodCwgZSwgaSA9ICEwKSB7XG4gICAgUWwodCwgZSwgaSk7XG4gIH1cbiAgLyoqIFN0YXRpYyAqL1xuICBzdGF0aWMgZ2V0SW5zdGFuY2UodCkge1xuICAgIHJldHVybiB5LmdldERhdGEodGUodCksIHRoaXMuREFUQV9LRVkpO1xuICB9XG4gIHN0YXRpYyBnZXRPckNyZWF0ZUluc3RhbmNlKHQsIGUgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKHQpIHx8IG5ldyB0aGlzKHQsIHR5cGVvZiBlID09IFwib2JqZWN0XCIgPyBlIDogbnVsbCk7XG4gIH1cbiAgc3RhdGljIGdldCBWRVJTSU9OKCkge1xuICAgIHJldHVybiB0ZDtcbiAgfVxuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ1lvdSBoYXZlIHRvIGltcGxlbWVudCB0aGUgc3RhdGljIG1ldGhvZCBcIk5BTUVcIiwgZm9yIGVhY2ggY29tcG9uZW50ISdcbiAgICApO1xuICB9XG4gIHN0YXRpYyBnZXQgREFUQV9LRVkoKSB7XG4gICAgcmV0dXJuIGB0ZS4ke3RoaXMuTkFNRX1gO1xuICB9XG4gIHN0YXRpYyBnZXQgRVZFTlRfS0VZKCkge1xuICAgIHJldHVybiBgLiR7dGhpcy5EQVRBX0tFWX1gO1xuICB9XG59XG5jb25zdCBlZCA9IFwiYnV0dG9uXCIsIGlkID0gXCJhY3RpdmVcIjtcbmNsYXNzIHJjIGV4dGVuZHMgZ3Qge1xuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gZWQ7XG4gIH1cbiAgLy8gUHVibGljXG4gIHRvZ2dsZSgpIHtcbiAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcbiAgICAgIFwiYXJpYS1wcmVzc2VkXCIsXG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC50b2dnbGUoaWQpXG4gICAgKTtcbiAgfVxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0KSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGUgPSByYy5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMpO1xuICAgICAgdCA9PT0gXCJ0b2dnbGVcIiAmJiBlW3RdKCk7XG4gICAgfSk7XG4gIH1cbn1cbnZhciBRID0gXCJ0b3BcIiwgZHQgPSBcImJvdHRvbVwiLCB1dCA9IFwicmlnaHRcIiwgSiA9IFwibGVmdFwiLCBIaSA9IFwiYXV0b1wiLCB0aSA9IFtRLCBkdCwgdXQsIEpdLCBUZSA9IFwic3RhcnRcIiwgS2UgPSBcImVuZFwiLCBhYyA9IFwiY2xpcHBpbmdQYXJlbnRzXCIsIFpvID0gXCJ2aWV3cG9ydFwiLCAkZSA9IFwicG9wcGVyXCIsIGxjID0gXCJyZWZlcmVuY2VcIiwgU28gPSAvKiBAX19QVVJFX18gKi8gdGkucmVkdWNlKGZ1bmN0aW9uKHMsIHQpIHtcbiAgcmV0dXJuIHMuY29uY2F0KFt0ICsgXCItXCIgKyBUZSwgdCArIFwiLVwiICsgS2VdKTtcbn0sIFtdKSwgUW8gPSAvKiBAX19QVVJFX18gKi8gW10uY29uY2F0KHRpLCBbSGldKS5yZWR1Y2UoZnVuY3Rpb24ocywgdCkge1xuICByZXR1cm4gcy5jb25jYXQoW3QsIHQgKyBcIi1cIiArIFRlLCB0ICsgXCItXCIgKyBLZV0pO1xufSwgW10pLCBjYyA9IFwiYmVmb3JlUmVhZFwiLCBoYyA9IFwicmVhZFwiLCBkYyA9IFwiYWZ0ZXJSZWFkXCIsIHVjID0gXCJiZWZvcmVNYWluXCIsIHBjID0gXCJtYWluXCIsIF9jID0gXCJhZnRlck1haW5cIiwgZmMgPSBcImJlZm9yZVdyaXRlXCIsIG1jID0gXCJ3cml0ZVwiLCBnYyA9IFwiYWZ0ZXJXcml0ZVwiLCBlbiA9IFtjYywgaGMsIGRjLCB1YywgcGMsIF9jLCBmYywgbWMsIGdjXTtcbmZ1bmN0aW9uIE10KHMpIHtcbiAgcmV0dXJuIHMgPyAocy5ub2RlTmFtZSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpIDogbnVsbDtcbn1cbmZ1bmN0aW9uIHB0KHMpIHtcbiAgaWYgKHMgPT0gbnVsbClcbiAgICByZXR1cm4gd2luZG93O1xuICBpZiAocy50b1N0cmluZygpICE9PSBcIltvYmplY3QgV2luZG93XVwiKSB7XG4gICAgdmFyIHQgPSBzLm93bmVyRG9jdW1lbnQ7XG4gICAgcmV0dXJuIHQgJiYgdC5kZWZhdWx0VmlldyB8fCB3aW5kb3c7XG4gIH1cbiAgcmV0dXJuIHM7XG59XG5mdW5jdGlvbiBFZShzKSB7XG4gIHZhciB0ID0gcHQocykuRWxlbWVudDtcbiAgcmV0dXJuIHMgaW5zdGFuY2VvZiB0IHx8IHMgaW5zdGFuY2VvZiBFbGVtZW50O1xufVxuZnVuY3Rpb24gaHQocykge1xuICB2YXIgdCA9IHB0KHMpLkhUTUxFbGVtZW50O1xuICByZXR1cm4gcyBpbnN0YW5jZW9mIHQgfHwgcyBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xufVxuZnVuY3Rpb24gSm8ocykge1xuICBpZiAodHlwZW9mIFNoYWRvd1Jvb3QgPiBcInVcIilcbiAgICByZXR1cm4gITE7XG4gIHZhciB0ID0gcHQocykuU2hhZG93Um9vdDtcbiAgcmV0dXJuIHMgaW5zdGFuY2VvZiB0IHx8IHMgaW5zdGFuY2VvZiBTaGFkb3dSb290O1xufVxuZnVuY3Rpb24gc2Qocykge1xuICB2YXIgdCA9IHMuc3RhdGU7XG4gIE9iamVjdC5rZXlzKHQuZWxlbWVudHMpLmZvckVhY2goZnVuY3Rpb24oZSkge1xuICAgIHZhciBpID0gdC5zdHlsZXNbZV0gfHwge30sIG4gPSB0LmF0dHJpYnV0ZXNbZV0gfHwge30sIG8gPSB0LmVsZW1lbnRzW2VdO1xuICAgICFodChvKSB8fCAhTXQobykgfHwgKE9iamVjdC5hc3NpZ24oby5zdHlsZSwgaSksIE9iamVjdC5rZXlzKG4pLmZvckVhY2goZnVuY3Rpb24ocikge1xuICAgICAgdmFyIGEgPSBuW3JdO1xuICAgICAgYSA9PT0gITEgPyBvLnJlbW92ZUF0dHJpYnV0ZShyKSA6IG8uc2V0QXR0cmlidXRlKHIsIGEgPT09ICEwID8gXCJcIiA6IGEpO1xuICAgIH0pKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBuZChzKSB7XG4gIHZhciB0ID0gcy5zdGF0ZSwgZSA9IHtcbiAgICBwb3BwZXI6IHtcbiAgICAgIHBvc2l0aW9uOiB0Lm9wdGlvbnMuc3RyYXRlZ3ksXG4gICAgICBsZWZ0OiBcIjBcIixcbiAgICAgIHRvcDogXCIwXCIsXG4gICAgICBtYXJnaW46IFwiMFwiXG4gICAgfSxcbiAgICBhcnJvdzoge1xuICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIlxuICAgIH0sXG4gICAgcmVmZXJlbmNlOiB7fVxuICB9O1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih0LmVsZW1lbnRzLnBvcHBlci5zdHlsZSwgZS5wb3BwZXIpLCB0LnN0eWxlcyA9IGUsIHQuZWxlbWVudHMuYXJyb3cgJiYgT2JqZWN0LmFzc2lnbih0LmVsZW1lbnRzLmFycm93LnN0eWxlLCBlLmFycm93KSwgZnVuY3Rpb24oKSB7XG4gICAgT2JqZWN0LmtleXModC5lbGVtZW50cykuZm9yRWFjaChmdW5jdGlvbihpKSB7XG4gICAgICB2YXIgbiA9IHQuZWxlbWVudHNbaV0sIG8gPSB0LmF0dHJpYnV0ZXNbaV0gfHwge30sIHIgPSBPYmplY3Qua2V5cyh0LnN0eWxlcy5oYXNPd25Qcm9wZXJ0eShpKSA/IHQuc3R5bGVzW2ldIDogZVtpXSksIGEgPSByLnJlZHVjZShmdW5jdGlvbihsLCBwKSB7XG4gICAgICAgIHJldHVybiBsW3BdID0gXCJcIiwgbDtcbiAgICAgIH0sIHt9KTtcbiAgICAgICFodChuKSB8fCAhTXQobikgfHwgKE9iamVjdC5hc3NpZ24obi5zdHlsZSwgYSksIE9iamVjdC5rZXlzKG8pLmZvckVhY2goZnVuY3Rpb24obCkge1xuICAgICAgICBuLnJlbW92ZUF0dHJpYnV0ZShsKTtcbiAgICAgIH0pKTtcbiAgICB9KTtcbiAgfTtcbn1cbmNvbnN0IHRyID0ge1xuICBuYW1lOiBcImFwcGx5U3R5bGVzXCIsXG4gIGVuYWJsZWQ6ICEwLFxuICBwaGFzZTogXCJ3cml0ZVwiLFxuICBmbjogc2QsXG4gIGVmZmVjdDogbmQsXG4gIHJlcXVpcmVzOiBbXCJjb21wdXRlU3R5bGVzXCJdXG59O1xuZnVuY3Rpb24gVHQocykge1xuICByZXR1cm4gcy5zcGxpdChcIi1cIilbMF07XG59XG52YXIgYmUgPSBNYXRoLm1heCwgc24gPSBNYXRoLm1pbiwgemUgPSBNYXRoLnJvdW5kO1xuZnVuY3Rpb24gSW8oKSB7XG4gIHZhciBzID0gbmF2aWdhdG9yLnVzZXJBZ2VudERhdGE7XG4gIHJldHVybiBzICE9IG51bGwgJiYgcy5icmFuZHMgJiYgQXJyYXkuaXNBcnJheShzLmJyYW5kcykgPyBzLmJyYW5kcy5tYXAoZnVuY3Rpb24odCkge1xuICAgIHJldHVybiB0LmJyYW5kICsgXCIvXCIgKyB0LnZlcnNpb247XG4gIH0pLmpvaW4oXCIgXCIpIDogbmF2aWdhdG9yLnVzZXJBZ2VudDtcbn1cbmZ1bmN0aW9uIGJjKCkge1xuICByZXR1cm4gIS9eKCg/IWNocm9tZXxhbmRyb2lkKS4pKnNhZmFyaS9pLnRlc3QoSW8oKSk7XG59XG5mdW5jdGlvbiBVZShzLCB0LCBlKSB7XG4gIHQgPT09IHZvaWQgMCAmJiAodCA9ICExKSwgZSA9PT0gdm9pZCAwICYmIChlID0gITEpO1xuICB2YXIgaSA9IHMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIG4gPSAxLCBvID0gMTtcbiAgdCAmJiBodChzKSAmJiAobiA9IHMub2Zmc2V0V2lkdGggPiAwICYmIHplKGkud2lkdGgpIC8gcy5vZmZzZXRXaWR0aCB8fCAxLCBvID0gcy5vZmZzZXRIZWlnaHQgPiAwICYmIHplKGkuaGVpZ2h0KSAvIHMub2Zmc2V0SGVpZ2h0IHx8IDEpO1xuICB2YXIgciA9IEVlKHMpID8gcHQocykgOiB3aW5kb3csIGEgPSByLnZpc3VhbFZpZXdwb3J0LCBsID0gIWJjKCkgJiYgZSwgcCA9IChpLmxlZnQgKyAobCAmJiBhID8gYS5vZmZzZXRMZWZ0IDogMCkpIC8gbiwgdSA9IChpLnRvcCArIChsICYmIGEgPyBhLm9mZnNldFRvcCA6IDApKSAvIG8sIF8gPSBpLndpZHRoIC8gbiwgZiA9IGkuaGVpZ2h0IC8gbztcbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogXyxcbiAgICBoZWlnaHQ6IGYsXG4gICAgdG9wOiB1LFxuICAgIHJpZ2h0OiBwICsgXyxcbiAgICBib3R0b206IHUgKyBmLFxuICAgIGxlZnQ6IHAsXG4gICAgeDogcCxcbiAgICB5OiB1XG4gIH07XG59XG5mdW5jdGlvbiBlcihzKSB7XG4gIHZhciB0ID0gVWUocyksIGUgPSBzLm9mZnNldFdpZHRoLCBpID0gcy5vZmZzZXRIZWlnaHQ7XG4gIHJldHVybiBNYXRoLmFicyh0LndpZHRoIC0gZSkgPD0gMSAmJiAoZSA9IHQud2lkdGgpLCBNYXRoLmFicyh0LmhlaWdodCAtIGkpIDw9IDEgJiYgKGkgPSB0LmhlaWdodCksIHtcbiAgICB4OiBzLm9mZnNldExlZnQsXG4gICAgeTogcy5vZmZzZXRUb3AsXG4gICAgd2lkdGg6IGUsXG4gICAgaGVpZ2h0OiBpXG4gIH07XG59XG5mdW5jdGlvbiB2YyhzLCB0KSB7XG4gIHZhciBlID0gdC5nZXRSb290Tm9kZSAmJiB0LmdldFJvb3ROb2RlKCk7XG4gIGlmIChzLmNvbnRhaW5zKHQpKVxuICAgIHJldHVybiAhMDtcbiAgaWYgKGUgJiYgSm8oZSkpIHtcbiAgICB2YXIgaSA9IHQ7XG4gICAgZG8ge1xuICAgICAgaWYgKGkgJiYgcy5pc1NhbWVOb2RlKGkpKVxuICAgICAgICByZXR1cm4gITA7XG4gICAgICBpID0gaS5wYXJlbnROb2RlIHx8IGkuaG9zdDtcbiAgICB9IHdoaWxlIChpKTtcbiAgfVxuICByZXR1cm4gITE7XG59XG5mdW5jdGlvbiBDdChzKSB7XG4gIHJldHVybiBwdChzKS5nZXRDb21wdXRlZFN0eWxlKHMpO1xufVxuZnVuY3Rpb24gb2Qocykge1xuICByZXR1cm4gW1widGFibGVcIiwgXCJ0ZFwiLCBcInRoXCJdLmluZGV4T2YoTXQocykpID49IDA7XG59XG5mdW5jdGlvbiBlZShzKSB7XG4gIHJldHVybiAoKEVlKHMpID8gcy5vd25lckRvY3VtZW50IDogKFxuICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgIHMuZG9jdW1lbnRcbiAgKSkgfHwgd2luZG93LmRvY3VtZW50KS5kb2N1bWVudEVsZW1lbnQ7XG59XG5mdW5jdGlvbiBybihzKSB7XG4gIHJldHVybiBNdChzKSA9PT0gXCJodG1sXCIgPyBzIDogKFxuICAgIC8vIHRoaXMgaXMgYSBxdWlja2VyIChidXQgbGVzcyB0eXBlIHNhZmUpIHdheSB0byBzYXZlIHF1aXRlIHNvbWUgYnl0ZXMgZnJvbSB0aGUgYnVuZGxlXG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxuICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgIHMuYXNzaWduZWRTbG90IHx8IC8vIHN0ZXAgaW50byB0aGUgc2hhZG93IERPTSBvZiB0aGUgcGFyZW50IG9mIGEgc2xvdHRlZCBub2RlXG4gICAgcy5wYXJlbnROb2RlIHx8IC8vIERPTSBFbGVtZW50IGRldGVjdGVkXG4gICAgKEpvKHMpID8gcy5ob3N0IDogbnVsbCkgfHwgLy8gU2hhZG93Um9vdCBkZXRlY3RlZFxuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhbGxdOiBIVE1MRWxlbWVudCBpcyBhIE5vZGVcbiAgICBlZShzKVxuICApO1xufVxuZnVuY3Rpb24gU3Iocykge1xuICByZXR1cm4gIWh0KHMpIHx8IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3BwZXJqcy9wb3BwZXItY29yZS9pc3N1ZXMvODM3XG4gIEN0KHMpLnBvc2l0aW9uID09PSBcImZpeGVkXCIgPyBudWxsIDogcy5vZmZzZXRQYXJlbnQ7XG59XG5mdW5jdGlvbiByZChzKSB7XG4gIHZhciB0ID0gL2ZpcmVmb3gvaS50ZXN0KElvKCkpLCBlID0gL1RyaWRlbnQvaS50ZXN0KElvKCkpO1xuICBpZiAoZSAmJiBodChzKSkge1xuICAgIHZhciBpID0gQ3Qocyk7XG4gICAgaWYgKGkucG9zaXRpb24gPT09IFwiZml4ZWRcIilcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBuID0gcm4ocyk7XG4gIGZvciAoSm8obikgJiYgKG4gPSBuLmhvc3QpOyBodChuKSAmJiBbXCJodG1sXCIsIFwiYm9keVwiXS5pbmRleE9mKE10KG4pKSA8IDA7ICkge1xuICAgIHZhciBvID0gQ3Qobik7XG4gICAgaWYgKG8udHJhbnNmb3JtICE9PSBcIm5vbmVcIiB8fCBvLnBlcnNwZWN0aXZlICE9PSBcIm5vbmVcIiB8fCBvLmNvbnRhaW4gPT09IFwicGFpbnRcIiB8fCBbXCJ0cmFuc2Zvcm1cIiwgXCJwZXJzcGVjdGl2ZVwiXS5pbmRleE9mKG8ud2lsbENoYW5nZSkgIT09IC0xIHx8IHQgJiYgby53aWxsQ2hhbmdlID09PSBcImZpbHRlclwiIHx8IHQgJiYgby5maWx0ZXIgJiYgby5maWx0ZXIgIT09IFwibm9uZVwiKVxuICAgICAgcmV0dXJuIG47XG4gICAgbiA9IG4ucGFyZW50Tm9kZTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIFZpKHMpIHtcbiAgZm9yICh2YXIgdCA9IHB0KHMpLCBlID0gU3Iocyk7IGUgJiYgb2QoZSkgJiYgQ3QoZSkucG9zaXRpb24gPT09IFwic3RhdGljXCI7IClcbiAgICBlID0gU3IoZSk7XG4gIHJldHVybiBlICYmIChNdChlKSA9PT0gXCJodG1sXCIgfHwgTXQoZSkgPT09IFwiYm9keVwiICYmIEN0KGUpLnBvc2l0aW9uID09PSBcInN0YXRpY1wiKSA/IHQgOiBlIHx8IHJkKHMpIHx8IHQ7XG59XG5mdW5jdGlvbiBpcihzKSB7XG4gIHJldHVybiBbXCJ0b3BcIiwgXCJib3R0b21cIl0uaW5kZXhPZihzKSA+PSAwID8gXCJ4XCIgOiBcInlcIjtcbn1cbmZ1bmN0aW9uIFNpKHMsIHQsIGUpIHtcbiAgcmV0dXJuIGJlKHMsIHNuKHQsIGUpKTtcbn1cbmZ1bmN0aW9uIGFkKHMsIHQsIGUpIHtcbiAgdmFyIGkgPSBTaShzLCB0LCBlKTtcbiAgcmV0dXJuIGkgPiBlID8gZSA6IGk7XG59XG5mdW5jdGlvbiBUYygpIHtcbiAgcmV0dXJuIHtcbiAgICB0b3A6IDAsXG4gICAgcmlnaHQ6IDAsXG4gICAgYm90dG9tOiAwLFxuICAgIGxlZnQ6IDBcbiAgfTtcbn1cbmZ1bmN0aW9uIEVjKHMpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIFRjKCksIHMpO1xufVxuZnVuY3Rpb24gQ2MocywgdCkge1xuICByZXR1cm4gdC5yZWR1Y2UoZnVuY3Rpb24oZSwgaSkge1xuICAgIHJldHVybiBlW2ldID0gcywgZTtcbiAgfSwge30pO1xufVxudmFyIGxkID0gZnVuY3Rpb24odCwgZSkge1xuICByZXR1cm4gdCA9IHR5cGVvZiB0ID09IFwiZnVuY3Rpb25cIiA/IHQoT2JqZWN0LmFzc2lnbih7fSwgZS5yZWN0cywge1xuICAgIHBsYWNlbWVudDogZS5wbGFjZW1lbnRcbiAgfSkpIDogdCwgRWModHlwZW9mIHQgIT0gXCJudW1iZXJcIiA/IHQgOiBDYyh0LCB0aSkpO1xufTtcbmZ1bmN0aW9uIGNkKHMpIHtcbiAgdmFyIHQsIGUgPSBzLnN0YXRlLCBpID0gcy5uYW1lLCBuID0gcy5vcHRpb25zLCBvID0gZS5lbGVtZW50cy5hcnJvdywgciA9IGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLCBhID0gVHQoZS5wbGFjZW1lbnQpLCBsID0gaXIoYSksIHAgPSBbSiwgdXRdLmluZGV4T2YoYSkgPj0gMCwgdSA9IHAgPyBcImhlaWdodFwiIDogXCJ3aWR0aFwiO1xuICBpZiAoISghbyB8fCAhcikpIHtcbiAgICB2YXIgXyA9IGxkKG4ucGFkZGluZywgZSksIGYgPSBlcihvKSwgZyA9IGwgPT09IFwieVwiID8gUSA6IEosIG0gPSBsID09PSBcInlcIiA/IGR0IDogdXQsIGIgPSBlLnJlY3RzLnJlZmVyZW5jZVt1XSArIGUucmVjdHMucmVmZXJlbmNlW2xdIC0gcltsXSAtIGUucmVjdHMucG9wcGVyW3VdLCB2ID0gcltsXSAtIGUucmVjdHMucmVmZXJlbmNlW2xdLCBDID0gVmkobyksIHcgPSBDID8gbCA9PT0gXCJ5XCIgPyBDLmNsaWVudEhlaWdodCB8fCAwIDogQy5jbGllbnRXaWR0aCB8fCAwIDogMCwgRSA9IGIgLyAyIC0gdiAvIDIsIFQgPSBfW2ddLCBBID0gdyAtIGZbdV0gLSBfW21dLCBrID0gdyAvIDIgLSBmW3VdIC8gMiArIEUsIEkgPSBTaShULCBrLCBBKSwgTyA9IGw7XG4gICAgZS5tb2RpZmllcnNEYXRhW2ldID0gKHQgPSB7fSwgdFtPXSA9IEksIHQuY2VudGVyT2Zmc2V0ID0gSSAtIGssIHQpO1xuICB9XG59XG5mdW5jdGlvbiBoZChzKSB7XG4gIHZhciB0ID0gcy5zdGF0ZSwgZSA9IHMub3B0aW9ucywgaSA9IGUuZWxlbWVudCwgbiA9IGkgPT09IHZvaWQgMCA/IFwiW2RhdGEtcG9wcGVyLWFycm93XVwiIDogaTtcbiAgaWYgKG4gIT0gbnVsbCAmJiAhKHR5cGVvZiBuID09IFwic3RyaW5nXCIgJiYgKG4gPSB0LmVsZW1lbnRzLnBvcHBlci5xdWVyeVNlbGVjdG9yKG4pLCAhbikpKSB7XG4gICAgaWYgKHt9Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAoaHQobikgfHwgY29uc29sZS5lcnJvcihbJ1BvcHBlcjogXCJhcnJvd1wiIGVsZW1lbnQgbXVzdCBiZSBhbiBIVE1MRWxlbWVudCAobm90IGFuIFNWR0VsZW1lbnQpLicsIFwiVG8gdXNlIGFuIFNWRyBhcnJvdywgd3JhcCBpdCBpbiBhbiBIVE1MRWxlbWVudCB0aGF0IHdpbGwgYmUgdXNlZCBhc1wiLCBcInRoZSBhcnJvdy5cIl0uam9pbihcIiBcIikpKSwgIXZjKHQuZWxlbWVudHMucG9wcGVyLCBuKSkge1xuICAgICAgKHt9KS5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgY29uc29sZS5lcnJvcihbJ1BvcHBlcjogXCJhcnJvd1wiIG1vZGlmaWVyXFwncyBgZWxlbWVudGAgbXVzdCBiZSBhIGNoaWxkIG9mIHRoZSBwb3BwZXInLCBcImVsZW1lbnQuXCJdLmpvaW4oXCIgXCIpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdC5lbGVtZW50cy5hcnJvdyA9IG47XG4gIH1cbn1cbmNvbnN0IEFjID0ge1xuICBuYW1lOiBcImFycm93XCIsXG4gIGVuYWJsZWQ6ICEwLFxuICBwaGFzZTogXCJtYWluXCIsXG4gIGZuOiBjZCxcbiAgZWZmZWN0OiBoZCxcbiAgcmVxdWlyZXM6IFtcInBvcHBlck9mZnNldHNcIl0sXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFtcInByZXZlbnRPdmVyZmxvd1wiXVxufTtcbmZ1bmN0aW9uIFhlKHMpIHtcbiAgcmV0dXJuIHMuc3BsaXQoXCItXCIpWzFdO1xufVxudmFyIGRkID0ge1xuICB0b3A6IFwiYXV0b1wiLFxuICByaWdodDogXCJhdXRvXCIsXG4gIGJvdHRvbTogXCJhdXRvXCIsXG4gIGxlZnQ6IFwiYXV0b1wiXG59O1xuZnVuY3Rpb24gdWQocywgdCkge1xuICB2YXIgZSA9IHMueCwgaSA9IHMueSwgbiA9IHQuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICByZXR1cm4ge1xuICAgIHg6IHplKGUgKiBuKSAvIG4gfHwgMCxcbiAgICB5OiB6ZShpICogbikgLyBuIHx8IDBcbiAgfTtcbn1cbmZ1bmN0aW9uIElyKHMpIHtcbiAgdmFyIHQsIGUgPSBzLnBvcHBlciwgaSA9IHMucG9wcGVyUmVjdCwgbiA9IHMucGxhY2VtZW50LCBvID0gcy52YXJpYXRpb24sIHIgPSBzLm9mZnNldHMsIGEgPSBzLnBvc2l0aW9uLCBsID0gcy5ncHVBY2NlbGVyYXRpb24sIHAgPSBzLmFkYXB0aXZlLCB1ID0gcy5yb3VuZE9mZnNldHMsIF8gPSBzLmlzRml4ZWQsIGYgPSByLngsIGcgPSBmID09PSB2b2lkIDAgPyAwIDogZiwgbSA9IHIueSwgYiA9IG0gPT09IHZvaWQgMCA/IDAgOiBtLCB2ID0gdHlwZW9mIHUgPT0gXCJmdW5jdGlvblwiID8gdSh7XG4gICAgeDogZyxcbiAgICB5OiBiXG4gIH0pIDoge1xuICAgIHg6IGcsXG4gICAgeTogYlxuICB9O1xuICBnID0gdi54LCBiID0gdi55O1xuICB2YXIgQyA9IHIuaGFzT3duUHJvcGVydHkoXCJ4XCIpLCB3ID0gci5oYXNPd25Qcm9wZXJ0eShcInlcIiksIEUgPSBKLCBUID0gUSwgQSA9IHdpbmRvdztcbiAgaWYgKHApIHtcbiAgICB2YXIgayA9IFZpKGUpLCBJID0gXCJjbGllbnRIZWlnaHRcIiwgTyA9IFwiY2xpZW50V2lkdGhcIjtcbiAgICBpZiAoayA9PT0gcHQoZSkgJiYgKGsgPSBlZShlKSwgQ3QoaykucG9zaXRpb24gIT09IFwic3RhdGljXCIgJiYgYSA9PT0gXCJhYnNvbHV0ZVwiICYmIChJID0gXCJzY3JvbGxIZWlnaHRcIiwgTyA9IFwic2Nyb2xsV2lkdGhcIikpLCBrID0gaywgbiA9PT0gUSB8fCAobiA9PT0gSiB8fCBuID09PSB1dCkgJiYgbyA9PT0gS2UpIHtcbiAgICAgIFQgPSBkdDtcbiAgICAgIHZhciB4ID0gXyAmJiBrID09PSBBICYmIEEudmlzdWFsVmlld3BvcnQgPyBBLnZpc3VhbFZpZXdwb3J0LmhlaWdodCA6IChcbiAgICAgICAgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gICAgICAgIGtbSV1cbiAgICAgICk7XG4gICAgICBiIC09IHggLSBpLmhlaWdodCwgYiAqPSBsID8gMSA6IC0xO1xuICAgIH1cbiAgICBpZiAobiA9PT0gSiB8fCAobiA9PT0gUSB8fCBuID09PSBkdCkgJiYgbyA9PT0gS2UpIHtcbiAgICAgIEUgPSB1dDtcbiAgICAgIHZhciBMID0gXyAmJiBrID09PSBBICYmIEEudmlzdWFsVmlld3BvcnQgPyBBLnZpc3VhbFZpZXdwb3J0LndpZHRoIDogKFxuICAgICAgICAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICAgICAga1tPXVxuICAgICAgKTtcbiAgICAgIGcgLT0gTCAtIGkud2lkdGgsIGcgKj0gbCA/IDEgOiAtMTtcbiAgICB9XG4gIH1cbiAgdmFyIFMgPSBPYmplY3QuYXNzaWduKHtcbiAgICBwb3NpdGlvbjogYVxuICB9LCBwICYmIGRkKSwgTiA9IHUgPT09ICEwID8gdWQoe1xuICAgIHg6IGcsXG4gICAgeTogYlxuICB9LCBwdChlKSkgOiB7XG4gICAgeDogZyxcbiAgICB5OiBiXG4gIH07XG4gIGlmIChnID0gTi54LCBiID0gTi55LCBsKSB7XG4gICAgdmFyIFA7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIFMsIChQID0ge30sIFBbVF0gPSB3ID8gXCIwXCIgOiBcIlwiLCBQW0VdID0gQyA/IFwiMFwiIDogXCJcIiwgUC50cmFuc2Zvcm0gPSAoQS5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpIDw9IDEgPyBcInRyYW5zbGF0ZShcIiArIGcgKyBcInB4LCBcIiArIGIgKyBcInB4KVwiIDogXCJ0cmFuc2xhdGUzZChcIiArIGcgKyBcInB4LCBcIiArIGIgKyBcInB4LCAwKVwiLCBQKSk7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIFMsICh0ID0ge30sIHRbVF0gPSB3ID8gYiArIFwicHhcIiA6IFwiXCIsIHRbRV0gPSBDID8gZyArIFwicHhcIiA6IFwiXCIsIHQudHJhbnNmb3JtID0gXCJcIiwgdCkpO1xufVxuZnVuY3Rpb24gcGQocykge1xuICB2YXIgdCA9IHMuc3RhdGUsIGUgPSBzLm9wdGlvbnMsIGkgPSBlLmdwdUFjY2VsZXJhdGlvbiwgbiA9IGkgPT09IHZvaWQgMCA/ICEwIDogaSwgbyA9IGUuYWRhcHRpdmUsIHIgPSBvID09PSB2b2lkIDAgPyAhMCA6IG8sIGEgPSBlLnJvdW5kT2Zmc2V0cywgbCA9IGEgPT09IHZvaWQgMCA/ICEwIDogYTtcbiAgaWYgKHt9Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHZhciBwID0gQ3QodC5lbGVtZW50cy5wb3BwZXIpLnRyYW5zaXRpb25Qcm9wZXJ0eSB8fCBcIlwiO1xuICAgIHIgJiYgW1widHJhbnNmb3JtXCIsIFwidG9wXCIsIFwicmlnaHRcIiwgXCJib3R0b21cIiwgXCJsZWZ0XCJdLnNvbWUoZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIHAuaW5kZXhPZihfKSA+PSAwO1xuICAgIH0pICYmIGNvbnNvbGUud2FybihbXCJQb3BwZXI6IERldGVjdGVkIENTUyB0cmFuc2l0aW9ucyBvbiBhdCBsZWFzdCBvbmUgb2YgdGhlIGZvbGxvd2luZ1wiLCAnQ1NTIHByb3BlcnRpZXM6IFwidHJhbnNmb3JtXCIsIFwidG9wXCIsIFwicmlnaHRcIiwgXCJib3R0b21cIiwgXCJsZWZ0XCIuJywgYFxuXG5gLCAnRGlzYWJsZSB0aGUgXCJjb21wdXRlU3R5bGVzXCIgbW9kaWZpZXJcXCdzIGBhZGFwdGl2ZWAgb3B0aW9uIHRvIGFsbG93JywgXCJmb3Igc21vb3RoIHRyYW5zaXRpb25zLCBvciByZW1vdmUgdGhlc2UgcHJvcGVydGllcyBmcm9tIHRoZSBDU1NcIiwgXCJ0cmFuc2l0aW9uIGRlY2xhcmF0aW9uIG9uIHRoZSBwb3BwZXIgZWxlbWVudCBpZiBvbmx5IHRyYW5zaXRpb25pbmdcIiwgXCJvcGFjaXR5IG9yIGJhY2tncm91bmQtY29sb3IgZm9yIGV4YW1wbGUuXCIsIGBcblxuYCwgXCJXZSByZWNvbW1lbmQgdXNpbmcgdGhlIHBvcHBlciBlbGVtZW50IGFzIGEgd3JhcHBlciBhcm91bmQgYW4gaW5uZXJcIiwgXCJlbGVtZW50IHRoYXQgY2FuIGhhdmUgYW55IENTUyBwcm9wZXJ0eSB0cmFuc2l0aW9uZWQgZm9yIGFuaW1hdGlvbnMuXCJdLmpvaW4oXCIgXCIpKTtcbiAgfVxuICB2YXIgdSA9IHtcbiAgICBwbGFjZW1lbnQ6IFR0KHQucGxhY2VtZW50KSxcbiAgICB2YXJpYXRpb246IFhlKHQucGxhY2VtZW50KSxcbiAgICBwb3BwZXI6IHQuZWxlbWVudHMucG9wcGVyLFxuICAgIHBvcHBlclJlY3Q6IHQucmVjdHMucG9wcGVyLFxuICAgIGdwdUFjY2VsZXJhdGlvbjogbixcbiAgICBpc0ZpeGVkOiB0Lm9wdGlvbnMuc3RyYXRlZ3kgPT09IFwiZml4ZWRcIlxuICB9O1xuICB0Lm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cyAhPSBudWxsICYmICh0LnN0eWxlcy5wb3BwZXIgPSBPYmplY3QuYXNzaWduKHt9LCB0LnN0eWxlcy5wb3BwZXIsIElyKE9iamVjdC5hc3NpZ24oe30sIHUsIHtcbiAgICBvZmZzZXRzOiB0Lm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cyxcbiAgICBwb3NpdGlvbjogdC5vcHRpb25zLnN0cmF0ZWd5LFxuICAgIGFkYXB0aXZlOiByLFxuICAgIHJvdW5kT2Zmc2V0czogbFxuICB9KSkpKSwgdC5tb2RpZmllcnNEYXRhLmFycm93ICE9IG51bGwgJiYgKHQuc3R5bGVzLmFycm93ID0gT2JqZWN0LmFzc2lnbih7fSwgdC5zdHlsZXMuYXJyb3csIElyKE9iamVjdC5hc3NpZ24oe30sIHUsIHtcbiAgICBvZmZzZXRzOiB0Lm1vZGlmaWVyc0RhdGEuYXJyb3csXG4gICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICBhZGFwdGl2ZTogITEsXG4gICAgcm91bmRPZmZzZXRzOiBsXG4gIH0pKSkpLCB0LmF0dHJpYnV0ZXMucG9wcGVyID0gT2JqZWN0LmFzc2lnbih7fSwgdC5hdHRyaWJ1dGVzLnBvcHBlciwge1xuICAgIFwiZGF0YS1wb3BwZXItcGxhY2VtZW50XCI6IHQucGxhY2VtZW50XG4gIH0pO1xufVxuY29uc3Qgc3IgPSB7XG4gIG5hbWU6IFwiY29tcHV0ZVN0eWxlc1wiLFxuICBlbmFibGVkOiAhMCxcbiAgcGhhc2U6IFwiYmVmb3JlV3JpdGVcIixcbiAgZm46IHBkLFxuICBkYXRhOiB7fVxufTtcbnZhciB0cyA9IHtcbiAgcGFzc2l2ZTogITBcbn07XG5mdW5jdGlvbiBfZChzKSB7XG4gIHZhciB0ID0gcy5zdGF0ZSwgZSA9IHMuaW5zdGFuY2UsIGkgPSBzLm9wdGlvbnMsIG4gPSBpLnNjcm9sbCwgbyA9IG4gPT09IHZvaWQgMCA/ICEwIDogbiwgciA9IGkucmVzaXplLCBhID0gciA9PT0gdm9pZCAwID8gITAgOiByLCBsID0gcHQodC5lbGVtZW50cy5wb3BwZXIpLCBwID0gW10uY29uY2F0KHQuc2Nyb2xsUGFyZW50cy5yZWZlcmVuY2UsIHQuc2Nyb2xsUGFyZW50cy5wb3BwZXIpO1xuICByZXR1cm4gbyAmJiBwLmZvckVhY2goZnVuY3Rpb24odSkge1xuICAgIHUuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBlLnVwZGF0ZSwgdHMpO1xuICB9KSwgYSAmJiBsLmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgZS51cGRhdGUsIHRzKSwgZnVuY3Rpb24oKSB7XG4gICAgbyAmJiBwLmZvckVhY2goZnVuY3Rpb24odSkge1xuICAgICAgdS5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIGUudXBkYXRlLCB0cyk7XG4gICAgfSksIGEgJiYgbC5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIGUudXBkYXRlLCB0cyk7XG4gIH07XG59XG5jb25zdCBuciA9IHtcbiAgbmFtZTogXCJldmVudExpc3RlbmVyc1wiLFxuICBlbmFibGVkOiAhMCxcbiAgcGhhc2U6IFwid3JpdGVcIixcbiAgZm46IGZ1bmN0aW9uKCkge1xuICB9LFxuICBlZmZlY3Q6IF9kLFxuICBkYXRhOiB7fVxufTtcbnZhciBmZCA9IHtcbiAgbGVmdDogXCJyaWdodFwiLFxuICByaWdodDogXCJsZWZ0XCIsXG4gIGJvdHRvbTogXCJ0b3BcIixcbiAgdG9wOiBcImJvdHRvbVwiXG59O1xuZnVuY3Rpb24gTXMocykge1xuICByZXR1cm4gcy5yZXBsYWNlKC9sZWZ0fHJpZ2h0fGJvdHRvbXx0b3AvZywgZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBmZFt0XTtcbiAgfSk7XG59XG52YXIgbWQgPSB7XG4gIHN0YXJ0OiBcImVuZFwiLFxuICBlbmQ6IFwic3RhcnRcIlxufTtcbmZ1bmN0aW9uIERyKHMpIHtcbiAgcmV0dXJuIHMucmVwbGFjZSgvc3RhcnR8ZW5kL2csIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gbWRbdF07XG4gIH0pO1xufVxuZnVuY3Rpb24gb3Iocykge1xuICB2YXIgdCA9IHB0KHMpLCBlID0gdC5wYWdlWE9mZnNldCwgaSA9IHQucGFnZVlPZmZzZXQ7XG4gIHJldHVybiB7XG4gICAgc2Nyb2xsTGVmdDogZSxcbiAgICBzY3JvbGxUb3A6IGlcbiAgfTtcbn1cbmZ1bmN0aW9uIHJyKHMpIHtcbiAgcmV0dXJuIFVlKGVlKHMpKS5sZWZ0ICsgb3Iocykuc2Nyb2xsTGVmdDtcbn1cbmZ1bmN0aW9uIGdkKHMsIHQpIHtcbiAgdmFyIGUgPSBwdChzKSwgaSA9IGVlKHMpLCBuID0gZS52aXN1YWxWaWV3cG9ydCwgbyA9IGkuY2xpZW50V2lkdGgsIHIgPSBpLmNsaWVudEhlaWdodCwgYSA9IDAsIGwgPSAwO1xuICBpZiAobikge1xuICAgIG8gPSBuLndpZHRoLCByID0gbi5oZWlnaHQ7XG4gICAgdmFyIHAgPSBiYygpO1xuICAgIChwIHx8ICFwICYmIHQgPT09IFwiZml4ZWRcIikgJiYgKGEgPSBuLm9mZnNldExlZnQsIGwgPSBuLm9mZnNldFRvcCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogbyxcbiAgICBoZWlnaHQ6IHIsXG4gICAgeDogYSArIHJyKHMpLFxuICAgIHk6IGxcbiAgfTtcbn1cbmZ1bmN0aW9uIGJkKHMpIHtcbiAgdmFyIHQsIGUgPSBlZShzKSwgaSA9IG9yKHMpLCBuID0gKHQgPSBzLm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiB0LmJvZHksIG8gPSBiZShlLnNjcm9sbFdpZHRoLCBlLmNsaWVudFdpZHRoLCBuID8gbi5zY3JvbGxXaWR0aCA6IDAsIG4gPyBuLmNsaWVudFdpZHRoIDogMCksIHIgPSBiZShlLnNjcm9sbEhlaWdodCwgZS5jbGllbnRIZWlnaHQsIG4gPyBuLnNjcm9sbEhlaWdodCA6IDAsIG4gPyBuLmNsaWVudEhlaWdodCA6IDApLCBhID0gLWkuc2Nyb2xsTGVmdCArIHJyKHMpLCBsID0gLWkuc2Nyb2xsVG9wO1xuICByZXR1cm4gQ3QobiB8fCBlKS5kaXJlY3Rpb24gPT09IFwicnRsXCIgJiYgKGEgKz0gYmUoZS5jbGllbnRXaWR0aCwgbiA/IG4uY2xpZW50V2lkdGggOiAwKSAtIG8pLCB7XG4gICAgd2lkdGg6IG8sXG4gICAgaGVpZ2h0OiByLFxuICAgIHg6IGEsXG4gICAgeTogbFxuICB9O1xufVxuZnVuY3Rpb24gYXIocykge1xuICB2YXIgdCA9IEN0KHMpLCBlID0gdC5vdmVyZmxvdywgaSA9IHQub3ZlcmZsb3dYLCBuID0gdC5vdmVyZmxvd1k7XG4gIHJldHVybiAvYXV0b3xzY3JvbGx8b3ZlcmxheXxoaWRkZW4vLnRlc3QoZSArIG4gKyBpKTtcbn1cbmZ1bmN0aW9uIHljKHMpIHtcbiAgcmV0dXJuIFtcImh0bWxcIiwgXCJib2R5XCIsIFwiI2RvY3VtZW50XCJdLmluZGV4T2YoTXQocykpID49IDAgPyBzLm93bmVyRG9jdW1lbnQuYm9keSA6IGh0KHMpICYmIGFyKHMpID8gcyA6IHljKHJuKHMpKTtcbn1cbmZ1bmN0aW9uIElpKHMsIHQpIHtcbiAgdmFyIGU7XG4gIHQgPT09IHZvaWQgMCAmJiAodCA9IFtdKTtcbiAgdmFyIGkgPSB5YyhzKSwgbiA9IGkgPT09ICgoZSA9IHMub3duZXJEb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IGUuYm9keSksIG8gPSBwdChpKSwgciA9IG4gPyBbb10uY29uY2F0KG8udmlzdWFsVmlld3BvcnQgfHwgW10sIGFyKGkpID8gaSA6IFtdKSA6IGksIGEgPSB0LmNvbmNhdChyKTtcbiAgcmV0dXJuIG4gPyBhIDogKFxuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhbGxdOiBpc0JvZHkgdGVsbHMgdXMgdGFyZ2V0IHdpbGwgYmUgYW4gSFRNTEVsZW1lbnQgaGVyZVxuICAgIGEuY29uY2F0KElpKHJuKHIpKSlcbiAgKTtcbn1cbmZ1bmN0aW9uIERvKHMpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHMsIHtcbiAgICBsZWZ0OiBzLngsXG4gICAgdG9wOiBzLnksXG4gICAgcmlnaHQ6IHMueCArIHMud2lkdGgsXG4gICAgYm90dG9tOiBzLnkgKyBzLmhlaWdodFxuICB9KTtcbn1cbmZ1bmN0aW9uIHZkKHMsIHQpIHtcbiAgdmFyIGUgPSBVZShzLCAhMSwgdCA9PT0gXCJmaXhlZFwiKTtcbiAgcmV0dXJuIGUudG9wID0gZS50b3AgKyBzLmNsaWVudFRvcCwgZS5sZWZ0ID0gZS5sZWZ0ICsgcy5jbGllbnRMZWZ0LCBlLmJvdHRvbSA9IGUudG9wICsgcy5jbGllbnRIZWlnaHQsIGUucmlnaHQgPSBlLmxlZnQgKyBzLmNsaWVudFdpZHRoLCBlLndpZHRoID0gcy5jbGllbnRXaWR0aCwgZS5oZWlnaHQgPSBzLmNsaWVudEhlaWdodCwgZS54ID0gZS5sZWZ0LCBlLnkgPSBlLnRvcCwgZTtcbn1cbmZ1bmN0aW9uICRyKHMsIHQsIGUpIHtcbiAgcmV0dXJuIHQgPT09IFpvID8gRG8oZ2QocywgZSkpIDogRWUodCkgPyB2ZCh0LCBlKSA6IERvKGJkKGVlKHMpKSk7XG59XG5mdW5jdGlvbiBUZChzKSB7XG4gIHZhciB0ID0gSWkocm4ocykpLCBlID0gW1wiYWJzb2x1dGVcIiwgXCJmaXhlZFwiXS5pbmRleE9mKEN0KHMpLnBvc2l0aW9uKSA+PSAwLCBpID0gZSAmJiBodChzKSA/IFZpKHMpIDogcztcbiAgcmV0dXJuIEVlKGkpID8gdC5maWx0ZXIoZnVuY3Rpb24obikge1xuICAgIHJldHVybiBFZShuKSAmJiB2YyhuLCBpKSAmJiBNdChuKSAhPT0gXCJib2R5XCI7XG4gIH0pIDogW107XG59XG5mdW5jdGlvbiBFZChzLCB0LCBlLCBpKSB7XG4gIHZhciBuID0gdCA9PT0gXCJjbGlwcGluZ1BhcmVudHNcIiA/IFRkKHMpIDogW10uY29uY2F0KHQpLCBvID0gW10uY29uY2F0KG4sIFtlXSksIHIgPSBvWzBdLCBhID0gby5yZWR1Y2UoZnVuY3Rpb24obCwgcCkge1xuICAgIHZhciB1ID0gJHIocywgcCwgaSk7XG4gICAgcmV0dXJuIGwudG9wID0gYmUodS50b3AsIGwudG9wKSwgbC5yaWdodCA9IHNuKHUucmlnaHQsIGwucmlnaHQpLCBsLmJvdHRvbSA9IHNuKHUuYm90dG9tLCBsLmJvdHRvbSksIGwubGVmdCA9IGJlKHUubGVmdCwgbC5sZWZ0KSwgbDtcbiAgfSwgJHIocywgciwgaSkpO1xuICByZXR1cm4gYS53aWR0aCA9IGEucmlnaHQgLSBhLmxlZnQsIGEuaGVpZ2h0ID0gYS5ib3R0b20gLSBhLnRvcCwgYS54ID0gYS5sZWZ0LCBhLnkgPSBhLnRvcCwgYTtcbn1cbmZ1bmN0aW9uIHdjKHMpIHtcbiAgdmFyIHQgPSBzLnJlZmVyZW5jZSwgZSA9IHMuZWxlbWVudCwgaSA9IHMucGxhY2VtZW50LCBuID0gaSA/IFR0KGkpIDogbnVsbCwgbyA9IGkgPyBYZShpKSA6IG51bGwsIHIgPSB0LnggKyB0LndpZHRoIC8gMiAtIGUud2lkdGggLyAyLCBhID0gdC55ICsgdC5oZWlnaHQgLyAyIC0gZS5oZWlnaHQgLyAyLCBsO1xuICBzd2l0Y2ggKG4pIHtcbiAgICBjYXNlIFE6XG4gICAgICBsID0ge1xuICAgICAgICB4OiByLFxuICAgICAgICB5OiB0LnkgLSBlLmhlaWdodFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgZHQ6XG4gICAgICBsID0ge1xuICAgICAgICB4OiByLFxuICAgICAgICB5OiB0LnkgKyB0LmhlaWdodFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgdXQ6XG4gICAgICBsID0ge1xuICAgICAgICB4OiB0LnggKyB0LndpZHRoLFxuICAgICAgICB5OiBhXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBKOlxuICAgICAgbCA9IHtcbiAgICAgICAgeDogdC54IC0gZS53aWR0aCxcbiAgICAgICAgeTogYVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBsID0ge1xuICAgICAgICB4OiB0LngsXG4gICAgICAgIHk6IHQueVxuICAgICAgfTtcbiAgfVxuICB2YXIgcCA9IG4gPyBpcihuKSA6IG51bGw7XG4gIGlmIChwICE9IG51bGwpIHtcbiAgICB2YXIgdSA9IHAgPT09IFwieVwiID8gXCJoZWlnaHRcIiA6IFwid2lkdGhcIjtcbiAgICBzd2l0Y2ggKG8pIHtcbiAgICAgIGNhc2UgVGU6XG4gICAgICAgIGxbcF0gPSBsW3BdIC0gKHRbdV0gLyAyIC0gZVt1XSAvIDIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgS2U6XG4gICAgICAgIGxbcF0gPSBsW3BdICsgKHRbdV0gLyAyIC0gZVt1XSAvIDIpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGw7XG59XG5mdW5jdGlvbiBHZShzLCB0KSB7XG4gIHQgPT09IHZvaWQgMCAmJiAodCA9IHt9KTtcbiAgdmFyIGUgPSB0LCBpID0gZS5wbGFjZW1lbnQsIG4gPSBpID09PSB2b2lkIDAgPyBzLnBsYWNlbWVudCA6IGksIG8gPSBlLnN0cmF0ZWd5LCByID0gbyA9PT0gdm9pZCAwID8gcy5zdHJhdGVneSA6IG8sIGEgPSBlLmJvdW5kYXJ5LCBsID0gYSA9PT0gdm9pZCAwID8gYWMgOiBhLCBwID0gZS5yb290Qm91bmRhcnksIHUgPSBwID09PSB2b2lkIDAgPyBabyA6IHAsIF8gPSBlLmVsZW1lbnRDb250ZXh0LCBmID0gXyA9PT0gdm9pZCAwID8gJGUgOiBfLCBnID0gZS5hbHRCb3VuZGFyeSwgbSA9IGcgPT09IHZvaWQgMCA/ICExIDogZywgYiA9IGUucGFkZGluZywgdiA9IGIgPT09IHZvaWQgMCA/IDAgOiBiLCBDID0gRWModHlwZW9mIHYgIT0gXCJudW1iZXJcIiA/IHYgOiBDYyh2LCB0aSkpLCB3ID0gZiA9PT0gJGUgPyBsYyA6ICRlLCBFID0gcy5yZWN0cy5wb3BwZXIsIFQgPSBzLmVsZW1lbnRzW20gPyB3IDogZl0sIEEgPSBFZChFZShUKSA/IFQgOiBULmNvbnRleHRFbGVtZW50IHx8IGVlKHMuZWxlbWVudHMucG9wcGVyKSwgbCwgdSwgciksIGsgPSBVZShzLmVsZW1lbnRzLnJlZmVyZW5jZSksIEkgPSB3Yyh7XG4gICAgcmVmZXJlbmNlOiBrLFxuICAgIGVsZW1lbnQ6IEUsXG4gICAgc3RyYXRlZ3k6IFwiYWJzb2x1dGVcIixcbiAgICBwbGFjZW1lbnQ6IG5cbiAgfSksIE8gPSBEbyhPYmplY3QuYXNzaWduKHt9LCBFLCBJKSksIHggPSBmID09PSAkZSA/IE8gOiBrLCBMID0ge1xuICAgIHRvcDogQS50b3AgLSB4LnRvcCArIEMudG9wLFxuICAgIGJvdHRvbTogeC5ib3R0b20gLSBBLmJvdHRvbSArIEMuYm90dG9tLFxuICAgIGxlZnQ6IEEubGVmdCAtIHgubGVmdCArIEMubGVmdCxcbiAgICByaWdodDogeC5yaWdodCAtIEEucmlnaHQgKyBDLnJpZ2h0XG4gIH0sIFMgPSBzLm1vZGlmaWVyc0RhdGEub2Zmc2V0O1xuICBpZiAoZiA9PT0gJGUgJiYgUykge1xuICAgIHZhciBOID0gU1tuXTtcbiAgICBPYmplY3Qua2V5cyhMKS5mb3JFYWNoKGZ1bmN0aW9uKFApIHtcbiAgICAgIHZhciB0dCA9IFt1dCwgZHRdLmluZGV4T2YoUCkgPj0gMCA/IDEgOiAtMSwgZXQgPSBbUSwgZHRdLmluZGV4T2YoUCkgPj0gMCA/IFwieVwiIDogXCJ4XCI7XG4gICAgICBMW1BdICs9IE5bZXRdICogdHQ7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIEw7XG59XG5mdW5jdGlvbiBDZChzLCB0KSB7XG4gIHQgPT09IHZvaWQgMCAmJiAodCA9IHt9KTtcbiAgdmFyIGUgPSB0LCBpID0gZS5wbGFjZW1lbnQsIG4gPSBlLmJvdW5kYXJ5LCBvID0gZS5yb290Qm91bmRhcnksIHIgPSBlLnBhZGRpbmcsIGEgPSBlLmZsaXBWYXJpYXRpb25zLCBsID0gZS5hbGxvd2VkQXV0b1BsYWNlbWVudHMsIHAgPSBsID09PSB2b2lkIDAgPyBRbyA6IGwsIHUgPSBYZShpKSwgXyA9IHUgPyBhID8gU28gOiBTby5maWx0ZXIoZnVuY3Rpb24obSkge1xuICAgIHJldHVybiBYZShtKSA9PT0gdTtcbiAgfSkgOiB0aSwgZiA9IF8uZmlsdGVyKGZ1bmN0aW9uKG0pIHtcbiAgICByZXR1cm4gcC5pbmRleE9mKG0pID49IDA7XG4gIH0pO1xuICBmLmxlbmd0aCA9PT0gMCAmJiAoZiA9IF8sIHt9Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBjb25zb2xlLmVycm9yKFtcIlBvcHBlcjogVGhlIGBhbGxvd2VkQXV0b1BsYWNlbWVudHNgIG9wdGlvbiBkaWQgbm90IGFsbG93IGFueVwiLCBcInBsYWNlbWVudHMuIEVuc3VyZSB0aGUgYHBsYWNlbWVudGAgb3B0aW9uIG1hdGNoZXMgdGhlIHZhcmlhdGlvblwiLCBcIm9mIHRoZSBhbGxvd2VkIHBsYWNlbWVudHMuXCIsICdGb3IgZXhhbXBsZSwgXCJhdXRvXCIgY2Fubm90IGJlIHVzZWQgdG8gYWxsb3cgXCJib3R0b20tc3RhcnRcIi4nLCAnVXNlIFwiYXV0by1zdGFydFwiIGluc3RlYWQuJ10uam9pbihcIiBcIikpKTtcbiAgdmFyIGcgPSBmLnJlZHVjZShmdW5jdGlvbihtLCBiKSB7XG4gICAgcmV0dXJuIG1bYl0gPSBHZShzLCB7XG4gICAgICBwbGFjZW1lbnQ6IGIsXG4gICAgICBib3VuZGFyeTogbixcbiAgICAgIHJvb3RCb3VuZGFyeTogbyxcbiAgICAgIHBhZGRpbmc6IHJcbiAgICB9KVtUdChiKV0sIG07XG4gIH0sIHt9KTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGcpLnNvcnQoZnVuY3Rpb24obSwgYikge1xuICAgIHJldHVybiBnW21dIC0gZ1tiXTtcbiAgfSk7XG59XG5mdW5jdGlvbiBBZChzKSB7XG4gIGlmIChUdChzKSA9PT0gSGkpXG4gICAgcmV0dXJuIFtdO1xuICB2YXIgdCA9IE1zKHMpO1xuICByZXR1cm4gW0RyKHMpLCB0LCBEcih0KV07XG59XG5mdW5jdGlvbiB5ZChzKSB7XG4gIHZhciB0ID0gcy5zdGF0ZSwgZSA9IHMub3B0aW9ucywgaSA9IHMubmFtZTtcbiAgaWYgKCF0Lm1vZGlmaWVyc0RhdGFbaV0uX3NraXApIHtcbiAgICBmb3IgKHZhciBuID0gZS5tYWluQXhpcywgbyA9IG4gPT09IHZvaWQgMCA/ICEwIDogbiwgciA9IGUuYWx0QXhpcywgYSA9IHIgPT09IHZvaWQgMCA/ICEwIDogciwgbCA9IGUuZmFsbGJhY2tQbGFjZW1lbnRzLCBwID0gZS5wYWRkaW5nLCB1ID0gZS5ib3VuZGFyeSwgXyA9IGUucm9vdEJvdW5kYXJ5LCBmID0gZS5hbHRCb3VuZGFyeSwgZyA9IGUuZmxpcFZhcmlhdGlvbnMsIG0gPSBnID09PSB2b2lkIDAgPyAhMCA6IGcsIGIgPSBlLmFsbG93ZWRBdXRvUGxhY2VtZW50cywgdiA9IHQub3B0aW9ucy5wbGFjZW1lbnQsIEMgPSBUdCh2KSwgdyA9IEMgPT09IHYsIEUgPSBsIHx8ICh3IHx8ICFtID8gW01zKHYpXSA6IEFkKHYpKSwgVCA9IFt2XS5jb25jYXQoRSkucmVkdWNlKGZ1bmN0aW9uKHllLCBIdCkge1xuICAgICAgcmV0dXJuIHllLmNvbmNhdChUdChIdCkgPT09IEhpID8gQ2QodCwge1xuICAgICAgICBwbGFjZW1lbnQ6IEh0LFxuICAgICAgICBib3VuZGFyeTogdSxcbiAgICAgICAgcm9vdEJvdW5kYXJ5OiBfLFxuICAgICAgICBwYWRkaW5nOiBwLFxuICAgICAgICBmbGlwVmFyaWF0aW9uczogbSxcbiAgICAgICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzOiBiXG4gICAgICB9KSA6IEh0KTtcbiAgICB9LCBbXSksIEEgPSB0LnJlY3RzLnJlZmVyZW5jZSwgayA9IHQucmVjdHMucG9wcGVyLCBJID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgTyA9ICEwLCB4ID0gVFswXSwgTCA9IDA7IEwgPCBULmxlbmd0aDsgTCsrKSB7XG4gICAgICB2YXIgUyA9IFRbTF0sIE4gPSBUdChTKSwgUCA9IFhlKFMpID09PSBUZSwgdHQgPSBbUSwgZHRdLmluZGV4T2YoTikgPj0gMCwgZXQgPSB0dCA/IFwid2lkdGhcIiA6IFwiaGVpZ2h0XCIsIFUgPSBHZSh0LCB7XG4gICAgICAgIHBsYWNlbWVudDogUyxcbiAgICAgICAgYm91bmRhcnk6IHUsXG4gICAgICAgIHJvb3RCb3VuZGFyeTogXyxcbiAgICAgICAgYWx0Qm91bmRhcnk6IGYsXG4gICAgICAgIHBhZGRpbmc6IHBcbiAgICAgIH0pLCBidCA9IHR0ID8gUCA/IHV0IDogSiA6IFAgPyBkdCA6IFE7XG4gICAgICBBW2V0XSA+IGtbZXRdICYmIChidCA9IE1zKGJ0KSk7XG4gICAgICB2YXIgR2kgPSBNcyhidCksIHNlID0gW107XG4gICAgICBpZiAobyAmJiBzZS5wdXNoKFVbTl0gPD0gMCksIGEgJiYgc2UucHVzaChVW2J0XSA8PSAwLCBVW0dpXSA8PSAwKSwgc2UuZXZlcnkoZnVuY3Rpb24oeWUpIHtcbiAgICAgICAgcmV0dXJuIHllO1xuICAgICAgfSkpIHtcbiAgICAgICAgeCA9IFMsIE8gPSAhMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBJLnNldChTLCBzZSk7XG4gICAgfVxuICAgIGlmIChPKVxuICAgICAgZm9yICh2YXIgcWkgPSBtID8gMyA6IDEsIG1uID0gZnVuY3Rpb24oSHQpIHtcbiAgICAgICAgdmFyIHJpID0gVC5maW5kKGZ1bmN0aW9uKFFpKSB7XG4gICAgICAgICAgdmFyIG5lID0gSS5nZXQoUWkpO1xuICAgICAgICAgIGlmIChuZSlcbiAgICAgICAgICAgIHJldHVybiBuZS5zbGljZSgwLCBIdCkuZXZlcnkoZnVuY3Rpb24oZ24pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGduO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocmkpXG4gICAgICAgICAgcmV0dXJuIHggPSByaSwgXCJicmVha1wiO1xuICAgICAgfSwgb2kgPSBxaTsgb2kgPiAwOyBvaS0tKSB7XG4gICAgICAgIHZhciBaaSA9IG1uKG9pKTtcbiAgICAgICAgaWYgKFppID09PSBcImJyZWFrXCIpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgdC5wbGFjZW1lbnQgIT09IHggJiYgKHQubW9kaWZpZXJzRGF0YVtpXS5fc2tpcCA9ICEwLCB0LnBsYWNlbWVudCA9IHgsIHQucmVzZXQgPSAhMCk7XG4gIH1cbn1cbmNvbnN0IGtjID0ge1xuICBuYW1lOiBcImZsaXBcIixcbiAgZW5hYmxlZDogITAsXG4gIHBoYXNlOiBcIm1haW5cIixcbiAgZm46IHlkLFxuICByZXF1aXJlc0lmRXhpc3RzOiBbXCJvZmZzZXRcIl0sXG4gIGRhdGE6IHtcbiAgICBfc2tpcDogITFcbiAgfVxufTtcbmZ1bmN0aW9uIExyKHMsIHQsIGUpIHtcbiAgcmV0dXJuIGUgPT09IHZvaWQgMCAmJiAoZSA9IHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfSksIHtcbiAgICB0b3A6IHMudG9wIC0gdC5oZWlnaHQgLSBlLnksXG4gICAgcmlnaHQ6IHMucmlnaHQgLSB0LndpZHRoICsgZS54LFxuICAgIGJvdHRvbTogcy5ib3R0b20gLSB0LmhlaWdodCArIGUueSxcbiAgICBsZWZ0OiBzLmxlZnQgLSB0LndpZHRoIC0gZS54XG4gIH07XG59XG5mdW5jdGlvbiBOcihzKSB7XG4gIHJldHVybiBbUSwgdXQsIGR0LCBKXS5zb21lKGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gc1t0XSA+PSAwO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHdkKHMpIHtcbiAgdmFyIHQgPSBzLnN0YXRlLCBlID0gcy5uYW1lLCBpID0gdC5yZWN0cy5yZWZlcmVuY2UsIG4gPSB0LnJlY3RzLnBvcHBlciwgbyA9IHQubW9kaWZpZXJzRGF0YS5wcmV2ZW50T3ZlcmZsb3csIHIgPSBHZSh0LCB7XG4gICAgZWxlbWVudENvbnRleHQ6IFwicmVmZXJlbmNlXCJcbiAgfSksIGEgPSBHZSh0LCB7XG4gICAgYWx0Qm91bmRhcnk6ICEwXG4gIH0pLCBsID0gTHIociwgaSksIHAgPSBMcihhLCBuLCBvKSwgdSA9IE5yKGwpLCBfID0gTnIocCk7XG4gIHQubW9kaWZpZXJzRGF0YVtlXSA9IHtcbiAgICByZWZlcmVuY2VDbGlwcGluZ09mZnNldHM6IGwsXG4gICAgcG9wcGVyRXNjYXBlT2Zmc2V0czogcCxcbiAgICBpc1JlZmVyZW5jZUhpZGRlbjogdSxcbiAgICBoYXNQb3BwZXJFc2NhcGVkOiBfXG4gIH0sIHQuYXR0cmlidXRlcy5wb3BwZXIgPSBPYmplY3QuYXNzaWduKHt9LCB0LmF0dHJpYnV0ZXMucG9wcGVyLCB7XG4gICAgXCJkYXRhLXBvcHBlci1yZWZlcmVuY2UtaGlkZGVuXCI6IHUsXG4gICAgXCJkYXRhLXBvcHBlci1lc2NhcGVkXCI6IF9cbiAgfSk7XG59XG5jb25zdCB4YyA9IHtcbiAgbmFtZTogXCJoaWRlXCIsXG4gIGVuYWJsZWQ6ICEwLFxuICBwaGFzZTogXCJtYWluXCIsXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFtcInByZXZlbnRPdmVyZmxvd1wiXSxcbiAgZm46IHdkXG59O1xuZnVuY3Rpb24ga2QocywgdCwgZSkge1xuICB2YXIgaSA9IFR0KHMpLCBuID0gW0osIFFdLmluZGV4T2YoaSkgPj0gMCA/IC0xIDogMSwgbyA9IHR5cGVvZiBlID09IFwiZnVuY3Rpb25cIiA/IGUoT2JqZWN0LmFzc2lnbih7fSwgdCwge1xuICAgIHBsYWNlbWVudDogc1xuICB9KSkgOiBlLCByID0gb1swXSwgYSA9IG9bMV07XG4gIHJldHVybiByID0gciB8fCAwLCBhID0gKGEgfHwgMCkgKiBuLCBbSiwgdXRdLmluZGV4T2YoaSkgPj0gMCA/IHtcbiAgICB4OiBhLFxuICAgIHk6IHJcbiAgfSA6IHtcbiAgICB4OiByLFxuICAgIHk6IGFcbiAgfTtcbn1cbmZ1bmN0aW9uIHhkKHMpIHtcbiAgdmFyIHQgPSBzLnN0YXRlLCBlID0gcy5vcHRpb25zLCBpID0gcy5uYW1lLCBuID0gZS5vZmZzZXQsIG8gPSBuID09PSB2b2lkIDAgPyBbMCwgMF0gOiBuLCByID0gUW8ucmVkdWNlKGZ1bmN0aW9uKHUsIF8pIHtcbiAgICByZXR1cm4gdVtfXSA9IGtkKF8sIHQucmVjdHMsIG8pLCB1O1xuICB9LCB7fSksIGEgPSByW3QucGxhY2VtZW50XSwgbCA9IGEueCwgcCA9IGEueTtcbiAgdC5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMgIT0gbnVsbCAmJiAodC5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMueCArPSBsLCB0Lm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cy55ICs9IHApLCB0Lm1vZGlmaWVyc0RhdGFbaV0gPSByO1xufVxuY29uc3QgT2MgPSB7XG4gIG5hbWU6IFwib2Zmc2V0XCIsXG4gIGVuYWJsZWQ6ICEwLFxuICBwaGFzZTogXCJtYWluXCIsXG4gIHJlcXVpcmVzOiBbXCJwb3BwZXJPZmZzZXRzXCJdLFxuICBmbjogeGRcbn07XG5mdW5jdGlvbiBPZChzKSB7XG4gIHZhciB0ID0gcy5zdGF0ZSwgZSA9IHMubmFtZTtcbiAgdC5tb2RpZmllcnNEYXRhW2VdID0gd2Moe1xuICAgIHJlZmVyZW5jZTogdC5yZWN0cy5yZWZlcmVuY2UsXG4gICAgZWxlbWVudDogdC5yZWN0cy5wb3BwZXIsXG4gICAgc3RyYXRlZ3k6IFwiYWJzb2x1dGVcIixcbiAgICBwbGFjZW1lbnQ6IHQucGxhY2VtZW50XG4gIH0pO1xufVxuY29uc3QgbHIgPSB7XG4gIG5hbWU6IFwicG9wcGVyT2Zmc2V0c1wiLFxuICBlbmFibGVkOiAhMCxcbiAgcGhhc2U6IFwicmVhZFwiLFxuICBmbjogT2QsXG4gIGRhdGE6IHt9XG59O1xuZnVuY3Rpb24gU2Qocykge1xuICByZXR1cm4gcyA9PT0gXCJ4XCIgPyBcInlcIiA6IFwieFwiO1xufVxuZnVuY3Rpb24gSWQocykge1xuICB2YXIgdCA9IHMuc3RhdGUsIGUgPSBzLm9wdGlvbnMsIGkgPSBzLm5hbWUsIG4gPSBlLm1haW5BeGlzLCBvID0gbiA9PT0gdm9pZCAwID8gITAgOiBuLCByID0gZS5hbHRBeGlzLCBhID0gciA9PT0gdm9pZCAwID8gITEgOiByLCBsID0gZS5ib3VuZGFyeSwgcCA9IGUucm9vdEJvdW5kYXJ5LCB1ID0gZS5hbHRCb3VuZGFyeSwgXyA9IGUucGFkZGluZywgZiA9IGUudGV0aGVyLCBnID0gZiA9PT0gdm9pZCAwID8gITAgOiBmLCBtID0gZS50ZXRoZXJPZmZzZXQsIGIgPSBtID09PSB2b2lkIDAgPyAwIDogbSwgdiA9IEdlKHQsIHtcbiAgICBib3VuZGFyeTogbCxcbiAgICByb290Qm91bmRhcnk6IHAsXG4gICAgcGFkZGluZzogXyxcbiAgICBhbHRCb3VuZGFyeTogdVxuICB9KSwgQyA9IFR0KHQucGxhY2VtZW50KSwgdyA9IFhlKHQucGxhY2VtZW50KSwgRSA9ICF3LCBUID0gaXIoQyksIEEgPSBTZChUKSwgayA9IHQubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLCBJID0gdC5yZWN0cy5yZWZlcmVuY2UsIE8gPSB0LnJlY3RzLnBvcHBlciwgeCA9IHR5cGVvZiBiID09IFwiZnVuY3Rpb25cIiA/IGIoT2JqZWN0LmFzc2lnbih7fSwgdC5yZWN0cywge1xuICAgIHBsYWNlbWVudDogdC5wbGFjZW1lbnRcbiAgfSkpIDogYiwgTCA9IHR5cGVvZiB4ID09IFwibnVtYmVyXCIgPyB7XG4gICAgbWFpbkF4aXM6IHgsXG4gICAgYWx0QXhpczogeFxuICB9IDogT2JqZWN0LmFzc2lnbih7XG4gICAgbWFpbkF4aXM6IDAsXG4gICAgYWx0QXhpczogMFxuICB9LCB4KSwgUyA9IHQubW9kaWZpZXJzRGF0YS5vZmZzZXQgPyB0Lm1vZGlmaWVyc0RhdGEub2Zmc2V0W3QucGxhY2VtZW50XSA6IG51bGwsIE4gPSB7XG4gICAgeDogMCxcbiAgICB5OiAwXG4gIH07XG4gIGlmIChrKSB7XG4gICAgaWYgKG8pIHtcbiAgICAgIHZhciBQLCB0dCA9IFQgPT09IFwieVwiID8gUSA6IEosIGV0ID0gVCA9PT0gXCJ5XCIgPyBkdCA6IHV0LCBVID0gVCA9PT0gXCJ5XCIgPyBcImhlaWdodFwiIDogXCJ3aWR0aFwiLCBidCA9IGtbVF0sIEdpID0gYnQgKyB2W3R0XSwgc2UgPSBidCAtIHZbZXRdLCBxaSA9IGcgPyAtT1tVXSAvIDIgOiAwLCBtbiA9IHcgPT09IFRlID8gSVtVXSA6IE9bVV0sIG9pID0gdyA9PT0gVGUgPyAtT1tVXSA6IC1JW1VdLCBaaSA9IHQuZWxlbWVudHMuYXJyb3csIHllID0gZyAmJiBaaSA/IGVyKFppKSA6IHtcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogMFxuICAgICAgfSwgSHQgPSB0Lm1vZGlmaWVyc0RhdGFbXCJhcnJvdyNwZXJzaXN0ZW50XCJdID8gdC5tb2RpZmllcnNEYXRhW1wiYXJyb3cjcGVyc2lzdGVudFwiXS5wYWRkaW5nIDogVGMoKSwgcmkgPSBIdFt0dF0sIFFpID0gSHRbZXRdLCBuZSA9IFNpKDAsIElbVV0sIHllW1VdKSwgZ24gPSBFID8gSVtVXSAvIDIgLSBxaSAtIG5lIC0gcmkgLSBMLm1haW5BeGlzIDogbW4gLSBuZSAtIHJpIC0gTC5tYWluQXhpcywgTGggPSBFID8gLUlbVV0gLyAyICsgcWkgKyBuZSArIFFpICsgTC5tYWluQXhpcyA6IG9pICsgbmUgKyBRaSArIEwubWFpbkF4aXMsIGJuID0gdC5lbGVtZW50cy5hcnJvdyAmJiBWaSh0LmVsZW1lbnRzLmFycm93KSwgTmggPSBibiA/IFQgPT09IFwieVwiID8gYm4uY2xpZW50VG9wIHx8IDAgOiBibi5jbGllbnRMZWZ0IHx8IDAgOiAwLCBiciA9IChQID0gUyA9PSBudWxsID8gdm9pZCAwIDogU1tUXSkgIT0gbnVsbCA/IFAgOiAwLCBNaCA9IGJ0ICsgZ24gLSBiciAtIE5oLCBSaCA9IGJ0ICsgTGggLSBiciwgdnIgPSBTaShnID8gc24oR2ksIE1oKSA6IEdpLCBidCwgZyA/IGJlKHNlLCBSaCkgOiBzZSk7XG4gICAgICBrW1RdID0gdnIsIE5bVF0gPSB2ciAtIGJ0O1xuICAgIH1cbiAgICBpZiAoYSkge1xuICAgICAgdmFyIFRyLCBQaCA9IFQgPT09IFwieFwiID8gUSA6IEosIEJoID0gVCA9PT0gXCJ4XCIgPyBkdCA6IHV0LCBvZSA9IGtbQV0sIEppID0gQSA9PT0gXCJ5XCIgPyBcImhlaWdodFwiIDogXCJ3aWR0aFwiLCBFciA9IG9lICsgdltQaF0sIENyID0gb2UgLSB2W0JoXSwgdm4gPSBbUSwgSl0uaW5kZXhPZihDKSAhPT0gLTEsIEFyID0gKFRyID0gUyA9PSBudWxsID8gdm9pZCAwIDogU1tBXSkgIT0gbnVsbCA/IFRyIDogMCwgeXIgPSB2biA/IEVyIDogb2UgLSBJW0ppXSAtIE9bSmldIC0gQXIgKyBMLmFsdEF4aXMsIHdyID0gdm4gPyBvZSArIElbSmldICsgT1tKaV0gLSBBciAtIEwuYWx0QXhpcyA6IENyLCBrciA9IGcgJiYgdm4gPyBhZCh5ciwgb2UsIHdyKSA6IFNpKGcgPyB5ciA6IEVyLCBvZSwgZyA/IHdyIDogQ3IpO1xuICAgICAga1tBXSA9IGtyLCBOW0FdID0ga3IgLSBvZTtcbiAgICB9XG4gICAgdC5tb2RpZmllcnNEYXRhW2ldID0gTjtcbiAgfVxufVxuY29uc3QgU2MgPSB7XG4gIG5hbWU6IFwicHJldmVudE92ZXJmbG93XCIsXG4gIGVuYWJsZWQ6ICEwLFxuICBwaGFzZTogXCJtYWluXCIsXG4gIGZuOiBJZCxcbiAgcmVxdWlyZXNJZkV4aXN0czogW1wib2Zmc2V0XCJdXG59O1xuZnVuY3Rpb24gRGQocykge1xuICByZXR1cm4ge1xuICAgIHNjcm9sbExlZnQ6IHMuc2Nyb2xsTGVmdCxcbiAgICBzY3JvbGxUb3A6IHMuc2Nyb2xsVG9wXG4gIH07XG59XG5mdW5jdGlvbiAkZChzKSB7XG4gIHJldHVybiBzID09PSBwdChzKSB8fCAhaHQocykgPyBvcihzKSA6IERkKHMpO1xufVxuZnVuY3Rpb24gTGQocykge1xuICB2YXIgdCA9IHMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGUgPSB6ZSh0LndpZHRoKSAvIHMub2Zmc2V0V2lkdGggfHwgMSwgaSA9IHplKHQuaGVpZ2h0KSAvIHMub2Zmc2V0SGVpZ2h0IHx8IDE7XG4gIHJldHVybiBlICE9PSAxIHx8IGkgIT09IDE7XG59XG5mdW5jdGlvbiBOZChzLCB0LCBlKSB7XG4gIGUgPT09IHZvaWQgMCAmJiAoZSA9ICExKTtcbiAgdmFyIGkgPSBodCh0KSwgbiA9IGh0KHQpICYmIExkKHQpLCBvID0gZWUodCksIHIgPSBVZShzLCBuLCBlKSwgYSA9IHtcbiAgICBzY3JvbGxMZWZ0OiAwLFxuICAgIHNjcm9sbFRvcDogMFxuICB9LCBsID0ge1xuICAgIHg6IDAsXG4gICAgeTogMFxuICB9O1xuICByZXR1cm4gKGkgfHwgIWkgJiYgIWUpICYmICgoTXQodCkgIT09IFwiYm9keVwiIHx8IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3BwZXJqcy9wb3BwZXItY29yZS9pc3N1ZXMvMTA3OFxuICBhcihvKSkgJiYgKGEgPSAkZCh0KSksIGh0KHQpID8gKGwgPSBVZSh0LCAhMCksIGwueCArPSB0LmNsaWVudExlZnQsIGwueSArPSB0LmNsaWVudFRvcCkgOiBvICYmIChsLnggPSBycihvKSkpLCB7XG4gICAgeDogci5sZWZ0ICsgYS5zY3JvbGxMZWZ0IC0gbC54LFxuICAgIHk6IHIudG9wICsgYS5zY3JvbGxUb3AgLSBsLnksXG4gICAgd2lkdGg6IHIud2lkdGgsXG4gICAgaGVpZ2h0OiByLmhlaWdodFxuICB9O1xufVxuZnVuY3Rpb24gTWQocykge1xuICB2YXIgdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLCBpID0gW107XG4gIHMuZm9yRWFjaChmdW5jdGlvbihvKSB7XG4gICAgdC5zZXQoby5uYW1lLCBvKTtcbiAgfSk7XG4gIGZ1bmN0aW9uIG4obykge1xuICAgIGUuYWRkKG8ubmFtZSk7XG4gICAgdmFyIHIgPSBbXS5jb25jYXQoby5yZXF1aXJlcyB8fCBbXSwgby5yZXF1aXJlc0lmRXhpc3RzIHx8IFtdKTtcbiAgICByLmZvckVhY2goZnVuY3Rpb24oYSkge1xuICAgICAgaWYgKCFlLmhhcyhhKSkge1xuICAgICAgICB2YXIgbCA9IHQuZ2V0KGEpO1xuICAgICAgICBsICYmIG4obCk7XG4gICAgICB9XG4gICAgfSksIGkucHVzaChvKTtcbiAgfVxuICByZXR1cm4gcy5mb3JFYWNoKGZ1bmN0aW9uKG8pIHtcbiAgICBlLmhhcyhvLm5hbWUpIHx8IG4obyk7XG4gIH0pLCBpO1xufVxuZnVuY3Rpb24gUmQocykge1xuICB2YXIgdCA9IE1kKHMpO1xuICByZXR1cm4gZW4ucmVkdWNlKGZ1bmN0aW9uKGUsIGkpIHtcbiAgICByZXR1cm4gZS5jb25jYXQodC5maWx0ZXIoZnVuY3Rpb24obikge1xuICAgICAgcmV0dXJuIG4ucGhhc2UgPT09IGk7XG4gICAgfSkpO1xuICB9LCBbXSk7XG59XG5mdW5jdGlvbiBQZChzKSB7XG4gIHZhciB0O1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHQgfHwgKHQgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihlKSB7XG4gICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICB0ID0gdm9pZCAwLCBlKHMoKSk7XG4gICAgICB9KTtcbiAgICB9KSksIHQ7XG4gIH07XG59XG5mdW5jdGlvbiBWdChzKSB7XG4gIGZvciAodmFyIHQgPSBhcmd1bWVudHMubGVuZ3RoLCBlID0gbmV3IEFycmF5KHQgPiAxID8gdCAtIDEgOiAwKSwgaSA9IDE7IGkgPCB0OyBpKyspXG4gICAgZVtpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gIHJldHVybiBbXS5jb25jYXQoZSkucmVkdWNlKGZ1bmN0aW9uKG4sIG8pIHtcbiAgICByZXR1cm4gbi5yZXBsYWNlKC8lcy8sIG8pO1xuICB9LCBzKTtcbn1cbnZhciBhZSA9ICdQb3BwZXI6IG1vZGlmaWVyIFwiJXNcIiBwcm92aWRlZCBhbiBpbnZhbGlkICVzIHByb3BlcnR5LCBleHBlY3RlZCAlcyBidXQgZ290ICVzJywgQmQgPSAnUG9wcGVyOiBtb2RpZmllciBcIiVzXCIgcmVxdWlyZXMgXCIlc1wiLCBidXQgXCIlc1wiIG1vZGlmaWVyIGlzIG5vdCBhdmFpbGFibGUnLCBNciA9IFtcIm5hbWVcIiwgXCJlbmFibGVkXCIsIFwicGhhc2VcIiwgXCJmblwiLCBcImVmZmVjdFwiLCBcInJlcXVpcmVzXCIsIFwib3B0aW9uc1wiXTtcbmZ1bmN0aW9uIEhkKHMpIHtcbiAgcy5mb3JFYWNoKGZ1bmN0aW9uKHQpIHtcbiAgICBbXS5jb25jYXQoT2JqZWN0LmtleXModCksIE1yKS5maWx0ZXIoZnVuY3Rpb24oZSwgaSwgbikge1xuICAgICAgcmV0dXJuIG4uaW5kZXhPZihlKSA9PT0gaTtcbiAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uKGUpIHtcbiAgICAgIHN3aXRjaCAoZSkge1xuICAgICAgICBjYXNlIFwibmFtZVwiOlxuICAgICAgICAgIHR5cGVvZiB0Lm5hbWUgIT0gXCJzdHJpbmdcIiAmJiBjb25zb2xlLmVycm9yKFZ0KGFlLCBTdHJpbmcodC5uYW1lKSwgJ1wibmFtZVwiJywgJ1wic3RyaW5nXCInLCAnXCInICsgU3RyaW5nKHQubmFtZSkgKyAnXCInKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJlbmFibGVkXCI6XG4gICAgICAgICAgdHlwZW9mIHQuZW5hYmxlZCAhPSBcImJvb2xlYW5cIiAmJiBjb25zb2xlLmVycm9yKFZ0KGFlLCB0Lm5hbWUsICdcImVuYWJsZWRcIicsICdcImJvb2xlYW5cIicsICdcIicgKyBTdHJpbmcodC5lbmFibGVkKSArICdcIicpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInBoYXNlXCI6XG4gICAgICAgICAgZW4uaW5kZXhPZih0LnBoYXNlKSA8IDAgJiYgY29uc29sZS5lcnJvcihWdChhZSwgdC5uYW1lLCAnXCJwaGFzZVwiJywgXCJlaXRoZXIgXCIgKyBlbi5qb2luKFwiLCBcIiksICdcIicgKyBTdHJpbmcodC5waGFzZSkgKyAnXCInKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJmblwiOlxuICAgICAgICAgIHR5cGVvZiB0LmZuICE9IFwiZnVuY3Rpb25cIiAmJiBjb25zb2xlLmVycm9yKFZ0KGFlLCB0Lm5hbWUsICdcImZuXCInLCAnXCJmdW5jdGlvblwiJywgJ1wiJyArIFN0cmluZyh0LmZuKSArICdcIicpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImVmZmVjdFwiOlxuICAgICAgICAgIHQuZWZmZWN0ICE9IG51bGwgJiYgdHlwZW9mIHQuZWZmZWN0ICE9IFwiZnVuY3Rpb25cIiAmJiBjb25zb2xlLmVycm9yKFZ0KGFlLCB0Lm5hbWUsICdcImVmZmVjdFwiJywgJ1wiZnVuY3Rpb25cIicsICdcIicgKyBTdHJpbmcodC5mbikgKyAnXCInKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJyZXF1aXJlc1wiOlxuICAgICAgICAgIHQucmVxdWlyZXMgIT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheSh0LnJlcXVpcmVzKSAmJiBjb25zb2xlLmVycm9yKFZ0KGFlLCB0Lm5hbWUsICdcInJlcXVpcmVzXCInLCAnXCJhcnJheVwiJywgJ1wiJyArIFN0cmluZyh0LnJlcXVpcmVzKSArICdcIicpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInJlcXVpcmVzSWZFeGlzdHNcIjpcbiAgICAgICAgICBBcnJheS5pc0FycmF5KHQucmVxdWlyZXNJZkV4aXN0cykgfHwgY29uc29sZS5lcnJvcihWdChhZSwgdC5uYW1lLCAnXCJyZXF1aXJlc0lmRXhpc3RzXCInLCAnXCJhcnJheVwiJywgJ1wiJyArIFN0cmluZyh0LnJlcXVpcmVzSWZFeGlzdHMpICsgJ1wiJykpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwib3B0aW9uc1wiOlxuICAgICAgICBjYXNlIFwiZGF0YVwiOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1BvcHBlckpTOiBhbiBpbnZhbGlkIHByb3BlcnR5IGhhcyBiZWVuIHByb3ZpZGVkIHRvIHRoZSBcIicgKyB0Lm5hbWUgKyAnXCIgbW9kaWZpZXIsIHZhbGlkIHByb3BlcnRpZXMgYXJlICcgKyBNci5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgICAgICAgcmV0dXJuICdcIicgKyBpICsgJ1wiJztcbiAgICAgICAgICB9KS5qb2luKFwiLCBcIikgKyAnOyBidXQgXCInICsgZSArICdcIiB3YXMgcHJvdmlkZWQuJyk7XG4gICAgICB9XG4gICAgICB0LnJlcXVpcmVzICYmIHQucmVxdWlyZXMuZm9yRWFjaChmdW5jdGlvbihpKSB7XG4gICAgICAgIHMuZmluZChmdW5jdGlvbihuKSB7XG4gICAgICAgICAgcmV0dXJuIG4ubmFtZSA9PT0gaTtcbiAgICAgICAgfSkgPT0gbnVsbCAmJiBjb25zb2xlLmVycm9yKFZ0KEJkLCBTdHJpbmcodC5uYW1lKSwgaSwgaSkpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gVmQocywgdCkge1xuICB2YXIgZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIHJldHVybiBzLmZpbHRlcihmdW5jdGlvbihpKSB7XG4gICAgdmFyIG4gPSB0KGkpO1xuICAgIGlmICghZS5oYXMobikpXG4gICAgICByZXR1cm4gZS5hZGQobiksICEwO1xuICB9KTtcbn1cbmZ1bmN0aW9uIFdkKHMpIHtcbiAgdmFyIHQgPSBzLnJlZHVjZShmdW5jdGlvbihlLCBpKSB7XG4gICAgdmFyIG4gPSBlW2kubmFtZV07XG4gICAgcmV0dXJuIGVbaS5uYW1lXSA9IG4gPyBPYmplY3QuYXNzaWduKHt9LCBuLCBpLCB7XG4gICAgICBvcHRpb25zOiBPYmplY3QuYXNzaWduKHt9LCBuLm9wdGlvbnMsIGkub3B0aW9ucyksXG4gICAgICBkYXRhOiBPYmplY3QuYXNzaWduKHt9LCBuLmRhdGEsIGkuZGF0YSlcbiAgICB9KSA6IGksIGU7XG4gIH0sIHt9KTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHQpLm1hcChmdW5jdGlvbihlKSB7XG4gICAgcmV0dXJuIHRbZV07XG4gIH0pO1xufVxudmFyIFJyID0gXCJQb3BwZXI6IEludmFsaWQgcmVmZXJlbmNlIG9yIHBvcHBlciBhcmd1bWVudCBwcm92aWRlZC4gVGhleSBtdXN0IGJlIGVpdGhlciBhIERPTSBlbGVtZW50IG9yIHZpcnR1YWwgZWxlbWVudC5cIiwgRmQgPSBcIlBvcHBlcjogQW4gaW5maW5pdGUgbG9vcCBpbiB0aGUgbW9kaWZpZXJzIGN5Y2xlIGhhcyBiZWVuIGRldGVjdGVkISBUaGUgY3ljbGUgaGFzIGJlZW4gaW50ZXJydXB0ZWQgdG8gcHJldmVudCBhIGJyb3dzZXIgY3Jhc2guXCIsIFByID0ge1xuICBwbGFjZW1lbnQ6IFwiYm90dG9tXCIsXG4gIG1vZGlmaWVyczogW10sXG4gIHN0cmF0ZWd5OiBcImFic29sdXRlXCJcbn07XG5mdW5jdGlvbiBCcigpIHtcbiAgZm9yICh2YXIgcyA9IGFyZ3VtZW50cy5sZW5ndGgsIHQgPSBuZXcgQXJyYXkocyksIGUgPSAwOyBlIDwgczsgZSsrKVxuICAgIHRbZV0gPSBhcmd1bWVudHNbZV07XG4gIHJldHVybiAhdC5zb21lKGZ1bmN0aW9uKGkpIHtcbiAgICByZXR1cm4gIShpICYmIHR5cGVvZiBpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCA9PSBcImZ1bmN0aW9uXCIpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGFuKHMpIHtcbiAgcyA9PT0gdm9pZCAwICYmIChzID0ge30pO1xuICB2YXIgdCA9IHMsIGUgPSB0LmRlZmF1bHRNb2RpZmllcnMsIGkgPSBlID09PSB2b2lkIDAgPyBbXSA6IGUsIG4gPSB0LmRlZmF1bHRPcHRpb25zLCBvID0gbiA9PT0gdm9pZCAwID8gUHIgOiBuO1xuICByZXR1cm4gZnVuY3Rpb24oYSwgbCwgcCkge1xuICAgIHAgPT09IHZvaWQgMCAmJiAocCA9IG8pO1xuICAgIHZhciB1ID0ge1xuICAgICAgcGxhY2VtZW50OiBcImJvdHRvbVwiLFxuICAgICAgb3JkZXJlZE1vZGlmaWVyczogW10sXG4gICAgICBvcHRpb25zOiBPYmplY3QuYXNzaWduKHt9LCBQciwgbyksXG4gICAgICBtb2RpZmllcnNEYXRhOiB7fSxcbiAgICAgIGVsZW1lbnRzOiB7XG4gICAgICAgIHJlZmVyZW5jZTogYSxcbiAgICAgICAgcG9wcGVyOiBsXG4gICAgICB9LFxuICAgICAgYXR0cmlidXRlczoge30sXG4gICAgICBzdHlsZXM6IHt9XG4gICAgfSwgXyA9IFtdLCBmID0gITEsIGcgPSB7XG4gICAgICBzdGF0ZTogdSxcbiAgICAgIHNldE9wdGlvbnM6IGZ1bmN0aW9uKEMpIHtcbiAgICAgICAgdmFyIHcgPSB0eXBlb2YgQyA9PSBcImZ1bmN0aW9uXCIgPyBDKHUub3B0aW9ucykgOiBDO1xuICAgICAgICBiKCksIHUub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG8sIHUub3B0aW9ucywgdyksIHUuc2Nyb2xsUGFyZW50cyA9IHtcbiAgICAgICAgICByZWZlcmVuY2U6IEVlKGEpID8gSWkoYSkgOiBhLmNvbnRleHRFbGVtZW50ID8gSWkoYS5jb250ZXh0RWxlbWVudCkgOiBbXSxcbiAgICAgICAgICBwb3BwZXI6IElpKGwpXG4gICAgICAgIH07XG4gICAgICAgIHZhciBFID0gUmQoV2QoW10uY29uY2F0KGksIHUub3B0aW9ucy5tb2RpZmllcnMpKSk7XG4gICAgICAgIGlmICh1Lm9yZGVyZWRNb2RpZmllcnMgPSBFLmZpbHRlcihmdW5jdGlvbihTKSB7XG4gICAgICAgICAgcmV0dXJuIFMuZW5hYmxlZDtcbiAgICAgICAgfSksIHt9Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgIHZhciBUID0gVmQoW10uY29uY2F0KEUsIHUub3B0aW9ucy5tb2RpZmllcnMpLCBmdW5jdGlvbihTKSB7XG4gICAgICAgICAgICB2YXIgTiA9IFMubmFtZTtcbiAgICAgICAgICAgIHJldHVybiBOO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChIZChUKSwgVHQodS5vcHRpb25zLnBsYWNlbWVudCkgPT09IEhpKSB7XG4gICAgICAgICAgICB2YXIgQSA9IHUub3JkZXJlZE1vZGlmaWVycy5maW5kKGZ1bmN0aW9uKFMpIHtcbiAgICAgICAgICAgICAgdmFyIE4gPSBTLm5hbWU7XG4gICAgICAgICAgICAgIHJldHVybiBOID09PSBcImZsaXBcIjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgQSB8fCBjb25zb2xlLmVycm9yKFsnUG9wcGVyOiBcImF1dG9cIiBwbGFjZW1lbnRzIHJlcXVpcmUgdGhlIFwiZmxpcFwiIG1vZGlmaWVyIGJlJywgXCJwcmVzZW50IGFuZCBlbmFibGVkIHRvIHdvcmsuXCJdLmpvaW4oXCIgXCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGsgPSBDdChsKSwgSSA9IGsubWFyZ2luVG9wLCBPID0gay5tYXJnaW5SaWdodCwgeCA9IGsubWFyZ2luQm90dG9tLCBMID0gay5tYXJnaW5MZWZ0O1xuICAgICAgICAgIFtJLCBPLCB4LCBMXS5zb21lKGZ1bmN0aW9uKFMpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KFMpO1xuICAgICAgICAgIH0pICYmIGNvbnNvbGUud2FybihbJ1BvcHBlcjogQ1NTIFwibWFyZ2luXCIgc3R5bGVzIGNhbm5vdCBiZSB1c2VkIHRvIGFwcGx5IHBhZGRpbmcnLCBcImJldHdlZW4gdGhlIHBvcHBlciBhbmQgaXRzIHJlZmVyZW5jZSBlbGVtZW50IG9yIGJvdW5kYXJ5LlwiLCBcIlRvIHJlcGxpY2F0ZSBtYXJnaW4sIHVzZSB0aGUgYG9mZnNldGAgbW9kaWZpZXIsIGFzIHdlbGwgYXNcIiwgXCJ0aGUgYHBhZGRpbmdgIG9wdGlvbiBpbiB0aGUgYHByZXZlbnRPdmVyZmxvd2AgYW5kIGBmbGlwYFwiLCBcIm1vZGlmaWVycy5cIl0uam9pbihcIiBcIikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtKCksIGcudXBkYXRlKCk7XG4gICAgICB9LFxuICAgICAgLy8gU3luYyB1cGRhdGUg4oCTIGl0IHdpbGwgYWx3YXlzIGJlIGV4ZWN1dGVkLCBldmVuIGlmIG5vdCBuZWNlc3NhcnkuIFRoaXNcbiAgICAgIC8vIGlzIHVzZWZ1bCBmb3IgbG93IGZyZXF1ZW5jeSB1cGRhdGVzIHdoZXJlIHN5bmMgYmVoYXZpb3Igc2ltcGxpZmllcyB0aGVcbiAgICAgIC8vIGxvZ2ljLlxuICAgICAgLy8gRm9yIGhpZ2ggZnJlcXVlbmN5IHVwZGF0ZXMgKGUuZy4gYHJlc2l6ZWAgYW5kIGBzY3JvbGxgIGV2ZW50cyksIGFsd2F5c1xuICAgICAgLy8gcHJlZmVyIHRoZSBhc3luYyBQb3BwZXIjdXBkYXRlIG1ldGhvZFxuICAgICAgZm9yY2VVcGRhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIWYpIHtcbiAgICAgICAgICB2YXIgQyA9IHUuZWxlbWVudHMsIHcgPSBDLnJlZmVyZW5jZSwgRSA9IEMucG9wcGVyO1xuICAgICAgICAgIGlmICghQnIodywgRSkpIHtcbiAgICAgICAgICAgICh7fSkuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGNvbnNvbGUuZXJyb3IoUnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB1LnJlY3RzID0ge1xuICAgICAgICAgICAgcmVmZXJlbmNlOiBOZCh3LCBWaShFKSwgdS5vcHRpb25zLnN0cmF0ZWd5ID09PSBcImZpeGVkXCIpLFxuICAgICAgICAgICAgcG9wcGVyOiBlcihFKVxuICAgICAgICAgIH0sIHUucmVzZXQgPSAhMSwgdS5wbGFjZW1lbnQgPSB1Lm9wdGlvbnMucGxhY2VtZW50LCB1Lm9yZGVyZWRNb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbihTKSB7XG4gICAgICAgICAgICByZXR1cm4gdS5tb2RpZmllcnNEYXRhW1MubmFtZV0gPSBPYmplY3QuYXNzaWduKHt9LCBTLmRhdGEpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGZvciAodmFyIFQgPSAwLCBBID0gMDsgQSA8IHUub3JkZXJlZE1vZGlmaWVycy5sZW5ndGg7IEErKykge1xuICAgICAgICAgICAgaWYgKHt9Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAoVCArPSAxLCBUID4gMTAwKSkge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKEZkKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodS5yZXNldCA9PT0gITApIHtcbiAgICAgICAgICAgICAgdS5yZXNldCA9ICExLCBBID0gLTE7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGsgPSB1Lm9yZGVyZWRNb2RpZmllcnNbQV0sIEkgPSBrLmZuLCBPID0gay5vcHRpb25zLCB4ID0gTyA9PT0gdm9pZCAwID8ge30gOiBPLCBMID0gay5uYW1lO1xuICAgICAgICAgICAgdHlwZW9mIEkgPT0gXCJmdW5jdGlvblwiICYmICh1ID0gSSh7XG4gICAgICAgICAgICAgIHN0YXRlOiB1LFxuICAgICAgICAgICAgICBvcHRpb25zOiB4LFxuICAgICAgICAgICAgICBuYW1lOiBMLFxuICAgICAgICAgICAgICBpbnN0YW5jZTogZ1xuICAgICAgICAgICAgfSkgfHwgdSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gQXN5bmMgYW5kIG9wdGltaXN0aWNhbGx5IG9wdGltaXplZCB1cGRhdGUg4oCTIGl0IHdpbGwgbm90IGJlIGV4ZWN1dGVkIGlmXG4gICAgICAvLyBub3QgbmVjZXNzYXJ5IChkZWJvdW5jZWQgdG8gcnVuIGF0IG1vc3Qgb25jZS1wZXItdGljaylcbiAgICAgIHVwZGF0ZTogUGQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbih2KSB7XG4gICAgICAgICAgZy5mb3JjZVVwZGF0ZSgpLCB2KHUpO1xuICAgICAgICB9KTtcbiAgICAgIH0pLFxuICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGIoKSwgZiA9ICEwO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKCFCcihhLCBsKSlcbiAgICAgIHJldHVybiB7fS5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgY29uc29sZS5lcnJvcihSciksIGc7XG4gICAgZy5zZXRPcHRpb25zKHApLnRoZW4oZnVuY3Rpb24odikge1xuICAgICAgIWYgJiYgcC5vbkZpcnN0VXBkYXRlICYmIHAub25GaXJzdFVwZGF0ZSh2KTtcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBtKCkge1xuICAgICAgdS5vcmRlcmVkTW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24odikge1xuICAgICAgICB2YXIgQyA9IHYubmFtZSwgdyA9IHYub3B0aW9ucywgRSA9IHcgPT09IHZvaWQgMCA/IHt9IDogdywgVCA9IHYuZWZmZWN0O1xuICAgICAgICBpZiAodHlwZW9mIFQgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgdmFyIEEgPSBUKHtcbiAgICAgICAgICAgIHN0YXRlOiB1LFxuICAgICAgICAgICAgbmFtZTogQyxcbiAgICAgICAgICAgIGluc3RhbmNlOiBnLFxuICAgICAgICAgICAgb3B0aW9uczogRVxuICAgICAgICAgIH0pLCBrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBfLnB1c2goQSB8fCBrKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGIoKSB7XG4gICAgICBfLmZvckVhY2goZnVuY3Rpb24odikge1xuICAgICAgICByZXR1cm4gdigpO1xuICAgICAgfSksIF8gPSBbXTtcbiAgICB9XG4gICAgcmV0dXJuIGc7XG4gIH07XG59XG52YXIgWWQgPSAvKiBAX19QVVJFX18gKi8gYW4oKSwgamQgPSBbbnIsIGxyLCBzciwgdHJdLCBLZCA9IC8qIEBfX1BVUkVfXyAqLyBhbih7XG4gIGRlZmF1bHRNb2RpZmllcnM6IGpkXG59KSwgemQgPSBbbnIsIGxyLCBzciwgdHIsIE9jLCBrYywgU2MsIEFjLCB4Y10sIENlID0gLyogQF9fUFVSRV9fICovIGFuKHtcbiAgZGVmYXVsdE1vZGlmaWVyczogemRcbn0pO1xuY29uc3QgSWMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmZyZWV6ZSgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmRlZmluZVByb3BlcnR5KHtcbiAgX19wcm90b19fOiBudWxsLFxuICBhZnRlck1haW46IF9jLFxuICBhZnRlclJlYWQ6IGRjLFxuICBhZnRlcldyaXRlOiBnYyxcbiAgYXBwbHlTdHlsZXM6IHRyLFxuICBhcnJvdzogQWMsXG4gIGF1dG86IEhpLFxuICBiYXNlUGxhY2VtZW50czogdGksXG4gIGJlZm9yZU1haW46IHVjLFxuICBiZWZvcmVSZWFkOiBjYyxcbiAgYmVmb3JlV3JpdGU6IGZjLFxuICBib3R0b206IGR0LFxuICBjbGlwcGluZ1BhcmVudHM6IGFjLFxuICBjb21wdXRlU3R5bGVzOiBzcixcbiAgY3JlYXRlUG9wcGVyOiBDZSxcbiAgY3JlYXRlUG9wcGVyQmFzZTogWWQsXG4gIGNyZWF0ZVBvcHBlckxpdGU6IEtkLFxuICBkZXRlY3RPdmVyZmxvdzogR2UsXG4gIGVuZDogS2UsXG4gIGV2ZW50TGlzdGVuZXJzOiBucixcbiAgZmxpcDoga2MsXG4gIGhpZGU6IHhjLFxuICBsZWZ0OiBKLFxuICBtYWluOiBwYyxcbiAgbW9kaWZpZXJQaGFzZXM6IGVuLFxuICBvZmZzZXQ6IE9jLFxuICBwbGFjZW1lbnRzOiBRbyxcbiAgcG9wcGVyOiAkZSxcbiAgcG9wcGVyR2VuZXJhdG9yOiBhbixcbiAgcG9wcGVyT2Zmc2V0czogbHIsXG4gIHByZXZlbnRPdmVyZmxvdzogU2MsXG4gIHJlYWQ6IGhjLFxuICByZWZlcmVuY2U6IGxjLFxuICByaWdodDogdXQsXG4gIHN0YXJ0OiBUZSxcbiAgdG9wOiBRLFxuICB2YXJpYXRpb25QbGFjZW1lbnRzOiBTbyxcbiAgdmlld3BvcnQ6IFpvLFxuICB3cml0ZTogbWNcbn0sIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogXCJNb2R1bGVcIiB9KSk7XG5mdW5jdGlvbiBBbihzKSB7XG4gIHJldHVybiBzID09PSBcInRydWVcIiA/ICEwIDogcyA9PT0gXCJmYWxzZVwiID8gITEgOiBzID09PSBOdW1iZXIocykudG9TdHJpbmcoKSA/IE51bWJlcihzKSA6IHMgPT09IFwiXCIgfHwgcyA9PT0gXCJudWxsXCIgPyBudWxsIDogcztcbn1cbmZ1bmN0aW9uIHluKHMpIHtcbiAgcmV0dXJuIHMucmVwbGFjZSgvW0EtWl0vZywgKHQpID0+IGAtJHt0LnRvTG93ZXJDYXNlKCl9YCk7XG59XG5jb25zdCBoID0ge1xuICBzZXREYXRhQXR0cmlidXRlKHMsIHQsIGUpIHtcbiAgICBzLnNldEF0dHJpYnV0ZShgZGF0YS10ZS0ke3luKHQpfWAsIGUpO1xuICB9LFxuICByZW1vdmVEYXRhQXR0cmlidXRlKHMsIHQpIHtcbiAgICBzLnJlbW92ZUF0dHJpYnV0ZShgZGF0YS10ZS0ke3luKHQpfWApO1xuICB9LFxuICBnZXREYXRhQXR0cmlidXRlcyhzKSB7XG4gICAgaWYgKCFzKVxuICAgICAgcmV0dXJuIHt9O1xuICAgIGNvbnN0IHQgPSB7fTtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMocy5kYXRhc2V0KS5maWx0ZXIoKGUpID0+IGUuc3RhcnRzV2l0aChcInRlXCIpKS5mb3JFYWNoKChlKSA9PiB7XG4gICAgICBpZiAoZS5zdGFydHNXaXRoKFwidGVDbGFzc1wiKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgbGV0IGkgPSBlLnJlcGxhY2UoL150ZS8sIFwiXCIpO1xuICAgICAgaSA9IGkuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkgKyBpLnNsaWNlKDEsIGkubGVuZ3RoKSwgdFtpXSA9IEFuKHMuZGF0YXNldFtlXSk7XG4gICAgfSksIHQ7XG4gIH0sXG4gIGdldERhdGFDbGFzc0F0dHJpYnV0ZXMocykge1xuICAgIGlmICghcylcbiAgICAgIHJldHVybiB7fTtcbiAgICBjb25zdCB0ID0ge1xuICAgICAgLi4ucy5kYXRhc2V0XG4gICAgfTtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModCkuZmlsdGVyKChlKSA9PiBlLnN0YXJ0c1dpdGgoXCJ0ZUNsYXNzXCIpKS5mb3JFYWNoKChlKSA9PiB7XG4gICAgICBsZXQgaSA9IGUucmVwbGFjZSgvXnRlQ2xhc3MvLCBcIlwiKTtcbiAgICAgIGkgPSBpLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpICsgaS5zbGljZSgxLCBpLmxlbmd0aCksIHRbaV0gPSBBbih0W2VdKTtcbiAgICB9KSwgdDtcbiAgfSxcbiAgZ2V0RGF0YUF0dHJpYnV0ZShzLCB0KSB7XG4gICAgcmV0dXJuIEFuKFxuICAgICAgcy5nZXRBdHRyaWJ1dGUoYGRhdGEtdGUtJHt5bih0KX1gKVxuICAgICk7XG4gIH0sXG4gIG9mZnNldChzKSB7XG4gICAgY29uc3QgdCA9IHMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvcDogdC50b3AgKyBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCxcbiAgICAgIGxlZnQ6IHQubGVmdCArIGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdFxuICAgIH07XG4gIH0sXG4gIHBvc2l0aW9uKHMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9wOiBzLm9mZnNldFRvcCxcbiAgICAgIGxlZnQ6IHMub2Zmc2V0TGVmdFxuICAgIH07XG4gIH0sXG4gIHN0eWxlKHMsIHQpIHtcbiAgICBPYmplY3QuYXNzaWduKHMuc3R5bGUsIHQpO1xuICB9LFxuICB0b2dnbGVDbGFzcyhzLCB0KSB7XG4gICAgcyAmJiB3bih0KS5mb3JFYWNoKChlKSA9PiB7XG4gICAgICBzLmNsYXNzTGlzdC5jb250YWlucyhlKSA/IHMuY2xhc3NMaXN0LnJlbW92ZShlKSA6IHMuY2xhc3NMaXN0LmFkZChlKTtcbiAgICB9KTtcbiAgfSxcbiAgYWRkQ2xhc3MocywgdCkge1xuICAgIHduKHQpLmZvckVhY2goXG4gICAgICAoZSkgPT4gIXMuY2xhc3NMaXN0LmNvbnRhaW5zKGUpICYmIHMuY2xhc3NMaXN0LmFkZChlKVxuICAgICk7XG4gIH0sXG4gIGFkZFN0eWxlKHMsIHQpIHtcbiAgICBPYmplY3Qua2V5cyh0KS5mb3JFYWNoKChlKSA9PiB7XG4gICAgICBzLnN0eWxlW2VdID0gdFtlXTtcbiAgICB9KTtcbiAgfSxcbiAgcmVtb3ZlQ2xhc3MocywgdCkge1xuICAgIHduKHQpLmZvckVhY2goXG4gICAgICAoZSkgPT4gcy5jbGFzc0xpc3QuY29udGFpbnMoZSkgJiYgcy5jbGFzc0xpc3QucmVtb3ZlKGUpXG4gICAgKTtcbiAgfSxcbiAgaGFzQ2xhc3MocywgdCkge1xuICAgIHJldHVybiBzLmNsYXNzTGlzdC5jb250YWlucyh0KTtcbiAgfSxcbiAgbWF4T2Zmc2V0KHMpIHtcbiAgICBjb25zdCB0ID0gcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4ge1xuICAgICAgdG9wOiB0LnRvcCArIE1hdGgubWF4KFxuICAgICAgICBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCxcbiAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCxcbiAgICAgICAgd2luZG93LnNjcm9sbFlcbiAgICAgICksXG4gICAgICBsZWZ0OiB0LmxlZnQgKyBNYXRoLm1heChcbiAgICAgICAgZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0LFxuICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCxcbiAgICAgICAgd2luZG93LnNjcm9sbFhcbiAgICAgIClcbiAgICB9O1xuICB9XG59O1xuZnVuY3Rpb24gd24ocykge1xuICByZXR1cm4gdHlwZW9mIHMgPT0gXCJzdHJpbmdcIiA/IHMuc3BsaXQoXCIgXCIpIDogQXJyYXkuaXNBcnJheShzKSA/IHMgOiAhMTtcbn1cbmNvbnN0IFVkID0gMywgZCA9IHtcbiAgY2xvc2VzdChzLCB0KSB7XG4gICAgcmV0dXJuIHMuY2xvc2VzdCh0KTtcbiAgfSxcbiAgbWF0Y2hlcyhzLCB0KSB7XG4gICAgcmV0dXJuIHMubWF0Y2hlcyh0KTtcbiAgfSxcbiAgZmluZChzLCB0ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgcmV0dXJuIFtdLmNvbmNhdChcbiAgICAgIC4uLkVsZW1lbnQucHJvdG90eXBlLnF1ZXJ5U2VsZWN0b3JBbGwuY2FsbCh0LCBzKVxuICAgICk7XG4gIH0sXG4gIGZpbmRPbmUocywgdCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgIHJldHVybiBFbGVtZW50LnByb3RvdHlwZS5xdWVyeVNlbGVjdG9yLmNhbGwodCwgcyk7XG4gIH0sXG4gIGNoaWxkcmVuKHMsIHQpIHtcbiAgICByZXR1cm4gW10uY29uY2F0KC4uLnMuY2hpbGRyZW4pLmZpbHRlcigoaSkgPT4gaS5tYXRjaGVzKHQpKTtcbiAgfSxcbiAgcGFyZW50cyhzLCB0KSB7XG4gICAgY29uc3QgZSA9IFtdO1xuICAgIGxldCBpID0gcy5wYXJlbnROb2RlO1xuICAgIGZvciAoOyBpICYmIGkubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFICYmIGkubm9kZVR5cGUgIT09IFVkOyApXG4gICAgICB0aGlzLm1hdGNoZXMoaSwgdCkgJiYgZS5wdXNoKGkpLCBpID0gaS5wYXJlbnROb2RlO1xuICAgIHJldHVybiBlO1xuICB9LFxuICBwcmV2KHMsIHQpIHtcbiAgICBsZXQgZSA9IHMucHJldmlvdXNFbGVtZW50U2libGluZztcbiAgICBmb3IgKDsgZTsgKSB7XG4gICAgICBpZiAoZS5tYXRjaGVzKHQpKVxuICAgICAgICByZXR1cm4gW2VdO1xuICAgICAgZSA9IGUucHJldmlvdXNFbGVtZW50U2libGluZztcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xuICB9LFxuICBuZXh0KHMsIHQpIHtcbiAgICBsZXQgZSA9IHMubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgIGZvciAoOyBlOyApIHtcbiAgICAgIGlmICh0aGlzLm1hdGNoZXMoZSwgdCkpXG4gICAgICAgIHJldHVybiBbZV07XG4gICAgICBlID0gZS5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfSxcbiAgZm9jdXNhYmxlQ2hpbGRyZW4ocykge1xuICAgIGNvbnN0IHQgPSBbXG4gICAgICBcImFcIixcbiAgICAgIFwiYnV0dG9uXCIsXG4gICAgICBcImlucHV0XCIsXG4gICAgICBcInRleHRhcmVhXCIsXG4gICAgICBcInNlbGVjdFwiLFxuICAgICAgXCJkZXRhaWxzXCIsXG4gICAgICBcIlt0YWJpbmRleF1cIixcbiAgICAgICdbY29udGVudGVkaXRhYmxlPVwidHJ1ZVwiXSdcbiAgICBdLm1hcCgoZSkgPT4gYCR7ZX06bm90KFt0YWJpbmRleF49XCItXCJdKWApLmpvaW4oXCIsIFwiKTtcbiAgICByZXR1cm4gdGhpcy5maW5kKHQsIHMpLmZpbHRlcihcbiAgICAgIChlKSA9PiAhZ2UoZSkgJiYgTnQoZSlcbiAgICApO1xuICB9XG59LCBrbiA9IFwiZHJvcGRvd25cIiwgWGQgPSBcInRlLmRyb3Bkb3duXCIsIEFlID0gYC4ke1hkfWAsIGNyID0gXCIuZGF0YS1hcGlcIiwgUnMgPSBcIkVzY2FwZVwiLCBIciA9IFwiU3BhY2VcIiwgVnIgPSBcIlRhYlwiLCAkbyA9IFwiQXJyb3dVcFwiLCBQcyA9IFwiQXJyb3dEb3duXCIsIEdkID0gMiwgcWQgPSBuZXcgUmVnRXhwKFxuICBgJHskb318JHtQc318JHtSc31gXG4pLCBaZCA9IGBoaWRlJHtBZX1gLCBRZCA9IGBoaWRkZW4ke0FlfWAsIEpkID0gYHNob3cke0FlfWAsIHR1ID0gYHNob3duJHtBZX1gLCBldSA9IGBjbGljayR7QWV9JHtjcn1gLCBXciA9IGBrZXlkb3duJHtBZX0ke2NyfWAsIGl1ID0gYGtleXVwJHtBZX0ke2NyfWAsIFd0ID0gXCJzaG93XCIsIHN1ID0gXCJkcm9wdXBcIiwgbnUgPSBcImRyb3BlbmRcIiwgb3UgPSBcImRyb3BzdGFydFwiLCBydSA9IFwiW2RhdGEtdGUtbmF2YmFyLXJlZl1cIiwgZXMgPSBcIltkYXRhLXRlLWRyb3Bkb3duLXRvZ2dsZS1yZWZdXCIsIHhuID0gXCJbZGF0YS10ZS1kcm9wZG93bi1tZW51LXJlZl1cIiwgYXUgPSBcIltkYXRhLXRlLW5hdmJhci1uYXYtcmVmXVwiLCBsdSA9IFwiW2RhdGEtdGUtZHJvcGRvd24tbWVudS1yZWZdIFtkYXRhLXRlLWRyb3Bkb3duLWl0ZW0tcmVmXTpub3QoLmRpc2FibGVkKTpub3QoOmRpc2FibGVkKVwiLCBjdSA9IEYoKSA/IFwidG9wLWVuZFwiIDogXCJ0b3Atc3RhcnRcIiwgaHUgPSBGKCkgPyBcInRvcC1zdGFydFwiIDogXCJ0b3AtZW5kXCIsIGR1ID0gRigpID8gXCJib3R0b20tZW5kXCIgOiBcImJvdHRvbS1zdGFydFwiLCB1dSA9IEYoKSA/IFwiYm90dG9tLXN0YXJ0XCIgOiBcImJvdHRvbS1lbmRcIiwgcHUgPSBGKCkgPyBcImxlZnQtc3RhcnRcIiA6IFwicmlnaHQtc3RhcnRcIiwgX3UgPSBGKCkgPyBcInJpZ2h0LXN0YXJ0XCIgOiBcImxlZnQtc3RhcnRcIiwgZnUgPSBbeyBvcGFjaXR5OiBcIjBcIiB9LCB7IG9wYWNpdHk6IFwiMVwiIH1dLCBtdSA9IFt7IG9wYWNpdHk6IFwiMVwiIH0sIHsgb3BhY2l0eTogXCIwXCIgfV0sIGlzID0ge1xuICBkdXJhdGlvbjogNTUwLFxuICBpdGVyYXRpb25zOiAxLFxuICBlYXNpbmc6IFwiZWFzZVwiLFxuICBmaWxsOiBcImJvdGhcIlxufSwgZ3UgPSB7XG4gIG9mZnNldDogWzAsIDJdLFxuICBib3VuZGFyeTogXCJjbGlwcGluZ1BhcmVudHNcIixcbiAgcmVmZXJlbmNlOiBcInRvZ2dsZVwiLFxuICBkaXNwbGF5OiBcImR5bmFtaWNcIixcbiAgcG9wcGVyQ29uZmlnOiBudWxsLFxuICBhdXRvQ2xvc2U6ICEwLFxuICBkcm9wZG93bkFuaW1hdGlvbjogXCJvblwiXG59LCBidSA9IHtcbiAgb2Zmc2V0OiBcIihhcnJheXxzdHJpbmd8ZnVuY3Rpb24pXCIsXG4gIGJvdW5kYXJ5OiBcIihzdHJpbmd8ZWxlbWVudClcIixcbiAgcmVmZXJlbmNlOiBcIihzdHJpbmd8ZWxlbWVudHxvYmplY3QpXCIsXG4gIGRpc3BsYXk6IFwic3RyaW5nXCIsXG4gIHBvcHBlckNvbmZpZzogXCIobnVsbHxvYmplY3R8ZnVuY3Rpb24pXCIsXG4gIGF1dG9DbG9zZTogXCIoYm9vbGVhbnxzdHJpbmcpXCIsXG4gIGRyb3Bkb3duQW5pbWF0aW9uOiBcInN0cmluZ1wiXG59O1xuY2xhc3MgRHQgZXh0ZW5kcyBndCB7XG4gIGNvbnN0cnVjdG9yKHQsIGUpIHtcbiAgICBzdXBlcih0KSwgdGhpcy5fcG9wcGVyID0gbnVsbCwgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLl9tZW51ID0gdGhpcy5fZ2V0TWVudUVsZW1lbnQoKSwgdGhpcy5faW5OYXZiYXIgPSB0aGlzLl9kZXRlY3ROYXZiYXIoKSwgdGhpcy5fZmFkZU91dEFuaW1hdGUgPSBudWxsO1xuICAgIGNvbnN0IGkgPSB3aW5kb3cubWF0Y2hNZWRpYShcbiAgICAgIFwiKHByZWZlcnMtcmVkdWNlZC1tb3Rpb246IHJlZHVjZSlcIlxuICAgICkubWF0Y2hlcztcbiAgICB0aGlzLl9hbmltYXRpb25DYW5QbGF5ID0gdGhpcy5fY29uZmlnLmRyb3Bkb3duQW5pbWF0aW9uID09PSBcIm9uXCIgJiYgIWksIHRoaXMuX2RpZEluaXQgPSAhMSwgdGhpcy5faW5pdCgpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgIHJldHVybiBndTtcbiAgfVxuICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgIHJldHVybiBidTtcbiAgfVxuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIGtuO1xuICB9XG4gIC8vIFB1YmxpY1xuICB0b2dnbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzU2hvd24oKSA/IHRoaXMuaGlkZSgpIDogdGhpcy5zaG93KCk7XG4gIH1cbiAgc2hvdygpIHtcbiAgICBpZiAoZ2UodGhpcy5fZWxlbWVudCkgfHwgdGhpcy5faXNTaG93bih0aGlzLl9tZW51KSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB0ID0ge1xuICAgICAgcmVsYXRlZFRhcmdldDogdGhpcy5fZWxlbWVudFxuICAgIH07XG4gICAgaWYgKGMudHJpZ2dlcihcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBKZCxcbiAgICAgIHRcbiAgICApLmRlZmF1bHRQcmV2ZW50ZWQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgaSA9IER0LmdldFBhcmVudEZyb21FbGVtZW50KHRoaXMuX2VsZW1lbnQpO1xuICAgIHRoaXMuX2luTmF2YmFyID8gaC5zZXREYXRhQXR0cmlidXRlKHRoaXMuX21lbnUsIFwicG9wcGVyXCIsIFwibm9uZVwiKSA6IHRoaXMuX2NyZWF0ZVBvcHBlcihpKSwgXCJvbnRvdWNoc3RhcnRcIiBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgIWkuY2xvc2VzdChhdSkgJiYgW10uY29uY2F0KC4uLmRvY3VtZW50LmJvZHkuY2hpbGRyZW4pLmZvckVhY2goKG4pID0+IGMub24obiwgXCJtb3VzZW92ZXJcIiwgdG4pKSwgdGhpcy5fZWxlbWVudC5mb2N1cygpLCB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtZXhwYW5kZWRcIiwgITApLCB0aGlzLl9tZW51LnNldEF0dHJpYnV0ZShgZGF0YS10ZS1kcm9wZG93bi0ke1d0fWAsIFwiXCIpLCB0aGlzLl9hbmltYXRpb25DYW5QbGF5ICYmIHRoaXMuX21lbnUuYW5pbWF0ZShmdSwgaXMpLCB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShgZGF0YS10ZS1kcm9wZG93bi0ke1d0fWAsIFwiXCIpLCBzZXRUaW1lb3V0KFxuICAgICAgKCkgPT4ge1xuICAgICAgICBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgdHUsIHQpO1xuICAgICAgfSxcbiAgICAgIHRoaXMuX2FuaW1hdGlvbkNhblBsYXkgPyBpcy5kdXJhdGlvbiA6IDBcbiAgICApO1xuICB9XG4gIGhpZGUoKSB7XG4gICAgaWYgKGdlKHRoaXMuX2VsZW1lbnQpIHx8ICF0aGlzLl9pc1Nob3duKHRoaXMuX21lbnUpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHQgPSB7XG4gICAgICByZWxhdGVkVGFyZ2V0OiB0aGlzLl9lbGVtZW50XG4gICAgfTtcbiAgICB0aGlzLl9jb21wbGV0ZUhpZGUodCk7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLl9wb3BwZXIgJiYgdGhpcy5fcG9wcGVyLmRlc3Ryb3koKSwgc3VwZXIuZGlzcG9zZSgpO1xuICB9XG4gIHVwZGF0ZSgpIHtcbiAgICB0aGlzLl9pbk5hdmJhciA9IHRoaXMuX2RldGVjdE5hdmJhcigpLCB0aGlzLl9wb3BwZXIgJiYgdGhpcy5fcG9wcGVyLnVwZGF0ZSgpO1xuICB9XG4gIC8vIFByaXZhdGVcbiAgX2luaXQoKSB7XG4gICAgdGhpcy5fZGlkSW5pdCB8fCAoYy5vbihcbiAgICAgIGRvY3VtZW50LFxuICAgICAgV3IsXG4gICAgICBlcyxcbiAgICAgIER0LmRhdGFBcGlLZXlkb3duSGFuZGxlclxuICAgICksIGMub24oXG4gICAgICBkb2N1bWVudCxcbiAgICAgIFdyLFxuICAgICAgeG4sXG4gICAgICBEdC5kYXRhQXBpS2V5ZG93bkhhbmRsZXJcbiAgICApLCBjLm9uKGRvY3VtZW50LCBldSwgRHQuY2xlYXJNZW51cyksIGMub24oZG9jdW1lbnQsIGl1LCBEdC5jbGVhck1lbnVzKSwgdGhpcy5fZGlkSW5pdCA9ICEwKTtcbiAgfVxuICBfY29tcGxldGVIaWRlKHQpIHtcbiAgICB0aGlzLl9mYWRlT3V0QW5pbWF0ZSAmJiB0aGlzLl9mYWRlT3V0QW5pbWF0ZS5wbGF5U3RhdGUgPT09IFwicnVubmluZ1wiIHx8IGMudHJpZ2dlcihcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBaZCxcbiAgICAgIHRcbiAgICApLmRlZmF1bHRQcmV2ZW50ZWQgfHwgKFwib250b3VjaHN0YXJ0XCIgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIFtdLmNvbmNhdCguLi5kb2N1bWVudC5ib2R5LmNoaWxkcmVuKS5mb3JFYWNoKChpKSA9PiBjLm9mZihpLCBcIm1vdXNlb3ZlclwiLCB0bikpLCB0aGlzLl9hbmltYXRpb25DYW5QbGF5ICYmICh0aGlzLl9mYWRlT3V0QW5pbWF0ZSA9IHRoaXMuX21lbnUuYW5pbWF0ZShcbiAgICAgIG11LFxuICAgICAgaXNcbiAgICApKSwgc2V0VGltZW91dChcbiAgICAgICgpID0+IHtcbiAgICAgICAgdGhpcy5fcG9wcGVyICYmIHRoaXMuX3BvcHBlci5kZXN0cm95KCksIHRoaXMuX21lbnUucmVtb3ZlQXR0cmlidXRlKGBkYXRhLXRlLWRyb3Bkb3duLSR7V3R9YCksIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGBkYXRhLXRlLWRyb3Bkb3duLSR7V3R9YCksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiLCBcImZhbHNlXCIpLCBoLnJlbW92ZURhdGFBdHRyaWJ1dGUodGhpcy5fbWVudSwgXCJwb3BwZXJcIiksIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBRZCwgdCk7XG4gICAgICB9LFxuICAgICAgdGhpcy5fYW5pbWF0aW9uQ2FuUGxheSA/IGlzLmR1cmF0aW9uIDogMFxuICAgICkpO1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIGlmICh0ID0ge1xuICAgICAgLi4udGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0LFxuICAgICAgLi4uaC5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KSxcbiAgICAgIC4uLnRcbiAgICB9LCBEKGtuLCB0LCB0aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHRUeXBlKSwgdHlwZW9mIHQucmVmZXJlbmNlID09IFwib2JqZWN0XCIgJiYgIWplKHQucmVmZXJlbmNlKSAmJiB0eXBlb2YgdC5yZWZlcmVuY2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ICE9IFwiZnVuY3Rpb25cIilcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgIGAke2tuLnRvVXBwZXJDYXNlKCl9OiBPcHRpb24gXCJyZWZlcmVuY2VcIiBwcm92aWRlZCB0eXBlIFwib2JqZWN0XCIgd2l0aG91dCBhIHJlcXVpcmVkIFwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0XCIgbWV0aG9kLmBcbiAgICAgICk7XG4gICAgcmV0dXJuIHQ7XG4gIH1cbiAgX2NyZWF0ZVBvcHBlcih0KSB7XG4gICAgaWYgKHR5cGVvZiBJYyA+IFwidVwiKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgXCJCb290c3RyYXAncyBkcm9wZG93bnMgcmVxdWlyZSBQb3BwZXIgKGh0dHBzOi8vcG9wcGVyLmpzLm9yZylcIlxuICAgICAgKTtcbiAgICBsZXQgZSA9IHRoaXMuX2VsZW1lbnQ7XG4gICAgdGhpcy5fY29uZmlnLnJlZmVyZW5jZSA9PT0gXCJwYXJlbnRcIiA/IGUgPSB0IDogamUodGhpcy5fY29uZmlnLnJlZmVyZW5jZSkgPyBlID0gdGUodGhpcy5fY29uZmlnLnJlZmVyZW5jZSkgOiB0eXBlb2YgdGhpcy5fY29uZmlnLnJlZmVyZW5jZSA9PSBcIm9iamVjdFwiICYmIChlID0gdGhpcy5fY29uZmlnLnJlZmVyZW5jZSk7XG4gICAgY29uc3QgaSA9IHRoaXMuX2dldFBvcHBlckNvbmZpZygpLCBuID0gaS5tb2RpZmllcnMuZmluZChcbiAgICAgIChvKSA9PiBvLm5hbWUgPT09IFwiYXBwbHlTdHlsZXNcIiAmJiBvLmVuYWJsZWQgPT09ICExXG4gICAgKTtcbiAgICB0aGlzLl9wb3BwZXIgPSBDZShcbiAgICAgIGUsXG4gICAgICB0aGlzLl9tZW51LFxuICAgICAgaVxuICAgICksIG4gJiYgaC5zZXREYXRhQXR0cmlidXRlKHRoaXMuX21lbnUsIFwicG9wcGVyXCIsIFwic3RhdGljXCIpO1xuICB9XG4gIF9pc1Nob3duKHQgPSB0aGlzLl9lbGVtZW50KSB7XG4gICAgcmV0dXJuIHQuZGF0YXNldFtgdGVEcm9wZG93biR7V3QuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBXdC5zbGljZSgxKX1gXSA9PT0gXCJcIjtcbiAgfVxuICBfZ2V0TWVudUVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIGQubmV4dCh0aGlzLl9lbGVtZW50LCB4bilbMF07XG4gIH1cbiAgX2dldFBsYWNlbWVudCgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fZWxlbWVudC5wYXJlbnROb2RlO1xuICAgIGlmICh0LmRhdGFzZXQudGVEcm9wZG93blBvc2l0aW9uID09PSBudSlcbiAgICAgIHJldHVybiBwdTtcbiAgICBpZiAodC5kYXRhc2V0LnRlRHJvcGRvd25Qb3NpdGlvbiA9PT0gb3UpXG4gICAgICByZXR1cm4gX3U7XG4gICAgY29uc3QgZSA9IHQuZGF0YXNldC50ZURyb3Bkb3duQWxpZ25tZW50ID09PSBcImVuZFwiO1xuICAgIHJldHVybiB0LmRhdGFzZXQudGVEcm9wZG93blBvc2l0aW9uID09PSBzdSA/IGUgPyBodSA6IGN1IDogZSA/IHV1IDogZHU7XG4gIH1cbiAgX2RldGVjdE5hdmJhcigpIHtcbiAgICByZXR1cm4gdGhpcy5fZWxlbWVudC5jbG9zZXN0KHJ1KSAhPT0gbnVsbDtcbiAgfVxuICBfZ2V0T2Zmc2V0KCkge1xuICAgIGNvbnN0IHsgb2Zmc2V0OiB0IH0gPSB0aGlzLl9jb25maWc7XG4gICAgcmV0dXJuIHR5cGVvZiB0ID09IFwic3RyaW5nXCIgPyB0LnNwbGl0KFwiLFwiKS5tYXAoKGUpID0+IE51bWJlci5wYXJzZUludChlLCAxMCkpIDogdHlwZW9mIHQgPT0gXCJmdW5jdGlvblwiID8gKGUpID0+IHQoZSwgdGhpcy5fZWxlbWVudCkgOiB0O1xuICB9XG4gIF9nZXRQb3BwZXJDb25maWcoKSB7XG4gICAgY29uc3QgdCA9IHtcbiAgICAgIHBsYWNlbWVudDogdGhpcy5fZ2V0UGxhY2VtZW50KCksXG4gICAgICBtb2RpZmllcnM6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwicHJldmVudE92ZXJmbG93XCIsXG4gICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgYm91bmRhcnk6IHRoaXMuX2NvbmZpZy5ib3VuZGFyeVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwib2Zmc2V0XCIsXG4gICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLl9nZXRPZmZzZXQoKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgXVxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5kaXNwbGF5ID09PSBcInN0YXRpY1wiICYmICh0Lm1vZGlmaWVycyA9IFtcbiAgICAgIHtcbiAgICAgICAgbmFtZTogXCJhcHBseVN0eWxlc1wiLFxuICAgICAgICBlbmFibGVkOiAhMVxuICAgICAgfVxuICAgIF0pLCB7XG4gICAgICAuLi50LFxuICAgICAgLi4udHlwZW9mIHRoaXMuX2NvbmZpZy5wb3BwZXJDb25maWcgPT0gXCJmdW5jdGlvblwiID8gdGhpcy5fY29uZmlnLnBvcHBlckNvbmZpZyh0KSA6IHRoaXMuX2NvbmZpZy5wb3BwZXJDb25maWdcbiAgICB9O1xuICB9XG4gIF9zZWxlY3RNZW51SXRlbSh7IGtleTogdCwgdGFyZ2V0OiBlIH0pIHtcbiAgICBjb25zdCBpID0gZC5maW5kKFxuICAgICAgbHUsXG4gICAgICB0aGlzLl9tZW51XG4gICAgKS5maWx0ZXIoTnQpO1xuICAgIGkubGVuZ3RoICYmIEpsKFxuICAgICAgaSxcbiAgICAgIGUsXG4gICAgICB0ID09PSBQcyxcbiAgICAgICFpLmluY2x1ZGVzKGUpXG4gICAgKS5mb2N1cygpO1xuICB9XG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgZSA9IER0LmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcywgdCk7XG4gICAgICBpZiAodHlwZW9mIHQgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAodHlwZW9mIGVbdF0gPiBcInVcIilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke3R9XCJgKTtcbiAgICAgICAgZVt0XSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBjbGVhck1lbnVzKHQpIHtcbiAgICBpZiAodCAmJiAodC5idXR0b24gPT09IEdkIHx8IHQudHlwZSA9PT0gXCJrZXl1cFwiICYmIHQua2V5ICE9PSBWcikpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZSA9IGQuZmluZChlcyk7XG4gICAgZm9yIChsZXQgaSA9IDAsIG4gPSBlLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgY29uc3QgbyA9IER0LmdldEluc3RhbmNlKGVbaV0pO1xuICAgICAgaWYgKCFvIHx8IG8uX2NvbmZpZy5hdXRvQ2xvc2UgPT09ICExIHx8ICFvLl9pc1Nob3duKCkpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY29uc3QgciA9IHtcbiAgICAgICAgcmVsYXRlZFRhcmdldDogby5fZWxlbWVudFxuICAgICAgfTtcbiAgICAgIGlmICh0KSB7XG4gICAgICAgIGNvbnN0IGEgPSB0LmNvbXBvc2VkUGF0aCgpLCBsID0gYS5pbmNsdWRlcyhvLl9tZW51KTtcbiAgICAgICAgaWYgKGEuaW5jbHVkZXMoby5fZWxlbWVudCkgfHwgby5fY29uZmlnLmF1dG9DbG9zZSA9PT0gXCJpbnNpZGVcIiAmJiAhbCB8fCBvLl9jb25maWcuYXV0b0Nsb3NlID09PSBcIm91dHNpZGVcIiAmJiBsIHx8IG8uX21lbnUuY29udGFpbnModC50YXJnZXQpICYmICh0LnR5cGUgPT09IFwia2V5dXBcIiAmJiB0LmtleSA9PT0gVnIgfHwgL2lucHV0fHNlbGVjdHxvcHRpb258dGV4dGFyZWF8Zm9ybS9pLnRlc3QodC50YXJnZXQudGFnTmFtZSkpKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB0LnR5cGUgPT09IFwiY2xpY2tcIiAmJiAoci5jbGlja0V2ZW50ID0gdCk7XG4gICAgICB9XG4gICAgICBvLl9jb21wbGV0ZUhpZGUocik7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBnZXRQYXJlbnRGcm9tRWxlbWVudCh0KSB7XG4gICAgcmV0dXJuIEp0KHQpIHx8IHQucGFyZW50Tm9kZTtcbiAgfVxuICBzdGF0aWMgZGF0YUFwaUtleWRvd25IYW5kbGVyKHQpIHtcbiAgICBpZiAoL2lucHV0fHRleHRhcmVhL2kudGVzdCh0LnRhcmdldC50YWdOYW1lKSA/IHQua2V5ID09PSBIciB8fCB0LmtleSAhPT0gUnMgJiYgKHQua2V5ICE9PSBQcyAmJiB0LmtleSAhPT0gJG8gfHwgdC50YXJnZXQuY2xvc2VzdCh4bikpIDogIXFkLnRlc3QodC5rZXkpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGUgPSB0aGlzLmRhdGFzZXRbYHRlRHJvcGRvd24ke1d0LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgV3Quc2xpY2UoMSl9YF0gPT09IFwiXCI7XG4gICAgaWYgKCFlICYmIHQua2V5ID09PSBScyB8fCAodC5wcmV2ZW50RGVmYXVsdCgpLCB0LnN0b3BQcm9wYWdhdGlvbigpLCBnZSh0aGlzKSkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgaSA9IHRoaXMubWF0Y2hlcyhlcykgPyB0aGlzIDogZC5wcmV2KHRoaXMsIGVzKVswXSwgbiA9IER0LmdldE9yQ3JlYXRlSW5zdGFuY2UoaSk7XG4gICAgaWYgKHQua2V5ID09PSBScykge1xuICAgICAgbi5oaWRlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0LmtleSA9PT0gJG8gfHwgdC5rZXkgPT09IFBzKSB7XG4gICAgICBlIHx8IG4uc2hvdygpLCBuLl9zZWxlY3RNZW51SXRlbSh0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgKCFlIHx8IHQua2V5ID09PSBIcikgJiYgRHQuY2xlYXJNZW51cygpO1xuICB9XG59XG5jb25zdCBPbiA9IFwiY29sbGFwc2VcIiwgRGMgPSBcInRlLmNvbGxhcHNlXCIsIGxuID0gYC4ke0RjfWAsIEZyID0ge1xuICB0b2dnbGU6ICEwLFxuICBwYXJlbnQ6IG51bGxcbn0sIHZ1ID0ge1xuICB0b2dnbGU6IFwiYm9vbGVhblwiLFxuICBwYXJlbnQ6IFwiKG51bGx8ZWxlbWVudClcIlxufSwgVHUgPSBgc2hvdyR7bG59YCwgRXUgPSBgc2hvd24ke2xufWAsIEN1ID0gYGhpZGUke2xufWAsIEF1ID0gYGhpZGRlbiR7bG59YCwgU24gPSBcImRhdGEtdGUtY29sbGFwc2Utc2hvd1wiLCBZciA9IFwiZGF0YS10ZS1jb2xsYXBzZS1jb2xsYXBzZWRcIiwgc3MgPSBcImRhdGEtdGUtY29sbGFwc2UtY29sbGFwc2luZ1wiLCB5dSA9IFwiZGF0YS10ZS1jb2xsYXBzZS1ob3Jpem9udGFsXCIsIE1lID0gXCJkYXRhLXRlLWNvbGxhcHNlLWl0ZW1cIiwganIgPSBgOnNjb3BlIFske01lfV0gWyR7TWV9XWAsIHd1ID0gXCJ3aWR0aFwiLCBrdSA9IFwiaGVpZ2h0XCIsIHh1ID0gXCJbZGF0YS10ZS1jb2xsYXBzZS1pdGVtXVtkYXRhLXRlLWNvbGxhcHNlLXNob3ddLCBbZGF0YS10ZS1jb2xsYXBzZS1pdGVtXVtkYXRhLXRlLWNvbGxhcHNlLWNvbGxhcHNpbmddXCIsIEtyID0gXCJbZGF0YS10ZS1jb2xsYXBzZS1pbml0XVwiLCBPdSA9IHtcbiAgdmlzaWJsZTogXCIhdmlzaWJsZVwiLFxuICBoaWRkZW46IFwiaGlkZGVuXCIsXG4gIGJhc2VUcmFuc2l0aW9uOiBcIm92ZXJmbG93LWhpZGRlbiBkdXJhdGlvbi1bMzUwbXNdIGVhc2UtW2N1YmljLWJlemllcigwLjI1LDAuMSwwLjI1LDEuMCldIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lXCIsXG4gIGNvbGxhcHNpbmc6IFwiaC0wIHRyYW5zaXRpb24tW2hlaWdodF0gb3ZlcmZsb3ctaGlkZGVuIGR1cmF0aW9uLVszNTBtc10gZWFzZS1bY3ViaWMtYmV6aWVyKDAuMjUsMC4xLDAuMjUsMS4wKV0gbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmVcIixcbiAgY29sbGFwc2luZ0hvcml6b250YWw6IFwidy0wIGgtYXV0byB0cmFuc2l0aW9uLVt3aWR0aF0gb3ZlcmZsb3ctaGlkZGVuIGR1cmF0aW9uLVszNTBtc10gZWFzZS1bY3ViaWMtYmV6aWVyKDAuMjUsMC4xLDAuMjUsMS4wKV0gbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmVcIlxufSwgU3UgPSB7XG4gIHZpc2libGU6IFwic3RyaW5nXCIsXG4gIGhpZGRlbjogXCJzdHJpbmdcIixcbiAgYmFzZVRyYW5zaXRpb246IFwic3RyaW5nXCIsXG4gIGNvbGxhcHNpbmc6IFwic3RyaW5nXCIsXG4gIGNvbGxhcHNpbmdIb3Jpem9udGFsOiBcInN0cmluZ1wiXG59O1xuY2xhc3MgWnQgZXh0ZW5kcyBndCB7XG4gIGNvbnN0cnVjdG9yKHQsIGUsIGkpIHtcbiAgICBzdXBlcih0KSwgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gITEsIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhlKSwgdGhpcy5fY2xhc3NlcyA9IHRoaXMuX2dldENsYXNzZXMoaSksIHRoaXMuX3RyaWdnZXJBcnJheSA9IFtdO1xuICAgIGNvbnN0IG4gPSBkLmZpbmQoS3IpO1xuICAgIGZvciAobGV0IG8gPSAwLCByID0gbi5sZW5ndGg7IG8gPCByOyBvKyspIHtcbiAgICAgIGNvbnN0IGEgPSBuW29dLCBsID0gcW8oYSksIHAgPSBkLmZpbmQobCkuZmlsdGVyKFxuICAgICAgICAodSkgPT4gdSA9PT0gdGhpcy5fZWxlbWVudFxuICAgICAgKTtcbiAgICAgIGwgIT09IG51bGwgJiYgcC5sZW5ndGggJiYgKHRoaXMuX3NlbGVjdG9yID0gbCwgdGhpcy5fdHJpZ2dlckFycmF5LnB1c2goYSkpO1xuICAgIH1cbiAgICB0aGlzLl9pbml0aWFsaXplQ2hpbGRyZW4oKSwgdGhpcy5fY29uZmlnLnBhcmVudCB8fCB0aGlzLl9hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3ModGhpcy5fdHJpZ2dlckFycmF5LCB0aGlzLl9pc1Nob3duKCkpLCB0aGlzLl9jb25maWcudG9nZ2xlICYmIHRoaXMudG9nZ2xlKCk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIEZyO1xuICB9XG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gT247XG4gIH1cbiAgLy8gUHVibGljXG4gIHRvZ2dsZSgpIHtcbiAgICB0aGlzLl9pc1Nob3duKCkgPyB0aGlzLmhpZGUoKSA6IHRoaXMuc2hvdygpO1xuICB9XG4gIHNob3coKSB7XG4gICAgaWYgKHRoaXMuX2lzVHJhbnNpdGlvbmluZyB8fCB0aGlzLl9pc1Nob3duKCkpXG4gICAgICByZXR1cm47XG4gICAgbGV0IHQgPSBbXSwgZTtcbiAgICBpZiAodGhpcy5fY29uZmlnLnBhcmVudCkge1xuICAgICAgY29uc3QgdSA9IGQuZmluZChcbiAgICAgICAganIsXG4gICAgICAgIHRoaXMuX2NvbmZpZy5wYXJlbnRcbiAgICAgICk7XG4gICAgICB0ID0gZC5maW5kKFxuICAgICAgICB4dSxcbiAgICAgICAgdGhpcy5fY29uZmlnLnBhcmVudFxuICAgICAgKS5maWx0ZXIoKF8pID0+ICF1LmluY2x1ZGVzKF8pKTtcbiAgICB9XG4gICAgY29uc3QgaSA9IGQuZmluZE9uZSh0aGlzLl9zZWxlY3Rvcik7XG4gICAgaWYgKHQubGVuZ3RoKSB7XG4gICAgICBjb25zdCB1ID0gdC5maW5kKChfKSA9PiBpICE9PSBfKTtcbiAgICAgIGlmIChlID0gdSA/IFp0LmdldEluc3RhbmNlKHUpIDogbnVsbCwgZSAmJiBlLl9pc1RyYW5zaXRpb25pbmcpXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBUdSkuZGVmYXVsdFByZXZlbnRlZClcbiAgICAgIHJldHVybjtcbiAgICB0LmZvckVhY2goKHUpID0+IHtcbiAgICAgIGkgIT09IHUgJiYgWnQuZ2V0T3JDcmVhdGVJbnN0YW5jZSh1LCB7IHRvZ2dsZTogITEgfSkuaGlkZSgpLCBlIHx8IHkuc2V0RGF0YSh1LCBEYywgbnVsbCk7XG4gICAgfSk7XG4gICAgY29uc3QgbyA9IHRoaXMuX2dldERpbWVuc2lvbigpLCByID0gbyA9PT0gXCJoZWlnaHRcIiA/IHRoaXMuX2NsYXNzZXMuY29sbGFwc2luZyA6IHRoaXMuX2NsYXNzZXMuY29sbGFwc2luZ0hvcml6b250YWw7XG4gICAgaC5yZW1vdmVDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl9jbGFzc2VzLnZpc2libGUpLCBoLnJlbW92ZUNsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NsYXNzZXMuaGlkZGVuKSwgaC5hZGRDbGFzcyh0aGlzLl9lbGVtZW50LCByKSwgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoTWUpLCB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShzcywgXCJcIiksIHRoaXMuX2VsZW1lbnQuc3R5bGVbb10gPSAwLCB0aGlzLl9hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3ModGhpcy5fdHJpZ2dlckFycmF5LCAhMCksIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9ICEwO1xuICAgIGNvbnN0IGEgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSAhMSwgaC5yZW1vdmVDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl9jbGFzc2VzLmhpZGRlbiksIGgucmVtb3ZlQ2xhc3ModGhpcy5fZWxlbWVudCwgciksIGguYWRkQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy52aXNpYmxlKSwgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoc3MpLCB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShNZSwgXCJcIiksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFNuLCBcIlwiKSwgdGhpcy5fZWxlbWVudC5zdHlsZVtvXSA9IFwiXCIsIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFdSk7XG4gICAgfSwgcCA9IGBzY3JvbGwke29bMF0udG9VcHBlckNhc2UoKSArIG8uc2xpY2UoMSl9YDtcbiAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKGEsIHRoaXMuX2VsZW1lbnQsICEwKSwgdGhpcy5fZWxlbWVudC5zdHlsZVtvXSA9IGAke3RoaXMuX2VsZW1lbnRbcF19cHhgO1xuICB9XG4gIGhpZGUoKSB7XG4gICAgaWYgKHRoaXMuX2lzVHJhbnNpdGlvbmluZyB8fCAhdGhpcy5faXNTaG93bigpIHx8IGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBDdSkuZGVmYXVsdFByZXZlbnRlZClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBlID0gdGhpcy5fZ2V0RGltZW5zaW9uKCksIGkgPSBlID09PSBcImhlaWdodFwiID8gdGhpcy5fY2xhc3Nlcy5jb2xsYXBzaW5nIDogdGhpcy5fY2xhc3Nlcy5jb2xsYXBzaW5nSG9yaXpvbnRhbDtcbiAgICB0aGlzLl9lbGVtZW50LnN0eWxlW2VdID0gYCR7dGhpcy5fZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVtlXX1weGAsIEplKHRoaXMuX2VsZW1lbnQpLCBoLmFkZENsYXNzKHRoaXMuX2VsZW1lbnQsIGkpLCBoLnJlbW92ZUNsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NsYXNzZXMudmlzaWJsZSksIGgucmVtb3ZlQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy5oaWRkZW4pLCB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShzcywgXCJcIiksIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKE1lKSwgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoU24pO1xuICAgIGNvbnN0IG4gPSB0aGlzLl90cmlnZ2VyQXJyYXkubGVuZ3RoO1xuICAgIGZvciAobGV0IHIgPSAwOyByIDwgbjsgcisrKSB7XG4gICAgICBjb25zdCBhID0gdGhpcy5fdHJpZ2dlckFycmF5W3JdLCBsID0gSnQoYSk7XG4gICAgICBsICYmICF0aGlzLl9pc1Nob3duKGwpICYmIHRoaXMuX2FkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyhbYV0sICExKTtcbiAgICB9XG4gICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gITA7XG4gICAgY29uc3QgbyA9ICgpID0+IHtcbiAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9ICExLCBoLnJlbW92ZUNsYXNzKHRoaXMuX2VsZW1lbnQsIGkpLCBoLmFkZENsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NsYXNzZXMudmlzaWJsZSksIGguYWRkQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy5oaWRkZW4pLCB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShzcyksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKE1lLCBcIlwiKSwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEF1KTtcbiAgICB9O1xuICAgIHRoaXMuX2VsZW1lbnQuc3R5bGVbZV0gPSBcIlwiLCB0aGlzLl9xdWV1ZUNhbGxiYWNrKG8sIHRoaXMuX2VsZW1lbnQsICEwKTtcbiAgfVxuICBfaXNTaG93bih0ID0gdGhpcy5fZWxlbWVudCkge1xuICAgIHJldHVybiB0Lmhhc0F0dHJpYnV0ZShTbik7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfZ2V0Q29uZmlnKHQpIHtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLkZyLFxuICAgICAgLi4uaC5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KSxcbiAgICAgIC4uLnRcbiAgICB9LCB0LnRvZ2dsZSA9ICEhdC50b2dnbGUsIHQucGFyZW50ID0gdGUodC5wYXJlbnQpLCBEKE9uLCB0LCB2dSksIHQ7XG4gIH1cbiAgX2dldENsYXNzZXModCkge1xuICAgIGNvbnN0IGUgPSBoLmdldERhdGFDbGFzc0F0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5PdSxcbiAgICAgIC4uLmUsXG4gICAgICAuLi50XG4gICAgfSwgRChPbiwgdCwgU3UpLCB0O1xuICB9XG4gIF9nZXREaW1lbnNpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQuaGFzQXR0cmlidXRlKHl1KSA/IHd1IDoga3U7XG4gIH1cbiAgX2luaXRpYWxpemVDaGlsZHJlbigpIHtcbiAgICBpZiAoIXRoaXMuX2NvbmZpZy5wYXJlbnQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdCA9IGQuZmluZChcbiAgICAgIGpyLFxuICAgICAgdGhpcy5fY29uZmlnLnBhcmVudFxuICAgICk7XG4gICAgZC5maW5kKEtyLCB0aGlzLl9jb25maWcucGFyZW50KS5maWx0ZXIoKGUpID0+ICF0LmluY2x1ZGVzKGUpKS5mb3JFYWNoKChlKSA9PiB7XG4gICAgICBjb25zdCBpID0gSnQoZSk7XG4gICAgICBpICYmIHRoaXMuX2FkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyhbZV0sIHRoaXMuX2lzU2hvd24oaSkpO1xuICAgIH0pO1xuICB9XG4gIF9hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3ModCwgZSkge1xuICAgIHQubGVuZ3RoICYmIHQuZm9yRWFjaCgoaSkgPT4ge1xuICAgICAgZSA/IGkucmVtb3ZlQXR0cmlidXRlKFlyKSA6IGkuc2V0QXR0cmlidXRlKGAke1lyfWAsIFwiXCIpLCBpLnNldEF0dHJpYnV0ZShcImFyaWEtZXhwYW5kZWRcIiwgZSk7XG4gICAgfSk7XG4gIH1cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBlID0ge307XG4gICAgICB0eXBlb2YgdCA9PSBcInN0cmluZ1wiICYmIC9zaG93fGhpZGUvLnRlc3QodCkgJiYgKGUudG9nZ2xlID0gITEpO1xuICAgICAgY29uc3QgaSA9IFp0LmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcywgZSk7XG4gICAgICBpZiAodHlwZW9mIHQgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAodHlwZW9mIGlbdF0gPiBcInVcIilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke3R9XCJgKTtcbiAgICAgICAgaVt0XSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5jb25zdCB6ciA9IFwiLmZpeGVkLXRvcCwgLmZpeGVkLWJvdHRvbSwgLmlzLWZpeGVkLCAuc3RpY2t5LXRvcFwiLCBVciA9IFwiLnN0aWNreS10b3BcIjtcbmNsYXNzIHFlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IGRvY3VtZW50LmJvZHk7XG4gIH1cbiAgZ2V0V2lkdGgoKSB7XG4gICAgY29uc3QgdCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDtcbiAgICByZXR1cm4gTWF0aC5hYnMod2luZG93LmlubmVyV2lkdGggLSB0KTtcbiAgfVxuICBoaWRlKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmdldFdpZHRoKCk7XG4gICAgdGhpcy5fZGlzYWJsZU92ZXJGbG93KCksIHRoaXMuX3NldEVsZW1lbnRBdHRyaWJ1dGVzKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIFwicGFkZGluZ1JpZ2h0XCIsXG4gICAgICAoZSkgPT4gZSArIHRcbiAgICApLCB0aGlzLl9zZXRFbGVtZW50QXR0cmlidXRlcyhcbiAgICAgIHpyLFxuICAgICAgXCJwYWRkaW5nUmlnaHRcIixcbiAgICAgIChlKSA9PiBlICsgdFxuICAgICksIHRoaXMuX3NldEVsZW1lbnRBdHRyaWJ1dGVzKFxuICAgICAgVXIsXG4gICAgICBcIm1hcmdpblJpZ2h0XCIsXG4gICAgICAoZSkgPT4gZSAtIHRcbiAgICApO1xuICB9XG4gIF9kaXNhYmxlT3ZlckZsb3coKSB7XG4gICAgdGhpcy5fc2F2ZUluaXRpYWxBdHRyaWJ1dGUodGhpcy5fZWxlbWVudCwgXCJvdmVyZmxvd1wiKSwgdGhpcy5fZWxlbWVudC5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG4gIH1cbiAgX3NldEVsZW1lbnRBdHRyaWJ1dGVzKHQsIGUsIGkpIHtcbiAgICBjb25zdCBuID0gdGhpcy5nZXRXaWR0aCgpLCBvID0gKHIpID0+IHtcbiAgICAgIGlmIChyICE9PSB0aGlzLl9lbGVtZW50ICYmIHdpbmRvdy5pbm5lcldpZHRoID4gci5jbGllbnRXaWR0aCArIG4pXG4gICAgICAgIHJldHVybjtcbiAgICAgIHRoaXMuX3NhdmVJbml0aWFsQXR0cmlidXRlKHIsIGUpO1xuICAgICAgY29uc3QgYSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHIpW2VdO1xuICAgICAgci5zdHlsZVtlXSA9IGAke2koXG4gICAgICAgIE51bWJlci5wYXJzZUZsb2F0KGEpXG4gICAgICApfXB4YDtcbiAgICB9O1xuICAgIHRoaXMuX2FwcGx5TWFuaXB1bGF0aW9uQ2FsbGJhY2sodCwgbyk7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5fcmVzZXRFbGVtZW50QXR0cmlidXRlcyh0aGlzLl9lbGVtZW50LCBcIm92ZXJmbG93XCIpLCB0aGlzLl9yZXNldEVsZW1lbnRBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQsIFwicGFkZGluZ1JpZ2h0XCIpLCB0aGlzLl9yZXNldEVsZW1lbnRBdHRyaWJ1dGVzKHpyLCBcInBhZGRpbmdSaWdodFwiKSwgdGhpcy5fcmVzZXRFbGVtZW50QXR0cmlidXRlcyhVciwgXCJtYXJnaW5SaWdodFwiKTtcbiAgfVxuICBfc2F2ZUluaXRpYWxBdHRyaWJ1dGUodCwgZSkge1xuICAgIGNvbnN0IGkgPSB0LnN0eWxlW2VdO1xuICAgIGkgJiYgaC5zZXREYXRhQXR0cmlidXRlKHQsIGUsIGkpO1xuICB9XG4gIF9yZXNldEVsZW1lbnRBdHRyaWJ1dGVzKHQsIGUpIHtcbiAgICBjb25zdCBpID0gKG4pID0+IHtcbiAgICAgIGNvbnN0IG8gPSBoLmdldERhdGFBdHRyaWJ1dGUobiwgZSk7XG4gICAgICB0eXBlb2YgbyA+IFwidVwiID8gbi5zdHlsZS5yZW1vdmVQcm9wZXJ0eShlKSA6IChoLnJlbW92ZURhdGFBdHRyaWJ1dGUobiwgZSksIG4uc3R5bGVbZV0gPSBvKTtcbiAgICB9O1xuICAgIHRoaXMuX2FwcGx5TWFuaXB1bGF0aW9uQ2FsbGJhY2sodCwgaSk7XG4gIH1cbiAgX2FwcGx5TWFuaXB1bGF0aW9uQ2FsbGJhY2sodCwgZSkge1xuICAgIGplKHQpID8gZSh0KSA6IGQuZmluZCh0LCB0aGlzLl9lbGVtZW50KS5mb3JFYWNoKGUpO1xuICB9XG4gIGlzT3ZlcmZsb3dpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0V2lkdGgoKSA+IDA7XG4gIH1cbn1cbmNvbnN0IEl1ID0ge1xuICBpc1Zpc2libGU6ICEwLFxuICAvLyBpZiBmYWxzZSwgd2UgdXNlIHRoZSBiYWNrZHJvcCBoZWxwZXIgd2l0aG91dCBhZGRpbmcgYW55IGVsZW1lbnQgdG8gdGhlIGRvbVxuICBpc0FuaW1hdGVkOiAhMSxcbiAgcm9vdEVsZW1lbnQ6IFwiYm9keVwiLFxuICAvLyBnaXZlIHRoZSBjaG9pY2UgdG8gcGxhY2UgYmFja2Ryb3AgdW5kZXIgZGlmZmVyZW50IGVsZW1lbnRzXG4gIGNsaWNrQ2FsbGJhY2s6IG51bGwsXG4gIGJhY2tkcm9wQ2xhc3NlczogbnVsbFxufSwgRHUgPSB7XG4gIGlzVmlzaWJsZTogXCJib29sZWFuXCIsXG4gIGlzQW5pbWF0ZWQ6IFwiYm9vbGVhblwiLFxuICByb290RWxlbWVudDogXCIoZWxlbWVudHxzdHJpbmcpXCIsXG4gIGNsaWNrQ2FsbGJhY2s6IFwiKGZ1bmN0aW9ufG51bGwpXCIsXG4gIGJhY2tkcm9wQ2xhc3NlczogXCIoYXJyYXl8bnVsbClcIlxufSwgJGMgPSBcImJhY2tkcm9wXCIsIFhyID0gYG1vdXNlZG93bi50ZS4keyRjfWA7XG5jbGFzcyBociB7XG4gIGNvbnN0cnVjdG9yKHQpIHtcbiAgICB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcodCksIHRoaXMuX2lzQXBwZW5kZWQgPSAhMSwgdGhpcy5fZWxlbWVudCA9IG51bGw7XG4gIH1cbiAgc2hvdyh0KSB7XG4gICAgaWYgKCF0aGlzLl9jb25maWcuaXNWaXNpYmxlKSB7XG4gICAgICBtZSh0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fYXBwZW5kKCksIHRoaXMuX2NvbmZpZy5pc0FuaW1hdGVkICYmIEplKHRoaXMuX2dldEVsZW1lbnQoKSk7XG4gICAgY29uc3QgZSA9IHRoaXMuX2NvbmZpZy5iYWNrZHJvcENsYXNzZXMgfHwgW1xuICAgICAgXCJvcGFjaXR5LTUwXCIsXG4gICAgICBcInRyYW5zaXRpb24tYWxsXCIsXG4gICAgICBcImR1cmF0aW9uLTMwMFwiLFxuICAgICAgXCJlYXNlLWluLW91dFwiLFxuICAgICAgXCJmaXhlZFwiLFxuICAgICAgXCJ0b3AtMFwiLFxuICAgICAgXCJsZWZ0LTBcIixcbiAgICAgIFwiei1bMTA0MF1cIixcbiAgICAgIFwiYmctYmxhY2tcIixcbiAgICAgIFwidy1zY3JlZW5cIixcbiAgICAgIFwiaC1zY3JlZW5cIlxuICAgIF07XG4gICAgaC5yZW1vdmVDbGFzcyh0aGlzLl9nZXRFbGVtZW50KCksIFwib3BhY2l0eS0wXCIpLCBoLmFkZENsYXNzKHRoaXMuX2dldEVsZW1lbnQoKSwgZSksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFwiZGF0YS10ZS1iYWNrZHJvcC1zaG93XCIsIFwiXCIpLCB0aGlzLl9lbXVsYXRlQW5pbWF0aW9uKCgpID0+IHtcbiAgICAgIG1lKHQpO1xuICAgIH0pO1xuICB9XG4gIGhpZGUodCkge1xuICAgIGlmICghdGhpcy5fY29uZmlnLmlzVmlzaWJsZSkge1xuICAgICAgbWUodCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS10ZS1iYWNrZHJvcC1zaG93XCIpLCB0aGlzLl9nZXRFbGVtZW50KCkuY2xhc3NMaXN0LmFkZChcIm9wYWNpdHktMFwiKSwgdGhpcy5fZ2V0RWxlbWVudCgpLmNsYXNzTGlzdC5yZW1vdmUoXCJvcGFjaXR5LTUwXCIpLCB0aGlzLl9lbXVsYXRlQW5pbWF0aW9uKCgpID0+IHtcbiAgICAgIHRoaXMuZGlzcG9zZSgpLCBtZSh0KTtcbiAgICB9KTtcbiAgfVxuICAvLyBQcml2YXRlXG4gIF9nZXRFbGVtZW50KCkge1xuICAgIGlmICghdGhpcy5fZWxlbWVudCkge1xuICAgICAgY29uc3QgdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICB0LmNsYXNzTmFtZSA9IHRoaXMuX2NvbmZpZy5jbGFzc05hbWUsIHRoaXMuX2NvbmZpZy5pc0FuaW1hdGVkICYmIHQuY2xhc3NMaXN0LmFkZChcIm9wYWNpdHktNTBcIiksIHRoaXMuX2VsZW1lbnQgPSB0O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZWxlbWVudDtcbiAgfVxuICBfZ2V0Q29uZmlnKHQpIHtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLkl1LFxuICAgICAgLi4udHlwZW9mIHQgPT0gXCJvYmplY3RcIiA/IHQgOiB7fVxuICAgIH0sIHQucm9vdEVsZW1lbnQgPSB0ZSh0LnJvb3RFbGVtZW50KSwgRCgkYywgdCwgRHUpLCB0O1xuICB9XG4gIF9hcHBlbmQoKSB7XG4gICAgdGhpcy5faXNBcHBlbmRlZCB8fCAodGhpcy5fY29uZmlnLnJvb3RFbGVtZW50LmFwcGVuZCh0aGlzLl9nZXRFbGVtZW50KCkpLCBjLm9uKHRoaXMuX2dldEVsZW1lbnQoKSwgWHIsICgpID0+IHtcbiAgICAgIG1lKHRoaXMuX2NvbmZpZy5jbGlja0NhbGxiYWNrKTtcbiAgICB9KSwgdGhpcy5faXNBcHBlbmRlZCA9ICEwKTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuX2lzQXBwZW5kZWQgJiYgKGMub2ZmKHRoaXMuX2VsZW1lbnQsIFhyKSwgdGhpcy5fZWxlbWVudC5yZW1vdmUoKSwgdGhpcy5faXNBcHBlbmRlZCA9ICExKTtcbiAgfVxuICBfZW11bGF0ZUFuaW1hdGlvbih0KSB7XG4gICAgUWwoXG4gICAgICB0LFxuICAgICAgdGhpcy5fZ2V0RWxlbWVudCgpLFxuICAgICAgdGhpcy5fY29uZmlnLmlzQW5pbWF0ZWRcbiAgICApO1xuICB9XG59XG5jbGFzcyBXaSB7XG4gIGNvbnN0cnVjdG9yKHQsIGUgPSB7fSwgaSkge1xuICAgIHRoaXMuX2VsZW1lbnQgPSB0LCB0aGlzLl90b2dnbGVyID0gaSwgdGhpcy5fZXZlbnQgPSBlLmV2ZW50IHx8IFwiYmx1clwiLCB0aGlzLl9jb25kaXRpb24gPSBlLmNvbmRpdGlvbiB8fCAoKCkgPT4gITApLCB0aGlzLl9zZWxlY3RvciA9IGUuc2VsZWN0b3IgfHwgJ2J1dHRvbiwgYSwgaW5wdXQsIHNlbGVjdCwgdGV4dGFyZWEsIFt0YWJpbmRleF06bm90KFt0YWJpbmRleD1cIi0xXCJdKScsIHRoaXMuX29ubHlWaXNpYmxlID0gZS5vbmx5VmlzaWJsZSB8fCAhMSwgdGhpcy5fZm9jdXNhYmxlRWxlbWVudHMgPSBbXSwgdGhpcy5fZmlyc3RFbGVtZW50ID0gbnVsbCwgdGhpcy5fbGFzdEVsZW1lbnQgPSBudWxsLCB0aGlzLmhhbmRsZXIgPSAobikgPT4ge1xuICAgICAgdGhpcy5fY29uZGl0aW9uKG4pICYmICFuLnNoaWZ0S2V5ICYmIG4udGFyZ2V0ID09PSB0aGlzLl9sYXN0RWxlbWVudCA/IChuLnByZXZlbnREZWZhdWx0KCksIHRoaXMuX2ZpcnN0RWxlbWVudC5mb2N1cygpKSA6IHRoaXMuX2NvbmRpdGlvbihuKSAmJiBuLnNoaWZ0S2V5ICYmIG4udGFyZ2V0ID09PSB0aGlzLl9maXJzdEVsZW1lbnQgJiYgKG4ucHJldmVudERlZmF1bHQoKSwgdGhpcy5fbGFzdEVsZW1lbnQuZm9jdXMoKSk7XG4gICAgfTtcbiAgfVxuICB0cmFwKCkge1xuICAgIHRoaXMuX3NldEVsZW1lbnRzKCksIHRoaXMuX2luaXQoKSwgdGhpcy5fc2V0Rm9jdXNUcmFwKCk7XG4gIH1cbiAgZGlzYWJsZSgpIHtcbiAgICB0aGlzLl9mb2N1c2FibGVFbGVtZW50cy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICB0LnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcy5fZXZlbnQsIHRoaXMuaGFuZGxlcik7XG4gICAgfSksIHRoaXMuX3RvZ2dsZXIgJiYgdGhpcy5fdG9nZ2xlci5mb2N1cygpO1xuICB9XG4gIHVwZGF0ZSgpIHtcbiAgICB0aGlzLl9zZXRFbGVtZW50cygpLCB0aGlzLl9zZXRGb2N1c1RyYXAoKTtcbiAgfVxuICBfaW5pdCgpIHtcbiAgICBjb25zdCB0ID0gKGUpID0+IHtcbiAgICAgICF0aGlzLl9maXJzdEVsZW1lbnQgfHwgZS5rZXkgIT09IFwiVGFiXCIgfHwgdGhpcy5fZm9jdXNhYmxlRWxlbWVudHMuaW5jbHVkZXMoZS50YXJnZXQpIHx8IChlLnByZXZlbnREZWZhdWx0KCksIHRoaXMuX2ZpcnN0RWxlbWVudC5mb2N1cygpLCB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdCkpO1xuICAgIH07XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHQpO1xuICB9XG4gIF9maWx0ZXJWaXNpYmxlKHQpIHtcbiAgICByZXR1cm4gdC5maWx0ZXIoKGUpID0+IHtcbiAgICAgIGlmICghTnQoZSkpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGNvbnN0IGkgPSBkLnBhcmVudHMoZSwgXCIqXCIpO1xuICAgICAgZm9yIChsZXQgbiA9IDA7IG4gPCBpLmxlbmd0aDsgbisrKSB7XG4gICAgICAgIGNvbnN0IG8gPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShpW25dKTtcbiAgICAgICAgaWYgKG8gJiYgKG8uZGlzcGxheSA9PT0gXCJub25lXCIgfHwgby52aXNpYmlsaXR5ID09PSBcImhpZGRlblwiKSlcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICB9XG4gICAgICByZXR1cm4gITA7XG4gICAgfSk7XG4gIH1cbiAgX3NldEVsZW1lbnRzKCkge1xuICAgIHRoaXMuX2ZvY3VzYWJsZUVsZW1lbnRzID0gZC5mb2N1c2FibGVDaGlsZHJlbih0aGlzLl9lbGVtZW50KSwgdGhpcy5fb25seVZpc2libGUgJiYgKHRoaXMuX2ZvY3VzYWJsZUVsZW1lbnRzID0gdGhpcy5fZmlsdGVyVmlzaWJsZSh0aGlzLl9mb2N1c2FibGVFbGVtZW50cykpLCB0aGlzLl9maXJzdEVsZW1lbnQgPSB0aGlzLl9mb2N1c2FibGVFbGVtZW50c1swXSwgdGhpcy5fbGFzdEVsZW1lbnQgPSB0aGlzLl9mb2N1c2FibGVFbGVtZW50c1t0aGlzLl9mb2N1c2FibGVFbGVtZW50cy5sZW5ndGggLSAxXTtcbiAgfVxuICBfc2V0Rm9jdXNUcmFwKCkge1xuICAgIHRoaXMuX2ZvY3VzYWJsZUVsZW1lbnRzLmZvckVhY2goKHQsIGUpID0+IHtcbiAgICAgIGUgPT09IHRoaXMuX2ZvY3VzYWJsZUVsZW1lbnRzLmxlbmd0aCAtIDEgfHwgZSA9PT0gMCA/IHQuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLl9ldmVudCwgdGhpcy5oYW5kbGVyKSA6IHQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLl9ldmVudCwgdGhpcy5oYW5kbGVyKTtcbiAgICB9KTtcbiAgfVxufVxubGV0IEdyID0gW107XG5jb25zdCBjbiA9IChzLCB0ID0gXCJoaWRlXCIpID0+IHtcbiAgY29uc3QgZSA9IGBjbGljay5kaXNtaXNzJHtzLkVWRU5UX0tFWX1gLCBpID0gcy5OQU1FO1xuICBHci5pbmNsdWRlcyhpKSB8fCAoR3IucHVzaChpKSwgYy5vbihcbiAgICBkb2N1bWVudCxcbiAgICBlLFxuICAgIGBbZGF0YS10ZS0ke2l9LWRpc21pc3NdYCxcbiAgICBmdW5jdGlvbihuKSB7XG4gICAgICBpZiAoW1wiQVwiLCBcIkFSRUFcIl0uaW5jbHVkZXModGhpcy50YWdOYW1lKSAmJiBuLnByZXZlbnREZWZhdWx0KCksIGdlKHRoaXMpKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBvID0gSnQodGhpcykgfHwgdGhpcy5jbG9zZXN0KGAuJHtpfWApIHx8IHRoaXMuY2xvc2VzdChgW2RhdGEtdGUtJHtpfS1pbml0XWApO1xuICAgICAgaWYgKCFvKVxuICAgICAgICByZXR1cm47XG4gICAgICBzLmdldE9yQ3JlYXRlSW5zdGFuY2UobylbdF0oKTtcbiAgICB9XG4gICkpO1xufSwgcXIgPSBcIm9mZmNhbnZhc1wiLCAkdSA9IFwidGUub2ZmY2FudmFzXCIsIGVpID0gYC4keyR1fWAsIEx1ID0gXCIuZGF0YS1hcGlcIiwgTnUgPSBgbG9hZCR7ZWl9JHtMdX1gLCBNdSA9IFwiRXNjYXBlXCIsIFpyID0ge1xuICBiYWNrZHJvcDogITAsXG4gIGtleWJvYXJkOiAhMCxcbiAgc2Nyb2xsOiAhMVxufSwgUnUgPSB7XG4gIGJhY2tkcm9wOiBcImJvb2xlYW5cIixcbiAga2V5Ym9hcmQ6IFwiYm9vbGVhblwiLFxuICBzY3JvbGw6IFwiYm9vbGVhblwiXG59LCBRciA9IFwic2hvd1wiLCBQdSA9IFwiW2RhdGEtdGUtb2ZmY2FudmFzLWluaXRdW2RhdGEtdGUtb2ZmY2FudmFzLXNob3ddXCIsIEJ1ID0gYHNob3cke2VpfWAsIEh1ID0gYHNob3duJHtlaX1gLCBWdSA9IGBoaWRlJHtlaX1gLCBXdSA9IGBoaWRkZW4ke2VpfWAsIEZ1ID0gYGtleWRvd24uZGlzbWlzcyR7ZWl9YDtcbmNsYXNzIEJzIGV4dGVuZHMgZ3Qge1xuICBjb25zdHJ1Y3Rvcih0LCBlKSB7XG4gICAgc3VwZXIodCksIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhlKSwgdGhpcy5faXNTaG93biA9ICExLCB0aGlzLl9iYWNrZHJvcCA9IHRoaXMuX2luaXRpYWxpemVCYWNrRHJvcCgpLCB0aGlzLl9mb2N1c3RyYXAgPSB0aGlzLl9pbml0aWFsaXplRm9jdXNUcmFwKCksIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKCksIHRoaXMuX2RpZEluaXQgPSAhMSwgdGhpcy5faW5pdCgpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBxcjtcbiAgfVxuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIFpyO1xuICB9XG4gIC8vIFB1YmxpY1xuICB0b2dnbGUodCkge1xuICAgIHJldHVybiB0aGlzLl9pc1Nob3duID8gdGhpcy5oaWRlKCkgOiB0aGlzLnNob3codCk7XG4gIH1cbiAgc2hvdyh0KSB7XG4gICAgaWYgKHRoaXMuX2lzU2hvd24gfHwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEJ1LCB7XG4gICAgICByZWxhdGVkVGFyZ2V0OiB0XG4gICAgfSkuZGVmYXVsdFByZXZlbnRlZClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9pc1Nob3duID0gITAsIHRoaXMuX2VsZW1lbnQuc3R5bGUudmlzaWJpbGl0eSA9IFwidmlzaWJsZVwiLCB0aGlzLl9iYWNrZHJvcC5zaG93KCksIHRoaXMuX2NvbmZpZy5zY3JvbGwgfHwgbmV3IHFlKCkuaGlkZSgpLCB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIpLCB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtbW9kYWxcIiwgITApLCB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJkaWFsb2dcIiksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKGBkYXRhLXRlLW9mZmNhbnZhcy0ke1FyfWAsIFwiXCIpO1xuICAgIGNvbnN0IGkgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9jb25maWcuc2Nyb2xsIHx8IHRoaXMuX2ZvY3VzdHJhcC50cmFwKCksIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBIdSwgeyByZWxhdGVkVGFyZ2V0OiB0IH0pO1xuICAgIH07XG4gICAgdGhpcy5fcXVldWVDYWxsYmFjayhpLCB0aGlzLl9lbGVtZW50LCAhMCk7XG4gIH1cbiAgaGlkZSgpIHtcbiAgICBpZiAoIXRoaXMuX2lzU2hvd24gfHwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIFZ1KS5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX2ZvY3VzdHJhcC5kaXNhYmxlKCksIHRoaXMuX2VsZW1lbnQuYmx1cigpLCB0aGlzLl9pc1Nob3duID0gITEsIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGBkYXRhLXRlLW9mZmNhbnZhcy0ke1FyfWApLCB0aGlzLl9iYWNrZHJvcC5oaWRlKCk7XG4gICAgY29uc3QgZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgITApLCB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtbW9kYWxcIiksIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwicm9sZVwiKSwgdGhpcy5fZWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIiwgdGhpcy5fY29uZmlnLnNjcm9sbCB8fCBuZXcgcWUoKS5yZXNldCgpLCBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgV3UpO1xuICAgIH07XG4gICAgdGhpcy5fcXVldWVDYWxsYmFjayhlLCB0aGlzLl9lbGVtZW50LCAhMCk7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLl9iYWNrZHJvcC5kaXNwb3NlKCksIHRoaXMuX2ZvY3VzdHJhcC5kaXNhYmxlKCksIHN1cGVyLmRpc3Bvc2UoKTtcbiAgfVxuICAvLyBQcml2YXRlXG4gIF9pbml0KCkge1xuICAgIHRoaXMuX2RpZEluaXQgfHwgKGMub24oXG4gICAgICB3aW5kb3csXG4gICAgICBOdSxcbiAgICAgICgpID0+IGQuZmluZChQdSkuZm9yRWFjaChcbiAgICAgICAgKHQpID0+IEJzLmdldE9yQ3JlYXRlSW5zdGFuY2UodCkuc2hvdygpXG4gICAgICApXG4gICAgKSwgdGhpcy5fZGlkSW5pdCA9ICEwLCBjbihCcykpO1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uWnIsXG4gICAgICAuLi5oLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgLi4udHlwZW9mIHQgPT0gXCJvYmplY3RcIiA/IHQgOiB7fVxuICAgIH0sIEQocXIsIHQsIFJ1KSwgdDtcbiAgfVxuICBfaW5pdGlhbGl6ZUJhY2tEcm9wKCkge1xuICAgIHJldHVybiBuZXcgaHIoe1xuICAgICAgaXNWaXNpYmxlOiB0aGlzLl9jb25maWcuYmFja2Ryb3AsXG4gICAgICBpc0FuaW1hdGVkOiAhMCxcbiAgICAgIHJvb3RFbGVtZW50OiB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUsXG4gICAgICBjbGlja0NhbGxiYWNrOiAoKSA9PiB0aGlzLmhpZGUoKVxuICAgIH0pO1xuICB9XG4gIF9pbml0aWFsaXplRm9jdXNUcmFwKCkge1xuICAgIHJldHVybiBuZXcgV2kodGhpcy5fZWxlbWVudCwge1xuICAgICAgZXZlbnQ6IFwia2V5ZG93blwiLFxuICAgICAgY29uZGl0aW9uOiAodCkgPT4gdC5rZXkgPT09IFwiVGFiXCJcbiAgICB9KTtcbiAgfVxuICBfYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgYy5vbih0aGlzLl9lbGVtZW50LCBGdSwgKHQpID0+IHtcbiAgICAgIHRoaXMuX2NvbmZpZy5rZXlib2FyZCAmJiB0LmtleSA9PT0gTXUgJiYgdGhpcy5oaWRlKCk7XG4gICAgfSk7XG4gIH1cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBlID0gQnMuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCB0KTtcbiAgICAgIGlmICh0eXBlb2YgdCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmIChlW3RdID09PSB2b2lkIDAgfHwgdC5zdGFydHNXaXRoKFwiX1wiKSB8fCB0ID09PSBcImNvbnN0cnVjdG9yXCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgIGVbdF0odGhpcyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmNvbnN0IEluID0gXCJhbGVydFwiLCBZdSA9IFwidGUuYWxlcnRcIiwgTGMgPSBgLiR7WXV9YCwganUgPSBgY2xvc2Uke0xjfWAsIEt1ID0gYGNsb3NlZCR7TGN9YCwgYWkgPSBcImRhdGEtdGUtYWxlcnQtc2hvd1wiLCB6dSA9IHtcbiAgYW5pbWF0aW9uOiBcImJvb2xlYW5cIixcbiAgYXV0b2hpZGU6IFwiYm9vbGVhblwiLFxuICBkZWxheTogXCJudW1iZXJcIlxufSwgSnIgPSB7XG4gIGFuaW1hdGlvbjogITAsXG4gIGF1dG9oaWRlOiAhMCxcbiAgZGVsYXk6IDFlM1xufSwgVXUgPSB7XG4gIGZhZGVJbjogXCJhbmltYXRlLVtmYWRlLWluXzAuM3NfYm90aF0gcC1bYXV0b10gbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmUgbW90aW9uLXJlZHVjZTphbmltYXRlLW5vbmVcIixcbiAgZmFkZU91dDogXCJhbmltYXRlLVtmYWRlLW91dF8wLjNzX2JvdGhdIHAtW2F1dG9dIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIG1vdGlvbi1yZWR1Y2U6YW5pbWF0ZS1ub25lXCJcbn0sIFh1ID0ge1xuICBmYWRlSW46IFwic3RyaW5nXCIsXG4gIGZhZGVPdXQ6IFwic3RyaW5nXCJcbn07XG5jbGFzcyBMbyBleHRlbmRzIGd0IHtcbiAgY29uc3RydWN0b3IodCwgZSwgaSkge1xuICAgIHN1cGVyKHQpLCB0aGlzLl9lbGVtZW50ID0gdCwgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLl9jbGFzc2VzID0gdGhpcy5fZ2V0Q2xhc3NlcyhpKSwgdGhpcy5fZGlkSW5pdCA9ICExLCB0aGlzLl9pbml0KCk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgIHJldHVybiB6dTtcbiAgfVxuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIEpyO1xuICB9XG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gSW47XG4gIH1cbiAgLy8gUHVibGljXG4gIGNsb3NlKCkge1xuICAgIGlmIChjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwganUpLmRlZmF1bHRQcmV2ZW50ZWQpXG4gICAgICByZXR1cm47XG4gICAgbGV0IGUgPSAwO1xuICAgIHRoaXMuX2NvbmZpZy5hbmltYXRpb24gJiYgKGUgPSAzMDAsIGguYWRkQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy5mYWRlT3V0KSksIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGFpKSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKFxuICAgICAgICAoKSA9PiB0aGlzLl9kZXN0cm95RWxlbWVudCgpLFxuICAgICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgICB0aGlzLl9jb25maWcuYW5pbWF0aW9uXG4gICAgICApO1xuICAgIH0sIGUpO1xuICB9XG4gIHNob3coKSB7XG4gICAgaWYgKHRoaXMuX2VsZW1lbnQpIHtcbiAgICAgIGlmICh0aGlzLl9jb25maWcuYXV0b2hpZGUgJiYgdGhpcy5fc2V0dXBBdXRvaGlkZSgpLCAhdGhpcy5fZWxlbWVudC5oYXNBdHRyaWJ1dGUoYWkpICYmIChoLnJlbW92ZUNsYXNzKHRoaXMuX2VsZW1lbnQsIFwiaGlkZGVuXCIpLCBoLmFkZENsYXNzKHRoaXMuX2VsZW1lbnQsIFwiYmxvY2tcIiksIE50KHRoaXMuX2VsZW1lbnQpKSkge1xuICAgICAgICBjb25zdCB0ID0gKGUpID0+IHtcbiAgICAgICAgICBoLnJlbW92ZUNsYXNzKHRoaXMuX2VsZW1lbnQsIFwiaGlkZGVuXCIpLCBoLmFkZENsYXNzKHRoaXMuX2VsZW1lbnQsIFwiYmxvY2tcIiksIGMub2ZmKGUudGFyZ2V0LCBcImFuaW1hdGlvbmVuZFwiLCB0KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoYWksIFwiXCIpLCBjLm9uKHRoaXMuX2VsZW1lbnQsIFwiYW5pbWF0aW9uZW5kXCIsIHQpO1xuICAgICAgfVxuICAgICAgdGhpcy5fY29uZmlnLmFuaW1hdGlvbiAmJiAoaC5yZW1vdmVDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl9jbGFzc2VzLmZhZGVPdXQpLCBoLmFkZENsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NsYXNzZXMuZmFkZUluKSk7XG4gICAgfVxuICB9XG4gIGhpZGUoKSB7XG4gICAgaWYgKHRoaXMuX2VsZW1lbnQgJiYgdGhpcy5fZWxlbWVudC5oYXNBdHRyaWJ1dGUoYWkpKSB7XG4gICAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShhaSk7XG4gICAgICBjb25zdCB0ID0gKGUpID0+IHtcbiAgICAgICAgaC5hZGRDbGFzcyh0aGlzLl9lbGVtZW50LCBcImhpZGRlblwiKSwgaC5yZW1vdmVDbGFzcyh0aGlzLl9lbGVtZW50LCBcImJsb2NrXCIpLCB0aGlzLl90aW1lb3V0ICE9PSBudWxsICYmIChjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dCksIHRoaXMuX3RpbWVvdXQgPSBudWxsKSwgYy5vZmYoZS50YXJnZXQsIFwiYW5pbWF0aW9uZW5kXCIsIHQpO1xuICAgICAgfTtcbiAgICAgIGMub24odGhpcy5fZWxlbWVudCwgXCJhbmltYXRpb25lbmRcIiwgdCksIGgucmVtb3ZlQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy5mYWRlSW4pLCBoLmFkZENsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NsYXNzZXMuZmFkZU91dCk7XG4gICAgfVxuICB9XG4gIC8vIFByaXZhdGVcbiAgX2luaXQoKSB7XG4gICAgdGhpcy5fZGlkSW5pdCB8fCAoY24oTG8sIFwiY2xvc2VcIiksIHRoaXMuX2RpZEluaXQgPSAhMCk7XG4gIH1cbiAgX2dldENvbmZpZyh0KSB7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5KcixcbiAgICAgIC4uLmguZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCksXG4gICAgICAuLi50eXBlb2YgdCA9PSBcIm9iamVjdFwiICYmIHQgPyB0IDoge31cbiAgICB9LCBEKEluLCB0LCB0aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHRUeXBlKSwgdDtcbiAgfVxuICBfZ2V0Q2xhc3Nlcyh0KSB7XG4gICAgY29uc3QgZSA9IGguZ2V0RGF0YUNsYXNzQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLlV1LFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBEKEluLCB0LCBYdSksIHQ7XG4gIH1cbiAgX3NldHVwQXV0b2hpZGUoKSB7XG4gICAgdGhpcy5fdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5oaWRlKCk7XG4gICAgfSwgdGhpcy5fY29uZmlnLmRlbGF5KTtcbiAgfVxuICBfZGVzdHJveUVsZW1lbnQoKSB7XG4gICAgdGhpcy5fZWxlbWVudC5yZW1vdmUoKSwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEt1KSwgdGhpcy5kaXNwb3NlKCk7XG4gIH1cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBlID0gTG8uZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzKTtcbiAgICAgIGlmICh0eXBlb2YgdCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmIChlW3RdID09PSB2b2lkIDAgfHwgdC5zdGFydHNXaXRoKFwiX1wiKSB8fCB0ID09PSBcImNvbnN0cnVjdG9yXCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgIGVbdF0odGhpcyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmNvbnN0IERuID0gXCJjYXJvdXNlbFwiLCBHdSA9IFwidGUuY2Fyb3VzZWxcIiwgX3QgPSBgLiR7R3V9YCwgTmMgPSBcIi5kYXRhLWFwaVwiLCBxdSA9IFwiQXJyb3dMZWZ0XCIsIFp1ID0gXCJBcnJvd1JpZ2h0XCIsIFF1ID0gNTAwLCBKdSA9IDQwLCB0YSA9IHtcbiAgaW50ZXJ2YWw6IDVlMyxcbiAga2V5Ym9hcmQ6ICEwLFxuICByaWRlOiAhMSxcbiAgcGF1c2U6IFwiaG92ZXJcIixcbiAgd3JhcDogITAsXG4gIHRvdWNoOiAhMFxufSwgdHAgPSB7XG4gIGludGVydmFsOiBcIihudW1iZXJ8Ym9vbGVhbilcIixcbiAga2V5Ym9hcmQ6IFwiYm9vbGVhblwiLFxuICByaWRlOiBcIihib29sZWFufHN0cmluZylcIixcbiAgcGF1c2U6IFwiKHN0cmluZ3xib29sZWFuKVwiLFxuICB3cmFwOiBcImJvb2xlYW5cIixcbiAgdG91Y2g6IFwiYm9vbGVhblwiXG59LCBlcCA9IHtcbiAgcG9pbnRlcjogXCJ0b3VjaC1wYW4teVwiLFxuICBibG9jazogXCIhYmxvY2tcIixcbiAgdmlzaWJsZTogXCJkYXRhLVt0ZS1jYXJvdXNlbC1mYWRlXTpvcGFjaXR5LTEwMCBkYXRhLVt0ZS1jYXJvdXNlbC1mYWRlXTp6LVsxXVwiLFxuICBpbnZpc2libGU6IFwiZGF0YS1bdGUtY2Fyb3VzZWwtZmFkZV06ei0wIGRhdGEtW3RlLWNhcm91c2VsLWZhZGVdOm9wYWNpdHktMCBkYXRhLVt0ZS1jYXJvdXNlbC1mYWRlXTpkdXJhdGlvbi1bNjAwbXNdIGRhdGEtW3RlLWNhcm91c2VsLWZhZGVdOmRlbGF5LTYwMFwiLFxuICBzbGlkZVJpZ2h0OiBcInRyYW5zbGF0ZS14LWZ1bGxcIixcbiAgc2xpZGVMZWZ0OiBcIi10cmFuc2xhdGUteC1mdWxsXCJcbn0sIGlwID0ge1xuICBwb2ludGVyOiBcInN0cmluZ1wiLFxuICBibG9jazogXCJzdHJpbmdcIixcbiAgdmlzaWJsZTogXCJzdHJpbmdcIixcbiAgaW52aXNpYmxlOiBcInN0cmluZ1wiLFxuICBzbGlkZVJpZ2h0OiBcInN0cmluZ1wiLFxuICBzbGlkZUxlZnQ6IFwic3RyaW5nXCJcbn0sIGxlID0gXCJuZXh0XCIsIGNlID0gXCJwcmV2XCIsIF9lID0gXCJsZWZ0XCIsIG1pID0gXCJyaWdodFwiLCBzcCA9IHtcbiAgW3F1XTogbWksXG4gIFtadV06IF9lXG59LCBucCA9IGBzbGlkZSR7X3R9YCwgJG4gPSBgc2xpZCR7X3R9YCwgb3AgPSBga2V5ZG93biR7X3R9YCwgcnAgPSBgbW91c2VlbnRlciR7X3R9YCwgYXAgPSBgbW91c2VsZWF2ZSR7X3R9YCwgbHAgPSBgdG91Y2hzdGFydCR7X3R9YCwgY3AgPSBgdG91Y2htb3ZlJHtfdH1gLCBocCA9IGB0b3VjaGVuZCR7X3R9YCwgZHAgPSBgcG9pbnRlcmRvd24ke190fWAsIHVwID0gYHBvaW50ZXJ1cCR7X3R9YCwgcHAgPSBgZHJhZ3N0YXJ0JHtfdH1gLCBfcCA9IGBsb2FkJHtfdH0ke05jfWAsIGZwID0gYGNsaWNrJHtfdH0ke05jfWAsIGVhID0gXCJkYXRhLXRlLWNhcm91c2VsLWluaXRcIiwgaGUgPSBcImRhdGEtdGUtY2Fyb3VzZWwtYWN0aXZlXCIsIG1wID0gXCJkYXRhLXRlLWNhcm91c2VsLWl0ZW0tZW5kXCIsIExuID0gXCJkYXRhLXRlLWNhcm91c2VsLWl0ZW0tc3RhcnRcIiwgZ3AgPSBcImRhdGEtdGUtY2Fyb3VzZWwtaXRlbS1uZXh0XCIsIGJwID0gXCJkYXRhLXRlLWNhcm91c2VsLWl0ZW0tcHJldlwiLCB2cCA9IFwiZGF0YS10ZS1jYXJvdXNlbC1wb2ludGVyLWV2ZW50XCIsIFRwID0gXCJbZGF0YS10ZS1jYXJvdXNlbC1pbml0XVwiLCBNYyA9IFwiW2RhdGEtdGUtY2Fyb3VzZWwtYWN0aXZlXVwiLCBkciA9IFwiW2RhdGEtdGUtY2Fyb3VzZWwtaXRlbV1cIiwgd2UgPSBgJHtNY30ke2RyfWAsIEVwID0gYCR7ZHJ9IGltZ2AsIENwID0gXCJbZGF0YS10ZS1jYXJvdXNlbC1pdGVtLW5leHRdLCBbZGF0YS10ZS1jYXJvdXNlbC1pdGVtLXByZXZdXCIsIEFwID0gXCJbZGF0YS10ZS1jYXJvdXNlbC1pbmRpY2F0b3JzXVwiLCB5cCA9IFwiW2RhdGEtdGUtdGFyZ2V0XVwiLCB3cCA9IFwiW2RhdGEtdGUtc2xpZGVdLCBbZGF0YS10ZS1zbGlkZS10b11cIiwga3AgPSBcInRvdWNoXCIsIHhwID0gXCJwZW5cIjtcbmNsYXNzIFV0IGV4dGVuZHMgZ3Qge1xuICBjb25zdHJ1Y3Rvcih0LCBlLCBpKSB7XG4gICAgc3VwZXIodCksIHRoaXMuX2l0ZW1zID0gbnVsbCwgdGhpcy5faW50ZXJ2YWwgPSBudWxsLCB0aGlzLl9hY3RpdmVFbGVtZW50ID0gbnVsbCwgdGhpcy5faXNQYXVzZWQgPSAhMSwgdGhpcy5faXNTbGlkaW5nID0gITEsIHRoaXMudG91Y2hUaW1lb3V0ID0gbnVsbCwgdGhpcy50b3VjaFN0YXJ0WCA9IDAsIHRoaXMudG91Y2hEZWx0YVggPSAwLCB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX2NsYXNzZXMgPSB0aGlzLl9nZXRDbGFzc2VzKGkpLCB0aGlzLl9pbmRpY2F0b3JzRWxlbWVudCA9IGQuZmluZE9uZShcbiAgICAgIEFwLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICksIHRoaXMuX3RvdWNoU3VwcG9ydGVkID0gXCJvbnRvdWNoc3RhcnRcIiBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgfHwgbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID4gMCwgdGhpcy5fcG9pbnRlckV2ZW50ID0gISF3aW5kb3cuUG9pbnRlckV2ZW50LCB0aGlzLl9zZXRBY3RpdmVFbGVtZW50Q2xhc3MoKSwgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcnMoKSwgdGhpcy5fZGlkSW5pdCA9ICExLCB0aGlzLl9pbml0KCksIHRoaXMuX2NvbmZpZy5yaWRlID09PSBcImNhcm91c2VsXCIgJiYgdGhpcy5jeWNsZSgpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgIHJldHVybiB0YTtcbiAgfVxuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIERuO1xuICB9XG4gIC8vIFB1YmxpY1xuICBuZXh0KCkge1xuICAgIHRoaXMuX3NsaWRlKGxlKTtcbiAgfVxuICBuZXh0V2hlblZpc2libGUoKSB7XG4gICAgIWRvY3VtZW50LmhpZGRlbiAmJiBOdCh0aGlzLl9lbGVtZW50KSAmJiB0aGlzLm5leHQoKTtcbiAgfVxuICBwcmV2KCkge1xuICAgIHRoaXMuX3NsaWRlKGNlKTtcbiAgfVxuICBwYXVzZSh0KSB7XG4gICAgdCB8fCAodGhpcy5faXNQYXVzZWQgPSAhMCksIGQuZmluZE9uZShDcCwgdGhpcy5fZWxlbWVudCkgJiYgKFhsKHRoaXMuX2VsZW1lbnQpLCB0aGlzLmN5Y2xlKCEwKSksIGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWwpLCB0aGlzLl9pbnRlcnZhbCA9IG51bGw7XG4gIH1cbiAgY3ljbGUodCkge1xuICAgIHQgfHwgKHRoaXMuX2lzUGF1c2VkID0gITEpLCB0aGlzLl9pbnRlcnZhbCAmJiAoY2xlYXJJbnRlcnZhbCh0aGlzLl9pbnRlcnZhbCksIHRoaXMuX2ludGVydmFsID0gbnVsbCksIHRoaXMuX2NvbmZpZyAmJiB0aGlzLl9jb25maWcuaW50ZXJ2YWwgJiYgIXRoaXMuX2lzUGF1c2VkICYmICh0aGlzLl91cGRhdGVJbnRlcnZhbCgpLCB0aGlzLl9pbnRlcnZhbCA9IHNldEludGVydmFsKFxuICAgICAgKGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA/IHRoaXMubmV4dFdoZW5WaXNpYmxlIDogdGhpcy5uZXh0KS5iaW5kKFxuICAgICAgICB0aGlzXG4gICAgICApLFxuICAgICAgdGhpcy5fY29uZmlnLmludGVydmFsXG4gICAgKSk7XG4gIH1cbiAgdG8odCkge1xuICAgIHRoaXMuX2FjdGl2ZUVsZW1lbnQgPSBkLmZpbmRPbmUoXG4gICAgICB3ZSxcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApO1xuICAgIGNvbnN0IGUgPSB0aGlzLl9nZXRJdGVtSW5kZXgodGhpcy5fYWN0aXZlRWxlbWVudCk7XG4gICAgaWYgKHQgPiB0aGlzLl9pdGVtcy5sZW5ndGggLSAxIHx8IHQgPCAwKVxuICAgICAgcmV0dXJuO1xuICAgIGlmICh0aGlzLl9pc1NsaWRpbmcpIHtcbiAgICAgIGMub25lKHRoaXMuX2VsZW1lbnQsICRuLCAoKSA9PiB0aGlzLnRvKHQpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGUgPT09IHQpIHtcbiAgICAgIHRoaXMucGF1c2UoKSwgdGhpcy5jeWNsZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpID0gdCA+IGUgPyBsZSA6IGNlO1xuICAgIHRoaXMuX3NsaWRlKGksIHRoaXMuX2l0ZW1zW3RdKTtcbiAgfVxuICAvLyBQcml2YXRlXG4gIF9pbml0KCkge1xuICAgIHRoaXMuX2RpZEluaXQgfHwgKGMub24oXG4gICAgICBkb2N1bWVudCxcbiAgICAgIGZwLFxuICAgICAgd3AsXG4gICAgICBVdC5kYXRhQXBpQ2xpY2tIYW5kbGVyXG4gICAgKSwgYy5vbih3aW5kb3csIF9wLCAoKSA9PiB7XG4gICAgICBjb25zdCB0ID0gZC5maW5kKFRwKTtcbiAgICAgIGZvciAobGV0IGUgPSAwLCBpID0gdC5sZW5ndGg7IGUgPCBpOyBlKyspXG4gICAgICAgIFV0LmNhcm91c2VsSW50ZXJmYWNlKFxuICAgICAgICAgIHRbZV0sXG4gICAgICAgICAgVXQuZ2V0SW5zdGFuY2UodFtlXSlcbiAgICAgICAgKTtcbiAgICB9KSwgdGhpcy5fZGlkSW5pdCA9ICEwKTtcbiAgfVxuICBfZ2V0Q29uZmlnKHQpIHtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLnRhLFxuICAgICAgLi4uaC5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KSxcbiAgICAgIC4uLnR5cGVvZiB0ID09IFwib2JqZWN0XCIgPyB0IDoge31cbiAgICB9LCBEKERuLCB0LCB0cCksIHQ7XG4gIH1cbiAgX2dldENsYXNzZXModCkge1xuICAgIGNvbnN0IGUgPSBoLmdldERhdGFDbGFzc0F0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5lcCxcbiAgICAgIC4uLmUsXG4gICAgICAuLi50XG4gICAgfSwgRChEbiwgdCwgaXApLCB0O1xuICB9XG4gIF9lbmFibGVDeWNsZSgpIHtcbiAgICBpZiAodGhpcy5fY29uZmlnLnJpZGUpIHtcbiAgICAgIGlmICh0aGlzLl9pc1NsaWRpbmcpIHtcbiAgICAgICAgYy5vbmUodGhpcy5fZWxlbWVudCwgJG4sICgpID0+IHRoaXMuY3ljbGUoKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuY3ljbGUoKTtcbiAgICB9XG4gIH1cbiAgX2FwcGx5SW5pdGlhbENsYXNzZXMoKSB7XG4gICAgY29uc3QgdCA9IGQuZmluZE9uZShcbiAgICAgIHdlLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICk7XG4gICAgdC5jbGFzc0xpc3QuYWRkKFxuICAgICAgdGhpcy5fY2xhc3Nlcy5ibG9jayxcbiAgICAgIC4uLnRoaXMuX2NsYXNzZXMudmlzaWJsZS5zcGxpdChcIiBcIilcbiAgICApLCB0aGlzLl9zZXRBY3RpdmVJbmRpY2F0b3JFbGVtZW50KHQpO1xuICB9XG4gIF9oYW5kbGVTd2lwZSgpIHtcbiAgICBjb25zdCB0ID0gTWF0aC5hYnModGhpcy50b3VjaERlbHRhWCk7XG4gICAgaWYgKHQgPD0gSnUpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZSA9IHQgLyB0aGlzLnRvdWNoRGVsdGFYO1xuICAgIHRoaXMudG91Y2hEZWx0YVggPSAwLCBlICYmIHRoaXMuX3NsaWRlKGUgPiAwID8gbWkgOiBfZSk7XG4gIH1cbiAgX3NldEFjdGl2ZUVsZW1lbnRDbGFzcygpIHtcbiAgICB0aGlzLl9hY3RpdmVFbGVtZW50ID0gZC5maW5kT25lKFxuICAgICAgd2UsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKSwgaC5hZGRDbGFzcyh0aGlzLl9hY3RpdmVFbGVtZW50LCBcImhpZGRlblwiKTtcbiAgfVxuICBfYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5fY29uZmlnLmtleWJvYXJkICYmIGMub24oXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgb3AsXG4gICAgICAodCkgPT4gdGhpcy5fa2V5ZG93bih0KVxuICAgICksIHRoaXMuX2NvbmZpZy5wYXVzZSA9PT0gXCJob3ZlclwiICYmIChjLm9uKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIHJwLFxuICAgICAgKHQpID0+IHRoaXMucGF1c2UodClcbiAgICApLCBjLm9uKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIGFwLFxuICAgICAgKHQpID0+IHRoaXMuX2VuYWJsZUN5Y2xlKHQpXG4gICAgKSksIHRoaXMuX2NvbmZpZy50b3VjaCAmJiB0aGlzLl90b3VjaFN1cHBvcnRlZCAmJiB0aGlzLl9hZGRUb3VjaEV2ZW50TGlzdGVuZXJzKCksIHRoaXMuX2FwcGx5SW5pdGlhbENsYXNzZXMoKTtcbiAgfVxuICBfYWRkVG91Y2hFdmVudExpc3RlbmVycygpIHtcbiAgICBjb25zdCB0ID0gKG8pID0+IHRoaXMuX3BvaW50ZXJFdmVudCAmJiAoby5wb2ludGVyVHlwZSA9PT0geHAgfHwgby5wb2ludGVyVHlwZSA9PT0ga3ApLCBlID0gKG8pID0+IHtcbiAgICAgIHQobykgPyB0aGlzLnRvdWNoU3RhcnRYID0gby5jbGllbnRYIDogdGhpcy5fcG9pbnRlckV2ZW50IHx8ICh0aGlzLnRvdWNoU3RhcnRYID0gby50b3VjaGVzWzBdLmNsaWVudFgpO1xuICAgIH0sIGkgPSAobykgPT4ge1xuICAgICAgdGhpcy50b3VjaERlbHRhWCA9IG8udG91Y2hlcyAmJiBvLnRvdWNoZXMubGVuZ3RoID4gMSA/IDAgOiBvLnRvdWNoZXNbMF0uY2xpZW50WCAtIHRoaXMudG91Y2hTdGFydFg7XG4gICAgfSwgbiA9IChvKSA9PiB7XG4gICAgICB0KG8pICYmICh0aGlzLnRvdWNoRGVsdGFYID0gby5jbGllbnRYIC0gdGhpcy50b3VjaFN0YXJ0WCksIHRoaXMuX2hhbmRsZVN3aXBlKCksIHRoaXMuX2NvbmZpZy5wYXVzZSA9PT0gXCJob3ZlclwiICYmICh0aGlzLnBhdXNlKCksIHRoaXMudG91Y2hUaW1lb3V0ICYmIGNsZWFyVGltZW91dCh0aGlzLnRvdWNoVGltZW91dCksIHRoaXMudG91Y2hUaW1lb3V0ID0gc2V0VGltZW91dChcbiAgICAgICAgKHIpID0+IHRoaXMuX2VuYWJsZUN5Y2xlKHIpLFxuICAgICAgICBRdSArIHRoaXMuX2NvbmZpZy5pbnRlcnZhbFxuICAgICAgKSk7XG4gICAgfTtcbiAgICBkLmZpbmQoRXAsIHRoaXMuX2VsZW1lbnQpLmZvckVhY2goXG4gICAgICAobykgPT4ge1xuICAgICAgICBjLm9uKFxuICAgICAgICAgIG8sXG4gICAgICAgICAgcHAsXG4gICAgICAgICAgKHIpID0+IHIucHJldmVudERlZmF1bHQoKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICksIHRoaXMuX3BvaW50ZXJFdmVudCA/IChjLm9uKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIGRwLFxuICAgICAgKG8pID0+IGUobylcbiAgICApLCBjLm9uKHRoaXMuX2VsZW1lbnQsIHVwLCAobykgPT4gbihvKSksIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZCh0aGlzLl9jbGFzc2VzLnBvaW50ZXIpLCB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShgJHt2cH1gLCBcIlwiKSkgOiAoYy5vbih0aGlzLl9lbGVtZW50LCBscCwgKG8pID0+IGUobykpLCBjLm9uKHRoaXMuX2VsZW1lbnQsIGNwLCAobykgPT4gaShvKSksIGMub24odGhpcy5fZWxlbWVudCwgaHAsIChvKSA9PiBuKG8pKSk7XG4gIH1cbiAgX2tleWRvd24odCkge1xuICAgIGlmICgvaW5wdXR8dGV4dGFyZWEvaS50ZXN0KHQudGFyZ2V0LnRhZ05hbWUpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGUgPSBzcFt0LmtleV07XG4gICAgZSAmJiAodC5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLl9zbGlkZShlKSk7XG4gIH1cbiAgX2dldEl0ZW1JbmRleCh0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2l0ZW1zID0gdCAmJiB0LnBhcmVudE5vZGUgPyBkLmZpbmQoZHIsIHQucGFyZW50Tm9kZSkgOiBbXSwgdGhpcy5faXRlbXMuaW5kZXhPZih0KTtcbiAgfVxuICBfZ2V0SXRlbUJ5T3JkZXIodCwgZSkge1xuICAgIGNvbnN0IGkgPSB0ID09PSBsZTtcbiAgICByZXR1cm4gSmwoXG4gICAgICB0aGlzLl9pdGVtcyxcbiAgICAgIGUsXG4gICAgICBpLFxuICAgICAgdGhpcy5fY29uZmlnLndyYXBcbiAgICApO1xuICB9XG4gIF90cmlnZ2VyU2xpZGVFdmVudCh0LCBlKSB7XG4gICAgY29uc3QgaSA9IHRoaXMuX2dldEl0ZW1JbmRleCh0KSwgbiA9IHRoaXMuX2dldEl0ZW1JbmRleChcbiAgICAgIGQuZmluZE9uZSh3ZSwgdGhpcy5fZWxlbWVudClcbiAgICApO1xuICAgIHJldHVybiBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgbnAsIHtcbiAgICAgIHJlbGF0ZWRUYXJnZXQ6IHQsXG4gICAgICBkaXJlY3Rpb246IGUsXG4gICAgICBmcm9tOiBuLFxuICAgICAgdG86IGlcbiAgICB9KTtcbiAgfVxuICBfc2V0QWN0aXZlSW5kaWNhdG9yRWxlbWVudCh0KSB7XG4gICAgaWYgKHRoaXMuX2luZGljYXRvcnNFbGVtZW50KSB7XG4gICAgICBjb25zdCBlID0gZC5maW5kT25lKFxuICAgICAgICBNYyxcbiAgICAgICAgdGhpcy5faW5kaWNhdG9yc0VsZW1lbnRcbiAgICAgICk7XG4gICAgICBlLnJlbW92ZUF0dHJpYnV0ZShoZSksIGUucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1jdXJyZW50XCIpLCBlLmNsYXNzTGlzdC5yZW1vdmUoXCIhb3BhY2l0eS0xMDBcIik7XG4gICAgICBjb25zdCBpID0gZC5maW5kKFxuICAgICAgICB5cCxcbiAgICAgICAgdGhpcy5faW5kaWNhdG9yc0VsZW1lbnRcbiAgICAgICk7XG4gICAgICBmb3IgKGxldCBuID0gMDsgbiA8IGkubGVuZ3RoOyBuKyspXG4gICAgICAgIGlmIChOdW1iZXIucGFyc2VJbnQoXG4gICAgICAgICAgaVtuXS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXRlLXNsaWRlLXRvXCIpLFxuICAgICAgICAgIDEwXG4gICAgICAgICkgPT09IHRoaXMuX2dldEl0ZW1JbmRleCh0KSkge1xuICAgICAgICAgIGlbbl0uc2V0QXR0cmlidXRlKGAke2hlfWAsIFwiXCIpLCBpW25dLnNldEF0dHJpYnV0ZShcImFyaWEtY3VycmVudFwiLCBcInRydWVcIiksIGlbbl0uY2xhc3NMaXN0LmFkZChcIiFvcGFjaXR5LTEwMFwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuICBfdXBkYXRlSW50ZXJ2YWwoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2FjdGl2ZUVsZW1lbnQgfHwgZC5maW5kT25lKHdlLCB0aGlzLl9lbGVtZW50KTtcbiAgICBpZiAoIXQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZSA9IE51bWJlci5wYXJzZUludChcbiAgICAgIHQuZ2V0QXR0cmlidXRlKFwiZGF0YS10ZS1pbnRlcnZhbFwiKSxcbiAgICAgIDEwXG4gICAgKTtcbiAgICBlID8gKHRoaXMuX2NvbmZpZy5kZWZhdWx0SW50ZXJ2YWwgPSB0aGlzLl9jb25maWcuZGVmYXVsdEludGVydmFsIHx8IHRoaXMuX2NvbmZpZy5pbnRlcnZhbCwgdGhpcy5fY29uZmlnLmludGVydmFsID0gZSkgOiB0aGlzLl9jb25maWcuaW50ZXJ2YWwgPSB0aGlzLl9jb25maWcuZGVmYXVsdEludGVydmFsIHx8IHRoaXMuX2NvbmZpZy5pbnRlcnZhbDtcbiAgfVxuICBfc2xpZGUodCwgZSkge1xuICAgIGNvbnN0IGkgPSB0aGlzLl9kaXJlY3Rpb25Ub09yZGVyKHQpLCBuID0gZC5maW5kT25lKFxuICAgICAgd2UsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKSwgbyA9IHRoaXMuX2dldEl0ZW1JbmRleChuKSwgciA9IGUgfHwgdGhpcy5fZ2V0SXRlbUJ5T3JkZXIoaSwgbiksIGEgPSB0aGlzLl9nZXRJdGVtSW5kZXgociksIGwgPSAhIXRoaXMuX2ludGVydmFsLCBwID0gaSA9PT0gbGUsIHUgPSBwID8gTG4gOiBtcCwgXyA9IHAgPyBncCA6IGJwLCBmID0gdGhpcy5fb3JkZXJUb0RpcmVjdGlvbihpKSwgZyA9IHUgPT09IExuID8gdGhpcy5fY2xhc3Nlcy5zbGlkZUxlZnQgOiB0aGlzLl9jbGFzc2VzLnNsaWRlUmlnaHQsIG0gPSB1ICE9PSBMbiA/IHRoaXMuX2NsYXNzZXMuc2xpZGVMZWZ0IDogdGhpcy5fY2xhc3Nlcy5zbGlkZVJpZ2h0O1xuICAgIGlmIChyICYmIHIuaGFzQXR0cmlidXRlKGhlKSkge1xuICAgICAgdGhpcy5faXNTbGlkaW5nID0gITE7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl9pc1NsaWRpbmcgfHwgdGhpcy5fdHJpZ2dlclNsaWRlRXZlbnQociwgZikuZGVmYXVsdFByZXZlbnRlZCB8fCAhbiB8fCAhcilcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9pc1NsaWRpbmcgPSAhMCwgbCAmJiB0aGlzLnBhdXNlKCksIHRoaXMuX3NldEFjdGl2ZUluZGljYXRvckVsZW1lbnQociksIHRoaXMuX2FjdGl2ZUVsZW1lbnQgPSByO1xuICAgIGNvbnN0IHYgPSAoKSA9PiB7XG4gICAgICBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgJG4sIHtcbiAgICAgICAgcmVsYXRlZFRhcmdldDogcixcbiAgICAgICAgZGlyZWN0aW9uOiBmLFxuICAgICAgICBmcm9tOiBvLFxuICAgICAgICB0bzogYVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBpZiAodGhpcy5fZWxlbWVudC5oYXNBdHRyaWJ1dGUoZWEpKSB7XG4gICAgICByLnNldEF0dHJpYnV0ZShgJHtffWAsIFwiXCIpLCByLmNsYXNzTGlzdC5hZGQodGhpcy5fY2xhc3Nlcy5ibG9jaywgbSksIEplKHIpLCBuLnNldEF0dHJpYnV0ZShgJHt1fWAsIFwiXCIpLCBuLmNsYXNzTGlzdC5hZGQoXG4gICAgICAgIGcsXG4gICAgICAgIC4uLnRoaXMuX2NsYXNzZXMuaW52aXNpYmxlLnNwbGl0KFwiIFwiKVxuICAgICAgKSwgbi5jbGFzc0xpc3QucmVtb3ZlKC4uLnRoaXMuX2NsYXNzZXMudmlzaWJsZS5zcGxpdChcIiBcIikpLCByLnNldEF0dHJpYnV0ZShgJHt1fWAsIFwiXCIpLCByLmNsYXNzTGlzdC5hZGQoLi4udGhpcy5fY2xhc3Nlcy52aXNpYmxlLnNwbGl0KFwiIFwiKSksIHIuY2xhc3NMaXN0LnJlbW92ZShcbiAgICAgICAgdGhpcy5fY2xhc3Nlcy5zbGlkZVJpZ2h0LFxuICAgICAgICB0aGlzLl9jbGFzc2VzLnNsaWRlTGVmdFxuICAgICAgKTtcbiAgICAgIGNvbnN0IEMgPSAoKSA9PiB7XG4gICAgICAgIHIucmVtb3ZlQXR0cmlidXRlKHUpLCByLnJlbW92ZUF0dHJpYnV0ZShfKSwgci5zZXRBdHRyaWJ1dGUoYCR7aGV9YCwgXCJcIiksIG4ucmVtb3ZlQXR0cmlidXRlKGhlKSwgbi5jbGFzc0xpc3QucmVtb3ZlKFxuICAgICAgICAgIGcsXG4gICAgICAgICAgLi4udGhpcy5fY2xhc3Nlcy5pbnZpc2libGUuc3BsaXQoXCIgXCIpLFxuICAgICAgICAgIHRoaXMuX2NsYXNzZXMuYmxvY2tcbiAgICAgICAgKSwgbi5yZW1vdmVBdHRyaWJ1dGUoXyksIG4ucmVtb3ZlQXR0cmlidXRlKHUpLCB0aGlzLl9pc1NsaWRpbmcgPSAhMSwgc2V0VGltZW91dCh2LCAwKTtcbiAgICAgIH07XG4gICAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKEMsIG4sICEwKTtcbiAgICB9IGVsc2VcbiAgICAgIG4ucmVtb3ZlQXR0cmlidXRlKGhlKSwgbi5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuX2NsYXNzZXMuYmxvY2spLCByLnNldEF0dHJpYnV0ZShgJHtoZX1gLCBcIlwiKSwgci5jbGFzc0xpc3QuYWRkKHRoaXMuX2NsYXNzZXMuYmxvY2spLCB0aGlzLl9pc1NsaWRpbmcgPSAhMSwgdigpO1xuICAgIGwgJiYgdGhpcy5jeWNsZSgpO1xuICB9XG4gIF9kaXJlY3Rpb25Ub09yZGVyKHQpIHtcbiAgICByZXR1cm4gW21pLCBfZV0uaW5jbHVkZXModCkgPyBGKCkgPyB0ID09PSBfZSA/IGNlIDogbGUgOiB0ID09PSBfZSA/IGxlIDogY2UgOiB0O1xuICB9XG4gIF9vcmRlclRvRGlyZWN0aW9uKHQpIHtcbiAgICByZXR1cm4gW2xlLCBjZV0uaW5jbHVkZXModCkgPyBGKCkgPyB0ID09PSBjZSA/IF9lIDogbWkgOiB0ID09PSBjZSA/IG1pIDogX2UgOiB0O1xuICB9XG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgY2Fyb3VzZWxJbnRlcmZhY2UodCwgZSkge1xuICAgIGNvbnN0IGkgPSBVdC5nZXRPckNyZWF0ZUluc3RhbmNlKHQsIGUpO1xuICAgIGxldCB7IF9jb25maWc6IG4gfSA9IGk7XG4gICAgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiAmJiAobiA9IHtcbiAgICAgIC4uLm4sXG4gICAgICAuLi5lXG4gICAgfSk7XG4gICAgY29uc3QgbyA9IHR5cGVvZiBlID09IFwic3RyaW5nXCIgPyBlIDogZS5zbGlkZTtcbiAgICBpZiAodHlwZW9mIGUgPT0gXCJudW1iZXJcIikge1xuICAgICAgaS50byhlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvID09IFwic3RyaW5nXCIpIHtcbiAgICAgIGlmICh0eXBlb2YgaVtvXSA+IFwidVwiKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke299XCJgKTtcbiAgICAgIGlbb10oKTtcbiAgICB9IGVsc2VcbiAgICAgIG4uaW50ZXJ2YWwgJiYgbi5yaWRlID09PSAhMCAmJiBpLnBhdXNlKCk7XG4gIH1cbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0KSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIFV0LmNhcm91c2VsSW50ZXJmYWNlKHRoaXMsIHQpO1xuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBkYXRhQXBpQ2xpY2tIYW5kbGVyKHQpIHtcbiAgICBjb25zdCBlID0gSnQodGhpcyk7XG4gICAgaWYgKCFlIHx8ICFlLmhhc0F0dHJpYnV0ZShlYSkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgaSA9IHtcbiAgICAgIC4uLmguZ2V0RGF0YUF0dHJpYnV0ZXMoZSksXG4gICAgICAuLi5oLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMpXG4gICAgfSwgbiA9IHRoaXMuZ2V0QXR0cmlidXRlKFwiZGF0YS10ZS1zbGlkZS10b1wiKTtcbiAgICBuICYmIChpLmludGVydmFsID0gITEpLCBVdC5jYXJvdXNlbEludGVyZmFjZShlLCBpKSwgbiAmJiBVdC5nZXRJbnN0YW5jZShlKS50byhuKSwgdC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG59XG5jb25zdCBObiA9IFwibW9kYWxcIiwgT3AgPSBcInRlLm1vZGFsXCIsIEF0ID0gYC4ke09wfWAsIGlhID0gXCJFc2NhcGVcIiwgc2EgPSB7XG4gIGJhY2tkcm9wOiAhMCxcbiAga2V5Ym9hcmQ6ICEwLFxuICBmb2N1czogITAsXG4gIG1vZGFsTm9uSW52YXNpdmU6ICExXG59LCBTcCA9IHtcbiAgYmFja2Ryb3A6IFwiKGJvb2xlYW58c3RyaW5nKVwiLFxuICBrZXlib2FyZDogXCJib29sZWFuXCIsXG4gIGZvY3VzOiBcImJvb2xlYW5cIixcbiAgbW9kYWxOb25JbnZhc2l2ZTogXCJib29sZWFuXCJcbn0sIElwID0ge1xuICBzaG93OiBcInRyYW5zZm9ybS1ub25lXCIsXG4gIHN0YXRpYzogXCJzY2FsZS1bMS4wMl1cIixcbiAgc3RhdGljUHJvcGVydGllczogXCJ0cmFuc2l0aW9uLXNjYWxlIGR1cmF0aW9uLTMwMCBlYXNlLWluLW91dFwiXG59LCBEcCA9IHtcbiAgc2hvdzogXCJzdHJpbmdcIixcbiAgc3RhdGljOiBcInN0cmluZ1wiLFxuICBzdGF0aWNQcm9wZXJ0aWVzOiBcInN0cmluZ1wiXG59LCAkcCA9IGBoaWRlJHtBdH1gLCBMcCA9IGBoaWRlUHJldmVudGVkJHtBdH1gLCBOcCA9IGBoaWRkZW4ke0F0fWAsIE1wID0gYHNob3cke0F0fWAsIFJwID0gYHNob3duJHtBdH1gLCBuYSA9IGByZXNpemUke0F0fWAsIG9hID0gYGNsaWNrLmRpc21pc3Mke0F0fWAsIHJhID0gYGtleWRvd24uZGlzbWlzcyR7QXR9YCwgUHAgPSBgbW91c2V1cC5kaXNtaXNzJHtBdH1gLCBhYSA9IGBtb3VzZWRvd24uZGlzbWlzcyR7QXR9YCwgbGEgPSBcImRhdGEtdGUtbW9kYWwtb3BlblwiLCBjYSA9IFwiZGF0YS10ZS1vcGVuXCIsIGxpID0gXCJbZGF0YS10ZS1tb2RhbC1kaWFsb2ctcmVmXVwiLCBCcCA9IFwiW2RhdGEtdGUtbW9kYWwtYm9keS1yZWZdXCI7XG5jbGFzcyBObyBleHRlbmRzIGd0IHtcbiAgY29uc3RydWN0b3IodCwgZSwgaSkge1xuICAgIHN1cGVyKHQpLCB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX2NsYXNzZXMgPSB0aGlzLl9nZXRDbGFzc2VzKGkpLCB0aGlzLl9kaWFsb2cgPSBkLmZpbmRPbmUobGksIHRoaXMuX2VsZW1lbnQpLCB0aGlzLl9iYWNrZHJvcCA9IHRoaXMuX2NvbmZpZy5tb2RhbE5vbkludmFzaXZlID8gbnVsbCA6IHRoaXMuX2luaXRpYWxpemVCYWNrRHJvcCgpLCB0aGlzLl9mb2N1c3RyYXAgPSB0aGlzLl9pbml0aWFsaXplRm9jdXNUcmFwKCksIHRoaXMuX2lzU2hvd24gPSAhMSwgdGhpcy5faWdub3JlQmFja2Ryb3BDbGljayA9ICExLCB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSAhMSwgdGhpcy5fc2Nyb2xsQmFyID0gbmV3IHFlKCksIHRoaXMuX2RpZEluaXQgPSAhMSwgdGhpcy5faW5pdCgpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgIHJldHVybiBzYTtcbiAgfVxuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIE5uO1xuICB9XG4gIC8vIFB1YmxpY1xuICB0b2dnbGUodCkge1xuICAgIHJldHVybiB0aGlzLl9pc1Nob3duID8gdGhpcy5oaWRlKCkgOiB0aGlzLnNob3codCk7XG4gIH1cbiAgc2hvdyh0KSB7XG4gICAgdGhpcy5faXNTaG93biB8fCB0aGlzLl9pc1RyYW5zaXRpb25pbmcgfHwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIE1wLCB7XG4gICAgICByZWxhdGVkVGFyZ2V0OiB0XG4gICAgfSkuZGVmYXVsdFByZXZlbnRlZCB8fCAodGhpcy5faXNTaG93biA9ICEwLCB0aGlzLl9pc0FuaW1hdGVkKCkgJiYgKHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9ICEwKSwgIXRoaXMuX2NvbmZpZy5tb2RhbE5vbkludmFzaXZlICYmIHRoaXMuX3Njcm9sbEJhci5oaWRlKCksIGRvY3VtZW50LmJvZHkuc2V0QXR0cmlidXRlKGxhLCBcInRydWVcIiksIHRoaXMuX2FkanVzdERpYWxvZygpLCB0aGlzLl9zZXRFc2NhcGVFdmVudCgpLCB0aGlzLl9zZXRSZXNpemVFdmVudCgpLCBjLm9uKHRoaXMuX2RpYWxvZywgYWEsICgpID0+IHtcbiAgICAgIGMub25lKHRoaXMuX2VsZW1lbnQsIFBwLCAoaSkgPT4ge1xuICAgICAgICBpLnRhcmdldCA9PT0gdGhpcy5fZWxlbWVudCAmJiAodGhpcy5faWdub3JlQmFja2Ryb3BDbGljayA9ICEwKTtcbiAgICAgIH0pO1xuICAgIH0pLCB0aGlzLl9zaG93RWxlbWVudCh0KSwgIXRoaXMuX2NvbmZpZy5tb2RhbE5vbkludmFzaXZlICYmIHRoaXMuX3Nob3dCYWNrZHJvcCgpKTtcbiAgfVxuICBoaWRlKCkge1xuICAgIGlmICghdGhpcy5faXNTaG93biB8fCB0aGlzLl9pc1RyYW5zaXRpb25pbmcgfHwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsICRwKS5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX2lzU2hvd24gPSAhMTtcbiAgICBjb25zdCBlID0gdGhpcy5faXNBbmltYXRlZCgpO1xuICAgIGUgJiYgKHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9ICEwKSwgdGhpcy5fc2V0RXNjYXBlRXZlbnQoKSwgdGhpcy5fc2V0UmVzaXplRXZlbnQoKSwgdGhpcy5fZm9jdXN0cmFwLmRpc2FibGUoKSwgZC5maW5kT25lKGxpLCB0aGlzLl9lbGVtZW50KS5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuX2NsYXNzZXMuc2hvdyksIGMub2ZmKHRoaXMuX2VsZW1lbnQsIG9hKSwgYy5vZmYodGhpcy5fZGlhbG9nLCBhYSksIHRoaXMuX3F1ZXVlQ2FsbGJhY2soKCkgPT4gdGhpcy5faGlkZU1vZGFsKCksIHRoaXMuX2VsZW1lbnQsIGUpLCB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShjYSk7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICBbd2luZG93LCB0aGlzLl9kaWFsb2ddLmZvckVhY2goXG4gICAgICAodCkgPT4gYy5vZmYodCwgQXQpXG4gICAgKSwgdGhpcy5fYmFja2Ryb3AgJiYgdGhpcy5fYmFja2Ryb3AuZGlzcG9zZSgpLCB0aGlzLl9mb2N1c3RyYXAuZGlzYWJsZSgpLCBzdXBlci5kaXNwb3NlKCk7XG4gIH1cbiAgaGFuZGxlVXBkYXRlKCkge1xuICAgIHRoaXMuX2FkanVzdERpYWxvZygpO1xuICB9XG4gIC8vIFByaXZhdGVcbiAgX2luaXQoKSB7XG4gICAgdGhpcy5fZGlkSW5pdCB8fCAoY24oTm8pLCB0aGlzLl9kaWRJbml0ID0gITApO1xuICB9XG4gIF9pbml0aWFsaXplQmFja0Ryb3AoKSB7XG4gICAgcmV0dXJuIG5ldyBocih7XG4gICAgICBpc1Zpc2libGU6ICEhdGhpcy5fY29uZmlnLmJhY2tkcm9wLFxuICAgICAgLy8gJ3N0YXRpYycgb3B0aW9uIHdpbGwgYmUgdHJhbnNsYXRlZCB0byB0cnVlLCBhbmQgYm9vbGVhbnMgd2lsbCBrZWVwIHRoZWlyIHZhbHVlXG4gICAgICBpc0FuaW1hdGVkOiB0aGlzLl9pc0FuaW1hdGVkKClcbiAgICB9KTtcbiAgfVxuICBfaW5pdGlhbGl6ZUZvY3VzVHJhcCgpIHtcbiAgICByZXR1cm4gbmV3IFdpKHRoaXMuX2VsZW1lbnQsIHtcbiAgICAgIGV2ZW50OiBcImtleWRvd25cIixcbiAgICAgIGNvbmRpdGlvbjogKHQpID0+IHQua2V5ID09PSBcIlRhYlwiXG4gICAgfSk7XG4gIH1cbiAgX2dldENvbmZpZyh0KSB7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5zYSxcbiAgICAgIC4uLmguZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCksXG4gICAgICAuLi50eXBlb2YgdCA9PSBcIm9iamVjdFwiID8gdCA6IHt9XG4gICAgfSwgRChObiwgdCwgU3ApLCB0O1xuICB9XG4gIF9nZXRDbGFzc2VzKHQpIHtcbiAgICBjb25zdCBlID0gaC5nZXREYXRhQ2xhc3NBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uSXAsXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIEQoTm4sIHQsIERwKSwgdDtcbiAgfVxuICBfc2hvd0VsZW1lbnQodCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLl9pc0FuaW1hdGVkKCksIGkgPSBkLmZpbmRPbmUoQnAsIHRoaXMuX2RpYWxvZyk7XG4gICAgKCF0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUgfHwgdGhpcy5fZWxlbWVudC5wYXJlbnROb2RlLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkgJiYgZG9jdW1lbnQuYm9keS5hcHBlbmQodGhpcy5fZWxlbWVudCksIHRoaXMuX2VsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIiwgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKFwiaGlkZGVuXCIpLCB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIpLCB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtbW9kYWxcIiwgITApLCB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJkaWFsb2dcIiksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKGAke2NhfWAsIFwidHJ1ZVwiKSwgdGhpcy5fZWxlbWVudC5zY3JvbGxUb3AgPSAwO1xuICAgIGNvbnN0IG4gPSBkLmZpbmRPbmUobGksIHRoaXMuX2VsZW1lbnQpO1xuICAgIG4uY2xhc3NMaXN0LmFkZCh0aGlzLl9jbGFzc2VzLnNob3cpLCBuLmNsYXNzTGlzdC5yZW1vdmUoXCJvcGFjaXR5LTBcIiksIG4uY2xhc3NMaXN0LmFkZChcIm9wYWNpdHktMTAwXCIpLCBpICYmIChpLnNjcm9sbFRvcCA9IDApLCBlICYmIEplKHRoaXMuX2VsZW1lbnQpO1xuICAgIGNvbnN0IG8gPSAoKSA9PiB7XG4gICAgICB0aGlzLl9jb25maWcuZm9jdXMgJiYgdGhpcy5fZm9jdXN0cmFwLnRyYXAoKSwgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gITEsIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBScCwge1xuICAgICAgICByZWxhdGVkVGFyZ2V0OiB0XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2sobywgdGhpcy5fZGlhbG9nLCBlKTtcbiAgfVxuICBfc2V0RXNjYXBlRXZlbnQoKSB7XG4gICAgdGhpcy5faXNTaG93biA/IGMub24oZG9jdW1lbnQsIHJhLCAodCkgPT4ge1xuICAgICAgdGhpcy5fY29uZmlnLmtleWJvYXJkICYmIHQua2V5ID09PSBpYSA/ICh0LnByZXZlbnREZWZhdWx0KCksIHRoaXMuaGlkZSgpKSA6ICF0aGlzLl9jb25maWcua2V5Ym9hcmQgJiYgdC5rZXkgPT09IGlhICYmIHRoaXMuX3RyaWdnZXJCYWNrZHJvcFRyYW5zaXRpb24oKTtcbiAgICB9KSA6IGMub2ZmKHRoaXMuX2VsZW1lbnQsIHJhKTtcbiAgfVxuICBfc2V0UmVzaXplRXZlbnQoKSB7XG4gICAgdGhpcy5faXNTaG93biA/IGMub24od2luZG93LCBuYSwgKCkgPT4gdGhpcy5fYWRqdXN0RGlhbG9nKCkpIDogYy5vZmYod2luZG93LCBuYSk7XG4gIH1cbiAgX2hpZGVNb2RhbCgpIHtcbiAgICBjb25zdCB0ID0gZC5maW5kT25lKGxpLCB0aGlzLl9lbGVtZW50KTtcbiAgICB0LmNsYXNzTGlzdC5yZW1vdmUodGhpcy5fY2xhc3Nlcy5zaG93KSwgdC5jbGFzc0xpc3QucmVtb3ZlKFwib3BhY2l0eS0xMDBcIiksIHQuY2xhc3NMaXN0LmFkZChcIm9wYWNpdHktMFwiKSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLl9lbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICB9LCAzMDApLCB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsICEwKSwgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLW1vZGFsXCIpLCB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcInJvbGVcIiksIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9ICExLCB0aGlzLl9iYWNrZHJvcCAmJiB0aGlzLl9iYWNrZHJvcC5oaWRlKCgpID0+IHtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQXR0cmlidXRlKGxhKSwgdGhpcy5fcmVzZXRBZGp1c3RtZW50cygpLCAhdGhpcy5fY29uZmlnLm1vZGFsTm9uSW52YXNpdmUgJiYgdGhpcy5fc2Nyb2xsQmFyLnJlc2V0KCksIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBOcCk7XG4gICAgfSk7XG4gIH1cbiAgX3Nob3dCYWNrZHJvcCh0KSB7XG4gICAgYy5vbih0aGlzLl9lbGVtZW50LCBvYSwgKGUpID0+IHtcbiAgICAgIGlmICh0aGlzLl9pZ25vcmVCYWNrZHJvcENsaWNrKSB7XG4gICAgICAgIHRoaXMuX2lnbm9yZUJhY2tkcm9wQ2xpY2sgPSAhMTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZS50YXJnZXQgPT09IGUuY3VycmVudFRhcmdldCAmJiAodGhpcy5fY29uZmlnLmJhY2tkcm9wID09PSAhMCA/IHRoaXMuaGlkZSgpIDogdGhpcy5fY29uZmlnLmJhY2tkcm9wID09PSBcInN0YXRpY1wiICYmIHRoaXMuX3RyaWdnZXJCYWNrZHJvcFRyYW5zaXRpb24oKSk7XG4gICAgfSksIHRoaXMuX2JhY2tkcm9wICYmIHRoaXMuX2JhY2tkcm9wLnNob3codCk7XG4gIH1cbiAgX2lzQW5pbWF0ZWQoKSB7XG4gICAgcmV0dXJuICEhZC5maW5kT25lKGxpLCB0aGlzLl9lbGVtZW50KTtcbiAgfVxuICBfdHJpZ2dlckJhY2tkcm9wVHJhbnNpdGlvbigpIHtcbiAgICBpZiAoYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIExwKS5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgY2xhc3NMaXN0OiBlLCBzY3JvbGxIZWlnaHQ6IGksIHN0eWxlOiBuIH0gPSB0aGlzLl9lbGVtZW50LCBvID0gaSA+IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gICAgIW8gJiYgbi5vdmVyZmxvd1kgPT09IFwiaGlkZGVuXCIgfHwgZS5jb250YWlucyh0aGlzLl9jbGFzc2VzLnN0YXRpYykgfHwgKG8gfHwgKG4ub3ZlcmZsb3dZID0gXCJoaWRkZW5cIiksIGUuYWRkKC4uLnRoaXMuX2NsYXNzZXMuc3RhdGljLnNwbGl0KFwiIFwiKSksIGUuYWRkKC4uLnRoaXMuX2NsYXNzZXMuc3RhdGljUHJvcGVydGllcy5zcGxpdChcIiBcIikpLCB0aGlzLl9xdWV1ZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgIGUucmVtb3ZlKHRoaXMuX2NsYXNzZXMuc3RhdGljKSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGUucmVtb3ZlKC4uLnRoaXMuX2NsYXNzZXMuc3RhdGljUHJvcGVydGllcy5zcGxpdChcIiBcIikpO1xuICAgICAgfSwgMzAwKSwgbyB8fCB0aGlzLl9xdWV1ZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgbi5vdmVyZmxvd1kgPSBcIlwiO1xuICAgICAgfSwgdGhpcy5fZGlhbG9nKTtcbiAgICB9LCB0aGlzLl9kaWFsb2cpLCB0aGlzLl9lbGVtZW50LmZvY3VzKCkpO1xuICB9XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gdGhlIGZvbGxvd2luZyBtZXRob2RzIGFyZSB1c2VkIHRvIGhhbmRsZSBvdmVyZmxvd2luZyBtb2RhbHNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBfYWRqdXN0RGlhbG9nKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9lbGVtZW50LnNjcm9sbEhlaWdodCA+IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQsIGUgPSB0aGlzLl9zY3JvbGxCYXIuZ2V0V2lkdGgoKSwgaSA9IGUgPiAwO1xuICAgICghaSAmJiB0ICYmICFGKCkgfHwgaSAmJiAhdCAmJiBGKCkpICYmICh0aGlzLl9lbGVtZW50LnN0eWxlLnBhZGRpbmdMZWZ0ID0gYCR7ZX1weGApLCAoaSAmJiAhdCAmJiAhRigpIHx8ICFpICYmIHQgJiYgRigpKSAmJiAodGhpcy5fZWxlbWVudC5zdHlsZS5wYWRkaW5nUmlnaHQgPSBgJHtlfXB4YCk7XG4gIH1cbiAgX3Jlc2V0QWRqdXN0bWVudHMoKSB7XG4gICAgdGhpcy5fZWxlbWVudC5zdHlsZS5wYWRkaW5nTGVmdCA9IFwiXCIsIHRoaXMuX2VsZW1lbnQuc3R5bGUucGFkZGluZ1JpZ2h0ID0gXCJcIjtcbiAgfVxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0LCBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGkgPSBOby5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMsIHQpO1xuICAgICAgaWYgKHR5cGVvZiB0ID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpW3RdID4gXCJ1XCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgIGlbdF0oZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmNvbnN0IEhwID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xuICBcImJhY2tncm91bmRcIixcbiAgXCJjaXRlXCIsXG4gIFwiaHJlZlwiLFxuICBcIml0ZW10eXBlXCIsXG4gIFwibG9uZ2Rlc2NcIixcbiAgXCJwb3N0ZXJcIixcbiAgXCJzcmNcIixcbiAgXCJ4bGluazpocmVmXCJcbl0pLCBWcCA9IC9eYXJpYS1bXFx3LV0qJC9pLCBXcCA9IC9eKD86KD86aHR0cHM/fG1haWx0b3xmdHB8dGVsfGZpbGV8c21zKTp8W14jJi86P10qKD86WyMvP118JCkpL2ksIEZwID0gL15kYXRhOig/OmltYWdlXFwvKD86Ym1wfGdpZnxqcGVnfGpwZ3xwbmd8dGlmZnx3ZWJwKXx2aWRlb1xcLyg/Om1wZWd8bXA0fG9nZ3x3ZWJtKXxhdWRpb1xcLyg/Om1wM3xvZ2F8b2dnfG9wdXMpKTtiYXNlNjQsW1xcZCsvYS16XSs9KiQvaSwgWXAgPSAocywgdCkgPT4ge1xuICBjb25zdCBlID0gcy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICBpZiAodC5pbmNsdWRlcyhlKSlcbiAgICByZXR1cm4gSHAuaGFzKGUpID8gISEoV3AudGVzdChzLm5vZGVWYWx1ZSkgfHwgRnAudGVzdChzLm5vZGVWYWx1ZSkpIDogITA7XG4gIGNvbnN0IGkgPSB0LmZpbHRlcihcbiAgICAobikgPT4gbiBpbnN0YW5jZW9mIFJlZ0V4cFxuICApO1xuICBmb3IgKGxldCBuID0gMCwgbyA9IGkubGVuZ3RoOyBuIDwgbzsgbisrKVxuICAgIGlmIChpW25dLnRlc3QoZSkpXG4gICAgICByZXR1cm4gITA7XG4gIHJldHVybiAhMTtcbn0sIGpwID0ge1xuICAvLyBHbG9iYWwgYXR0cmlidXRlcyBhbGxvd2VkIG9uIGFueSBzdXBwbGllZCBlbGVtZW50IGJlbG93LlxuICBcIipcIjogW1wiY2xhc3NcIiwgXCJkaXJcIiwgXCJpZFwiLCBcImxhbmdcIiwgXCJyb2xlXCIsIFZwXSxcbiAgYTogW1widGFyZ2V0XCIsIFwiaHJlZlwiLCBcInRpdGxlXCIsIFwicmVsXCJdLFxuICBhcmVhOiBbXSxcbiAgYjogW10sXG4gIGJyOiBbXSxcbiAgY29sOiBbXSxcbiAgY29kZTogW10sXG4gIGRpdjogW10sXG4gIGVtOiBbXSxcbiAgaHI6IFtdLFxuICBoMTogW10sXG4gIGgyOiBbXSxcbiAgaDM6IFtdLFxuICBoNDogW10sXG4gIGg1OiBbXSxcbiAgaDY6IFtdLFxuICBpOiBbXSxcbiAgaW1nOiBbXCJzcmNcIiwgXCJzcmNzZXRcIiwgXCJhbHRcIiwgXCJ0aXRsZVwiLCBcIndpZHRoXCIsIFwiaGVpZ2h0XCJdLFxuICBsaTogW10sXG4gIG9sOiBbXSxcbiAgcDogW10sXG4gIHByZTogW10sXG4gIHM6IFtdLFxuICBzbWFsbDogW10sXG4gIHNwYW46IFtdLFxuICBzdWI6IFtdLFxuICBzdXA6IFtdLFxuICBzdHJvbmc6IFtdLFxuICB1OiBbXSxcbiAgdWw6IFtdXG59O1xuZnVuY3Rpb24gaGEocywgdCwgZSkge1xuICBpZiAoIXMubGVuZ3RoKVxuICAgIHJldHVybiBzO1xuICBpZiAoZSAmJiB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIpXG4gICAgcmV0dXJuIGUocyk7XG4gIGNvbnN0IG4gPSBuZXcgd2luZG93LkRPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyhzLCBcInRleHQvaHRtbFwiKSwgbyA9IFtdLmNvbmNhdCguLi5uLmJvZHkucXVlcnlTZWxlY3RvckFsbChcIipcIikpO1xuICBmb3IgKGxldCByID0gMCwgYSA9IG8ubGVuZ3RoOyByIDwgYTsgcisrKSB7XG4gICAgY29uc3QgbCA9IG9bcl0sIHAgPSBsLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKCFPYmplY3Qua2V5cyh0KS5pbmNsdWRlcyhwKSkge1xuICAgICAgbC5yZW1vdmUoKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCB1ID0gW10uY29uY2F0KC4uLmwuYXR0cmlidXRlcyksIF8gPSBbXS5jb25jYXQoXG4gICAgICB0W1wiKlwiXSB8fCBbXSxcbiAgICAgIHRbcF0gfHwgW11cbiAgICApO1xuICAgIHUuZm9yRWFjaCgoZikgPT4ge1xuICAgICAgWXAoZiwgXykgfHwgbC5yZW1vdmVBdHRyaWJ1dGUoZi5ub2RlTmFtZSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG4uYm9keS5pbm5lckhUTUw7XG59XG5jb25zdCBkYSA9IFwidG9vbHRpcFwiLCBLcCA9IFwidGUudG9vbHRpcFwiLCB3dCA9IGAuJHtLcH1gLCB6cCA9IFwidGUtdG9vbHRpcFwiLCBVcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcInNhbml0aXplXCIsIFwiYWxsb3dMaXN0XCIsIFwic2FuaXRpemVGblwiXSksIFhwID0ge1xuICBhbmltYXRpb246IFwiYm9vbGVhblwiLFxuICB0ZW1wbGF0ZTogXCJzdHJpbmdcIixcbiAgdGl0bGU6IFwiKHN0cmluZ3xlbGVtZW50fGZ1bmN0aW9uKVwiLFxuICB0cmlnZ2VyOiBcInN0cmluZ1wiLFxuICBkZWxheTogXCIobnVtYmVyfG9iamVjdClcIixcbiAgaHRtbDogXCJib29sZWFuXCIsXG4gIHNlbGVjdG9yOiBcIihzdHJpbmd8Ym9vbGVhbilcIixcbiAgcGxhY2VtZW50OiBcIihzdHJpbmd8ZnVuY3Rpb24pXCIsXG4gIG9mZnNldDogXCIoYXJyYXl8c3RyaW5nfGZ1bmN0aW9uKVwiLFxuICBjb250YWluZXI6IFwiKHN0cmluZ3xlbGVtZW50fGJvb2xlYW4pXCIsXG4gIGZhbGxiYWNrUGxhY2VtZW50czogXCJhcnJheVwiLFxuICBib3VuZGFyeTogXCIoc3RyaW5nfGVsZW1lbnQpXCIsXG4gIGN1c3RvbUNsYXNzOiBcIihzdHJpbmd8ZnVuY3Rpb24pXCIsXG4gIHNhbml0aXplOiBcImJvb2xlYW5cIixcbiAgc2FuaXRpemVGbjogXCIobnVsbHxmdW5jdGlvbilcIixcbiAgYWxsb3dMaXN0OiBcIm9iamVjdFwiLFxuICBwb3BwZXJDb25maWc6IFwiKG51bGx8b2JqZWN0fGZ1bmN0aW9uKVwiXG59LCBHcCA9IHtcbiAgQVVUTzogXCJhdXRvXCIsXG4gIFRPUDogXCJ0b3BcIixcbiAgUklHSFQ6IEYoKSA/IFwibGVmdFwiIDogXCJyaWdodFwiLFxuICBCT1RUT006IFwiYm90dG9tXCIsXG4gIExFRlQ6IEYoKSA/IFwicmlnaHRcIiA6IFwibGVmdFwiXG59LCBxcCA9IHtcbiAgYW5pbWF0aW9uOiAhMCxcbiAgdGVtcGxhdGU6ICc8ZGl2IGNsYXNzPVwib3BhY2l0eS0wIHRyYW5zaXRpb24tb3BhY2l0eSBkdXJhdGlvbi0zMDAgZWFzZS1pbi1vdXQgYWJzb2x1dGUgei1bMTA4MF0gYmxvY2sgbS0wIHRleHQtc20gbm90LWl0YWxpYyBmb250LW5vcm1hbCB0ZXh0LWxlZnQgbm8tdW5kZXJsaW5lIHVuZGVybGluZS1vZmZzZXQtYXV0byBub3JtYWwtY2FzZSBsZWFkaW5nLTYgdHJhY2tpbmctbm9ybWFsIGJyZWFrLW5vcm1hbCB3aGl0ZXNwYWNlLW5vcm1hbFwiIHJvbGU9XCJ0b29sdGlwXCI+PGRpdiBkYXRhLXRlLXRvb2x0aXAtaW5uZXItcmVmIGNsYXNzPVwidG9vbHRpcC1pbm5lciBtYXgtdy1bMjAwcHhdIHRleHQtc20gcHktMS41IHB4LTQgdGV4dC13aGl0ZSB0ZXh0LWNlbnRlciBiZy1bIzZkNmQ2ZF0gcm91bmRlZFwiPjwvZGl2PjwvZGl2PicsXG4gIHRyaWdnZXI6IFwiaG92ZXIgZm9jdXNcIixcbiAgdGl0bGU6IFwiXCIsXG4gIGRlbGF5OiAwLFxuICBodG1sOiAhMSxcbiAgc2VsZWN0b3I6ICExLFxuICBwbGFjZW1lbnQ6IFwidG9wXCIsXG4gIG9mZnNldDogWzAsIDBdLFxuICBjb250YWluZXI6ICExLFxuICBmYWxsYmFja1BsYWNlbWVudHM6IFtcInRvcFwiLCBcInJpZ2h0XCIsIFwiYm90dG9tXCIsIFwibGVmdFwiXSxcbiAgYm91bmRhcnk6IFwiY2xpcHBpbmdQYXJlbnRzXCIsXG4gIGN1c3RvbUNsYXNzOiBcIlwiLFxuICBzYW5pdGl6ZTogITAsXG4gIHNhbml0aXplRm46IG51bGwsXG4gIGFsbG93TGlzdDoganAsXG4gIHBvcHBlckNvbmZpZzogeyBoaWRlOiAhMCB9XG59LCBacCA9IHtcbiAgSElERTogYGhpZGUke3d0fWAsXG4gIEhJRERFTjogYGhpZGRlbiR7d3R9YCxcbiAgU0hPVzogYHNob3cke3d0fWAsXG4gIFNIT1dOOiBgc2hvd24ke3d0fWAsXG4gIElOU0VSVEVEOiBgaW5zZXJ0ZWQke3d0fWAsXG4gIENMSUNLOiBgY2xpY2ske3d0fWAsXG4gIEZPQ1VTSU46IGBmb2N1c2luJHt3dH1gLFxuICBGT0NVU09VVDogYGZvY3Vzb3V0JHt3dH1gLFxuICBNT1VTRUVOVEVSOiBgbW91c2VlbnRlciR7d3R9YCxcbiAgTU9VU0VMRUFWRTogYG1vdXNlbGVhdmUke3d0fWBcbn0sIFFwID0gXCJmYWRlXCIsIEpwID0gXCJtb2RhbFwiLCBNbiA9IFwic2hvd1wiLCBjaSA9IFwic2hvd1wiLCBSbiA9IFwib3V0XCIsIHVhID0gXCIudG9vbHRpcC1pbm5lclwiLCBwYSA9IGAuJHtKcH1gLCBfYSA9IFwiaGlkZS50ZS5tb2RhbFwiLCBoaSA9IFwiaG92ZXJcIiwgUG4gPSBcImZvY3VzXCIsIHRfID0gXCJjbGlja1wiLCBlXyA9IFwibWFudWFsXCI7XG5jbGFzcyBpaSBleHRlbmRzIGd0IHtcbiAgY29uc3RydWN0b3IodCwgZSkge1xuICAgIGlmICh0eXBlb2YgSWMgPiBcInVcIilcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgIFwiQm9vdHN0cmFwJ3MgdG9vbHRpcHMgcmVxdWlyZSBQb3BwZXIgKGh0dHBzOi8vcG9wcGVyLmpzLm9yZylcIlxuICAgICAgKTtcbiAgICBzdXBlcih0KSwgdGhpcy5faXNFbmFibGVkID0gITAsIHRoaXMuX3RpbWVvdXQgPSAwLCB0aGlzLl9ob3ZlclN0YXRlID0gXCJcIiwgdGhpcy5fYWN0aXZlVHJpZ2dlciA9IHt9LCB0aGlzLl9wb3BwZXIgPSBudWxsLCB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMudGlwID0gbnVsbCwgdGhpcy5fc2V0TGlzdGVuZXJzKCk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIHFwO1xuICB9XG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gZGE7XG4gIH1cbiAgc3RhdGljIGdldCBFdmVudCgpIHtcbiAgICByZXR1cm4gWnA7XG4gIH1cbiAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcbiAgICByZXR1cm4gWHA7XG4gIH1cbiAgLy8gUHVibGljXG4gIGVuYWJsZSgpIHtcbiAgICB0aGlzLl9pc0VuYWJsZWQgPSAhMDtcbiAgfVxuICBkaXNhYmxlKCkge1xuICAgIHRoaXMuX2lzRW5hYmxlZCA9ICExO1xuICB9XG4gIHRvZ2dsZUVuYWJsZWQoKSB7XG4gICAgdGhpcy5faXNFbmFibGVkID0gIXRoaXMuX2lzRW5hYmxlZDtcbiAgfVxuICB0b2dnbGUodCkge1xuICAgIGlmICh0aGlzLl9pc0VuYWJsZWQpXG4gICAgICBpZiAodCkge1xuICAgICAgICBjb25zdCBlID0gdGhpcy5faW5pdGlhbGl6ZU9uRGVsZWdhdGVkVGFyZ2V0KHQpO1xuICAgICAgICBlLl9hY3RpdmVUcmlnZ2VyLmNsaWNrID0gIWUuX2FjdGl2ZVRyaWdnZXIuY2xpY2ssIGUuX2lzV2l0aEFjdGl2ZVRyaWdnZXIoKSA/IGUuX2VudGVyKG51bGwsIGUpIDogZS5fbGVhdmUobnVsbCwgZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5nZXRUaXBFbGVtZW50KCkuY2xhc3NMaXN0LmNvbnRhaW5zKE1uKSkge1xuICAgICAgICAgIHRoaXMuX2xlYXZlKG51bGwsIHRoaXMpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9lbnRlcihudWxsLCB0aGlzKTtcbiAgICAgIH1cbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KSwgYy5vZmYoXG4gICAgICB0aGlzLl9lbGVtZW50LmNsb3Nlc3QocGEpLFxuICAgICAgX2EsXG4gICAgICB0aGlzLl9oaWRlTW9kYWxIYW5kbGVyXG4gICAgKSwgdGhpcy50aXAgJiYgdGhpcy50aXAucmVtb3ZlKCksIHRoaXMuX2Rpc3Bvc2VQb3BwZXIoKSwgc3VwZXIuZGlzcG9zZSgpO1xuICB9XG4gIHNob3coKSB7XG4gICAgaWYgKHRoaXMuX2VsZW1lbnQuc3R5bGUuZGlzcGxheSA9PT0gXCJub25lXCIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2UgdXNlIHNob3cgb24gdmlzaWJsZSBlbGVtZW50c1wiKTtcbiAgICBpZiAoISh0aGlzLmlzV2l0aENvbnRlbnQoKSAmJiB0aGlzLl9pc0VuYWJsZWQpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHQgPSBjLnRyaWdnZXIoXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5TSE9XXG4gICAgKSwgZSA9IEdsKHRoaXMuX2VsZW1lbnQpLCBpID0gZSA9PT0gbnVsbCA/IHRoaXMuX2VsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY29udGFpbnModGhpcy5fZWxlbWVudCkgOiBlLmNvbnRhaW5zKHRoaXMuX2VsZW1lbnQpO1xuICAgIGlmICh0LmRlZmF1bHRQcmV2ZW50ZWQgfHwgIWkpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5jb25zdHJ1Y3Rvci5OQU1FID09PSBcInRvb2x0aXBcIiAmJiB0aGlzLnRpcCAmJiB0aGlzLmdldFRpdGxlKCkgIT09IHRoaXMudGlwLnF1ZXJ5U2VsZWN0b3IodWEpLmlubmVySFRNTCAmJiAodGhpcy5fZGlzcG9zZVBvcHBlcigpLCB0aGlzLnRpcC5yZW1vdmUoKSwgdGhpcy50aXAgPSBudWxsKTtcbiAgICBjb25zdCBuID0gdGhpcy5nZXRUaXBFbGVtZW50KCksIG8gPSBydCh0aGlzLmNvbnN0cnVjdG9yLk5BTUUpO1xuICAgIG4uc2V0QXR0cmlidXRlKFwiaWRcIiwgbyksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1kZXNjcmliZWRieVwiLCBvKSwgdGhpcy5fY29uZmlnLmFuaW1hdGlvbiAmJiBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMudGlwLmNsYXNzTGlzdC5hZGQoXCJvcGFjaXR5LTEwMFwiKSwgdGhpcy50aXAuY2xhc3NMaXN0LnJlbW92ZShcIm9wYWNpdHktMFwiKTtcbiAgICB9LCAxMDApO1xuICAgIGNvbnN0IHIgPSB0eXBlb2YgdGhpcy5fY29uZmlnLnBsYWNlbWVudCA9PSBcImZ1bmN0aW9uXCIgPyB0aGlzLl9jb25maWcucGxhY2VtZW50LmNhbGwodGhpcywgbiwgdGhpcy5fZWxlbWVudCkgOiB0aGlzLl9jb25maWcucGxhY2VtZW50LCBhID0gdGhpcy5fZ2V0QXR0YWNobWVudChyKTtcbiAgICB0aGlzLl9hZGRBdHRhY2htZW50Q2xhc3MoYSk7XG4gICAgY29uc3QgeyBjb250YWluZXI6IGwgfSA9IHRoaXMuX2NvbmZpZztcbiAgICBpZiAoeS5zZXREYXRhKG4sIHRoaXMuY29uc3RydWN0b3IuREFUQV9LRVksIHRoaXMpLCB0aGlzLl9lbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zKHRoaXMudGlwKSB8fCAobC5hcHBlbmQobiksIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LklOU0VSVEVEKSksIHRoaXMuX3BvcHBlciA/IHRoaXMuX3BvcHBlci51cGRhdGUoKSA6IHRoaXMuX3BvcHBlciA9IENlKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIG4sXG4gICAgICB0aGlzLl9nZXRQb3BwZXJDb25maWcoYSlcbiAgICApLCBuLmdldEF0dHJpYnV0ZShcImlkXCIpLmluY2x1ZGVzKFwidG9vbHRpcFwiKSlcbiAgICAgIHN3aXRjaCAocikge1xuICAgICAgICBjYXNlIFwiYm90dG9tXCI6XG4gICAgICAgICAgbi5jbGFzc0xpc3QuYWRkKFwicHktWzAuNHJlbV1cIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJsZWZ0XCI6XG4gICAgICAgICAgbi5jbGFzc0xpc3QuYWRkKFwicHgtWzAuNHJlbV1cIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJyaWdodFwiOlxuICAgICAgICAgIG4uY2xhc3NMaXN0LmFkZChcInB4LVswLjRyZW1dXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIG4uY2xhc3NMaXN0LmFkZChcInB5LVswLjRyZW1dXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGNvbnN0IHUgPSB0aGlzLl9yZXNvbHZlUG9zc2libGVGdW5jdGlvbih0aGlzLl9jb25maWcuY3VzdG9tQ2xhc3MpO1xuICAgIHUgJiYgbi5jbGFzc0xpc3QuYWRkKC4uLnUuc3BsaXQoXCIgXCIpKSwgXCJvbnRvdWNoc3RhcnRcIiBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgW10uY29uY2F0KC4uLmRvY3VtZW50LmJvZHkuY2hpbGRyZW4pLmZvckVhY2goKGcpID0+IHtcbiAgICAgIGMub24oZywgXCJtb3VzZW92ZXJcIiwgdG4pO1xuICAgIH0pO1xuICAgIGNvbnN0IF8gPSAoKSA9PiB7XG4gICAgICBjb25zdCBnID0gdGhpcy5faG92ZXJTdGF0ZTtcbiAgICAgIHRoaXMuX2hvdmVyU3RhdGUgPSBudWxsLCBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5TSE9XTiksIGcgPT09IFJuICYmIHRoaXMuX2xlYXZlKG51bGwsIHRoaXMpO1xuICAgIH0sIGYgPSB0aGlzLnRpcC5jbGFzc0xpc3QuY29udGFpbnMoXCJ0cmFuc2l0aW9uLW9wYWNpdHlcIik7XG4gICAgdGhpcy5fcXVldWVDYWxsYmFjayhfLCB0aGlzLnRpcCwgZik7XG4gIH1cbiAgaGlkZSgpIHtcbiAgICBpZiAoIXRoaXMuX3BvcHBlcilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB0ID0gdGhpcy5nZXRUaXBFbGVtZW50KCksIGUgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9pc1dpdGhBY3RpdmVUcmlnZ2VyKCkgfHwgKHRoaXMuX2hvdmVyU3RhdGUgIT09IGNpICYmIHQucmVtb3ZlKCksIHRoaXMuX2NsZWFuVGlwQ2xhc3MoKSwgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWRlc2NyaWJlZGJ5XCIpLCBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5ISURERU4pLCB0aGlzLl9kaXNwb3NlUG9wcGVyKCkpO1xuICAgIH07XG4gICAgaWYgKGMudHJpZ2dlcihcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICB0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LkhJREVcbiAgICApLmRlZmF1bHRQcmV2ZW50ZWQpXG4gICAgICByZXR1cm47XG4gICAgdC5jbGFzc0xpc3QuYWRkKFwib3BhY2l0eS0wXCIpLCB0LmNsYXNzTGlzdC5yZW1vdmUoXCJvcGFjaXR5LTEwMFwiKSwgXCJvbnRvdWNoc3RhcnRcIiBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgW10uY29uY2F0KC4uLmRvY3VtZW50LmJvZHkuY2hpbGRyZW4pLmZvckVhY2goKG8pID0+IGMub2ZmKG8sIFwibW91c2VvdmVyXCIsIHRuKSksIHRoaXMuX2FjdGl2ZVRyaWdnZXJbdF9dID0gITEsIHRoaXMuX2FjdGl2ZVRyaWdnZXJbUG5dID0gITEsIHRoaXMuX2FjdGl2ZVRyaWdnZXJbaGldID0gITE7XG4gICAgY29uc3QgbiA9IHRoaXMudGlwLmNsYXNzTGlzdC5jb250YWlucyhcIm9wYWNpdHktMFwiKTtcbiAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKGUsIHRoaXMudGlwLCBuKSwgdGhpcy5faG92ZXJTdGF0ZSA9IFwiXCI7XG4gIH1cbiAgdXBkYXRlKCkge1xuICAgIHRoaXMuX3BvcHBlciAhPT0gbnVsbCAmJiB0aGlzLl9wb3BwZXIudXBkYXRlKCk7XG4gIH1cbiAgLy8gUHJvdGVjdGVkXG4gIGlzV2l0aENvbnRlbnQoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5nZXRUaXRsZSgpO1xuICB9XG4gIGdldFRpcEVsZW1lbnQoKSB7XG4gICAgaWYgKHRoaXMudGlwKVxuICAgICAgcmV0dXJuIHRoaXMudGlwO1xuICAgIGNvbnN0IHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHQuaW5uZXJIVE1MID0gdGhpcy5fY29uZmlnLnRlbXBsYXRlO1xuICAgIGNvbnN0IGUgPSB0LmNoaWxkcmVuWzBdO1xuICAgIHJldHVybiB0aGlzLnNldENvbnRlbnQoZSksIGUuY2xhc3NMaXN0LnJlbW92ZShRcCwgTW4pLCB0aGlzLnRpcCA9IGUsIHRoaXMudGlwO1xuICB9XG4gIHNldENvbnRlbnQodCkge1xuICAgIHRoaXMuX3Nhbml0aXplQW5kU2V0Q29udGVudCh0LCB0aGlzLmdldFRpdGxlKCksIHVhKTtcbiAgfVxuICBfc2FuaXRpemVBbmRTZXRDb250ZW50KHQsIGUsIGkpIHtcbiAgICBjb25zdCBuID0gZC5maW5kT25lKGksIHQpO1xuICAgIGlmICghZSAmJiBuKSB7XG4gICAgICBuLnJlbW92ZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNldEVsZW1lbnRDb250ZW50KG4sIGUpO1xuICB9XG4gIHNldEVsZW1lbnRDb250ZW50KHQsIGUpIHtcbiAgICBpZiAodCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGplKGUpKSB7XG4gICAgICAgIGUgPSB0ZShlKSwgdGhpcy5fY29uZmlnLmh0bWwgPyBlLnBhcmVudE5vZGUgIT09IHQgJiYgKHQuaW5uZXJIVE1MID0gXCJcIiwgdC5hcHBlbmQoZSkpIDogdC50ZXh0Q29udGVudCA9IGUudGV4dENvbnRlbnQ7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NvbmZpZy5odG1sID8gKHRoaXMuX2NvbmZpZy5zYW5pdGl6ZSAmJiAoZSA9IGhhKFxuICAgICAgICBlLFxuICAgICAgICB0aGlzLl9jb25maWcuYWxsb3dMaXN0LFxuICAgICAgICB0aGlzLl9jb25maWcuc2FuaXRpemVGblxuICAgICAgKSksIHQuaW5uZXJIVE1MID0gZSkgOiB0LnRleHRDb250ZW50ID0gZTtcbiAgICB9XG4gIH1cbiAgZ2V0VGl0bGUoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2VsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS10ZS1vcmlnaW5hbC10aXRsZVwiKSB8fCB0aGlzLl9jb25maWcudGl0bGU7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVQb3NzaWJsZUZ1bmN0aW9uKHQpO1xuICB9XG4gIHVwZGF0ZUF0dGFjaG1lbnQodCkge1xuICAgIHJldHVybiB0ID09PSBcInJpZ2h0XCIgPyBcImVuZFwiIDogdCA9PT0gXCJsZWZ0XCIgPyBcInN0YXJ0XCIgOiB0O1xuICB9XG4gIC8vIFByaXZhdGVcbiAgX2luaXRpYWxpemVPbkRlbGVnYXRlZFRhcmdldCh0LCBlKSB7XG4gICAgcmV0dXJuIGUgfHwgdGhpcy5jb25zdHJ1Y3Rvci5nZXRPckNyZWF0ZUluc3RhbmNlKFxuICAgICAgdC5kZWxlZ2F0ZVRhcmdldCxcbiAgICAgIHRoaXMuX2dldERlbGVnYXRlQ29uZmlnKClcbiAgICApO1xuICB9XG4gIF9nZXRPZmZzZXQoKSB7XG4gICAgY29uc3QgeyBvZmZzZXQ6IHQgfSA9IHRoaXMuX2NvbmZpZztcbiAgICByZXR1cm4gdHlwZW9mIHQgPT0gXCJzdHJpbmdcIiA/IHQuc3BsaXQoXCIsXCIpLm1hcCgoZSkgPT4gTnVtYmVyLnBhcnNlSW50KGUsIDEwKSkgOiB0eXBlb2YgdCA9PSBcImZ1bmN0aW9uXCIgPyAoZSkgPT4gdChlLCB0aGlzLl9lbGVtZW50KSA6IHQ7XG4gIH1cbiAgX3Jlc29sdmVQb3NzaWJsZUZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdHlwZW9mIHQgPT0gXCJmdW5jdGlvblwiID8gdC5jYWxsKHRoaXMuX2VsZW1lbnQpIDogdDtcbiAgfVxuICBfZ2V0UG9wcGVyQ29uZmlnKHQpIHtcbiAgICBjb25zdCBlID0ge1xuICAgICAgcGxhY2VtZW50OiB0LFxuICAgICAgbW9kaWZpZXJzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcImZsaXBcIixcbiAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBmYWxsYmFja1BsYWNlbWVudHM6IHRoaXMuX2NvbmZpZy5mYWxsYmFja1BsYWNlbWVudHNcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcIm9mZnNldFwiLFxuICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIG9mZnNldDogdGhpcy5fZ2V0T2Zmc2V0KClcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcInByZXZlbnRPdmVyZmxvd1wiLFxuICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIGJvdW5kYXJ5OiB0aGlzLl9jb25maWcuYm91bmRhcnlcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcImFycm93XCIsXG4gICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgZWxlbWVudDogYC4ke3RoaXMuY29uc3RydWN0b3IuTkFNRX0tYXJyb3dgXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJvbkNoYW5nZVwiLFxuICAgICAgICAgIGVuYWJsZWQ6ICEwLFxuICAgICAgICAgIHBoYXNlOiBcImFmdGVyV3JpdGVcIixcbiAgICAgICAgICBmbjogKGkpID0+IHRoaXMuX2hhbmRsZVBvcHBlclBsYWNlbWVudENoYW5nZShpKVxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgb25GaXJzdFVwZGF0ZTogKGkpID0+IHtcbiAgICAgICAgaS5vcHRpb25zLnBsYWNlbWVudCAhPT0gaS5wbGFjZW1lbnQgJiYgdGhpcy5faGFuZGxlUG9wcGVyUGxhY2VtZW50Q2hhbmdlKGkpO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmUsXG4gICAgICAuLi50eXBlb2YgdGhpcy5fY29uZmlnLnBvcHBlckNvbmZpZyA9PSBcImZ1bmN0aW9uXCIgPyB0aGlzLl9jb25maWcucG9wcGVyQ29uZmlnKGUpIDogdGhpcy5fY29uZmlnLnBvcHBlckNvbmZpZ1xuICAgIH07XG4gIH1cbiAgX2FkZEF0dGFjaG1lbnRDbGFzcyh0KSB7XG4gICAgdGhpcy5nZXRUaXBFbGVtZW50KCkuY2xhc3NMaXN0LmFkZChcbiAgICAgIGAke3RoaXMuX2dldEJhc2ljQ2xhc3NQcmVmaXgoKX0tJHt0aGlzLnVwZGF0ZUF0dGFjaG1lbnQodCl9YFxuICAgICk7XG4gIH1cbiAgX2dldEF0dGFjaG1lbnQodCkge1xuICAgIHJldHVybiBHcFt0LnRvVXBwZXJDYXNlKCldO1xuICB9XG4gIF9zZXRMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5fY29uZmlnLnRyaWdnZXIuc3BsaXQoXCIgXCIpLmZvckVhY2goKGUpID0+IHtcbiAgICAgIGlmIChlID09PSBcImNsaWNrXCIpXG4gICAgICAgIGMub24oXG4gICAgICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LkNMSUNLLFxuICAgICAgICAgIHRoaXMuX2NvbmZpZy5zZWxlY3RvcixcbiAgICAgICAgICAoaSkgPT4gdGhpcy50b2dnbGUoaSlcbiAgICAgICAgKTtcbiAgICAgIGVsc2UgaWYgKGUgIT09IGVfKSB7XG4gICAgICAgIGNvbnN0IGkgPSBlID09PSBoaSA/IHRoaXMuY29uc3RydWN0b3IuRXZlbnQuTU9VU0VFTlRFUiA6IHRoaXMuY29uc3RydWN0b3IuRXZlbnQuRk9DVVNJTiwgbiA9IGUgPT09IGhpID8gdGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5NT1VTRUxFQVZFIDogdGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5GT0NVU09VVDtcbiAgICAgICAgYy5vbihcbiAgICAgICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgICAgIGksXG4gICAgICAgICAgdGhpcy5fY29uZmlnLnNlbGVjdG9yLFxuICAgICAgICAgIChvKSA9PiB0aGlzLl9lbnRlcihvKVxuICAgICAgICApLCBjLm9uKFxuICAgICAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICAgICAgbixcbiAgICAgICAgICB0aGlzLl9jb25maWcuc2VsZWN0b3IsXG4gICAgICAgICAgKG8pID0+IHRoaXMuX2xlYXZlKG8pXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSksIHRoaXMuX2hpZGVNb2RhbEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9lbGVtZW50ICYmIHRoaXMuaGlkZSgpO1xuICAgIH0sIGMub24oXG4gICAgICB0aGlzLl9lbGVtZW50LmNsb3Nlc3QocGEpLFxuICAgICAgX2EsXG4gICAgICB0aGlzLl9oaWRlTW9kYWxIYW5kbGVyXG4gICAgKSwgdGhpcy5fY29uZmlnLnNlbGVjdG9yID8gdGhpcy5fY29uZmlnID0ge1xuICAgICAgLi4udGhpcy5fY29uZmlnLFxuICAgICAgdHJpZ2dlcjogXCJtYW51YWxcIixcbiAgICAgIHNlbGVjdG9yOiBcIlwiXG4gICAgfSA6IHRoaXMuX2ZpeFRpdGxlKCk7XG4gIH1cbiAgX2ZpeFRpdGxlKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9lbGVtZW50LmdldEF0dHJpYnV0ZShcInRpdGxlXCIpLCBlID0gdHlwZW9mIHRoaXMuX2VsZW1lbnQuZ2V0QXR0cmlidXRlKFxuICAgICAgXCJkYXRhLXRlLW9yaWdpbmFsLXRpdGxlXCJcbiAgICApO1xuICAgICh0IHx8IGUgIT09IFwic3RyaW5nXCIpICYmICh0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcImRhdGEtdGUtb3JpZ2luYWwtdGl0bGVcIiwgdCB8fCBcIlwiKSwgdCAmJiAhdGhpcy5fZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIpICYmICF0aGlzLl9lbGVtZW50LnRleHRDb250ZW50ICYmIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCB0KSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJ0aXRsZVwiLCBcIlwiKSk7XG4gIH1cbiAgX2VudGVyKHQsIGUpIHtcbiAgICBpZiAoZSA9IHRoaXMuX2luaXRpYWxpemVPbkRlbGVnYXRlZFRhcmdldCh0LCBlKSwgdCAmJiAoZS5fYWN0aXZlVHJpZ2dlclt0LnR5cGUgPT09IFwiZm9jdXNpblwiID8gUG4gOiBoaV0gPSAhMCksIGUuZ2V0VGlwRWxlbWVudCgpLmNsYXNzTGlzdC5jb250YWlucyhNbikgfHwgZS5faG92ZXJTdGF0ZSA9PT0gY2kpIHtcbiAgICAgIGUuX2hvdmVyU3RhdGUgPSBjaTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNsZWFyVGltZW91dChlLl90aW1lb3V0KSwgZS5faG92ZXJTdGF0ZSA9IGNpLCAhZS5fY29uZmlnLmRlbGF5IHx8ICFlLl9jb25maWcuZGVsYXkuc2hvdykge1xuICAgICAgZS5zaG93KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGUuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGUuX2hvdmVyU3RhdGUgPT09IGNpICYmIGUuc2hvdygpO1xuICAgIH0sIGUuX2NvbmZpZy5kZWxheS5zaG93KTtcbiAgfVxuICBfbGVhdmUodCwgZSkge1xuICAgIGlmIChlID0gdGhpcy5faW5pdGlhbGl6ZU9uRGVsZWdhdGVkVGFyZ2V0KHQsIGUpLCB0ICYmIChlLl9hY3RpdmVUcmlnZ2VyW3QudHlwZSA9PT0gXCJmb2N1c291dFwiID8gUG4gOiBoaV0gPSBlLl9lbGVtZW50LmNvbnRhaW5zKHQucmVsYXRlZFRhcmdldCkpLCAhZS5faXNXaXRoQWN0aXZlVHJpZ2dlcigpKSB7XG4gICAgICBpZiAoY2xlYXJUaW1lb3V0KGUuX3RpbWVvdXQpLCBlLl9ob3ZlclN0YXRlID0gUm4sICFlLl9jb25maWcuZGVsYXkgfHwgIWUuX2NvbmZpZy5kZWxheS5oaWRlKSB7XG4gICAgICAgIGUuaGlkZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBlLl90aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGUuX2hvdmVyU3RhdGUgPT09IFJuICYmIGUuaGlkZSgpO1xuICAgICAgfSwgZS5fY29uZmlnLmRlbGF5LmhpZGUpO1xuICAgIH1cbiAgfVxuICBfaXNXaXRoQWN0aXZlVHJpZ2dlcigpIHtcbiAgICBmb3IgKGNvbnN0IHQgaW4gdGhpcy5fYWN0aXZlVHJpZ2dlcilcbiAgICAgIGlmICh0aGlzLl9hY3RpdmVUcmlnZ2VyW3RdKVxuICAgICAgICByZXR1cm4gITA7XG4gICAgcmV0dXJuICExO1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIGNvbnN0IGUgPSBoLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhlKS5mb3JFYWNoKChpKSA9PiB7XG4gICAgICBVcC5oYXMoaSkgJiYgZGVsZXRlIGVbaV07XG4gICAgfSksIHQgPSB7XG4gICAgICAuLi50aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHQsXG4gICAgICAuLi5lLFxuICAgICAgLi4udHlwZW9mIHQgPT0gXCJvYmplY3RcIiAmJiB0ID8gdCA6IHt9XG4gICAgfSwgdC5jb250YWluZXIgPSB0LmNvbnRhaW5lciA9PT0gITEgPyBkb2N1bWVudC5ib2R5IDogdGUodC5jb250YWluZXIpLCB0eXBlb2YgdC5kZWxheSA9PSBcIm51bWJlclwiICYmICh0LmRlbGF5ID0ge1xuICAgICAgc2hvdzogdC5kZWxheSxcbiAgICAgIGhpZGU6IHQuZGVsYXlcbiAgICB9KSwgdHlwZW9mIHQudGl0bGUgPT0gXCJudW1iZXJcIiAmJiAodC50aXRsZSA9IHQudGl0bGUudG9TdHJpbmcoKSksIHR5cGVvZiB0LmNvbnRlbnQgPT0gXCJudW1iZXJcIiAmJiAodC5jb250ZW50ID0gdC5jb250ZW50LnRvU3RyaW5nKCkpLCBEKGRhLCB0LCB0aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHRUeXBlKSwgdC5zYW5pdGl6ZSAmJiAodC50ZW1wbGF0ZSA9IGhhKFxuICAgICAgdC50ZW1wbGF0ZSxcbiAgICAgIHQuYWxsb3dMaXN0LFxuICAgICAgdC5zYW5pdGl6ZUZuXG4gICAgKSksIHQ7XG4gIH1cbiAgX2dldERlbGVnYXRlQ29uZmlnKCkge1xuICAgIGNvbnN0IHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGUgaW4gdGhpcy5fY29uZmlnKVxuICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0W2VdICE9PSB0aGlzLl9jb25maWdbZV0gJiYgKHRbZV0gPSB0aGlzLl9jb25maWdbZV0pO1xuICAgIHJldHVybiB0O1xuICB9XG4gIF9jbGVhblRpcENsYXNzKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmdldFRpcEVsZW1lbnQoKSwgZSA9IG5ldyBSZWdFeHAoXG4gICAgICBgKF58XFxcXHMpJHt0aGlzLl9nZXRCYXNpY0NsYXNzUHJlZml4KCl9XFxcXFMrYCxcbiAgICAgIFwiZ1wiXG4gICAgKSwgaSA9IHQuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikubWF0Y2goZSk7XG4gICAgaSAhPT0gbnVsbCAmJiBpLmxlbmd0aCA+IDAgJiYgaS5tYXAoKG4pID0+IG4udHJpbSgpKS5mb3JFYWNoKChuKSA9PiB0LmNsYXNzTGlzdC5yZW1vdmUobikpO1xuICB9XG4gIF9nZXRCYXNpY0NsYXNzUHJlZml4KCkge1xuICAgIHJldHVybiB6cDtcbiAgfVxuICBfaGFuZGxlUG9wcGVyUGxhY2VtZW50Q2hhbmdlKHQpIHtcbiAgICBjb25zdCB7IHN0YXRlOiBlIH0gPSB0O1xuICAgIGUgJiYgKHRoaXMudGlwID0gZS5lbGVtZW50cy5wb3BwZXIsIHRoaXMuX2NsZWFuVGlwQ2xhc3MoKSwgdGhpcy5fYWRkQXR0YWNobWVudENsYXNzKHRoaXMuX2dldEF0dGFjaG1lbnQoZS5wbGFjZW1lbnQpKSk7XG4gIH1cbiAgX2Rpc3Bvc2VQb3BwZXIoKSB7XG4gICAgdGhpcy5fcG9wcGVyICYmICh0aGlzLl9wb3BwZXIuZGVzdHJveSgpLCB0aGlzLl9wb3BwZXIgPSBudWxsKTtcbiAgfVxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0KSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGUgPSBpaS5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMsIHQpO1xuICAgICAgaWYgKHR5cGVvZiB0ID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlW3RdID4gXCJ1XCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgIGVbdF0oKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuY29uc3QgaV8gPSBcInBvcG92ZXJcIiwgc18gPSBcInRlLnBvcG92ZXJcIiwga3QgPSBgLiR7c199YCwgbl8gPSBcInRlLXBvcG92ZXJcIiwgb18gPSB7XG4gIC4uLmlpLkRlZmF1bHQsXG4gIHBsYWNlbWVudDogXCJyaWdodFwiLFxuICBvZmZzZXQ6IFswLCA4XSxcbiAgdHJpZ2dlcjogXCJjbGlja1wiLFxuICBjb250ZW50OiBcIlwiLFxuICB0ZW1wbGF0ZTogJzxkaXYgY2xhc3M9XCJvcGFjaXR5LTAgdHJhbnNpdGlvbi1vcGFjaXR5IGR1cmF0aW9uLTE1MCBlYXNlLWluLW91dCBhYnNvbHV0ZSB0b3AtMCBsZWZ0LTAgei1bMTA3MF0gYmxvY2sgbWF4LXctWzI2N3B4XSBicmVhay13b3JkcyBiZy13aGl0ZSBiZy1jbGlwLXBhZGRpbmcgYm9yZGVyIGJvcmRlci1uZXV0cmFsLTEwMCByb3VuZGVkLWxnIHNoYWRvdy1bMF8wcHhfM3B4XzBfcmdiYSgwLDAsMCwwLjA3KSwwXzJweF8ycHhfMF9yZ2JhKDAsMCwwLDAuMDQpXSB0ZXh0LXNtIG5vdC1pdGFsaWMgZm9udC1ub3JtYWwgdGV4dC1sZWZ0IG5vLXVuZGVybGluZSB1bmRlcmxpbmUtb2Zmc2V0LWF1dG8gbm9ybWFsLWNhc2UgbGVhZGluZy02IHRyYWNraW5nLW5vcm1hbCBicmVhay1ub3JtYWwgd2hpdGVzcGFjZS1ub3JtYWwgZGFyazpiZy1uZXV0cmFsLTcwMCBkYXJrOmJvcmRlci0wIGRhcms6dGV4dC13aGl0ZSBkYXRhLVtwb3BwZXItcmVmZXJlbmNlLWhpZGRlbl06aGlkZGVuXCIgcm9sZT1cInRvb2x0aXBcIj48aDMgY2xhc3M9XCJwb3BvdmVyLWhlYWRlciBweS0yIHB4LTQgbWItMCBib3JkZXItYi0yIGJvcmRlci1uZXV0cmFsLTEwMCByb3VuZGVkLXQtbGcgZm9udC1tZWRpdW0gZW1wdHk6aGlkZGVuIGRhcms6Ym9yZGVyLW5ldXRyYWwtNTAwXCI+PC9oMz48ZGl2IGNsYXNzPVwicG9wb3Zlci1ib2R5IHAtNCB0ZXh0LVsjMjEyNTI5XSBkYXJrOnRleHQtd2hpdGVcIj48L2Rpdj48L2Rpdj4nXG59LCByXyA9IHtcbiAgLi4uaWkuRGVmYXVsdFR5cGUsXG4gIGNvbnRlbnQ6IFwiKHN0cmluZ3xlbGVtZW50fGZ1bmN0aW9uKVwiXG59LCBhXyA9IHtcbiAgSElERTogYGhpZGUke2t0fWAsXG4gIEhJRERFTjogYGhpZGRlbiR7a3R9YCxcbiAgU0hPVzogYHNob3cke2t0fWAsXG4gIFNIT1dOOiBgc2hvd24ke2t0fWAsXG4gIElOU0VSVEVEOiBgaW5zZXJ0ZWQke2t0fWAsXG4gIENMSUNLOiBgY2xpY2ske2t0fWAsXG4gIEZPQ1VTSU46IGBmb2N1c2luJHtrdH1gLFxuICBGT0NVU09VVDogYGZvY3Vzb3V0JHtrdH1gLFxuICBNT1VTRUVOVEVSOiBgbW91c2VlbnRlciR7a3R9YCxcbiAgTU9VU0VMRUFWRTogYG1vdXNlbGVhdmUke2t0fWBcbn0sIGxfID0gXCIucG9wb3Zlci1oZWFkZXJcIiwgY18gPSBcIi5wb3BvdmVyLWJvZHlcIjtcbmNsYXNzIFJjIGV4dGVuZHMgaWkge1xuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gb187XG4gIH1cbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBpXztcbiAgfVxuICBzdGF0aWMgZ2V0IEV2ZW50KCkge1xuICAgIHJldHVybiBhXztcbiAgfVxuICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgIHJldHVybiByXztcbiAgfVxuICAvLyBPdmVycmlkZXNcbiAgaXNXaXRoQ29udGVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRUaXRsZSgpIHx8IHRoaXMuX2dldENvbnRlbnQoKTtcbiAgfVxuICBzZXRDb250ZW50KHQpIHtcbiAgICB0aGlzLl9zYW5pdGl6ZUFuZFNldENvbnRlbnQodCwgdGhpcy5nZXRUaXRsZSgpLCBsXyksIHRoaXMuX3Nhbml0aXplQW5kU2V0Q29udGVudCh0LCB0aGlzLl9nZXRDb250ZW50KCksIGNfKTtcbiAgfVxuICAvLyBQcml2YXRlXG4gIF9nZXRDb250ZW50KCkge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlUG9zc2libGVGdW5jdGlvbih0aGlzLl9jb25maWcuY29udGVudCk7XG4gIH1cbiAgX2dldEJhc2ljQ2xhc3NQcmVmaXgoKSB7XG4gICAgcmV0dXJuIG5fO1xuICB9XG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgZSA9IFJjLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcywgdCk7XG4gICAgICBpZiAodHlwZW9mIHQgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAodHlwZW9mIGVbdF0gPiBcInVcIilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke3R9XCJgKTtcbiAgICAgICAgZVt0XSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5jb25zdCBCbiA9IFwic2Nyb2xsc3B5XCIsIGhfID0gXCJ0ZS5zY3JvbGxzcHlcIiwgdXIgPSBgLiR7aF99YCwgZmEgPSB7XG4gIG9mZnNldDogMTAsXG4gIG1ldGhvZDogXCJhdXRvXCIsXG4gIHRhcmdldDogXCJcIlxufSwgZF8gPSB7XG4gIG9mZnNldDogXCJudW1iZXJcIixcbiAgbWV0aG9kOiBcInN0cmluZ1wiLFxuICB0YXJnZXQ6IFwiKHN0cmluZ3xlbGVtZW50KVwiXG59LCB1XyA9IHtcbiAgYWN0aXZlOiBcIiF0ZXh0LXByaW1hcnkgZGFyazohdGV4dC1wcmltYXJ5LTQwMCBmb250LXNlbWlib2xkIGJvcmRlci1sLVswLjEyNXJlbV0gYm9yZGVyLXNvbGlkIGJvcmRlci1wcmltYXJ5IGRhcms6Ym9yZGVyLXByaW1hcnktNDAwXCJcbn0sIHBfID0ge1xuICBhY3RpdmU6IFwic3RyaW5nXCJcbn0sIF9fID0gYGFjdGl2YXRlJHt1cn1gLCBmXyA9IGBzY3JvbGwke3VyfWAsIEhuID0gXCJkYXRhLXRlLW5hdi1saW5rLWFjdGl2ZVwiLCBQYyA9IFwiW2RhdGEtdGUtZHJvcGRvd24taXRlbS1yZWZdXCIsIG1fID0gXCJbZGF0YS10ZS1uYXYtbGlzdC1yZWZdXCIsIE1vID0gXCJbZGF0YS10ZS1uYXYtbGluay1yZWZdXCIsIGdfID0gXCJbZGF0YS10ZS1uYXYtaXRlbS1yZWZdXCIsIEJjID0gXCJbZGF0YS10ZS1saXN0LWdyb3VwLWl0ZW0tcmVmXVwiLCBWbiA9IGAke01vfSwgJHtCY30sICR7UGN9YCwgYl8gPSBcIltkYXRhLXRlLWRyb3Bkb3duLXJlZl1cIiwgdl8gPSBcIltkYXRhLXRlLWRyb3Bkb3duLXRvZ2dsZS1yZWZdXCIsIFRfID0gXCJtYXhPZmZzZXRcIiwgbWEgPSBcInBvc2l0aW9uXCI7XG5jbGFzcyBIYyBleHRlbmRzIGd0IHtcbiAgY29uc3RydWN0b3IodCwgZSwgaSkge1xuICAgIHN1cGVyKHQpLCB0aGlzLl9zY3JvbGxFbGVtZW50ID0gdGhpcy5fZWxlbWVudC50YWdOYW1lID09PSBcIkJPRFlcIiA/IHdpbmRvdyA6IHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhlKSwgdGhpcy5fY2xhc3NlcyA9IHRoaXMuX2dldENsYXNzZXMoaSksIHRoaXMuX29mZnNldHMgPSBbXSwgdGhpcy5fdGFyZ2V0cyA9IFtdLCB0aGlzLl9hY3RpdmVUYXJnZXQgPSBudWxsLCB0aGlzLl9zY3JvbGxIZWlnaHQgPSAwLCBjLm9uKHRoaXMuX3Njcm9sbEVsZW1lbnQsIGZfLCAoKSA9PiB0aGlzLl9wcm9jZXNzKCkpLCB0aGlzLnJlZnJlc2goKSwgdGhpcy5fcHJvY2VzcygpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgIHJldHVybiBmYTtcbiAgfVxuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIEJuO1xuICB9XG4gIC8vIFB1YmxpY1xuICByZWZyZXNoKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9zY3JvbGxFbGVtZW50ID09PSB0aGlzLl9zY3JvbGxFbGVtZW50LndpbmRvdyA/IFRfIDogbWEsIGUgPSB0aGlzLl9jb25maWcubWV0aG9kID09PSBcImF1dG9cIiA/IHQgOiB0aGlzLl9jb25maWcubWV0aG9kLCBpID0gZSA9PT0gbWEgPyB0aGlzLl9nZXRTY3JvbGxUb3AoKSA6IDA7XG4gICAgdGhpcy5fb2Zmc2V0cyA9IFtdLCB0aGlzLl90YXJnZXRzID0gW10sIHRoaXMuX3Njcm9sbEhlaWdodCA9IHRoaXMuX2dldFNjcm9sbEhlaWdodCgpLCBkLmZpbmQoXG4gICAgICBWbixcbiAgICAgIHRoaXMuX2NvbmZpZy50YXJnZXRcbiAgICApLm1hcCgobykgPT4ge1xuICAgICAgY29uc3QgciA9IHFvKG8pLCBhID0gciA/IGQuZmluZE9uZShyKSA6IG51bGw7XG4gICAgICBpZiAoYSkge1xuICAgICAgICBjb25zdCBsID0gYS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKGwud2lkdGggfHwgbC5oZWlnaHQpXG4gICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGhbZV0oYSkudG9wICsgaSxcbiAgICAgICAgICAgIHJcbiAgICAgICAgICBdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSkuZmlsdGVyKChvKSA9PiBvKS5zb3J0KChvLCByKSA9PiBvWzBdIC0gclswXSkuZm9yRWFjaCgobykgPT4ge1xuICAgICAgdGhpcy5fb2Zmc2V0cy5wdXNoKG9bMF0pLCB0aGlzLl90YXJnZXRzLnB1c2gob1sxXSk7XG4gICAgfSk7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICBjLm9mZih0aGlzLl9zY3JvbGxFbGVtZW50LCB1ciksIHN1cGVyLmRpc3Bvc2UoKTtcbiAgfVxuICAvLyBQcml2YXRlXG4gIF9nZXRDb25maWcodCkge1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uZmEsXG4gICAgICAuLi5oLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgLi4udHlwZW9mIHQgPT0gXCJvYmplY3RcIiAmJiB0ID8gdCA6IHt9XG4gICAgfSwgdC50YXJnZXQgPSB0ZSh0LnRhcmdldCkgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBEKEJuLCB0LCBkXyksIHQ7XG4gIH1cbiAgX2dldENsYXNzZXModCkge1xuICAgIGNvbnN0IGUgPSBoLmdldERhdGFDbGFzc0F0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi51XyxcbiAgICAgIC4uLmUsXG4gICAgICAuLi50XG4gICAgfSwgRChCbiwgdCwgcF8pLCB0O1xuICB9XG4gIF9nZXRTY3JvbGxUb3AoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Njcm9sbEVsZW1lbnQgPT09IHdpbmRvdyA/IHRoaXMuX3Njcm9sbEVsZW1lbnQucGFnZVlPZmZzZXQgOiB0aGlzLl9zY3JvbGxFbGVtZW50LnNjcm9sbFRvcDtcbiAgfVxuICBfZ2V0U2Nyb2xsSGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLl9zY3JvbGxFbGVtZW50LnNjcm9sbEhlaWdodCB8fCBNYXRoLm1heChcbiAgICAgIGRvY3VtZW50LmJvZHkuc2Nyb2xsSGVpZ2h0LFxuICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbEhlaWdodFxuICAgICk7XG4gIH1cbiAgX2dldE9mZnNldEhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2Nyb2xsRWxlbWVudCA9PT0gd2luZG93ID8gd2luZG93LmlubmVySGVpZ2h0IDogdGhpcy5fc2Nyb2xsRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG4gIH1cbiAgX3Byb2Nlc3MoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2dldFNjcm9sbFRvcCgpICsgdGhpcy5fY29uZmlnLm9mZnNldCwgZSA9IHRoaXMuX2dldFNjcm9sbEhlaWdodCgpLCBpID0gdGhpcy5fY29uZmlnLm9mZnNldCArIGUgLSB0aGlzLl9nZXRPZmZzZXRIZWlnaHQoKTtcbiAgICBpZiAodGhpcy5fc2Nyb2xsSGVpZ2h0ICE9PSBlICYmIHRoaXMucmVmcmVzaCgpLCB0ID49IGkpIHtcbiAgICAgIGNvbnN0IG4gPSB0aGlzLl90YXJnZXRzW3RoaXMuX3RhcmdldHMubGVuZ3RoIC0gMV07XG4gICAgICB0aGlzLl9hY3RpdmVUYXJnZXQgIT09IG4gJiYgdGhpcy5fYWN0aXZhdGUobik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl9hY3RpdmVUYXJnZXQgJiYgdCA8IHRoaXMuX29mZnNldHNbMF0gJiYgdGhpcy5fb2Zmc2V0c1swXSA+IDApIHtcbiAgICAgIHRoaXMuX2FjdGl2ZVRhcmdldCA9IG51bGwsIHRoaXMuX2NsZWFyKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAobGV0IG4gPSB0aGlzLl9vZmZzZXRzLmxlbmd0aDsgbi0tOyApXG4gICAgICB0aGlzLl9hY3RpdmVUYXJnZXQgIT09IHRoaXMuX3RhcmdldHNbbl0gJiYgdCA+PSB0aGlzLl9vZmZzZXRzW25dICYmICh0eXBlb2YgdGhpcy5fb2Zmc2V0c1tuICsgMV0gPiBcInVcIiB8fCB0IDwgdGhpcy5fb2Zmc2V0c1tuICsgMV0pICYmIHRoaXMuX2FjdGl2YXRlKHRoaXMuX3RhcmdldHNbbl0pO1xuICB9XG4gIF9hY3RpdmF0ZSh0KSB7XG4gICAgdGhpcy5fYWN0aXZlVGFyZ2V0ID0gdCwgdGhpcy5fY2xlYXIoKTtcbiAgICBjb25zdCBlID0gVm4uc3BsaXQoXCIsXCIpLm1hcChcbiAgICAgIChuKSA9PiBgJHtufVtkYXRhLXRlLXRhcmdldD1cIiR7dH1cIl0sJHtufVtocmVmPVwiJHt0fVwiXWBcbiAgICApLCBpID0gZC5maW5kT25lKGUuam9pbihcIixcIiksIHRoaXMuX2NvbmZpZy50YXJnZXQpO1xuICAgIGkuY2xhc3NMaXN0LmFkZCguLi50aGlzLl9jbGFzc2VzLmFjdGl2ZS5zcGxpdChcIiBcIikpLCBpLnNldEF0dHJpYnV0ZShIbiwgXCJcIiksIGkuZ2V0QXR0cmlidXRlKFBjKSA/IGQuZmluZE9uZShcbiAgICAgIHZfLFxuICAgICAgaS5jbG9zZXN0KGJfKVxuICAgICkuY2xhc3NMaXN0LmFkZCguLi50aGlzLl9jbGFzc2VzLmFjdGl2ZS5zcGxpdChcIiBcIikpIDogZC5wYXJlbnRzKGksIG1fKS5mb3JFYWNoKFxuICAgICAgKG4pID0+IHtcbiAgICAgICAgZC5wcmV2KFxuICAgICAgICAgIG4sXG4gICAgICAgICAgYCR7TW99LCAke0JjfWBcbiAgICAgICAgKS5mb3JFYWNoKChvKSA9PiB7XG4gICAgICAgICAgby5jbGFzc0xpc3QuYWRkKC4uLnRoaXMuX2NsYXNzZXMuYWN0aXZlLnNwbGl0KFwiIFwiKSksIG8uc2V0QXR0cmlidXRlKEhuLCBcIlwiKTtcbiAgICAgICAgfSksIGQucHJldihuLCBnXykuZm9yRWFjaChcbiAgICAgICAgICAobykgPT4ge1xuICAgICAgICAgICAgZC5jaGlsZHJlbihvLCBNbykuZm9yRWFjaChcbiAgICAgICAgICAgICAgKHIpID0+IHIuY2xhc3NMaXN0LmFkZCguLi50aGlzLl9jbGFzc2VzLmFjdGl2ZS5zcGxpdChcIiBcIikpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICApLCBjLnRyaWdnZXIodGhpcy5fc2Nyb2xsRWxlbWVudCwgX18sIHtcbiAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRcbiAgICB9KTtcbiAgfVxuICBfY2xlYXIoKSB7XG4gICAgZC5maW5kKFZuLCB0aGlzLl9jb25maWcudGFyZ2V0KS5maWx0ZXIoXG4gICAgICAodCkgPT4gdC5jbGFzc0xpc3QuY29udGFpbnMoLi4udGhpcy5fY2xhc3Nlcy5hY3RpdmUuc3BsaXQoXCIgXCIpKVxuICAgICkuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgdC5jbGFzc0xpc3QucmVtb3ZlKC4uLnRoaXMuX2NsYXNzZXMuYWN0aXZlLnNwbGl0KFwiIFwiKSksIHQucmVtb3ZlQXR0cmlidXRlKEhuKTtcbiAgICB9KTtcbiAgfVxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0KSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGUgPSBIYy5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMsIHQpO1xuICAgICAgaWYgKHR5cGVvZiB0ID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlW3RdID4gXCJ1XCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgIGVbdF0oKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuY29uc3QgZ2EgPSBcInRhYlwiLCBFXyA9IFwidGUudGFiXCIsIGhuID0gYC4ke0VffWAsIENfID0gYGhpZGUke2hufWAsIEFfID0gYGhpZGRlbiR7aG59YCwgeV8gPSBgc2hvdyR7aG59YCwgd18gPSBgc2hvd24ke2hufWAsIGtfID0gXCJkYXRhLXRlLWRyb3Bkb3duLW1lbnUtcmVmXCIsIExlID0gXCJkYXRhLXRlLXRhYi1hY3RpdmVcIiwgSHMgPSBcImRhdGEtdGUtbmF2LWFjdGl2ZVwiLCB4XyA9IFwiW2RhdGEtdGUtZHJvcGRvd24tcmVmXVwiLCBPXyA9IFwiW2RhdGEtdGUtbmF2LXJlZl1cIiwgYmEgPSBgWyR7TGV9XWAsIFNfID0gYFske0hzfV1gLCB2YSA9IFwiOnNjb3BlID4gbGkgPiAuYWN0aXZlXCIsIElfID0gXCJbZGF0YS10ZS1kcm9wZG93bi10b2dnbGUtcmVmXVwiLCBEXyA9IFwiOnNjb3BlID4gW2RhdGEtdGUtZHJvcGRvd24tbWVudS1yZWZdIFtkYXRhLXRlLWRyb3Bkb3duLXNob3ddXCIsICRfID0ge1xuICBzaG93OiBcIm9wYWNpdHktMTAwXCIsXG4gIGhpZGU6IFwib3BhY2l0eS0wXCJcbn0sIExfID0ge1xuICBzaG93OiBcInN0cmluZ1wiLFxuICBoaWRlOiBcInN0cmluZ1wiXG59O1xuY2xhc3MgVmMgZXh0ZW5kcyBndCB7XG4gIGNvbnN0cnVjdG9yKHQsIGUpIHtcbiAgICBzdXBlcih0KSwgdGhpcy5fY2xhc3NlcyA9IHRoaXMuX2dldENsYXNzZXMoZSk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIGdhO1xuICB9XG4gIC8vIFB1YmxpY1xuICBzaG93KCkge1xuICAgIGlmICh0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUgJiYgdGhpcy5fZWxlbWVudC5wYXJlbnROb2RlLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSAmJiB0aGlzLl9lbGVtZW50LmdldEF0dHJpYnV0ZShIcykgPT09IFwiXCIpXG4gICAgICByZXR1cm47XG4gICAgbGV0IHQ7XG4gICAgY29uc3QgZSA9IEp0KHRoaXMuX2VsZW1lbnQpLCBpID0gdGhpcy5fZWxlbWVudC5jbG9zZXN0KE9fKSwgbiA9IGQuZmluZE9uZShcbiAgICAgIFNfLFxuICAgICAgaVxuICAgICk7XG4gICAgaWYgKGkpIHtcbiAgICAgIGNvbnN0IGwgPSBpLm5vZGVOYW1lID09PSBcIlVMXCIgfHwgaS5ub2RlTmFtZSA9PT0gXCJPTFwiID8gdmEgOiBiYTtcbiAgICAgIHQgPSBkLmZpbmQobCwgaSksIHQgPSB0W3QubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIGNvbnN0IG8gPSB0ID8gYy50cmlnZ2VyKHQsIENfLCB7XG4gICAgICByZWxhdGVkVGFyZ2V0OiB0aGlzLl9lbGVtZW50XG4gICAgfSkgOiBudWxsO1xuICAgIGlmIChjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgeV8sIHtcbiAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRcbiAgICB9KS5kZWZhdWx0UHJldmVudGVkIHx8IG8gIT09IG51bGwgJiYgby5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX2FjdGl2YXRlKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIGksXG4gICAgICBudWxsLFxuICAgICAgbixcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApO1xuICAgIGNvbnN0IGEgPSAoKSA9PiB7XG4gICAgICBjLnRyaWdnZXIodCwgQV8sIHtcbiAgICAgICAgcmVsYXRlZFRhcmdldDogdGhpcy5fZWxlbWVudFxuICAgICAgfSksIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCB3Xywge1xuICAgICAgICByZWxhdGVkVGFyZ2V0OiB0XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGUgPyB0aGlzLl9hY3RpdmF0ZShcbiAgICAgIGUsXG4gICAgICBlLnBhcmVudE5vZGUsXG4gICAgICBhLFxuICAgICAgbixcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApIDogYSgpO1xuICB9XG4gIC8vIFByaXZhdGVcbiAgX2dldENsYXNzZXModCkge1xuICAgIGNvbnN0IGUgPSBoLmdldERhdGFDbGFzc0F0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi4kXyxcbiAgICAgIC4uLmUsXG4gICAgICAuLi50XG4gICAgfSwgRChnYSwgdCwgTF8pLCB0O1xuICB9XG4gIF9hY3RpdmF0ZSh0LCBlLCBpLCBuLCBvKSB7XG4gICAgY29uc3QgYSA9IChlICYmIChlLm5vZGVOYW1lID09PSBcIlVMXCIgfHwgZS5ub2RlTmFtZSA9PT0gXCJPTFwiKSA/IGQuZmluZCh2YSwgZSkgOiBkLmNoaWxkcmVuKGUsIGJhKSlbMF0sIGwgPSBpICYmIGEgJiYgYS5oYXNBdHRyaWJ1dGUoTGUpLCBwID0gKCkgPT4gdGhpcy5fdHJhbnNpdGlvbkNvbXBsZXRlKFxuICAgICAgdCxcbiAgICAgIGEsXG4gICAgICBpLFxuICAgICAgbixcbiAgICAgIG9cbiAgICApO1xuICAgIGEgJiYgbCA/IChoLnJlbW92ZUNsYXNzKGEsIHRoaXMuX2NsYXNzZXMuc2hvdyksIGguYWRkQ2xhc3MoYSwgdGhpcy5fY2xhc3Nlcy5oaWRlKSwgdGhpcy5fcXVldWVDYWxsYmFjayhwLCB0LCAhMCkpIDogcCgpO1xuICB9XG4gIF90cmFuc2l0aW9uQ29tcGxldGUodCwgZSwgaSwgbiwgbykge1xuICAgIGlmIChlICYmIG4pIHtcbiAgICAgIGUucmVtb3ZlQXR0cmlidXRlKExlKSwgbi5yZW1vdmVBdHRyaWJ1dGUoSHMpO1xuICAgICAgY29uc3QgYSA9IGQuZmluZE9uZShcbiAgICAgICAgRF8sXG4gICAgICAgIGUucGFyZW50Tm9kZVxuICAgICAgKTtcbiAgICAgIGEgJiYgYS5yZW1vdmVBdHRyaWJ1dGUoTGUpLCBlLmdldEF0dHJpYnV0ZShcInJvbGVcIikgPT09IFwidGFiXCIgJiYgZS5zZXRBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIsICExKTtcbiAgICB9XG4gICAgdC5zZXRBdHRyaWJ1dGUoTGUsIFwiXCIpLCBvLnNldEF0dHJpYnV0ZShIcywgXCJcIiksIHQuZ2V0QXR0cmlidXRlKFwicm9sZVwiKSA9PT0gXCJ0YWJcIiAmJiB0LnNldEF0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIiwgITApLCBKZSh0KSwgdC5jbGFzc0xpc3QuY29udGFpbnModGhpcy5fY2xhc3Nlcy5oaWRlKSAmJiAoaC5yZW1vdmVDbGFzcyh0LCB0aGlzLl9jbGFzc2VzLmhpZGUpLCBoLmFkZENsYXNzKHQsIHRoaXMuX2NsYXNzZXMuc2hvdykpO1xuICAgIGxldCByID0gdC5wYXJlbnROb2RlO1xuICAgIGlmIChyICYmIHIubm9kZU5hbWUgPT09IFwiTElcIiAmJiAociA9IHIucGFyZW50Tm9kZSksIHIgJiYgci5oYXNBdHRyaWJ1dGUoa18pKSB7XG4gICAgICBjb25zdCBhID0gdC5jbG9zZXN0KHhfKTtcbiAgICAgIGEgJiYgZC5maW5kKElfLCBhKS5mb3JFYWNoKFxuICAgICAgICAobCkgPT4gbC5zZXRBdHRyaWJ1dGUoTGUsIFwiXCIpXG4gICAgICApLCB0LnNldEF0dHJpYnV0ZShcImFyaWEtZXhwYW5kZWRcIiwgITApO1xuICAgIH1cbiAgICBpICYmIGkoKTtcbiAgfVxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0KSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGUgPSBWYy5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMpO1xuICAgICAgaWYgKHR5cGVvZiB0ID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlW3RdID4gXCJ1XCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgIGVbdF0oKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuY29uc3QgV24gPSBcInRvYXN0XCIsIE5fID0gXCJ0ZS50b2FzdFwiLCBpZSA9IGAuJHtOX31gLCBNXyA9IGBtb3VzZW92ZXIke2llfWAsIFJfID0gYG1vdXNlb3V0JHtpZX1gLCBQXyA9IGBmb2N1c2luJHtpZX1gLCBCXyA9IGBmb2N1c291dCR7aWV9YCwgSF8gPSBgaGlkZSR7aWV9YCwgVl8gPSBgaGlkZGVuJHtpZX1gLCBXXyA9IGBzaG93JHtpZX1gLCBGXyA9IGBzaG93biR7aWV9YCwgVGEgPSBcImRhdGEtdGUtdG9hc3QtaGlkZVwiLCBGbiA9IFwiZGF0YS10ZS10b2FzdC1zaG93XCIsIG5zID0gXCJkYXRhLXRlLXRvYXN0LXNob3dpbmdcIiwgWV8gPSB7XG4gIGFuaW1hdGlvbjogXCJib29sZWFuXCIsXG4gIGF1dG9oaWRlOiBcImJvb2xlYW5cIixcbiAgZGVsYXk6IFwibnVtYmVyXCJcbn0sIEVhID0ge1xuICBhbmltYXRpb246ICEwLFxuICBhdXRvaGlkZTogITAsXG4gIGRlbGF5OiA1ZTNcbn0sIGpfID0ge1xuICBmYWRlSW46IFwiYW5pbWF0ZS1bZmFkZS1pbl8wLjNzX2JvdGhdIHAtW2F1dG9dIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIG1vdGlvbi1yZWR1Y2U6YW5pbWF0ZS1ub25lXCIsXG4gIGZhZGVPdXQ6IFwiYW5pbWF0ZS1bZmFkZS1vdXRfMC4zc19ib3RoXSBwLVthdXRvXSBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBtb3Rpb24tcmVkdWNlOmFuaW1hdGUtbm9uZVwiXG59LCBLXyA9IHtcbiAgZmFkZUluOiBcInN0cmluZ1wiLFxuICBmYWRlT3V0OiBcInN0cmluZ1wiXG59O1xuY2xhc3MgUm8gZXh0ZW5kcyBndCB7XG4gIGNvbnN0cnVjdG9yKHQsIGUsIGkpIHtcbiAgICBzdXBlcih0KSwgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLl9jbGFzc2VzID0gdGhpcy5fZ2V0Q2xhc3NlcyhpKSwgdGhpcy5fdGltZW91dCA9IG51bGwsIHRoaXMuX2hhc01vdXNlSW50ZXJhY3Rpb24gPSAhMSwgdGhpcy5faGFzS2V5Ym9hcmRJbnRlcmFjdGlvbiA9ICExLCB0aGlzLl9zZXRMaXN0ZW5lcnMoKSwgdGhpcy5fZGlkSW5pdCA9ICExLCB0aGlzLl9pbml0KCk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgIHJldHVybiBZXztcbiAgfVxuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIEVhO1xuICB9XG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gV247XG4gIH1cbiAgLy8gUHVibGljXG4gIHNob3coKSB7XG4gICAgaWYgKGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBXXykuZGVmYXVsdFByZXZlbnRlZClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9jbGVhclRpbWVvdXQoKSwgdGhpcy5fY29uZmlnLmFuaW1hdGlvbiAmJiAoaC5yZW1vdmVDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl9jbGFzc2VzLmZhZGVPdXQpLCBoLmFkZENsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NsYXNzZXMuZmFkZUluKSk7XG4gICAgY29uc3QgZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKG5zKSwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEZfKSwgdGhpcy5fbWF5YmVTY2hlZHVsZUhpZGUoKTtcbiAgICB9O1xuICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFRhKSwgSmUodGhpcy5fZWxlbWVudCksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKEZuLCBcIlwiKSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUobnMsIFwiXCIpLCB0aGlzLl9xdWV1ZUNhbGxiYWNrKGUsIHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NvbmZpZy5hbmltYXRpb24pO1xuICB9XG4gIGhpZGUoKSB7XG4gICAgaWYgKCF0aGlzLl9lbGVtZW50IHx8IHRoaXMuX2VsZW1lbnQuZGF0YXNldC50ZVRvYXN0U2hvdyA9PT0gdm9pZCAwIHx8IGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBIXykuZGVmYXVsdFByZXZlbnRlZClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBlID0gKCkgPT4ge1xuICAgICAgbGV0IGkgPSAwO1xuICAgICAgdGhpcy5fY29uZmlnLmFuaW1hdGlvbiAmJiAoaSA9IDMwMCwgaC5yZW1vdmVDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl9jbGFzc2VzLmZhZGVJbiksIGguYWRkQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy5mYWRlT3V0KSksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShUYSwgXCJcIiksIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKG5zKSwgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoRm4pLCBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgVl8pO1xuICAgICAgfSwgaSk7XG4gICAgfTtcbiAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShucywgXCJcIiksIHRoaXMuX3F1ZXVlQ2FsbGJhY2soZSwgdGhpcy5fZWxlbWVudCwgdGhpcy5fY29uZmlnLmFuaW1hdGlvbik7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLl9jbGVhclRpbWVvdXQoKSwgdGhpcy5fZWxlbWVudC5kYXRhc2V0LnRlVG9hc3RTaG93ICE9PSB2b2lkIDAgJiYgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoRm4pLCBzdXBlci5kaXNwb3NlKCk7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfaW5pdCgpIHtcbiAgICB0aGlzLl9kaWRJbml0IHx8IChjbihSbyksIHRoaXMuX2RpZEluaXQgPSAhMCk7XG4gIH1cbiAgX2dldENvbmZpZyh0KSB7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5FYSxcbiAgICAgIC4uLmguZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCksXG4gICAgICAuLi50eXBlb2YgdCA9PSBcIm9iamVjdFwiICYmIHQgPyB0IDoge31cbiAgICB9LCBEKFduLCB0LCB0aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHRUeXBlKSwgdDtcbiAgfVxuICBfZ2V0Q2xhc3Nlcyh0KSB7XG4gICAgY29uc3QgZSA9IGguZ2V0RGF0YUNsYXNzQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLmpfLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBEKFduLCB0LCBLXyksIHQ7XG4gIH1cbiAgX21heWJlU2NoZWR1bGVIaWRlKCkge1xuICAgIHRoaXMuX2NvbmZpZy5hdXRvaGlkZSAmJiAodGhpcy5faGFzTW91c2VJbnRlcmFjdGlvbiB8fCB0aGlzLl9oYXNLZXlib2FyZEludGVyYWN0aW9uIHx8ICh0aGlzLl90aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmhpZGUoKTtcbiAgICB9LCB0aGlzLl9jb25maWcuZGVsYXkpKSk7XG4gIH1cbiAgX29uSW50ZXJhY3Rpb24odCwgZSkge1xuICAgIHN3aXRjaCAodC50eXBlKSB7XG4gICAgICBjYXNlIFwibW91c2VvdmVyXCI6XG4gICAgICBjYXNlIFwibW91c2VvdXRcIjpcbiAgICAgICAgdGhpcy5faGFzTW91c2VJbnRlcmFjdGlvbiA9IGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImZvY3VzaW5cIjpcbiAgICAgIGNhc2UgXCJmb2N1c291dFwiOlxuICAgICAgICB0aGlzLl9oYXNLZXlib2FyZEludGVyYWN0aW9uID0gZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChlKSB7XG4gICAgICB0aGlzLl9jbGVhclRpbWVvdXQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaSA9IHQucmVsYXRlZFRhcmdldDtcbiAgICB0aGlzLl9lbGVtZW50ID09PSBpIHx8IHRoaXMuX2VsZW1lbnQuY29udGFpbnMoaSkgfHwgdGhpcy5fbWF5YmVTY2hlZHVsZUhpZGUoKTtcbiAgfVxuICBfc2V0TGlzdGVuZXJzKCkge1xuICAgIGMub24oXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgTV8sXG4gICAgICAodCkgPT4gdGhpcy5fb25JbnRlcmFjdGlvbih0LCAhMClcbiAgICApLCBjLm9uKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIFJfLFxuICAgICAgKHQpID0+IHRoaXMuX29uSW50ZXJhY3Rpb24odCwgITEpXG4gICAgKSwgYy5vbihcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBQXyxcbiAgICAgICh0KSA9PiB0aGlzLl9vbkludGVyYWN0aW9uKHQsICEwKVxuICAgICksIGMub24oXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgQl8sXG4gICAgICAodCkgPT4gdGhpcy5fb25JbnRlcmFjdGlvbih0LCAhMSlcbiAgICApO1xuICB9XG4gIF9jbGVhclRpbWVvdXQoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpLCB0aGlzLl90aW1lb3V0ID0gbnVsbDtcbiAgfVxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0KSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGUgPSBSby5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMsIHQpO1xuICAgICAgaWYgKHR5cGVvZiB0ID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlW3RdID4gXCJ1XCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgIGVbdF0odGhpcyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbigoKSA9PiB7XG4gIHZhciBzID0geyA0NTQ6IChpLCBuLCBvKSA9PiB7XG4gICAgby5kKG4sIHsgWjogKCkgPT4gbCB9KTtcbiAgICB2YXIgciA9IG8oNjQ1KSwgYSA9IG8ubihyKSgpKGZ1bmN0aW9uKHApIHtcbiAgICAgIHJldHVybiBwWzFdO1xuICAgIH0pO1xuICAgIGEucHVzaChbaS5pZCwgXCJJTlBVVDotd2Via2l0LWF1dG9maWxsLFNFTEVDVDotd2Via2l0LWF1dG9maWxsLFRFWFRBUkVBOi13ZWJraXQtYXV0b2ZpbGx7YW5pbWF0aW9uLW5hbWU6b25hdXRvZmlsbHN0YXJ0fUlOUFVUOm5vdCg6LXdlYmtpdC1hdXRvZmlsbCksU0VMRUNUOm5vdCg6LXdlYmtpdC1hdXRvZmlsbCksVEVYVEFSRUE6bm90KDotd2Via2l0LWF1dG9maWxsKXthbmltYXRpb24tbmFtZTpvbmF1dG9maWxsY2FuY2VsfUBrZXlmcmFtZXMgb25hdXRvZmlsbHN0YXJ0e31Aa2V5ZnJhbWVzIG9uYXV0b2ZpbGxjYW5jZWx7fVwiLCBcIlwiXSk7XG4gICAgY29uc3QgbCA9IGE7XG4gIH0sIDY0NTogKGkpID0+IHtcbiAgICBpLmV4cG9ydHMgPSBmdW5jdGlvbihuKSB7XG4gICAgICB2YXIgbyA9IFtdO1xuICAgICAgcmV0dXJuIG8udG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgICB2YXIgYSA9IG4ocik7XG4gICAgICAgICAgcmV0dXJuIHJbMl0gPyBcIkBtZWRpYSBcIi5jb25jYXQoclsyXSwgXCIge1wiKS5jb25jYXQoYSwgXCJ9XCIpIDogYTtcbiAgICAgICAgfSkuam9pbihcIlwiKTtcbiAgICAgIH0sIG8uaSA9IGZ1bmN0aW9uKHIsIGEsIGwpIHtcbiAgICAgICAgdHlwZW9mIHIgPT0gXCJzdHJpbmdcIiAmJiAociA9IFtbbnVsbCwgciwgXCJcIl1dKTtcbiAgICAgICAgdmFyIHAgPSB7fTtcbiAgICAgICAgaWYgKGwpXG4gICAgICAgICAgZm9yICh2YXIgdSA9IDA7IHUgPCB0aGlzLmxlbmd0aDsgdSsrKSB7XG4gICAgICAgICAgICB2YXIgXyA9IHRoaXNbdV1bMF07XG4gICAgICAgICAgICBfICE9IG51bGwgJiYgKHBbX10gPSAhMCk7XG4gICAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBmID0gMDsgZiA8IHIubGVuZ3RoOyBmKyspIHtcbiAgICAgICAgICB2YXIgZyA9IFtdLmNvbmNhdChyW2ZdKTtcbiAgICAgICAgICBsICYmIHBbZ1swXV0gfHwgKGEgJiYgKGdbMl0gPyBnWzJdID0gXCJcIi5jb25jYXQoYSwgXCIgYW5kIFwiKS5jb25jYXQoZ1syXSkgOiBnWzJdID0gYSksIG8ucHVzaChnKSk7XG4gICAgICAgIH1cbiAgICAgIH0sIG87XG4gICAgfTtcbiAgfSwgODEwOiAoKSA9PiB7XG4gICAgKGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPCBcInVcIilcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgaSA9IG5ldyB3aW5kb3cuQ3VzdG9tRXZlbnQoXCJ0ZXN0XCIsIHsgY2FuY2VsYWJsZTogITAgfSk7XG4gICAgICAgICAgaWYgKGkucHJldmVudERlZmF1bHQoKSwgaS5kZWZhdWx0UHJldmVudGVkICE9PSAhMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBwcmV2ZW50IGRlZmF1bHRcIik7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIHZhciBuID0gZnVuY3Rpb24ociwgYSkge1xuICAgICAgICAgICAgdmFyIGwsIHA7XG4gICAgICAgICAgICByZXR1cm4gKGEgPSBhIHx8IHt9KS5idWJibGVzID0gISFhLmJ1YmJsZXMsIGEuY2FuY2VsYWJsZSA9ICEhYS5jYW5jZWxhYmxlLCAobCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiQ3VzdG9tRXZlbnRcIikpLmluaXRDdXN0b21FdmVudChyLCBhLmJ1YmJsZXMsIGEuY2FuY2VsYWJsZSwgYS5kZXRhaWwpLCBwID0gbC5wcmV2ZW50RGVmYXVsdCwgbC5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBwLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZGVmYXVsdFByZXZlbnRlZFwiLCB7IGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgfSB9KTtcbiAgICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWZhdWx0UHJldmVudGVkID0gITA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGw7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBuLnByb3RvdHlwZSA9IHdpbmRvdy5FdmVudC5wcm90b3R5cGUsIHdpbmRvdy5DdXN0b21FdmVudCA9IG47XG4gICAgICAgIH1cbiAgICB9KSgpO1xuICB9LCAzNzk6IChpLCBuLCBvKSA9PiB7XG4gICAgdmFyIHIsIGEgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBFID0ge307XG4gICAgICByZXR1cm4gZnVuY3Rpb24oVCkge1xuICAgICAgICBpZiAoRVtUXSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgdmFyIEEgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFQpO1xuICAgICAgICAgIGlmICh3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQgJiYgQSBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudClcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIEEgPSBBLmNvbnRlbnREb2N1bWVudC5oZWFkO1xuICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICAgIEEgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIEVbVF0gPSBBO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBFW1RdO1xuICAgICAgfTtcbiAgICB9KCksIGwgPSBbXTtcbiAgICBmdW5jdGlvbiBwKEUpIHtcbiAgICAgIGZvciAodmFyIFQgPSAtMSwgQSA9IDA7IEEgPCBsLmxlbmd0aDsgQSsrKVxuICAgICAgICBpZiAobFtBXS5pZGVudGlmaWVyID09PSBFKSB7XG4gICAgICAgICAgVCA9IEE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBUO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1KEUsIFQpIHtcbiAgICAgIGZvciAodmFyIEEgPSB7fSwgayA9IFtdLCBJID0gMDsgSSA8IEUubGVuZ3RoOyBJKyspIHtcbiAgICAgICAgdmFyIE8gPSBFW0ldLCB4ID0gVC5iYXNlID8gT1swXSArIFQuYmFzZSA6IE9bMF0sIEwgPSBBW3hdIHx8IDAsIFMgPSBcIlwiLmNvbmNhdCh4LCBcIiBcIikuY29uY2F0KEwpO1xuICAgICAgICBBW3hdID0gTCArIDE7XG4gICAgICAgIHZhciBOID0gcChTKSwgUCA9IHsgY3NzOiBPWzFdLCBtZWRpYTogT1syXSwgc291cmNlTWFwOiBPWzNdIH07XG4gICAgICAgIE4gIT09IC0xID8gKGxbTl0ucmVmZXJlbmNlcysrLCBsW05dLnVwZGF0ZXIoUCkpIDogbC5wdXNoKHsgaWRlbnRpZmllcjogUywgdXBkYXRlcjogdyhQLCBUKSwgcmVmZXJlbmNlczogMSB9KSwgay5wdXNoKFMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGs7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF8oRSkge1xuICAgICAgdmFyIFQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIiksIEEgPSBFLmF0dHJpYnV0ZXMgfHwge307XG4gICAgICBpZiAoQS5ub25jZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHZhciBrID0gby5uYztcbiAgICAgICAgayAmJiAoQS5ub25jZSA9IGspO1xuICAgICAgfVxuICAgICAgaWYgKE9iamVjdC5rZXlzKEEpLmZvckVhY2goZnVuY3Rpb24oTykge1xuICAgICAgICBULnNldEF0dHJpYnV0ZShPLCBBW09dKTtcbiAgICAgIH0pLCB0eXBlb2YgRS5pbnNlcnQgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICBFLmluc2VydChUKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgSSA9IGEoRS5pbnNlcnQgfHwgXCJoZWFkXCIpO1xuICAgICAgICBpZiAoIUkpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnQnIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcbiAgICAgICAgSS5hcHBlbmRDaGlsZChUKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBUO1xuICAgIH1cbiAgICB2YXIgZiwgZyA9IChmID0gW10sIGZ1bmN0aW9uKEUsIFQpIHtcbiAgICAgIHJldHVybiBmW0VdID0gVCwgZi5maWx0ZXIoQm9vbGVhbikuam9pbihgXG5gKTtcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBtKEUsIFQsIEEsIGspIHtcbiAgICAgIHZhciBJID0gQSA/IFwiXCIgOiBrLm1lZGlhID8gXCJAbWVkaWEgXCIuY29uY2F0KGsubWVkaWEsIFwiIHtcIikuY29uY2F0KGsuY3NzLCBcIn1cIikgOiBrLmNzcztcbiAgICAgIGlmIChFLnN0eWxlU2hlZXQpXG4gICAgICAgIEUuc3R5bGVTaGVldC5jc3NUZXh0ID0gZyhULCBJKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgTyA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKEkpLCB4ID0gRS5jaGlsZE5vZGVzO1xuICAgICAgICB4W1RdICYmIEUucmVtb3ZlQ2hpbGQoeFtUXSksIHgubGVuZ3RoID8gRS5pbnNlcnRCZWZvcmUoTywgeFtUXSkgOiBFLmFwcGVuZENoaWxkKE8pO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBiKEUsIFQsIEEpIHtcbiAgICAgIHZhciBrID0gQS5jc3MsIEkgPSBBLm1lZGlhLCBPID0gQS5zb3VyY2VNYXA7XG4gICAgICBpZiAoSSA/IEUuc2V0QXR0cmlidXRlKFwibWVkaWFcIiwgSSkgOiBFLnJlbW92ZUF0dHJpYnV0ZShcIm1lZGlhXCIpLCBPICYmIHR5cGVvZiBidG9hIDwgXCJ1XCIgJiYgKGsgKz0gYFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxgLmNvbmNhdChidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShPKSkpKSwgXCIgKi9cIikpLCBFLnN0eWxlU2hlZXQpXG4gICAgICAgIEUuc3R5bGVTaGVldC5jc3NUZXh0ID0gaztcbiAgICAgIGVsc2Uge1xuICAgICAgICBmb3IgKDsgRS5maXJzdENoaWxkOyApXG4gICAgICAgICAgRS5yZW1vdmVDaGlsZChFLmZpcnN0Q2hpbGQpO1xuICAgICAgICBFLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGspKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHYgPSBudWxsLCBDID0gMDtcbiAgICBmdW5jdGlvbiB3KEUsIFQpIHtcbiAgICAgIHZhciBBLCBrLCBJO1xuICAgICAgaWYgKFQuc2luZ2xldG9uKSB7XG4gICAgICAgIHZhciBPID0gQysrO1xuICAgICAgICBBID0gdiB8fCAodiA9IF8oVCkpLCBrID0gbS5iaW5kKG51bGwsIEEsIE8sICExKSwgSSA9IG0uYmluZChudWxsLCBBLCBPLCAhMCk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgQSA9IF8oVCksIGsgPSBiLmJpbmQobnVsbCwgQSwgVCksIEkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAoZnVuY3Rpb24oeCkge1xuICAgICAgICAgICAgaWYgKHgucGFyZW50Tm9kZSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICAgICAgeC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHgpO1xuICAgICAgICAgIH0pKEEpO1xuICAgICAgICB9O1xuICAgICAgcmV0dXJuIGsoRSksIGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgaWYgKHgpIHtcbiAgICAgICAgICBpZiAoeC5jc3MgPT09IEUuY3NzICYmIHgubWVkaWEgPT09IEUubWVkaWEgJiYgeC5zb3VyY2VNYXAgPT09IEUuc291cmNlTWFwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGsoRSA9IHgpO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICBJKCk7XG4gICAgICB9O1xuICAgIH1cbiAgICBpLmV4cG9ydHMgPSBmdW5jdGlvbihFLCBUKSB7XG4gICAgICAoVCA9IFQgfHwge30pLnNpbmdsZXRvbiB8fCB0eXBlb2YgVC5zaW5nbGV0b24gPT0gXCJib29sZWFuXCIgfHwgKFQuc2luZ2xldG9uID0gKHIgPT09IHZvaWQgMCAmJiAociA9ICEhKHdpbmRvdyAmJiBkb2N1bWVudCAmJiBkb2N1bWVudC5hbGwgJiYgIXdpbmRvdy5hdG9iKSksIHIpKTtcbiAgICAgIHZhciBBID0gdShFID0gRSB8fCBbXSwgVCk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oaykge1xuICAgICAgICBpZiAoayA9IGsgfHwgW10sIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChrKSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiKSB7XG4gICAgICAgICAgZm9yICh2YXIgSSA9IDA7IEkgPCBBLmxlbmd0aDsgSSsrKSB7XG4gICAgICAgICAgICB2YXIgTyA9IHAoQVtJXSk7XG4gICAgICAgICAgICBsW09dLnJlZmVyZW5jZXMtLTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICh2YXIgeCA9IHUoaywgVCksIEwgPSAwOyBMIDwgQS5sZW5ndGg7IEwrKykge1xuICAgICAgICAgICAgdmFyIFMgPSBwKEFbTF0pO1xuICAgICAgICAgICAgbFtTXS5yZWZlcmVuY2VzID09PSAwICYmIChsW1NdLnVwZGF0ZXIoKSwgbC5zcGxpY2UoUywgMSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBBID0geDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuICB9IH0sIHQgPSB7fTtcbiAgZnVuY3Rpb24gZShpKSB7XG4gICAgdmFyIG4gPSB0W2ldO1xuICAgIGlmIChuICE9PSB2b2lkIDApXG4gICAgICByZXR1cm4gbi5leHBvcnRzO1xuICAgIHZhciBvID0gdFtpXSA9IHsgaWQ6IGksIGV4cG9ydHM6IHt9IH07XG4gICAgcmV0dXJuIHNbaV0obywgby5leHBvcnRzLCBlKSwgby5leHBvcnRzO1xuICB9XG4gIGUubiA9IChpKSA9PiB7XG4gICAgdmFyIG4gPSBpICYmIGkuX19lc01vZHVsZSA/ICgpID0+IGkuZGVmYXVsdCA6ICgpID0+IGk7XG4gICAgcmV0dXJuIGUuZChuLCB7IGE6IG4gfSksIG47XG4gIH0sIGUuZCA9IChpLCBuKSA9PiB7XG4gICAgZm9yICh2YXIgbyBpbiBuKVxuICAgICAgZS5vKG4sIG8pICYmICFlLm8oaSwgbykgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KGksIG8sIHsgZW51bWVyYWJsZTogITAsIGdldDogbltvXSB9KTtcbiAgfSwgZS5vID0gKGksIG4pID0+IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChpLCBuKSwgKCgpID0+IHtcbiAgICB2YXIgaSA9IGUoMzc5KSwgbiA9IGUubihpKSwgbyA9IGUoNDU0KTtcbiAgICBmdW5jdGlvbiByKGwpIHtcbiAgICAgIGlmICghbC5oYXNBdHRyaWJ1dGUoXCJhdXRvY29tcGxldGVkXCIpKSB7XG4gICAgICAgIGwuc2V0QXR0cmlidXRlKFwiYXV0b2NvbXBsZXRlZFwiLCBcIlwiKTtcbiAgICAgICAgdmFyIHAgPSBuZXcgd2luZG93LkN1c3RvbUV2ZW50KFwib25hdXRvY29tcGxldGVcIiwgeyBidWJibGVzOiAhMCwgY2FuY2VsYWJsZTogITAsIGRldGFpbDogbnVsbCB9KTtcbiAgICAgICAgbC5kaXNwYXRjaEV2ZW50KHApIHx8IChsLnZhbHVlID0gXCJcIik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGEobCkge1xuICAgICAgbC5oYXNBdHRyaWJ1dGUoXCJhdXRvY29tcGxldGVkXCIpICYmIChsLnJlbW92ZUF0dHJpYnV0ZShcImF1dG9jb21wbGV0ZWRcIiksIGwuZGlzcGF0Y2hFdmVudChuZXcgd2luZG93LkN1c3RvbUV2ZW50KFwib25hdXRvY29tcGxldGVcIiwgeyBidWJibGVzOiAhMCwgY2FuY2VsYWJsZTogITEsIGRldGFpbDogbnVsbCB9KSkpO1xuICAgIH1cbiAgICBuKCkoby5aLCB7IGluc2VydDogXCJoZWFkXCIsIHNpbmdsZXRvbjogITEgfSksIG8uWi5sb2NhbHMsIGUoODEwKSwgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImFuaW1hdGlvbnN0YXJ0XCIsIGZ1bmN0aW9uKGwpIHtcbiAgICAgIGwuYW5pbWF0aW9uTmFtZSA9PT0gXCJvbmF1dG9maWxsc3RhcnRcIiA/IHIobC50YXJnZXQpIDogYShsLnRhcmdldCk7XG4gICAgfSwgITApLCBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgZnVuY3Rpb24obCkge1xuICAgICAgbC5pbnB1dFR5cGUgIT09IFwiaW5zZXJ0UmVwbGFjZW1lbnRUZXh0XCIgJiYgXCJkYXRhXCIgaW4gbCA/IGEobC50YXJnZXQpIDogcihsLnRhcmdldCk7XG4gICAgfSwgITApO1xuICB9KSgpO1xufSkoKTtcbmNvbnN0IFluID0gXCJpbnB1dFwiLCBvcyA9IFwidGUuaW5wdXRcIiwgV2MgPSBcImRhdGEtdGUtaW5wdXQtd3JhcHBlci1pbml0XCIsIEZjID0gXCJkYXRhLXRlLWlucHV0LW5vdGNoLXJlZlwiLCBZYyA9IFwiZGF0YS10ZS1pbnB1dC1ub3RjaC1sZWFkaW5nLXJlZlwiLCBqYyA9IFwiZGF0YS10ZS1pbnB1dC1ub3RjaC1taWRkbGUtcmVmXCIsIHpfID0gXCJkYXRhLXRlLWlucHV0LW5vdGNoLXRyYWlsaW5nLXJlZlwiLCBVXyA9IFwiZGF0YS10ZS1pbnB1dC1oZWxwZXItcmVmXCIsIFhfID0gXCJkYXRhLXRlLWlucHV0LXBsYWNlaG9sZGVyLWFjdGl2ZVwiLCBGdCA9IFwiZGF0YS10ZS1pbnB1dC1zdGF0ZS1hY3RpdmVcIiwgQ2EgPSBcImRhdGEtdGUtaW5wdXQtZm9jdXNlZFwiLCBBYSA9IFwiZGF0YS10ZS1pbnB1dC1mb3JtLWNvdW50ZXJcIiwgZGUgPSBgWyR7V2N9XSBpbnB1dGAsIHVlID0gYFske1djfV0gdGV4dGFyZWFgLCBrZSA9IGBbJHtGY31dYCwgeWEgPSBgWyR7WWN9XWAsIHdhID0gYFske2pjfV1gLCBHXyA9IGBbJHtVX31dYCwgcV8gPSB7XG4gIGlucHV0Rm9ybVdoaXRlOiAhMVxufSwgWl8gPSB7XG4gIGlucHV0Rm9ybVdoaXRlOiBcIihib29sZWFuKVwiXG59LCBLYyA9IHtcbiAgbm90Y2g6IFwiZ3JvdXAgZmxleCBhYnNvbHV0ZSBsZWZ0LTAgdG9wLTAgdy1mdWxsIG1heC13LWZ1bGwgaC1mdWxsIHRleHQtbGVmdCBwb2ludGVyLWV2ZW50cy1ub25lXCIsXG4gIG5vdGNoTGVhZGluZzogXCJwb2ludGVyLWV2ZW50cy1ub25lIGJvcmRlciBib3JkZXItc29saWQgYm94LWJvcmRlciBiZy10cmFuc3BhcmVudCB0cmFuc2l0aW9uLWFsbCBkdXJhdGlvbi0yMDAgZWFzZS1saW5lYXIgbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmUgbGVmdC0wIHRvcC0wIGgtZnVsbCB3LTIgYm9yZGVyLXItMCByb3VuZGVkLWwtWzAuMjVyZW1dIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOmJvcmRlci1yLTAgZ3JvdXAtZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTpib3JkZXItci0wXCIsXG4gIG5vdGNoTGVhZGluZ05vcm1hbDogXCJib3JkZXItbmV1dHJhbC0zMDAgZGFyazpib3JkZXItbmV1dHJhbC02MDAgZ3JvdXAtZGF0YS1bdGUtaW5wdXQtZm9jdXNlZF06c2hhZG93LVstMXB4XzBfMF8jM2I3MWNhLF8wXzFweF8wXzBfIzNiNzFjYSxfMF8tMXB4XzBfMF8jM2I3MWNhXSBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpib3JkZXItcHJpbWFyeVwiLFxuICBub3RjaExlYWRpbmdXaGl0ZTogXCJib3JkZXItbmV1dHJhbC0yMDAgZ3JvdXAtZGF0YS1bdGUtaW5wdXQtZm9jdXNlZF06c2hhZG93LVstMXB4XzBfMF8jZmZmZmZmLF8wXzFweF8wXzBfI2ZmZmZmZixfMF8tMXB4XzBfMF8jZmZmZmZmXSBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpib3JkZXItd2hpdGVcIixcbiAgbm90Y2hNaWRkbGU6IFwicG9pbnRlci1ldmVudHMtbm9uZSBib3JkZXIgYm9yZGVyLXNvbGlkIGJveC1ib3JkZXIgYmctdHJhbnNwYXJlbnQgdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tMjAwIGVhc2UtbGluZWFyIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIGdyb3ctMCBzaHJpbmstMCBiYXNpcy1hdXRvIHctYXV0byBtYXgtdy1bY2FsYygxMDAlLTFyZW0pXSBoLWZ1bGwgYm9yZGVyLXItMCBib3JkZXItbC0wIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOmJvcmRlci14LTAgZ3JvdXAtZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTpib3JkZXIteC0wIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOmJvcmRlci10IGdyb3VwLWRhdGEtW3RlLWlucHV0LXN0YXRlLWFjdGl2ZV06Ym9yZGVyLXQgZ3JvdXAtZGF0YS1bdGUtaW5wdXQtZm9jdXNlZF06Ym9yZGVyLXNvbGlkIGdyb3VwLWRhdGEtW3RlLWlucHV0LXN0YXRlLWFjdGl2ZV06Ym9yZGVyLXNvbGlkIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOmJvcmRlci10LXRyYW5zcGFyZW50IGdyb3VwLWRhdGEtW3RlLWlucHV0LXN0YXRlLWFjdGl2ZV06Ym9yZGVyLXQtdHJhbnNwYXJlbnRcIixcbiAgbm90Y2hNaWRkbGVOb3JtYWw6IFwiYm9yZGVyLW5ldXRyYWwtMzAwIGRhcms6Ym9yZGVyLW5ldXRyYWwtNjAwIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOnNoYWRvdy1bMF8xcHhfMF8wXyMzYjcxY2FdIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOmJvcmRlci1wcmltYXJ5XCIsXG4gIG5vdGNoTWlkZGxlV2hpdGU6IFwiYm9yZGVyLW5ldXRyYWwtMjAwIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOnNoYWRvdy1bMF8xcHhfMF8wXyNmZmZmZmZdIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOmJvcmRlci13aGl0ZVwiLFxuICBub3RjaFRyYWlsaW5nOiBcInBvaW50ZXItZXZlbnRzLW5vbmUgYm9yZGVyIGJvcmRlci1zb2xpZCBib3gtYm9yZGVyIGJnLXRyYW5zcGFyZW50IHRyYW5zaXRpb24tYWxsIGR1cmF0aW9uLTIwMCBlYXNlLWxpbmVhciBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBncm93IGgtZnVsbCBib3JkZXItbC0wIHJvdW5kZWQtci1bMC4yNXJlbV0gZ3JvdXAtZGF0YS1bdGUtaW5wdXQtZm9jdXNlZF06Ym9yZGVyLWwtMCBncm91cC1kYXRhLVt0ZS1pbnB1dC1zdGF0ZS1hY3RpdmVdOmJvcmRlci1sLTBcIixcbiAgbm90Y2hUcmFpbGluZ05vcm1hbDogXCJib3JkZXItbmV1dHJhbC0zMDAgZGFyazpib3JkZXItbmV1dHJhbC02MDAgZ3JvdXAtZGF0YS1bdGUtaW5wdXQtZm9jdXNlZF06c2hhZG93LVsxcHhfMF8wXyMzYjcxY2EsXzBfLTFweF8wXzBfIzNiNzFjYSxfMF8xcHhfMF8wXyMzYjcxY2FdIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOmJvcmRlci1wcmltYXJ5XCIsXG4gIG5vdGNoVHJhaWxpbmdXaGl0ZTogXCJib3JkZXItbmV1dHJhbC0yMDAgZ3JvdXAtZGF0YS1bdGUtaW5wdXQtZm9jdXNlZF06c2hhZG93LVsxcHhfMF8wXyNmZmZmZmYsXzBfLTFweF8wXzBfI2ZmZmZmZixfMF8xcHhfMF8wXyNmZmZmZmZdIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOmJvcmRlci13aGl0ZVwiLFxuICBjb3VudGVyOiBcInRleHQtcmlnaHQgbGVhZGluZy1bMS42XVwiXG59LCBRXyA9IHtcbiAgbm90Y2g6IFwic3RyaW5nXCIsXG4gIG5vdGNoTGVhZGluZzogXCJzdHJpbmdcIixcbiAgbm90Y2hMZWFkaW5nTm9ybWFsOiBcInN0cmluZ1wiLFxuICBub3RjaExlYWRpbmdXaGl0ZTogXCJzdHJpbmdcIixcbiAgbm90Y2hNaWRkbGU6IFwic3RyaW5nXCIsXG4gIG5vdGNoTWlkZGxlTm9ybWFsOiBcInN0cmluZ1wiLFxuICBub3RjaE1pZGRsZVdoaXRlOiBcInN0cmluZ1wiLFxuICBub3RjaFRyYWlsaW5nOiBcInN0cmluZ1wiLFxuICBub3RjaFRyYWlsaW5nTm9ybWFsOiBcInN0cmluZ1wiLFxuICBub3RjaFRyYWlsaW5nV2hpdGU6IFwic3RyaW5nXCIsXG4gIGNvdW50ZXI6IFwic3RyaW5nXCJcbn07XG5jbGFzcyBWIHtcbiAgY29uc3RydWN0b3IodCwgZSwgaSkge1xuICAgIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhlLCB0KSwgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX2NsYXNzZXMgPSB0aGlzLl9nZXRDbGFzc2VzKGkpLCB0aGlzLl9sYWJlbCA9IG51bGwsIHRoaXMuX2xhYmVsV2lkdGggPSAwLCB0aGlzLl9sYWJlbE1hcmdpbkxlZnQgPSAwLCB0aGlzLl9ub3RjaExlYWRpbmcgPSBudWxsLCB0aGlzLl9ub3RjaE1pZGRsZSA9IG51bGwsIHRoaXMuX25vdGNoVHJhaWxpbmcgPSBudWxsLCB0aGlzLl9pbml0aWF0ZWQgPSAhMSwgdGhpcy5faGVscGVyID0gbnVsbCwgdGhpcy5fY291bnRlciA9ICExLCB0aGlzLl9jb3VudGVyRWxlbWVudCA9IG51bGwsIHRoaXMuX21heExlbmd0aCA9IDAsIHRoaXMuX2xlYWRpbmdJY29uID0gbnVsbCwgdGhpcy5fZWxlbWVudCAmJiAoeS5zZXREYXRhKHQsIG9zLCB0aGlzKSwgdGhpcy5pbml0KCkpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBZbjtcbiAgfVxuICBnZXQgaW5wdXQoKSB7XG4gICAgcmV0dXJuIGQuZmluZE9uZShcImlucHV0XCIsIHRoaXMuX2VsZW1lbnQpIHx8IGQuZmluZE9uZShcInRleHRhcmVhXCIsIHRoaXMuX2VsZW1lbnQpO1xuICB9XG4gIC8vIFB1YmxpY1xuICBpbml0KCkge1xuICAgIHRoaXMuX2luaXRpYXRlZCB8fCAodGhpcy5fZ2V0TGFiZWxEYXRhKCksIHRoaXMuX2FwcGx5RGl2cygpLCB0aGlzLl9hcHBseU5vdGNoKCksIHRoaXMuX2FjdGl2YXRlKCksIHRoaXMuX2dldEhlbHBlcigpLCB0aGlzLl9nZXRDb3VudGVyKCksIHRoaXMuX2dldEV2ZW50cygpLCB0aGlzLl9pbml0aWF0ZWQgPSAhMCk7XG4gIH1cbiAgdXBkYXRlKCkge1xuICAgIHRoaXMuX2dldExhYmVsRGF0YSgpLCB0aGlzLl9nZXROb3RjaERhdGEoKSwgdGhpcy5fYXBwbHlOb3RjaCgpLCB0aGlzLl9hY3RpdmF0ZSgpLCB0aGlzLl9nZXRIZWxwZXIoKSwgdGhpcy5fZ2V0Q291bnRlcigpO1xuICB9XG4gIGZvcmNlQWN0aXZlKCkge1xuICAgIHRoaXMuaW5wdXQuc2V0QXR0cmlidXRlKEZ0LCBcIlwiKSwgZC5maW5kT25lKGtlLCB0aGlzLmlucHV0LnBhcmVudE5vZGUpLnNldEF0dHJpYnV0ZShcbiAgICAgIEZ0LFxuICAgICAgXCJcIlxuICAgICk7XG4gIH1cbiAgZm9yY2VJbmFjdGl2ZSgpIHtcbiAgICB0aGlzLmlucHV0LnJlbW92ZUF0dHJpYnV0ZShGdCksIGQuZmluZE9uZShcbiAgICAgIGtlLFxuICAgICAgdGhpcy5pbnB1dC5wYXJlbnROb2RlXG4gICAgKS5yZW1vdmVBdHRyaWJ1dGUoRnQpO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5fcmVtb3ZlQm9yZGVyKCksIHkucmVtb3ZlRGF0YSh0aGlzLl9lbGVtZW50LCBvcyksIHRoaXMuX2VsZW1lbnQgPSBudWxsO1xuICB9XG4gIC8vIFByaXZhdGVcbiAgX2dldENvbmZpZyh0LCBlKSB7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5xXyxcbiAgICAgIC4uLmguZ2V0RGF0YUF0dHJpYnV0ZXMoZSksXG4gICAgICAuLi50eXBlb2YgdCA9PSBcIm9iamVjdFwiID8gdCA6IHt9XG4gICAgfSwgRChZbiwgdCwgWl8pLCB0O1xuICB9XG4gIF9nZXRDbGFzc2VzKHQpIHtcbiAgICBjb25zdCBlID0gaC5nZXREYXRhQ2xhc3NBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uS2MsXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIEQoWW4sIHQsIFFfKSwgdDtcbiAgfVxuICBfZ2V0TGFiZWxEYXRhKCkge1xuICAgIHRoaXMuX2xhYmVsID0gZC5maW5kT25lKFwibGFiZWxcIiwgdGhpcy5fZWxlbWVudCksIHRoaXMuX2xhYmVsID09PSBudWxsID8gdGhpcy5fc2hvd1BsYWNlaG9sZGVyKCkgOiAodGhpcy5fZ2V0TGFiZWxXaWR0aCgpLCB0aGlzLl9nZXRMYWJlbFBvc2l0aW9uSW5JbnB1dEdyb3VwKCksIHRoaXMuX3RvZ2dsZURlZmF1bHREYXRlUGxhY2Vob2xkZXIoKSk7XG4gIH1cbiAgX2dldEhlbHBlcigpIHtcbiAgICB0aGlzLl9oZWxwZXIgPSBkLmZpbmRPbmUoR18sIHRoaXMuX2VsZW1lbnQpO1xuICB9XG4gIF9nZXRDb3VudGVyKCkge1xuICAgIHRoaXMuX2NvdW50ZXIgPSBoLmdldERhdGFBdHRyaWJ1dGUoXG4gICAgICB0aGlzLmlucHV0LFxuICAgICAgXCJpbnB1dFNob3djb3VudGVyXCJcbiAgICApLCB0aGlzLl9jb3VudGVyICYmICh0aGlzLl9tYXhMZW5ndGggPSB0aGlzLmlucHV0Lm1heExlbmd0aCwgdGhpcy5fc2hvd0NvdW50ZXIoKSk7XG4gIH1cbiAgX2dldEV2ZW50cygpIHtcbiAgICBjLm9uKFxuICAgICAgZG9jdW1lbnQsXG4gICAgICBcImZvY3VzXCIsXG4gICAgICBkZSxcbiAgICAgIFYuYWN0aXZhdGUobmV3IFYoKSlcbiAgICApLCBjLm9uKFxuICAgICAgZG9jdW1lbnQsXG4gICAgICBcImlucHV0XCIsXG4gICAgICBkZSxcbiAgICAgIFYuYWN0aXZhdGUobmV3IFYoKSlcbiAgICApLCBjLm9uKFxuICAgICAgZG9jdW1lbnQsXG4gICAgICBcImJsdXJcIixcbiAgICAgIGRlLFxuICAgICAgVi5kZWFjdGl2YXRlKG5ldyBWKCkpXG4gICAgKSwgYy5vbihcbiAgICAgIGRvY3VtZW50LFxuICAgICAgXCJmb2N1c1wiLFxuICAgICAgdWUsXG4gICAgICBWLmFjdGl2YXRlKG5ldyBWKCkpXG4gICAgKSwgYy5vbihcbiAgICAgIGRvY3VtZW50LFxuICAgICAgXCJpbnB1dFwiLFxuICAgICAgdWUsXG4gICAgICBWLmFjdGl2YXRlKG5ldyBWKCkpXG4gICAgKSwgYy5vbihcbiAgICAgIGRvY3VtZW50LFxuICAgICAgXCJibHVyXCIsXG4gICAgICB1ZSxcbiAgICAgIFYuZGVhY3RpdmF0ZShuZXcgVigpKVxuICAgICksIGMub24od2luZG93LCBcInNob3duLnRlLm1vZGFsXCIsICh0KSA9PiB7XG4gICAgICBkLmZpbmQoZGUsIHQudGFyZ2V0KS5mb3JFYWNoKFxuICAgICAgICAoZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGkgPSBWLmdldEluc3RhbmNlKGUucGFyZW50Tm9kZSk7XG4gICAgICAgICAgaSAmJiBpLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICApLCBkLmZpbmQodWUsIHQudGFyZ2V0KS5mb3JFYWNoKFxuICAgICAgICAoZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGkgPSBWLmdldEluc3RhbmNlKGUucGFyZW50Tm9kZSk7XG4gICAgICAgICAgaSAmJiBpLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH0pLCBjLm9uKHdpbmRvdywgXCJzaG93bi50ZS5kcm9wZG93blwiLCAodCkgPT4ge1xuICAgICAgY29uc3QgZSA9IHQudGFyZ2V0LnBhcmVudE5vZGUucXVlcnlTZWxlY3RvcihcbiAgICAgICAgXCJbZGF0YS10ZS1kcm9wZG93bi1tZW51LXJlZl1cIlxuICAgICAgKTtcbiAgICAgIGUgJiYgKGQuZmluZChkZSwgZSkuZm9yRWFjaChcbiAgICAgICAgKGkpID0+IHtcbiAgICAgICAgICBjb25zdCBuID0gVi5nZXRJbnN0YW5jZShpLnBhcmVudE5vZGUpO1xuICAgICAgICAgIG4gJiYgbi51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgKSwgZC5maW5kKHVlLCBlKS5mb3JFYWNoKFxuICAgICAgICAoaSkgPT4ge1xuICAgICAgICAgIGNvbnN0IG4gPSBWLmdldEluc3RhbmNlKGkucGFyZW50Tm9kZSk7XG4gICAgICAgICAgbiAmJiBuLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICApKTtcbiAgICB9KSwgYy5vbih3aW5kb3csIFwic2hvd24udGUudGFiXCIsICh0KSA9PiB7XG4gICAgICBsZXQgZTtcbiAgICAgIHQudGFyZ2V0LmhyZWYgPyBlID0gdC50YXJnZXQuaHJlZi5zcGxpdChcIiNcIilbMV0gOiBlID0gaC5nZXREYXRhQXR0cmlidXRlKHQudGFyZ2V0LCBcInRhcmdldFwiKS5zcGxpdChcbiAgICAgICAgXCIjXCJcbiAgICAgIClbMV07XG4gICAgICBjb25zdCBpID0gZC5maW5kT25lKGAjJHtlfWApO1xuICAgICAgZC5maW5kKGRlLCBpKS5mb3JFYWNoKChuKSA9PiB7XG4gICAgICAgIGNvbnN0IG8gPSBWLmdldEluc3RhbmNlKG4ucGFyZW50Tm9kZSk7XG4gICAgICAgIG8gJiYgby51cGRhdGUoKTtcbiAgICAgIH0pLCBkLmZpbmQodWUsIGkpLmZvckVhY2goXG4gICAgICAgIChuKSA9PiB7XG4gICAgICAgICAgY29uc3QgbyA9IFYuZ2V0SW5zdGFuY2Uobi5wYXJlbnROb2RlKTtcbiAgICAgICAgICBvICYmIG8udXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSksIGMub24od2luZG93LCBcInJlc2V0XCIsICh0KSA9PiB7XG4gICAgICBkLmZpbmQoZGUsIHQudGFyZ2V0KS5mb3JFYWNoKFxuICAgICAgICAoZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGkgPSBWLmdldEluc3RhbmNlKGUucGFyZW50Tm9kZSk7XG4gICAgICAgICAgaSAmJiBpLmZvcmNlSW5hY3RpdmUoKTtcbiAgICAgICAgfVxuICAgICAgKSwgZC5maW5kKHVlLCB0LnRhcmdldCkuZm9yRWFjaChcbiAgICAgICAgKGUpID0+IHtcbiAgICAgICAgICBjb25zdCBpID0gVi5nZXRJbnN0YW5jZShlLnBhcmVudE5vZGUpO1xuICAgICAgICAgIGkgJiYgaS5mb3JjZUluYWN0aXZlKCk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSksIGMub24od2luZG93LCBcIm9uYXV0b2NvbXBsZXRlXCIsICh0KSA9PiB7XG4gICAgICBjb25zdCBlID0gVi5nZXRJbnN0YW5jZSh0LnRhcmdldC5wYXJlbnROb2RlKTtcbiAgICAgICFlIHx8ICF0LmNhbmNlbGFibGUgfHwgZS5mb3JjZUFjdGl2ZSgpO1xuICAgIH0pO1xuICB9XG4gIF9zaG93Q291bnRlcigpIHtcbiAgICBpZiAoZC5maW5kKFxuICAgICAgYFske0FhfV1gLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICkubGVuZ3RoID4gMClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9jb3VudGVyRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksIGguYWRkQ2xhc3ModGhpcy5fY291bnRlckVsZW1lbnQsIHRoaXMuX2NsYXNzZXMuY291bnRlciksIHRoaXMuX2NvdW50ZXJFbGVtZW50LnNldEF0dHJpYnV0ZShBYSwgXCJcIik7XG4gICAgY29uc3QgZSA9IHRoaXMuaW5wdXQudmFsdWUubGVuZ3RoO1xuICAgIHRoaXMuX2NvdW50ZXJFbGVtZW50LmlubmVySFRNTCA9IGAke2V9IC8gJHt0aGlzLl9tYXhMZW5ndGh9YCwgdGhpcy5faGVscGVyLmFwcGVuZENoaWxkKHRoaXMuX2NvdW50ZXJFbGVtZW50KSwgdGhpcy5fYmluZENvdW50ZXIoKTtcbiAgfVxuICBfYmluZENvdW50ZXIoKSB7XG4gICAgYy5vbih0aGlzLmlucHV0LCBcImlucHV0XCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHQgPSB0aGlzLmlucHV0LnZhbHVlLmxlbmd0aDtcbiAgICAgIHRoaXMuX2NvdW50ZXJFbGVtZW50LmlubmVySFRNTCA9IGAke3R9IC8gJHt0aGlzLl9tYXhMZW5ndGh9YDtcbiAgICB9KTtcbiAgfVxuICBfdG9nZ2xlRGVmYXVsdERhdGVQbGFjZWhvbGRlcih0ID0gdGhpcy5pbnB1dCkge1xuICAgIGlmICghKHQuZ2V0QXR0cmlidXRlKFwidHlwZVwiKSA9PT0gXCJkYXRlXCIpKVxuICAgICAgcmV0dXJuO1xuICAgICEoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gdCkgJiYgIXQudmFsdWUgPyB0LnN0eWxlLm9wYWNpdHkgPSAwIDogdC5zdHlsZS5vcGFjaXR5ID0gMTtcbiAgfVxuICBfc2hvd1BsYWNlaG9sZGVyKCkge1xuICAgIHRoaXMuaW5wdXQuc2V0QXR0cmlidXRlKFhfLCBcIlwiKTtcbiAgfVxuICBfZ2V0Tm90Y2hEYXRhKCkge1xuICAgIHRoaXMuX25vdGNoTWlkZGxlID0gZC5maW5kT25lKFxuICAgICAgd2EsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKSwgdGhpcy5fbm90Y2hMZWFkaW5nID0gZC5maW5kT25lKFxuICAgICAgeWEsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKTtcbiAgfVxuICBfZ2V0TGFiZWxXaWR0aCgpIHtcbiAgICB0aGlzLl9sYWJlbFdpZHRoID0gdGhpcy5fbGFiZWwuY2xpZW50V2lkdGggKiAwLjggKyA4O1xuICB9XG4gIF9nZXRMYWJlbFBvc2l0aW9uSW5JbnB1dEdyb3VwKCkge1xuICAgIGlmICh0aGlzLl9sYWJlbE1hcmdpbkxlZnQgPSAwLCAhdGhpcy5fZWxlbWVudC5oYXNBdHRyaWJ1dGUoXCJkYXRhLXRlLWlucHV0LWdyb3VwLXJlZlwiKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB0ID0gdGhpcy5pbnB1dCwgZSA9IGQucHJldihcbiAgICAgIHQsXG4gICAgICBcIltkYXRhLXRlLWlucHV0LWdyb3VwLXRleHQtcmVmXVwiXG4gICAgKVswXTtcbiAgICBlID09PSB2b2lkIDAgPyB0aGlzLl9sYWJlbE1hcmdpbkxlZnQgPSAwIDogdGhpcy5fbGFiZWxNYXJnaW5MZWZ0ID0gZS5vZmZzZXRXaWR0aCAtIDE7XG4gIH1cbiAgX2FwcGx5RGl2cygpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fY29uZmlnLmlucHV0Rm9ybVdoaXRlID8gdGhpcy5fY2xhc3Nlcy5ub3RjaExlYWRpbmdXaGl0ZSA6IHRoaXMuX2NsYXNzZXMubm90Y2hMZWFkaW5nTm9ybWFsLCBlID0gdGhpcy5fY29uZmlnLmlucHV0Rm9ybVdoaXRlID8gdGhpcy5fY2xhc3Nlcy5ub3RjaE1pZGRsZVdoaXRlIDogdGhpcy5fY2xhc3Nlcy5ub3RjaE1pZGRsZU5vcm1hbCwgaSA9IHRoaXMuX2NvbmZpZy5pbnB1dEZvcm1XaGl0ZSA/IHRoaXMuX2NsYXNzZXMubm90Y2hUcmFpbGluZ1doaXRlIDogdGhpcy5fY2xhc3Nlcy5ub3RjaFRyYWlsaW5nTm9ybWFsLCBuID0gZC5maW5kKGtlLCB0aGlzLl9lbGVtZW50KSwgbyA9ICQoXCJkaXZcIik7XG4gICAgaC5hZGRDbGFzcyhvLCB0aGlzLl9jbGFzc2VzLm5vdGNoKSwgby5zZXRBdHRyaWJ1dGUoRmMsIFwiXCIpLCB0aGlzLl9ub3RjaExlYWRpbmcgPSAkKFwiZGl2XCIpLCBoLmFkZENsYXNzKFxuICAgICAgdGhpcy5fbm90Y2hMZWFkaW5nLFxuICAgICAgYCR7dGhpcy5fY2xhc3Nlcy5ub3RjaExlYWRpbmd9ICR7dH1gXG4gICAgKSwgdGhpcy5fbm90Y2hMZWFkaW5nLnNldEF0dHJpYnV0ZShZYywgXCJcIiksIHRoaXMuX25vdGNoTWlkZGxlID0gJChcImRpdlwiKSwgaC5hZGRDbGFzcyhcbiAgICAgIHRoaXMuX25vdGNoTWlkZGxlLFxuICAgICAgYCR7dGhpcy5fY2xhc3Nlcy5ub3RjaE1pZGRsZX0gJHtlfWBcbiAgICApLCB0aGlzLl9ub3RjaE1pZGRsZS5zZXRBdHRyaWJ1dGUoamMsIFwiXCIpLCB0aGlzLl9ub3RjaFRyYWlsaW5nID0gJChcImRpdlwiKSwgaC5hZGRDbGFzcyhcbiAgICAgIHRoaXMuX25vdGNoVHJhaWxpbmcsXG4gICAgICBgJHt0aGlzLl9jbGFzc2VzLm5vdGNoVHJhaWxpbmd9ICR7aX1gXG4gICAgKSwgdGhpcy5fbm90Y2hUcmFpbGluZy5zZXRBdHRyaWJ1dGUoel8sIFwiXCIpLCAhKG4ubGVuZ3RoID49IDEpICYmIChvLmFwcGVuZCh0aGlzLl9ub3RjaExlYWRpbmcpLCBvLmFwcGVuZCh0aGlzLl9ub3RjaE1pZGRsZSksIG8uYXBwZW5kKHRoaXMuX25vdGNoVHJhaWxpbmcpLCB0aGlzLl9lbGVtZW50LmFwcGVuZChvKSk7XG4gIH1cbiAgX2FwcGx5Tm90Y2goKSB7XG4gICAgdGhpcy5fbm90Y2hNaWRkbGUuc3R5bGUud2lkdGggPSBgJHt0aGlzLl9sYWJlbFdpZHRofXB4YCwgdGhpcy5fbm90Y2hMZWFkaW5nLnN0eWxlLndpZHRoID0gYCR7dGhpcy5fbGFiZWxNYXJnaW5MZWZ0ICsgOX1weGAsIHRoaXMuX2xhYmVsICE9PSBudWxsICYmICh0aGlzLl9sYWJlbC5zdHlsZS5tYXJnaW5MZWZ0ID0gYCR7dGhpcy5fbGFiZWxNYXJnaW5MZWZ0fXB4YCk7XG4gIH1cbiAgX3JlbW92ZUJvcmRlcigpIHtcbiAgICBjb25zdCB0ID0gZC5maW5kT25lKGtlLCB0aGlzLl9lbGVtZW50KTtcbiAgICB0ICYmIHQucmVtb3ZlKCk7XG4gIH1cbiAgX2FjdGl2YXRlKHQpIHtcbiAgICBabCgoKSA9PiB7XG4gICAgICB0aGlzLl9nZXRFbGVtZW50cyh0KTtcbiAgICAgIGNvbnN0IGUgPSB0ID8gdC50YXJnZXQgOiB0aGlzLmlucHV0LCBpID0gZC5maW5kT25lKFxuICAgICAgICBrZSxcbiAgICAgICAgdGhpcy5fZWxlbWVudFxuICAgICAgKTtcbiAgICAgIHQgJiYgdC50eXBlID09PSBcImZvY3VzXCIgJiYgaSAmJiBpLnNldEF0dHJpYnV0ZShDYSwgXCJcIiksIGUudmFsdWUgIT09IFwiXCIgJiYgKGUuc2V0QXR0cmlidXRlKEZ0LCBcIlwiKSwgaSAmJiBpLnNldEF0dHJpYnV0ZShGdCwgXCJcIikpLCB0aGlzLl90b2dnbGVEZWZhdWx0RGF0ZVBsYWNlaG9sZGVyKGUpO1xuICAgIH0pO1xuICB9XG4gIF9nZXRFbGVtZW50cyh0KSB7XG4gICAgaWYgKHQgJiYgKHRoaXMuX2VsZW1lbnQgPSB0LnRhcmdldC5wYXJlbnROb2RlLCB0aGlzLl9sYWJlbCA9IGQuZmluZE9uZShcImxhYmVsXCIsIHRoaXMuX2VsZW1lbnQpKSwgdCAmJiB0aGlzLl9sYWJlbCkge1xuICAgICAgY29uc3QgZSA9IHRoaXMuX2xhYmVsV2lkdGg7XG4gICAgICB0aGlzLl9nZXRMYWJlbERhdGEoKSwgZSAhPT0gdGhpcy5fbGFiZWxXaWR0aCAmJiAodGhpcy5fbm90Y2hNaWRkbGUgPSBkLmZpbmRPbmUoXG4gICAgICAgIHdhLFxuICAgICAgICB0LnRhcmdldC5wYXJlbnROb2RlXG4gICAgICApLCB0aGlzLl9ub3RjaExlYWRpbmcgPSBkLmZpbmRPbmUoXG4gICAgICAgIHlhLFxuICAgICAgICB0LnRhcmdldC5wYXJlbnROb2RlXG4gICAgICApLCB0aGlzLl9hcHBseU5vdGNoKCkpO1xuICAgIH1cbiAgfVxuICBfZGVhY3RpdmF0ZSh0KSB7XG4gICAgY29uc3QgZSA9IHQgPyB0LnRhcmdldCA6IHRoaXMuaW5wdXQsIGkgPSBkLmZpbmRPbmUoXG4gICAgICBrZSxcbiAgICAgIGUucGFyZW50Tm9kZVxuICAgICk7XG4gICAgaS5yZW1vdmVBdHRyaWJ1dGUoQ2EpLCBlLnZhbHVlID09PSBcIlwiICYmIChlLnJlbW92ZUF0dHJpYnV0ZShGdCksIGkucmVtb3ZlQXR0cmlidXRlKEZ0KSksIHRoaXMuX3RvZ2dsZURlZmF1bHREYXRlUGxhY2Vob2xkZXIoZSk7XG4gIH1cbiAgc3RhdGljIGFjdGl2YXRlKHQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZSkge1xuICAgICAgdC5fYWN0aXZhdGUoZSk7XG4gICAgfTtcbiAgfVxuICBzdGF0aWMgZGVhY3RpdmF0ZSh0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGUpIHtcbiAgICAgIHQuX2RlYWN0aXZhdGUoZSk7XG4gICAgfTtcbiAgfVxuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQsIGUpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgbGV0IGkgPSB5LmdldERhdGEodGhpcywgb3MpO1xuICAgICAgY29uc3QgbiA9IHR5cGVvZiB0ID09IFwib2JqZWN0XCIgJiYgdDtcbiAgICAgIGlmICghKCFpICYmIC9kaXNwb3NlLy50ZXN0KHQpKSAmJiAoaSB8fCAoaSA9IG5ldyBWKHRoaXMsIG4pKSwgdHlwZW9mIHQgPT0gXCJzdHJpbmdcIikpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpW3RdID4gXCJ1XCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgIGlbdF0oZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGdldEluc3RhbmNlKHQpIHtcbiAgICByZXR1cm4geS5nZXREYXRhKHQsIG9zKTtcbiAgfVxuICBzdGF0aWMgZ2V0T3JDcmVhdGVJbnN0YW5jZSh0LCBlID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSh0KSB8fCBuZXcgdGhpcyh0LCB0eXBlb2YgZSA9PSBcIm9iamVjdFwiID8gZSA6IG51bGwpO1xuICB9XG59XG5jb25zdCBrYSA9IFwiYW5pbWF0aW9uXCIsIGpuID0gXCJ0ZS5hbmltYXRpb25cIiwgSl8gPSB7XG4gIGFuaW1hdGlvbjogXCJzdHJpbmdcIixcbiAgYW5pbWF0aW9uU3RhcnQ6IFwic3RyaW5nXCIsXG4gIGFuaW1hdGlvblNob3dPbkxvYWQ6IFwiYm9vbGVhblwiLFxuICBvblN0YXJ0OiBcIihudWxsfGZ1bmN0aW9uKVwiLFxuICBvbkVuZDogXCIobnVsbHxmdW5jdGlvbilcIixcbiAgb25IaWRlOiBcIihudWxsfGZ1bmN0aW9uKVwiLFxuICBvblNob3c6IFwiKG51bGx8ZnVuY3Rpb24pXCIsXG4gIGFuaW1hdGlvbk9uU2Nyb2xsOiBcIihzdHJpbmcpXCIsXG4gIGFuaW1hdGlvbldpbmRvd0hlaWdodDogXCJudW1iZXJcIixcbiAgYW5pbWF0aW9uT2Zmc2V0OiBcIihudW1iZXJ8c3RyaW5nKVwiLFxuICBhbmltYXRpb25EZWxheTogXCIobnVtYmVyfHN0cmluZylcIixcbiAgYW5pbWF0aW9uUmV2ZXJzZTogXCJib29sZWFuXCIsXG4gIGFuaW1hdGlvbkludGVydmFsOiBcIihudW1iZXJ8c3RyaW5nKVwiLFxuICBhbmltYXRpb25SZXBlYXQ6IFwiKG51bWJlcnxib29sZWFuKVwiLFxuICBhbmltYXRpb25SZXNldDogXCJib29sZWFuXCJcbn0sIHRmID0ge1xuICBhbmltYXRpb246IFwiZmFkZVwiLFxuICBhbmltYXRpb25TdGFydDogXCJvbkNsaWNrXCIsXG4gIGFuaW1hdGlvblNob3dPbkxvYWQ6ICEwLFxuICBvblN0YXJ0OiBudWxsLFxuICBvbkVuZDogbnVsbCxcbiAgb25IaWRlOiBudWxsLFxuICBvblNob3c6IG51bGwsXG4gIGFuaW1hdGlvbk9uU2Nyb2xsOiBcIm9uY2VcIixcbiAgYW5pbWF0aW9uV2luZG93SGVpZ2h0OiAwLFxuICBhbmltYXRpb25PZmZzZXQ6IDAsXG4gIGFuaW1hdGlvbkRlbGF5OiAwLFxuICBhbmltYXRpb25SZXZlcnNlOiAhMSxcbiAgYW5pbWF0aW9uSW50ZXJ2YWw6IDAsXG4gIGFuaW1hdGlvblJlcGVhdDogITEsXG4gIGFuaW1hdGlvblJlc2V0OiAhMVxufTtcbmNsYXNzIHByIHtcbiAgY29uc3RydWN0b3IodCwgZSkge1xuICAgIHRoaXMuX2VsZW1lbnQgPSB0LCB0aGlzLl9hbmltYXRlRWxlbWVudCA9IHRoaXMuX2dldEFuaW1hdGVFbGVtZW50KCksIHRoaXMuX2lzRmlyc3RTY3JvbGwgPSAhMCwgdGhpcy5fcmVwZWF0QW5pbWF0ZU9uU2Nyb2xsID0gITAsIHRoaXMuX29wdGlvbnMgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX2VsZW1lbnQgJiYgKHkuc2V0RGF0YSh0LCBqbiwgdGhpcyksIHRoaXMuX2luaXQoKSk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIGthO1xuICB9XG4gIC8vIFB1YmxpY1xuICBpbml0KCkge1xuICAgIHRoaXMuX2luaXQoKTtcbiAgfVxuICBzdGFydEFuaW1hdGlvbigpIHtcbiAgICB0aGlzLl9zdGFydEFuaW1hdGlvbigpO1xuICB9XG4gIHN0b3BBbmltYXRpb24oKSB7XG4gICAgdGhpcy5fY2xlYXJBbmltYXRpb25DbGFzcygpO1xuICB9XG4gIGNoYW5nZUFuaW1hdGlvblR5cGUodCkge1xuICAgIHRoaXMuX29wdGlvbnMuYW5pbWF0aW9uID0gdDtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIGMub2ZmKHRoaXMuX2VsZW1lbnQsIFwibW91c2Vkb3duXCIpLCBjLm9mZih0aGlzLl9hbmltYXRlRWxlbWVudCwgXCJhbmltYXRpb25lbmRcIiksIGMub2ZmKHdpbmRvdywgXCJzY3JvbGxcIiksIGMub2ZmKHRoaXMuX2VsZW1lbnQsIFwibW91c2VvdmVyXCIpLCB5LnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgam4pLCB0aGlzLl9lbGVtZW50ID0gbnVsbCwgdGhpcy5fYW5pbWF0ZUVsZW1lbnQgPSBudWxsLCB0aGlzLl9pc0ZpcnN0U2Nyb2xsID0gbnVsbCwgdGhpcy5fcmVwZWF0QW5pbWF0ZU9uU2Nyb2xsID0gbnVsbCwgdGhpcy5fb3B0aW9ucyA9IG51bGw7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfaW5pdCgpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX29wdGlvbnMuYW5pbWF0aW9uU3RhcnQpIHtcbiAgICAgIGNhc2UgXCJvbkhvdmVyXCI6XG4gICAgICAgIHRoaXMuX2JpbmRIb3ZlckV2ZW50cygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJvbkxvYWRcIjpcbiAgICAgICAgdGhpcy5fc3RhcnRBbmltYXRpb24oKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwib25TY3JvbGxcIjpcbiAgICAgICAgdGhpcy5fYmluZFNjcm9sbEV2ZW50cygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJvbkNsaWNrXCI6XG4gICAgICAgIHRoaXMuX2JpbmRDbGlja0V2ZW50cygpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdGhpcy5fYmluZFRyaWdnZXJPbkVuZENhbGxiYWNrKCksIHRoaXMuX29wdGlvbnMuYW5pbWF0aW9uUmVzZXQgJiYgdGhpcy5fYmluZFJlc2V0QW5pbWF0aW9uQWZ0ZXJGaW5pc2goKTtcbiAgfVxuICBfZ2V0QW5pbWF0ZUVsZW1lbnQoKSB7XG4gICAgY29uc3QgdCA9IGguZ2V0RGF0YUF0dHJpYnV0ZShcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBcImFuaW1hdGlvbi10YXJnZXRcIlxuICAgICk7XG4gICAgcmV0dXJuIHQgPyBkLmZpbmQodClbMF0gOiB0aGlzLl9lbGVtZW50O1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIGNvbnN0IGUgPSBoLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2FuaW1hdGVFbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLnRmLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBEKGthLCB0LCBKXyksIHQ7XG4gIH1cbiAgX2FuaW1hdGVPblNjcm9sbCgpIHtcbiAgICBjb25zdCB0ID0gaC5vZmZzZXQodGhpcy5fYW5pbWF0ZUVsZW1lbnQpLnRvcCwgZSA9IHRoaXMuX2FuaW1hdGVFbGVtZW50Lm9mZnNldEhlaWdodCwgaSA9IHdpbmRvdy5pbm5lckhlaWdodCwgbiA9IHQgKyB0aGlzLl9vcHRpb25zLmFuaW1hdGlvbk9mZnNldCA8PSBpICYmIHQgKyB0aGlzLl9vcHRpb25zLmFuaW1hdGlvbk9mZnNldCArIGUgPj0gMCwgbyA9IHRoaXMuX2FuaW1hdGVFbGVtZW50LnN0eWxlLnZpc2liaWxpdHkgPT09IFwidmlzaWJsZVwiO1xuICAgIHN3aXRjaCAoITApIHtcbiAgICAgIGNhc2UgKG4gJiYgdGhpcy5faXNGaXJzdFNjcm9sbCk6XG4gICAgICAgIHRoaXMuX2lzRmlyc3RTY3JvbGwgPSAhMSwgdGhpcy5fc3RhcnRBbmltYXRpb24oKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICghbiAmJiB0aGlzLl9pc0ZpcnN0U2Nyb2xsKTpcbiAgICAgICAgdGhpcy5faXNGaXJzdFNjcm9sbCA9ICExLCB0aGlzLl9oaWRlQW5pbWF0ZUVsZW1lbnQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIChuICYmICFvICYmIHRoaXMuX3JlcGVhdEFuaW1hdGVPblNjcm9sbCk6XG4gICAgICAgIHRoaXMuX29wdGlvbnMuYW5pbWF0aW9uT25TY3JvbGwgIT09IFwicmVwZWF0XCIgJiYgKHRoaXMuX3JlcGVhdEFuaW1hdGVPblNjcm9sbCA9ICExKSwgdGhpcy5fY2FsbGJhY2sodGhpcy5fb3B0aW9ucy5vblNob3cpLCB0aGlzLl9zaG93QW5pbWF0ZUVsZW1lbnQoKSwgdGhpcy5fc3RhcnRBbmltYXRpb24oKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICghbiAmJiBvICYmIHRoaXMuX3JlcGVhdEFuaW1hdGVPblNjcm9sbCk6XG4gICAgICAgIHRoaXMuX2hpZGVBbmltYXRlRWxlbWVudCgpLCB0aGlzLl9jbGVhckFuaW1hdGlvbkNsYXNzKCksIHRoaXMuX2NhbGxiYWNrKHRoaXMuX29wdGlvbnMub25IaWRlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIF9hZGRBbmltYXRlZENsYXNzKCkge1xuICAgIGguYWRkQ2xhc3MoXG4gICAgICB0aGlzLl9hbmltYXRlRWxlbWVudCxcbiAgICAgIGBhbmltYXRlLSR7dGhpcy5fb3B0aW9ucy5hbmltYXRpb259YFxuICAgICk7XG4gIH1cbiAgX2NsZWFyQW5pbWF0aW9uQ2xhc3MoKSB7XG4gICAgdGhpcy5fYW5pbWF0ZUVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShgYW5pbWF0ZS0ke3RoaXMuX29wdGlvbnMuYW5pbWF0aW9ufWApO1xuICB9XG4gIF9zdGFydEFuaW1hdGlvbigpIHtcbiAgICB0aGlzLl9jYWxsYmFjayh0aGlzLl9vcHRpb25zLm9uU3RhcnQpLCB0aGlzLl9hZGRBbmltYXRlZENsYXNzKCksIHRoaXMuX29wdGlvbnMuYW5pbWF0aW9uUmVwZWF0ICYmICF0aGlzLl9vcHRpb25zLmFuaW1hdGlvbkludGVydmFsICYmIHRoaXMuX3NldEFuaW1hdGlvblJlcGVhdCgpLCB0aGlzLl9vcHRpb25zLmFuaW1hdGlvblJldmVyc2UgJiYgdGhpcy5fc2V0QW5pbWF0aW9uUmV2ZXJzZSgpLCB0aGlzLl9vcHRpb25zLmFuaW1hdGlvbkRlbGF5ICYmIHRoaXMuX3NldEFuaW1hdGlvbkRlbGF5KCksIHRoaXMuX29wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb24gJiYgdGhpcy5fc2V0QW5pbWF0aW9uRHVyYXRpb24oKSwgdGhpcy5fb3B0aW9ucy5hbmltYXRpb25JbnRlcnZhbCAmJiB0aGlzLl9zZXRBbmltYXRpb25JbnRlcnZhbCgpO1xuICB9XG4gIF9zZXRBbmltYXRpb25SZXZlcnNlKCkge1xuICAgIGguc3R5bGUodGhpcy5fYW5pbWF0ZUVsZW1lbnQsIHtcbiAgICAgIGFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OiB0aGlzLl9vcHRpb25zLmFuaW1hdGlvblJlcGVhdCA9PT0gITAgPyBcImluZmluaXRlXCIgOiBcIjJcIixcbiAgICAgIGFuaW1hdGlvbkRpcmVjdGlvbjogXCJhbHRlcm5hdGVcIlxuICAgIH0pO1xuICB9XG4gIF9zZXRBbmltYXRpb25EdXJhdGlvbigpIHtcbiAgICBoLnN0eWxlKHRoaXMuX2FuaW1hdGVFbGVtZW50LCB7XG4gICAgICBhbmltYXRpb25EdXJhdGlvbjogYCR7dGhpcy5fb3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbn1tc2BcbiAgICB9KTtcbiAgfVxuICBfc2V0QW5pbWF0aW9uRGVsYXkoKSB7XG4gICAgaC5zdHlsZSh0aGlzLl9hbmltYXRlRWxlbWVudCwge1xuICAgICAgYW5pbWF0aW9uRGVsYXk6IGAke3RoaXMuX29wdGlvbnMuYW5pbWF0aW9uRGVsYXl9bXNgXG4gICAgfSk7XG4gIH1cbiAgX3NldEFuaW1hdGlvblJlcGVhdCgpIHtcbiAgICBoLnN0eWxlKHRoaXMuX2FuaW1hdGVFbGVtZW50LCB7XG4gICAgICBhbmltYXRpb25JdGVyYXRpb25Db3VudDogdGhpcy5fb3B0aW9ucy5hbmltYXRpb25SZXBlYXQgPT09ICEwID8gXCJpbmZpbml0ZVwiIDogdGhpcy5fb3B0aW9ucy5hbmltYXRpb25SZXBlYXRcbiAgICB9KTtcbiAgfVxuICBfc2V0QW5pbWF0aW9uSW50ZXJ2YWwoKSB7XG4gICAgYy5vbih0aGlzLl9hbmltYXRlRWxlbWVudCwgXCJjbGlja1wiLCAoKSA9PiB7XG4gICAgICB0aGlzLl9jbGVhckFuaW1hdGlvbkNsYXNzKCksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLl9hZGRBbmltYXRlZENsYXNzKCk7XG4gICAgICB9LCB0aGlzLl9vcHRpb25zLmFuaW1hdGlvbkludGVydmFsKTtcbiAgICB9KTtcbiAgfVxuICBfaGlkZUFuaW1hdGVFbGVtZW50KCkge1xuICAgIGguc3R5bGUodGhpcy5fYW5pbWF0ZUVsZW1lbnQsIHsgdmlzaWJpbGl0eTogXCJoaWRkZW5cIiB9KTtcbiAgfVxuICBfc2hvd0FuaW1hdGVFbGVtZW50KCkge1xuICAgIGguc3R5bGUodGhpcy5fYW5pbWF0ZUVsZW1lbnQsIHsgdmlzaWJpbGl0eTogXCJ2aXNpYmxlXCIgfSk7XG4gIH1cbiAgX2JpbmRSZXNldEFuaW1hdGlvbkFmdGVyRmluaXNoKCkge1xuICAgIGMub24odGhpcy5fYW5pbWF0ZUVsZW1lbnQsIFwiYW5pbWF0aW9uZW5kXCIsICgpID0+IHtcbiAgICAgIHRoaXMuX2NsZWFyQW5pbWF0aW9uQ2xhc3MoKTtcbiAgICB9KTtcbiAgfVxuICBfYmluZFRyaWdnZXJPbkVuZENhbGxiYWNrKCkge1xuICAgIGMub24odGhpcy5fYW5pbWF0ZUVsZW1lbnQsIFwiYW5pbWF0aW9uZW5kXCIsICgpID0+IHtcbiAgICAgIHRoaXMuX2NhbGxiYWNrKHRoaXMuX29wdGlvbnMub25FbmQpO1xuICAgIH0pO1xuICB9XG4gIF9iaW5kU2Nyb2xsRXZlbnRzKCkge1xuICAgIHRoaXMuX29wdGlvbnMuYW5pbWF0aW9uU2hvd09uTG9hZCB8fCB0aGlzLl9hbmltYXRlT25TY3JvbGwoKSwgYy5vbih3aW5kb3csIFwic2Nyb2xsXCIsICgpID0+IHtcbiAgICAgIHRoaXMuX2FuaW1hdGVPblNjcm9sbCgpO1xuICAgIH0pO1xuICB9XG4gIF9iaW5kQ2xpY2tFdmVudHMoKSB7XG4gICAgYy5vbih0aGlzLl9lbGVtZW50LCBcIm1vdXNlZG93blwiLCAoKSA9PiB7XG4gICAgICB0aGlzLl9zdGFydEFuaW1hdGlvbigpO1xuICAgIH0pO1xuICB9XG4gIF9iaW5kSG92ZXJFdmVudHMoKSB7XG4gICAgYy5vbmUodGhpcy5fZWxlbWVudCwgXCJtb3VzZW92ZXJcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fc3RhcnRBbmltYXRpb24oKTtcbiAgICB9KSwgYy5vbmUodGhpcy5fYW5pbWF0ZUVsZW1lbnQsIFwiYW5pbWF0aW9uZW5kXCIsICgpID0+IHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLl9iaW5kSG92ZXJFdmVudHMoKTtcbiAgICAgIH0sIDEwMCk7XG4gICAgfSk7XG4gIH1cbiAgX2NhbGxiYWNrKHQpIHtcbiAgICB0IGluc3RhbmNlb2YgRnVuY3Rpb24gJiYgdCgpO1xuICB9XG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgYXV0b0luaXQodCkge1xuICAgIHQuX2luaXQoKTtcbiAgfVxuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQpIHtcbiAgICBuZXcgcHIodGhpc1swXSwgdCkuaW5pdCgpO1xuICB9XG4gIHN0YXRpYyBnZXRJbnN0YW5jZSh0KSB7XG4gICAgcmV0dXJuIHkuZ2V0RGF0YSh0LCBqbik7XG4gIH1cbiAgc3RhdGljIGdldE9yQ3JlYXRlSW5zdGFuY2UodCwgZSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UodCkgfHwgbmV3IHRoaXModCwgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiA/IGUgOiBudWxsKTtcbiAgfVxufVxuY29uc3QgS24gPSBcInJpcHBsZVwiLCBycyA9IFwidGUucmlwcGxlXCIsIGVmID0gXCJyZ2JhKHt7Y29sb3J9fSwgMC4yKSAwLCByZ2JhKHt7Y29sb3J9fSwgMC4zKSA0MCUsIHJnYmEoe3tjb2xvcn19LCAwLjQpIDUwJSwgcmdiYSh7e2NvbG9yfX0sIDAuNSkgNjAlLCByZ2JhKHt7Y29sb3J9fSwgMCkgNzAlXCIsIHNmID0gW1wiW2RhdGEtdGUtcmlwcGxlLWluaXRdXCJdLCBhcyA9IFswLCAwLCAwXSwgbmYgPSBbXG4gIHsgbmFtZTogXCJwcmltYXJ5XCIsIGdyYWRpZW50Q29sb3I6IFwiIzNCNzFDQVwiIH0sXG4gIHsgbmFtZTogXCJzZWNvbmRhcnlcIiwgZ3JhZGllbnRDb2xvcjogXCIjOUZBNkIyXCIgfSxcbiAgeyBuYW1lOiBcInN1Y2Nlc3NcIiwgZ3JhZGllbnRDb2xvcjogXCIjMTRBNDREXCIgfSxcbiAgeyBuYW1lOiBcImRhbmdlclwiLCBncmFkaWVudENvbG9yOiBcIiNEQzRDNjRcIiB9LFxuICB7IG5hbWU6IFwid2FybmluZ1wiLCBncmFkaWVudENvbG9yOiBcIiNFNEExMUJcIiB9LFxuICB7IG5hbWU6IFwiaW5mb1wiLCBncmFkaWVudENvbG9yOiBcIiM1NEI0RDNcIiB9LFxuICB7IG5hbWU6IFwibGlnaHRcIiwgZ3JhZGllbnRDb2xvcjogXCIjZmJmYmZiXCIgfSxcbiAgeyBuYW1lOiBcImRhcmtcIiwgZ3JhZGllbnRDb2xvcjogXCIjMjYyNjI2XCIgfVxuXSwgeGEgPSAwLjUsIG9mID0ge1xuICByaXBwbGVDZW50ZXJlZDogITEsXG4gIHJpcHBsZUNvbG9yOiBcIlwiLFxuICByaXBwbGVDb2xvckRhcms6IFwiXCIsXG4gIHJpcHBsZUR1cmF0aW9uOiBcIjUwMG1zXCIsXG4gIHJpcHBsZVJhZGl1czogMCxcbiAgcmlwcGxlVW5ib3VuZDogITFcbn0sIHJmID0ge1xuICByaXBwbGVDZW50ZXJlZDogXCJib29sZWFuXCIsXG4gIHJpcHBsZUNvbG9yOiBcInN0cmluZ1wiLFxuICByaXBwbGVDb2xvckRhcms6IFwic3RyaW5nXCIsXG4gIHJpcHBsZUR1cmF0aW9uOiBcInN0cmluZ1wiLFxuICByaXBwbGVSYWRpdXM6IFwibnVtYmVyXCIsXG4gIHJpcHBsZVVuYm91bmQ6IFwiYm9vbGVhblwiXG59LCBhZiA9IHtcbiAgcmlwcGxlOiBcInJlbGF0aXZlIG92ZXJmbG93LWhpZGRlbiBpbmxpbmUtYmxvY2sgYWxpZ24tYm90dG9tXCIsXG4gIHJpcHBsZVdhdmU6IFwicm91bmRlZC1bNTAlXSBvcGFjaXR5LTUwIHBvaW50ZXItZXZlbnRzLW5vbmUgYWJzb2x1dGUgdG91Y2gtbm9uZSBzY2FsZS0wIHRyYW5zaXRpb24tW3RyYW5zZm9ybSxfb3BhY2l0eV0gZWFzZS1bY3ViaWMtYmV6aWVyKDAsMCwwLjE1LDEpLF9jdWJpYy1iZXppZXIoMCwwLDAuMTUsMSldIHotWzk5OV1cIixcbiAgdW5ib3VuZDogXCJvdmVyZmxvdy12aXNpYmxlXCJcbn0sIGxmID0ge1xuICByaXBwbGU6IFwic3RyaW5nXCIsXG4gIHJpcHBsZVdhdmU6IFwic3RyaW5nXCIsXG4gIHVuYm91bmQ6IFwic3RyaW5nXCJcbn07XG5jbGFzcyBaZSB7XG4gIGNvbnN0cnVjdG9yKHQsIGUsIGkpIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gdCwgdGhpcy5fb3B0aW9ucyA9IHRoaXMuX2dldENvbmZpZyhlKSwgdGhpcy5fY2xhc3NlcyA9IHRoaXMuX2dldENsYXNzZXMoaSksIHRoaXMuX2VsZW1lbnQgJiYgKHkuc2V0RGF0YSh0LCBycywgdGhpcyksIGguYWRkQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy5yaXBwbGUpKSwgdGhpcy5fY2xpY2tIYW5kbGVyID0gdGhpcy5fY3JlYXRlUmlwcGxlLmJpbmQodGhpcyksIHRoaXMuX3JpcHBsZVRpbWVyID0gbnVsbCwgdGhpcy5faXNNaW5XaWR0aFNldCA9ICExLCB0aGlzLl9pbml0aWFsQ2xhc3NlcyA9IG51bGwsIHRoaXMuaW5pdCgpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBLbjtcbiAgfVxuICAvLyBQdWJsaWNcbiAgaW5pdCgpIHtcbiAgICB0aGlzLl9hZGRDbGlja0V2ZW50KHRoaXMuX2VsZW1lbnQpO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgeS5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIHJzKSwgYy5vZmYodGhpcy5fZWxlbWVudCwgXCJjbGlja1wiLCB0aGlzLl9jbGlja0hhbmRsZXIpLCB0aGlzLl9lbGVtZW50ID0gbnVsbCwgdGhpcy5fb3B0aW9ucyA9IG51bGw7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfYXV0b0luaXQodCkge1xuICAgIHNmLmZvckVhY2goKGUpID0+IHtcbiAgICAgIGQuY2xvc2VzdCh0LnRhcmdldCwgZSkgJiYgKHRoaXMuX2VsZW1lbnQgPSBkLmNsb3Nlc3QodC50YXJnZXQsIGUpKTtcbiAgICB9KSwgdGhpcy5fZWxlbWVudC5zdHlsZS5taW5XaWR0aCB8fCAoaC5zdHlsZSh0aGlzLl9lbGVtZW50LCB7XG4gICAgICBcIm1pbi13aWR0aFwiOiBnZXRDb21wdXRlZFN0eWxlKHRoaXMuX2VsZW1lbnQpLndpZHRoXG4gICAgfSksIHRoaXMuX2lzTWluV2lkdGhTZXQgPSAhMCksIHRoaXMuX29wdGlvbnMgPSB0aGlzLl9nZXRDb25maWcoKSwgdGhpcy5fY2xhc3NlcyA9IHRoaXMuX2dldENsYXNzZXMoKSwgdGhpcy5faW5pdGlhbENsYXNzZXMgPSBbLi4udGhpcy5fZWxlbWVudC5jbGFzc0xpc3RdLCBoLmFkZENsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NsYXNzZXMucmlwcGxlKSwgdGhpcy5fY3JlYXRlUmlwcGxlKHQpO1xuICB9XG4gIF9hZGRDbGlja0V2ZW50KHQpIHtcbiAgICBjLm9uKHQsIFwibW91c2Vkb3duXCIsIHRoaXMuX2NsaWNrSGFuZGxlcik7XG4gIH1cbiAgX2NyZWF0ZVJpcHBsZSh0KSB7XG4gICAgdGhpcy5fZWxlbWVudC5jbGFzc05hbWUuaW5kZXhPZih0aGlzLl9jbGFzc2VzLnJpcHBsZSkgPCAwICYmIGguYWRkQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy5yaXBwbGUpO1xuICAgIGNvbnN0IHsgbGF5ZXJYOiBlLCBsYXllclk6IGkgfSA9IHQsIG4gPSB0Lm9mZnNldFggfHwgZSwgbyA9IHQub2Zmc2V0WSB8fCBpLCByID0gdGhpcy5fZWxlbWVudC5vZmZzZXRIZWlnaHQsIGEgPSB0aGlzLl9lbGVtZW50Lm9mZnNldFdpZHRoLCBsID0gdGhpcy5fZHVyYXRpb25Ub01zTnVtYmVyKHRoaXMuX29wdGlvbnMucmlwcGxlRHVyYXRpb24pLCBwID0ge1xuICAgICAgb2Zmc2V0WDogdGhpcy5fb3B0aW9ucy5yaXBwbGVDZW50ZXJlZCA/IHIgLyAyIDogbixcbiAgICAgIG9mZnNldFk6IHRoaXMuX29wdGlvbnMucmlwcGxlQ2VudGVyZWQgPyBhIC8gMiA6IG8sXG4gICAgICBoZWlnaHQ6IHIsXG4gICAgICB3aWR0aDogYVxuICAgIH0sIHUgPSB0aGlzLl9nZXREaWFtZXRlcihwKSwgXyA9IHRoaXMuX29wdGlvbnMucmlwcGxlUmFkaXVzIHx8IHUgLyAyLCBmID0ge1xuICAgICAgZGVsYXk6IGwgKiB4YSxcbiAgICAgIGR1cmF0aW9uOiBsIC0gbCAqIHhhXG4gICAgfSwgZyA9IHtcbiAgICAgIGxlZnQ6IHRoaXMuX29wdGlvbnMucmlwcGxlQ2VudGVyZWQgPyBgJHthIC8gMiAtIF99cHhgIDogYCR7biAtIF99cHhgLFxuICAgICAgdG9wOiB0aGlzLl9vcHRpb25zLnJpcHBsZUNlbnRlcmVkID8gYCR7ciAvIDIgLSBffXB4YCA6IGAke28gLSBffXB4YCxcbiAgICAgIGhlaWdodDogYCR7dGhpcy5fb3B0aW9ucy5yaXBwbGVSYWRpdXMgKiAyIHx8IHV9cHhgLFxuICAgICAgd2lkdGg6IGAke3RoaXMuX29wdGlvbnMucmlwcGxlUmFkaXVzICogMiB8fCB1fXB4YCxcbiAgICAgIHRyYW5zaXRpb25EZWxheTogYDBzLCAke2YuZGVsYXl9bXNgLFxuICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uOiBgJHtsfW1zLCAke2YuZHVyYXRpb259bXNgXG4gICAgfSwgbSA9ICQoXCJkaXZcIik7XG4gICAgdGhpcy5fY3JlYXRlSFRNTFJpcHBsZSh7XG4gICAgICB3cmFwcGVyOiB0aGlzLl9lbGVtZW50LFxuICAgICAgcmlwcGxlOiBtLFxuICAgICAgc3R5bGVzOiBnXG4gICAgfSksIHRoaXMuX3JlbW92ZUhUTUxSaXBwbGUoeyByaXBwbGU6IG0sIGR1cmF0aW9uOiBsIH0pO1xuICB9XG4gIF9jcmVhdGVIVE1MUmlwcGxlKHsgd3JhcHBlcjogdCwgcmlwcGxlOiBlLCBzdHlsZXM6IGkgfSkge1xuICAgIE9iamVjdC5rZXlzKGkpLmZvckVhY2goXG4gICAgICAobikgPT4gZS5zdHlsZVtuXSA9IGlbbl1cbiAgICApLCBoLmFkZENsYXNzKGUsIHRoaXMuX2NsYXNzZXMucmlwcGxlV2F2ZSksIGUuc2V0QXR0cmlidXRlKFwiZGF0YS10ZS1yaXBwbGUtcmVmXCIsIFwiXCIpLCB0aGlzLl9hZGRDb2xvcihlLCB0KSwgdGhpcy5fdG9nZ2xlVW5ib3VuZCh0KSwgdGhpcy5fYXBwZW5kUmlwcGxlKGUsIHQpO1xuICB9XG4gIF9yZW1vdmVIVE1MUmlwcGxlKHsgcmlwcGxlOiB0LCBkdXJhdGlvbjogZSB9KSB7XG4gICAgdGhpcy5fcmlwcGxlVGltZXIgJiYgKGNsZWFyVGltZW91dCh0aGlzLl9yaXBwbGVUaW1lciksIHRoaXMuX3JpcHBsZVRpbWVyID0gbnVsbCksIHQgJiYgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0LmNsYXNzTGlzdC5hZGQoXCIhb3BhY2l0eS0wXCIpO1xuICAgIH0sIDEwKSwgdGhpcy5fcmlwcGxlVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICh0ICYmICh0LnJlbW92ZSgpLCB0aGlzLl9lbGVtZW50KSkge1xuICAgICAgICBkLmZpbmQoXCJbZGF0YS10ZS1yaXBwbGUtcmVmXVwiLCB0aGlzLl9lbGVtZW50KS5mb3JFYWNoKFxuICAgICAgICAgIChuKSA9PiB7XG4gICAgICAgICAgICBuLnJlbW92ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgKSwgdGhpcy5faXNNaW5XaWR0aFNldCAmJiAoaC5zdHlsZSh0aGlzLl9lbGVtZW50LCB7IFwibWluLXdpZHRoXCI6IFwiXCIgfSksIHRoaXMuX2lzTWluV2lkdGhTZXQgPSAhMSk7XG4gICAgICAgIGNvbnN0IGkgPSB0aGlzLl9pbml0aWFsQ2xhc3NlcyA/IHRoaXMuX2FkZGVkTmV3UmlwcGxlQ2xhc3NlcyhcbiAgICAgICAgICB0aGlzLl9jbGFzc2VzLnJpcHBsZSxcbiAgICAgICAgICB0aGlzLl9pbml0aWFsQ2xhc3Nlc1xuICAgICAgICApIDogdGhpcy5fY2xhc3Nlcy5yaXBwbGUuc3BsaXQoXCIgXCIpO1xuICAgICAgICBoLnJlbW92ZUNsYXNzKHRoaXMuX2VsZW1lbnQsIGkpO1xuICAgICAgfVxuICAgIH0sIGUpO1xuICB9XG4gIF9hZGRlZE5ld1JpcHBsZUNsYXNzZXModCwgZSkge1xuICAgIHJldHVybiB0LnNwbGl0KFwiIFwiKS5maWx0ZXIoXG4gICAgICAoaSkgPT4gZS5maW5kSW5kZXgoKG4pID0+IGkgPT09IG4pID09PSAtMVxuICAgICk7XG4gIH1cbiAgX2R1cmF0aW9uVG9Nc051bWJlcih0KSB7XG4gICAgcmV0dXJuIE51bWJlcih0LnJlcGxhY2UoXCJtc1wiLCBcIlwiKS5yZXBsYWNlKFwic1wiLCBcIjAwMFwiKSk7XG4gIH1cbiAgX2dldENvbmZpZyh0ID0ge30pIHtcbiAgICBjb25zdCBlID0gaC5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLm9mLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBEKEtuLCB0LCByZiksIHQ7XG4gIH1cbiAgX2dldENsYXNzZXModCA9IHt9KSB7XG4gICAgY29uc3QgZSA9IGguZ2V0RGF0YUNsYXNzQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLmFmLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBEKEtuLCB0LCBsZiksIHQ7XG4gIH1cbiAgX2dldERpYW1ldGVyKHsgb2Zmc2V0WDogdCwgb2Zmc2V0WTogZSwgaGVpZ2h0OiBpLCB3aWR0aDogbiB9KSB7XG4gICAgY29uc3QgbyA9IGUgPD0gaSAvIDIsIHIgPSB0IDw9IG4gLyAyLCBhID0gKGYsIGcpID0+IE1hdGguc3FydChmICoqIDIgKyBnICoqIDIpLCBsID0gZSA9PT0gaSAvIDIgJiYgdCA9PT0gbiAvIDIsIHAgPSB7XG4gICAgICBmaXJzdDogbyA9PT0gITAgJiYgciA9PT0gITEsXG4gICAgICBzZWNvbmQ6IG8gPT09ICEwICYmIHIgPT09ICEwLFxuICAgICAgdGhpcmQ6IG8gPT09ICExICYmIHIgPT09ICEwLFxuICAgICAgZm91cnRoOiBvID09PSAhMSAmJiByID09PSAhMVxuICAgIH0sIHUgPSB7XG4gICAgICB0b3BMZWZ0OiBhKHQsIGUpLFxuICAgICAgdG9wUmlnaHQ6IGEobiAtIHQsIGUpLFxuICAgICAgYm90dG9tTGVmdDogYSh0LCBpIC0gZSksXG4gICAgICBib3R0b21SaWdodDogYShuIC0gdCwgaSAtIGUpXG4gICAgfTtcbiAgICBsZXQgXyA9IDA7XG4gICAgcmV0dXJuIGwgfHwgcC5mb3VydGggPyBfID0gdS50b3BMZWZ0IDogcC50aGlyZCA/IF8gPSB1LnRvcFJpZ2h0IDogcC5zZWNvbmQgPyBfID0gdS5ib3R0b21SaWdodCA6IHAuZmlyc3QgJiYgKF8gPSB1LmJvdHRvbUxlZnQpLCBfICogMjtcbiAgfVxuICBfYXBwZW5kUmlwcGxlKHQsIGUpIHtcbiAgICBlLmFwcGVuZENoaWxkKHQpLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGguYWRkQ2xhc3ModCwgXCJvcGFjaXR5LTAgc2NhbGUtMTAwXCIpO1xuICAgIH0sIDUwKTtcbiAgfVxuICBfdG9nZ2xlVW5ib3VuZCh0KSB7XG4gICAgdGhpcy5fb3B0aW9ucy5yaXBwbGVVbmJvdW5kID09PSAhMCA/IGguYWRkQ2xhc3ModCwgdGhpcy5fY2xhc3Nlcy51bmJvdW5kKSA6IGgucmVtb3ZlQ2xhc3ModCwgdGhpcy5fY2xhc3Nlcy51bmJvdW5kKTtcbiAgfVxuICBfYWRkQ29sb3IodCkge1xuICAgIGxldCBlID0gdGhpcy5fb3B0aW9ucy5yaXBwbGVDb2xvciB8fCBcInJnYigwLDAsMClcIjtcbiAgICAobG9jYWxTdG9yYWdlLnRoZW1lID09PSBcImRhcmtcIiB8fCAhKFwidGhlbWVcIiBpbiBsb2NhbFN0b3JhZ2UpICYmIHdpbmRvdy5tYXRjaE1lZGlhKFwiKHByZWZlcnMtY29sb3Itc2NoZW1lOiBkYXJrKVwiKS5tYXRjaGVzKSAmJiAoZSA9IHRoaXMuX29wdGlvbnMucmlwcGxlQ29sb3JEYXJrIHx8IHRoaXMuX29wdGlvbnMucmlwcGxlQ29sb3IpO1xuICAgIGNvbnN0IGkgPSBuZi5maW5kKFxuICAgICAgKHIpID0+IHIubmFtZSA9PT0gZS50b0xvd2VyQ2FzZSgpXG4gICAgKSwgbiA9IGkgPyB0aGlzLl9jb2xvclRvUkdCKGkuZ3JhZGllbnRDb2xvcikuam9pbihcIixcIikgOiB0aGlzLl9jb2xvclRvUkdCKGUpLmpvaW4oXCIsXCIpLCBvID0gZWYuc3BsaXQoXCJ7e2NvbG9yfX1cIikuam9pbihgJHtufWApO1xuICAgIHQuc3R5bGUuYmFja2dyb3VuZEltYWdlID0gYHJhZGlhbC1ncmFkaWVudChjaXJjbGUsICR7b30pYDtcbiAgfVxuICBfY29sb3JUb1JHQih0KSB7XG4gICAgZnVuY3Rpb24gZShvKSB7XG4gICAgICByZXR1cm4gby5sZW5ndGggPCA3ICYmIChvID0gYCMke29bMV19JHtvWzFdfSR7b1syXX0ke29bMl19JHtvWzNdfSR7b1szXX1gKSwgW1xuICAgICAgICBwYXJzZUludChvLnN1YnN0cigxLCAyKSwgMTYpLFxuICAgICAgICBwYXJzZUludChvLnN1YnN0cigzLCAyKSwgMTYpLFxuICAgICAgICBwYXJzZUludChvLnN1YnN0cig1LCAyKSwgMTYpXG4gICAgICBdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpKG8pIHtcbiAgICAgIGNvbnN0IHIgPSBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKFxuICAgICAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZmljdHVtXCIpXG4gICAgICApLCBhID0gXCJyZ2IoMSwgMiwgMylcIjtcbiAgICAgIHJldHVybiByLnN0eWxlLmNvbG9yID0gYSwgci5zdHlsZS5jb2xvciAhPT0gYSB8fCAoci5zdHlsZS5jb2xvciA9IG8sIHIuc3R5bGUuY29sb3IgPT09IGEgfHwgci5zdHlsZS5jb2xvciA9PT0gXCJcIikgPyBhcyA6IChvID0gZ2V0Q29tcHV0ZWRTdHlsZShyKS5jb2xvciwgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChyKSwgbyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG4obykge1xuICAgICAgcmV0dXJuIG8gPSBvLm1hdGNoKC9bLlxcZF0rL2cpLm1hcCgocikgPT4gK051bWJlcihyKSksIG8ubGVuZ3RoID0gMywgbztcbiAgICB9XG4gICAgcmV0dXJuIHQudG9Mb3dlckNhc2UoKSA9PT0gXCJ0cmFuc3BhcmVudFwiID8gYXMgOiB0WzBdID09PSBcIiNcIiA/IGUodCkgOiAodC5pbmRleE9mKFwicmdiXCIpID09PSAtMSAmJiAodCA9IGkodCkpLCB0LmluZGV4T2YoXCJyZ2JcIikgPT09IDAgPyBuKHQpIDogYXMpO1xuICB9XG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgYXV0b0luaXRpYWwodCkge1xuICAgIHJldHVybiBmdW5jdGlvbihlKSB7XG4gICAgICB0Ll9hdXRvSW5pdChlKTtcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4geS5nZXREYXRhKHRoaXMsIHJzKSA/IG51bGwgOiBuZXcgWmUodGhpcywgdCk7XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGdldEluc3RhbmNlKHQpIHtcbiAgICByZXR1cm4geS5nZXREYXRhKHQsIHJzKTtcbiAgfVxuICBzdGF0aWMgZ2V0T3JDcmVhdGVJbnN0YW5jZSh0LCBlID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSh0KSB8fCBuZXcgdGhpcyh0LCB0eXBlb2YgZSA9PSBcIm9iamVjdFwiID8gZSA6IG51bGwpO1xuICB9XG59XG5mdW5jdGlvbiBaKHMpIHtcbiAgcmV0dXJuIHMuZ2V0RGF0ZSgpO1xufVxuZnVuY3Rpb24gVnMocykge1xuICByZXR1cm4gcy5nZXREYXkoKTtcbn1cbmZ1bmN0aW9uIFkocykge1xuICByZXR1cm4gcy5nZXRNb250aCgpO1xufVxuZnVuY3Rpb24gQihzKSB7XG4gIHJldHVybiBzLmdldEZ1bGxZZWFyKCk7XG59XG5mdW5jdGlvbiBjZihzLCB0LCBlKSB7XG4gIGNvbnN0IGkgPSBlLnN0YXJ0RGF5LCBuID0gaSA+IDAgPyA3IC0gaSA6IDAsIHIgPSBuZXcgRGF0ZShzLCB0KS5nZXREYXkoKSArIG47XG4gIHJldHVybiByID49IDcgPyByIC0gNyA6IHI7XG59XG5mdW5jdGlvbiBQbyhzKSB7XG4gIHJldHVybiBoZihzKS5nZXREYXRlKCk7XG59XG5mdW5jdGlvbiBoZihzKSB7XG4gIHJldHVybiBFdChzLmdldEZ1bGxZZWFyKCksIHMuZ2V0TW9udGgoKSArIDEsIDApO1xufVxuZnVuY3Rpb24gQmUoKSB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbn1cbmZ1bmN0aW9uIGl0KHMsIHQpIHtcbiAgcmV0dXJuIG50KHMsIHQgKiAxMik7XG59XG5mdW5jdGlvbiBudChzLCB0KSB7XG4gIGNvbnN0IGUgPSBFdChcbiAgICBzLmdldEZ1bGxZZWFyKCksXG4gICAgcy5nZXRNb250aCgpICsgdCxcbiAgICBzLmdldERhdGUoKVxuICApLCBpID0gWihzKSwgbiA9IFooZSk7XG4gIHJldHVybiBpICE9PSBuICYmIGUuc2V0RGF0ZSgwKSwgZTtcbn1cbmZ1bmN0aW9uIHhlKHMsIHQpIHtcbiAgcmV0dXJuIEV0KHMuZ2V0RnVsbFllYXIoKSwgcy5nZXRNb250aCgpLCBzLmdldERhdGUoKSArIHQpO1xufVxuZnVuY3Rpb24gRXQocywgdCwgZSkge1xuICBjb25zdCBpID0gbmV3IERhdGUocywgdCwgZSk7XG4gIHJldHVybiBzID49IDAgJiYgcyA8IDEwMCAmJiBpLnNldEZ1bGxZZWFyKGkuZ2V0RnVsbFllYXIoKSAtIDE5MDApLCBpO1xufVxuZnVuY3Rpb24gT2Eocykge1xuICBjb25zdCB0ID0gcy5zcGxpdChcIi1cIiksIGUgPSB0WzBdLCBpID0gdFsxXSwgbiA9IHRbMl07XG4gIHJldHVybiBFdChlLCBpLCBuKTtcbn1cbmZ1bmN0aW9uIGRmKHMpIHtcbiAgcmV0dXJuICFOdW1iZXIuaXNOYU4ocy5nZXRUaW1lKCkpO1xufVxuZnVuY3Rpb24gUmUocywgdCkge1xuICByZXR1cm4gQihzKSAtIEIodCkgfHwgWShzKSAtIFkodCkgfHwgWihzKSAtIFoodCk7XG59XG5mdW5jdGlvbiBmZShzLCB0KSB7XG4gIHJldHVybiBzLnNldEhvdXJzKDAsIDAsIDAsIDApLCB0LnNldEhvdXJzKDAsIDAsIDAsIDApLCBzLmdldFRpbWUoKSA9PT0gdC5nZXRUaW1lKCk7XG59XG5mdW5jdGlvbiBXcyhzLCB0KSB7XG4gIGNvbnN0IGkgPSBCKHMpIC0gcGYoKTtcbiAgcmV0dXJuIHVmKGksIHQpO1xufVxuZnVuY3Rpb24gdWYocywgdCkge1xuICByZXR1cm4gKHMgJSB0ICsgdCkgJSB0O1xufVxuZnVuY3Rpb24gcGYocywgdCwgZSkge1xuICBsZXQgaSA9IDA7XG4gIHJldHVybiBlID8gaSA9IEIoZSkgLSBzICsgMSA6IHQgJiYgKGkgPSBCKHQpKSwgaTtcbn1cbmZ1bmN0aW9uIG5uKHMsIHQsIGUsIGksIG4sIG8pIHtcbiAgY29uc3QgciA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICByLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICBjb25zdCBhID0gdCAmJiBSZShzLCB0KSA8PSAtMSwgbCA9IGUgJiYgUmUocywgZSkgPj0gMSwgcCA9IG4gJiYgUmUocywgcikgPD0gLTEsIHUgPSBvICYmIFJlKHMsIHIpID49IDEsIF8gPSBpICYmIGkocykgPT09ICExO1xuICByZXR1cm4gYSB8fCBsIHx8IF8gfHwgcCB8fCB1O1xufVxuZnVuY3Rpb24gemMocywgdCwgZSwgaSwgbiwgbykge1xuICBjb25zdCByID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksIGEgPSBpICYmIEIoaSksIGwgPSBpICYmIFkoaSksIHAgPSBlICYmIEIoZSksIHUgPSBlICYmIFkoZSksIF8gPSBCKHIpLCBmID0gWShyKSwgZyA9IGwgJiYgYSAmJiAodCA+IGEgfHwgdCA9PT0gYSAmJiBzID4gbCksIG0gPSB1ICYmIHAgJiYgKHQgPCBwIHx8IHQgPT09IHAgJiYgcyA8IHUpLCBiID0gbiAmJiAodCA8IF8gfHwgdCA9PT0gXyAmJiBzIDwgZiksIHYgPSBvICYmICh0ID4gXyB8fCB0ID09PSBfICYmIHMgPiBmKTtcbiAgcmV0dXJuIGcgfHwgbSB8fCBiIHx8IHY7XG59XG5mdW5jdGlvbiBCbyhzLCB0LCBlLCBpLCBuKSB7XG4gIGNvbnN0IG8gPSB0ICYmIEIodCksIHIgPSBlICYmIEIoZSksIGEgPSBCKC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKSwgbCA9IHIgJiYgcyA+IHIsIHAgPSBvICYmIHMgPCBvLCB1ID0gaSAmJiBzIDwgYSwgXyA9IG4gJiYgcyA+IGE7XG4gIHJldHVybiBsIHx8IHAgfHwgdSB8fCBfO1xufVxuZnVuY3Rpb24gX2YocywgdCwgZSwgaSwgbiwgbywgciwgYSkge1xuICBjb25zdCBsID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gIHJldHVybiBsLnNldEhvdXJzKDAsIDAsIDAsIDApLCAocyAmJiBvICYmIFJlKG8sIGwpIDwgMCB8fCBzKSAmJiAobyA9IGwpLCBvICYmIERpKFxuICAgIHQsXG4gICAgbyxcbiAgICBlLFxuICAgIGksXG4gICAgbixcbiAgICBvLFxuICAgIHIsXG4gICAgYVxuICApO1xufVxuZnVuY3Rpb24gZmYocywgdCwgZSwgaSwgbiwgbywgciwgYSkge1xuICBjb25zdCBsID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gIHJldHVybiBsLnNldEhvdXJzKDAsIDAsIDAsIDApLCAocyAmJiBuICYmIFJlKG4sIGwpIDwgMCB8fCBzKSAmJiAobiA9IGwpLCBuICYmIERpKFxuICAgIHQsXG4gICAgbixcbiAgICBlLFxuICAgIGksXG4gICAgbixcbiAgICBvLFxuICAgIHIsXG4gICAgYVxuICApO1xufVxuZnVuY3Rpb24gRGkocywgdCwgZSwgaSwgbiwgbywgciwgYSkge1xuICByZXR1cm4gZSA9PT0gXCJkYXlzXCIgPyBCKHMpID09PSBCKHQpICYmIFkocykgPT09IFkodCkgOiBlID09PSBcIm1vbnRoc1wiID8gQihzKSA9PT0gQih0KSA6IGUgPT09IFwieWVhcnNcIiA/IEIodCkgPj0gYSAmJiBCKHQpIDw9IHIgOiAhMTtcbn1cbmNvbnN0IG1mID0gXCJkYXRhLXRlLWRhdGVwaWNrZXItbW9kYWwtY29udGFpbmVyLXJlZlwiLCBnZiA9IFwiZGF0YS10ZS1kYXRlcGlja2VyLWRyb3Bkb3duLWNvbnRhaW5lci1yZWZcIiwgYmYgPSBcImRhdGEtdGUtZHJvcGRvd24tYmFja2Ryb3AtcmVmXCIsIHZmID0gXCJkYXRhLXRlLWRhdGVwaWNrZXItZGF0ZS10ZXh0LXJlZlwiLCBTYSA9IFwiZGF0YS10ZS1kYXRlcGlja2VyLXZpZXctcmVmXCIsIFRmID0gXCJkYXRhLXRlLWRhdGVwaWNrZXItcHJldmlvdXMtYnV0dG9uLXJlZlwiLCBFZiA9IFwiZGF0YS10ZS1kYXRlcGlja2VyLW5leHQtYnV0dG9uLXJlZlwiLCBDZiA9IFwiZGF0YS10ZS1kYXRlcGlja2VyLW9rLWJ1dHRvbi1yZWZcIiwgQWYgPSBcImRhdGEtdGUtZGF0ZXBpY2tlci1jYW5jZWwtYnV0dG9uLXJlZlwiLCB5ZiA9IFwiZGF0YS10ZS1kYXRlcGlja2VyLWNsZWFyLWJ1dHRvbi1yZWZcIiwgd2YgPSBcImRhdGEtdGUtZGF0ZXBpY2tlci12aWV3LWNoYW5nZS1idXR0b24tcmVmXCI7XG5mdW5jdGlvbiBrZihzLCB0LCBlLCBpLCBuLCBvLCByLCBhLCBsLCBwKSB7XG4gIGNvbnN0IHUgPSBZKHMpLCBfID0gQihzKSwgZiA9IFoocyksIGcgPSBWcyhzKSwgbSA9ICQoXCJkaXZcIiksIGIgPSBgXG4gICAgICAgICR7SWEoXG4gICAgcyxcbiAgICB1LFxuICAgIF8sXG4gICAgdCxcbiAgICBlLFxuICAgIGksXG4gICAgbixcbiAgICBvLFxuICAgIHIsXG4gICAgYSxcbiAgICBwXG4gICl9XG4gICAgYCwgdiA9IGBcbiAgICAgICR7T2YoZiwgZywgdSwgbiwgcCl9XG4gICAgICAke0lhKFxuICAgIHMsXG4gICAgdSxcbiAgICBfLFxuICAgIHQsXG4gICAgZSxcbiAgICBpLFxuICAgIG4sXG4gICAgbyxcbiAgICByLFxuICAgIGEsXG4gICAgcFxuICApfVxuICAgIGA7XG4gIHJldHVybiBuLmlubGluZSA/IChoLmFkZENsYXNzKG0sIHAuZGF0ZXBpY2tlckRyb3Bkb3duQ29udGFpbmVyKSwgbS5zZXRBdHRyaWJ1dGUoZ2YsIGwpLCBtLmlubmVySFRNTCA9IGIpIDogKGguYWRkQ2xhc3MobSwgcC5tb2RhbENvbnRhaW5lciksIG0uc2V0QXR0cmlidXRlKG1mLCBsKSwgbS5pbm5lckhUTUwgPSB2KSwgbTtcbn1cbmZ1bmN0aW9uIHhmKHMpIHtcbiAgY29uc3QgdCA9ICQoXCJkaXZcIik7XG4gIHJldHVybiBoLmFkZENsYXNzKHQsIHMpLCB0LnNldEF0dHJpYnV0ZShiZiwgXCJcIiksIHQ7XG59XG5mdW5jdGlvbiBPZihzLCB0LCBlLCBpLCBuKSB7XG4gIHJldHVybiBgXG4gICAgICA8ZGl2IGNsYXNzPVwiJHtuLmRhdGVwaWNrZXJIZWFkZXJ9XCIgZGF0YS10ZS1kYXRlcGlja2VyLWhlYWRlcj5cbiAgICAgICAgPGRpdiBjbGFzcz1cIiR7bi5kYXRlcGlja2VyVGl0bGV9XCI+XG4gICAgICAgICAgPHNwYW4gY2xhc3M9XCIke24uZGF0ZXBpY2tlclRpdGxlVGV4dH1cIj4ke2kudGl0bGV9PC9zcGFuPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cIiR7bi5kYXRlcGlja2VyRGF0ZX1cIj5cbiAgICAgICAgICA8c3BhbiBjbGFzcz1cIiR7bi5kYXRlcGlja2VyRGF0ZVRleHR9XCIgJHt2Zn0gPiR7aS53ZWVrZGF5c1Nob3J0W3RdfSwgJHtpLm1vbnRoc1Nob3J0W2VdfSAke3N9PC9zcGFuPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIGA7XG59XG5mdW5jdGlvbiBJYShzLCB0LCBlLCBpLCBuLCBvLCByLCBhLCBsLCBwLCB1KSB7XG4gIGxldCBfO1xuICByZXR1cm4gci5pbmxpbmUgPyBfID0gYFxuICAgIDxkaXYgY2xhc3M9XCIke3UuZGF0ZXBpY2tlck1haW59XCI+XG4gICAgICAkeyRhKHQsIGUsIHIsIHUpfVxuICAgICAgPGRpdiBjbGFzcz1cIiR7dS5kYXRlcGlja2VyVmlld31cIiAke1NhfSB0YWJpbmRleD1cIjBcIj5cbiAgICAgICAgJHtEYShcbiAgICBzLFxuICAgIGUsXG4gICAgaSxcbiAgICBuLFxuICAgIG8sXG4gICAgcixcbiAgICBhLFxuICAgIGwsXG4gICAgcCxcbiAgICB1XG4gICl9XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgYCA6IF8gPSBgXG4gICAgPGRpdiBjbGFzcz1cIiR7dS5kYXRlcGlja2VyTWFpbn1cIj5cbiAgICAgICR7JGEodCwgZSwgciwgdSl9XG4gICAgICA8ZGl2IGNsYXNzPVwiJHt1LmRhdGVwaWNrZXJWaWV3fVwiICR7U2F9IHRhYmluZGV4PVwiMFwiPlxuICAgICAgICAke0RhKFxuICAgIHMsXG4gICAgZSxcbiAgICBpLFxuICAgIG4sXG4gICAgbyxcbiAgICByLFxuICAgIGEsXG4gICAgbCxcbiAgICBwLFxuICAgIHVcbiAgKX1cbiAgICAgIDwvZGl2PlxuICAgICAgJHtTZihyLCB1KX1cbiAgICA8L2Rpdj5cbiAgYCwgXztcbn1cbmZ1bmN0aW9uIERhKHMsIHQsIGUsIGksIG4sIG8sIHIsIGEsIGwsIHApIHtcbiAgbGV0IHU7XG4gIHJldHVybiBvLnZpZXcgPT09IFwiZGF5c1wiID8gdSA9IEZzKHMsIGUsIG8sIHApIDogby52aWV3ID09PSBcIm1vbnRoc1wiID8gdSA9IFlzKFxuICAgIHQsXG4gICAgaSxcbiAgICBuLFxuICAgIG8sXG4gICAgcixcbiAgICBwXG4gICkgOiB1ID0ganMoXG4gICAgcyxcbiAgICBpLFxuICAgIG8sXG4gICAgYSxcbiAgICBsLFxuICAgIHBcbiAgKSwgdTtcbn1cbmZ1bmN0aW9uICRhKHMsIHQsIGUsIGkpIHtcbiAgcmV0dXJuIGBcbiAgICA8ZGl2IGNsYXNzPVwiJHtpLmRhdGVwaWNrZXJEYXRlQ29udHJvbHN9XCI+XG4gICAgICA8YnV0dG9uIGNsYXNzPVwiJHtpLmRhdGVwaWNrZXJWaWV3Q2hhbmdlQnV0dG9ufVwiIGFyaWEtbGFiZWw9XCIke2Uuc3dpdGNoVG9NdWx0aVllYXJWaWV3TGFiZWx9XCIgJHt3Zn0+XG4gICAgICAgICR7ZS5tb250aHNGdWxsW3NdfSAke3R9ICR7JHQoXG4gICAgZSxcbiAgICBpXG4gICl9XG4gICAgICA8L2J1dHRvbj5cbiAgICAgIDxkaXYgY2xhc3M9XCIke2kuZGF0ZXBpY2tlckFycm93Q29udHJvbHN9XCI+XG4gICAgICAgIDxidXR0b24gY2xhc3M9XCIke2kuZGF0ZXBpY2tlclByZXZpb3VzQnV0dG9ufVwiIGFyaWEtbGFiZWw9XCIke2UucHJldk1vbnRoTGFiZWx9XCIgJHtUZn0+JHtlLmNoYW5nZU1vbnRoSWNvblRlbXBsYXRlfTwvYnV0dG9uPlxuICAgICAgICA8YnV0dG9uIGNsYXNzPVwiJHtpLmRhdGVwaWNrZXJOZXh0QnV0dG9ufVwiIGFyaWEtbGFiZWw9XCIke2UubmV4dE1vbnRoTGFiZWx9XCIgJHtFZn0+JHtlLmNoYW5nZU1vbnRoSWNvblRlbXBsYXRlfTwvYnV0dG9uPlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICAgYDtcbn1cbmZ1bmN0aW9uICR0KHMsIHQpIHtcbiAgcmV0dXJuIGBcbiAgPHNwYW4gY2xhc3M9XCIke3QuZGF0ZXBpY2tlclZpZXdDaGFuZ2VJY29ufVwiPlxuICAke3Mudmlld0NoYW5nZUljb25UZW1wbGF0ZX1cbiAgPC9zcGFuPlxuICBgO1xufVxuZnVuY3Rpb24gU2YocywgdCkge1xuICBjb25zdCBlID0gYDxidXR0b24gY2xhc3M9XCIke3QuZGF0ZXBpY2tlckZvb3RlckJ0bn1cIiBhcmlhLWxhYmVsPVwiJHtzLm9rQnRuTGFiZWx9XCIgJHtDZn0+JHtzLm9rQnRuVGV4dH08L2J1dHRvbj5gLCBpID0gYDxidXR0b24gY2xhc3M9XCIke3QuZGF0ZXBpY2tlckZvb3RlckJ0bn1cIiBhcmlhLWxhYmVsPVwiJHtzLmNhbmNlbEJ0bkxhYmVsfVwiICR7QWZ9PiR7cy5jYW5jZWxCdG5UZXh0fTwvYnV0dG9uPmAsIG4gPSBgPGJ1dHRvbiBjbGFzcz1cIiR7dC5kYXRlcGlja2VyRm9vdGVyQnRufSAke3QuZGF0ZXBpY2tlckNsZWFyQnRufVwiIGFyaWEtbGFiZWw9XCIke3MuY2xlYXJCdG5MYWJlbH1cIiAke3lmfT4ke3MuY2xlYXJCdG5UZXh0fTwvYnV0dG9uPmA7XG4gIHJldHVybiBgXG4gICAgICAgIDxkaXYgY2xhc3M9XCIke3QuZGF0ZXBpY2tlckZvb3Rlcn1cIj5cbiAgICAgICAgICBcbiAgICAgICAgJHtzLnJlbW92ZUNsZWFyQnRuID8gXCJcIiA6IG59XG4gICAgICAgICR7cy5yZW1vdmVDYW5jZWxCdG4gPyBcIlwiIDogaX1cbiAgICAgICAgJHtzLnJlbW92ZU9rQnRuID8gXCJcIiA6IGV9XG4gICAgICAgIDwvZGl2PlxuICAgICAgYDtcbn1cbmZ1bmN0aW9uIEZzKHMsIHQsIGUsIGkpIHtcbiAgY29uc3QgbiA9IElmKHMsIHQsIGUpLCByID0gYFxuICAgICAgPHRyPlxuICAgICAgICAke2Uud2Vla2RheXNOYXJyb3cubWFwKChsLCBwKSA9PiBgPHRoIGNsYXNzPVwiJHtpLmRhdGVwaWNrZXJEYXlIZWFkaW5nfVwiIHNjb3BlPVwiY29sXCIgYXJpYS1sYWJlbD1cIiR7ZS53ZWVrZGF5c0Z1bGxbcF19XCI+JHtsfTwvdGg+YCkuam9pbihcIlwiKX1cbiAgICAgIDwvdHI+XG4gICAgYCwgYSA9IG4ubWFwKChsKSA9PiBgXG4gICAgICAgIDx0cj5cbiAgICAgICAgICAke2wubWFwKChwKSA9PiBgXG4gICAgICAgICAgICAgIDx0ZFxuICAgICAgICAgICAgICBjbGFzcz1cIiR7aS5kYXRlcGlja2VyQ2VsbH0gJHtpLmRhdGVwaWNrZXJDZWxsU21hbGx9XCJcbiAgICAgICAgICAgICAgZGF0YS10ZS1kYXRlPVwiJHtCKHAuZGF0ZSl9LSR7WShcbiAgICBwLmRhdGVcbiAgKX0tJHtaKHAuZGF0ZSl9XCJcbiAgICAgICAgICAgICAgYXJpYS1sYWJlbD1cIiR7cC5kYXRlfVwiXG4gICAgICAgICAgICAgIGFyaWEtc2VsZWN0ZWQ9XCIke3AuaXNTZWxlY3RlZH1cIlxuICAgICAgICAgICAgICAke3AuaXNTZWxlY3RlZCA/IFwiZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtc2VsZWN0ZWRcIiA6IFwiXCJ9XG4gICAgICAgICAgICAgICR7IXAuY3VycmVudE1vbnRoIHx8IHAuZGlzYWJsZWQgPyBcImRhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLWRpc2FibGVkXCIgOiBcIlwifVxuICAgICAgICAgICAgICAke3AuaXNUb2RheSA/IFwiZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtY3VycmVudFwiIDogXCJcIn1cbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICAgIGNsYXNzPVwiJHtpLmRhdGVwaWNrZXJDZWxsQ29udGVudH0gJHtpLmRhdGVwaWNrZXJDZWxsQ29udGVudFNtYWxsfVwiXG4gICAgICAgICAgICAgICAgICBzdHlsZT1cIiR7cC5jdXJyZW50TW9udGggPyBcImRpc3BsYXk6IGJsb2NrXCIgOiBcImRpc3BsYXk6IG5vbmVcIn1cIlxuICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgJHtwLmRheU51bWJlcn1cbiAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgYCkuam9pbihcIlwiKX1cbiAgICAgICAgPC90cj5cbiAgICAgIGApLmpvaW4oXCJcIik7XG4gIHJldHVybiBgXG4gICAgICA8dGFibGUgY2xhc3M9XCIke2kuZGF0ZXBpY2tlclRhYmxlfVwiPlxuICAgICAgICA8dGhlYWQ+XG4gICAgICAgICAgJHtyfVxuICAgICAgICA8L3RoZWFkPlxuICAgICAgICA8dGJvZHk+XG4gICAgICAgICAke2F9XG4gICAgICAgIDwvdGJvZHk+XG4gICAgICA8L3RhYmxlPlxuICAgIGA7XG59XG5mdW5jdGlvbiBJZihzLCB0LCBlKSB7XG4gIGNvbnN0IGkgPSBbXSwgbiA9IFkocyksIG8gPSBZKG50KHMsIC0xKSksIHIgPSBZKG50KHMsIDEpKSwgYSA9IEIocyksIGwgPSBjZihhLCBuLCBlKSwgcCA9IFBvKHMpLCB1ID0gUG8obnQocywgLTEpKSwgXyA9IDc7XG4gIGxldCBmID0gMSwgZyA9ICExO1xuICBmb3IgKGxldCBtID0gMTsgbSA8IF87IG0rKykge1xuICAgIGNvbnN0IGIgPSBbXTtcbiAgICBpZiAobSA9PT0gMSkge1xuICAgICAgY29uc3QgdiA9IHUgLSBsICsgMTtcbiAgICAgIGZvciAobGV0IHcgPSB2OyB3IDw9IHU7IHcrKykge1xuICAgICAgICBjb25zdCBFID0gRXQoYSwgbywgdyk7XG4gICAgICAgIGIucHVzaCh7XG4gICAgICAgICAgZGF0ZTogRSxcbiAgICAgICAgICBjdXJyZW50TW9udGg6IGcsXG4gICAgICAgICAgaXNTZWxlY3RlZDogdCAmJiBmZShFLCB0KSxcbiAgICAgICAgICBpc1RvZGF5OiBmZShFLCBCZSgpKSxcbiAgICAgICAgICBkYXlOdW1iZXI6IFooRSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBnID0gITA7XG4gICAgICBjb25zdCBDID0gXyAtIGIubGVuZ3RoO1xuICAgICAgZm9yIChsZXQgdyA9IDA7IHcgPCBDOyB3KyspIHtcbiAgICAgICAgY29uc3QgRSA9IEV0KGEsIG4sIGYpO1xuICAgICAgICBiLnB1c2goe1xuICAgICAgICAgIGRhdGU6IEUsXG4gICAgICAgICAgY3VycmVudE1vbnRoOiBnLFxuICAgICAgICAgIGlzU2VsZWN0ZWQ6IHQgJiYgZmUoRSwgdCksXG4gICAgICAgICAgaXNUb2RheTogZmUoRSwgQmUoKSksXG4gICAgICAgICAgZGF5TnVtYmVyOiBaKEUpLFxuICAgICAgICAgIGRpc2FibGVkOiBubihcbiAgICAgICAgICAgIEUsXG4gICAgICAgICAgICBlLm1pbixcbiAgICAgICAgICAgIGUubWF4LFxuICAgICAgICAgICAgZS5maWx0ZXIsXG4gICAgICAgICAgICBlLmRpc2FibGVQYXN0LFxuICAgICAgICAgICAgZS5kaXNhYmxlRnV0dXJlXG4gICAgICAgICAgKVxuICAgICAgICB9KSwgZisrO1xuICAgICAgfVxuICAgIH0gZWxzZVxuICAgICAgZm9yIChsZXQgdiA9IDE7IHYgPCA4OyB2KyspIHtcbiAgICAgICAgZiA+IHAgJiYgKGYgPSAxLCBnID0gITEpO1xuICAgICAgICBjb25zdCBDID0gRXQoXG4gICAgICAgICAgYSxcbiAgICAgICAgICBnID8gbiA6IHIsXG4gICAgICAgICAgZlxuICAgICAgICApO1xuICAgICAgICBiLnB1c2goe1xuICAgICAgICAgIGRhdGU6IEMsXG4gICAgICAgICAgY3VycmVudE1vbnRoOiBnLFxuICAgICAgICAgIGlzU2VsZWN0ZWQ6IHQgJiYgZmUoQywgdCksXG4gICAgICAgICAgaXNUb2RheTogZmUoQywgQmUoKSksXG4gICAgICAgICAgZGF5TnVtYmVyOiBaKEMpLFxuICAgICAgICAgIGRpc2FibGVkOiBubihcbiAgICAgICAgICAgIEMsXG4gICAgICAgICAgICBlLm1pbixcbiAgICAgICAgICAgIGUubWF4LFxuICAgICAgICAgICAgZS5maWx0ZXIsXG4gICAgICAgICAgICBlLmRpc2FibGVQYXN0LFxuICAgICAgICAgICAgZS5kaXNhYmxlRnV0dXJlXG4gICAgICAgICAgKVxuICAgICAgICB9KSwgZisrO1xuICAgICAgfVxuICAgIGkucHVzaChiKTtcbiAgfVxuICByZXR1cm4gaTtcbn1cbmZ1bmN0aW9uIFlzKHMsIHQsIGUsIGksIG4sIG8pIHtcbiAgY29uc3QgciA9IERmKGksIG4pLCBhID0gWShCZSgpKSwgbCA9IEIoQmUoKSksIHAgPSBgXG4gICAgICAke3IubWFwKCh1KSA9PiBgXG4gICAgICAgICAgPHRyPlxuICAgICAgICAgICAgJHt1Lm1hcCgoXykgPT4ge1xuICAgIGNvbnN0IGYgPSBpLm1vbnRoc1Nob3J0LmluZGV4T2YoXyk7XG4gICAgcmV0dXJuIGBcbiAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XCIke28uZGF0ZXBpY2tlckNlbGx9ICR7by5kYXRlcGlja2VyQ2VsbExhcmdlfVwiXG4gICAgICAgICAgICAgICAgJHt6YyhcbiAgICAgIGYsXG4gICAgICBzLFxuICAgICAgaS5taW4sXG4gICAgICBpLm1heCxcbiAgICAgIGkuZGlzYWJsZVBhc3QsXG4gICAgICBpLmRpc2FibGVGdXR1cmVcbiAgICApID8gXCJkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1kaXNhYmxlZFwiIDogXCJcIn1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBkYXRhLXRlLW1vbnRoPVwiJHtmfVwiIGRhdGEtdGUteWVhcj1cIiR7c31cIiBhcmlhLWxhYmVsPVwiJHtffSwgJHtzfVwiXG4gICAgICAgICAgICAgICAgJHtmID09PSBlICYmIHMgPT09IHQgPyBcImRhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLXNlbGVjdGVkXCIgOiBcIlwifVxuICAgICAgICAgICAgICAgICR7ZiA9PT0gYSAmJiBzID09PSBsID8gXCJkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1jdXJyZW50XCIgOiBcIlwifVwiIGRhdGEtdGUtbW9udGg9XCIke2Z9XCIgZGF0YS10ZS15ZWFyPVwiJHtzfVwiIGFyaWEtbGFiZWw9XCIke199LCAke3N9XCI+XG4gICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiJHtvLmRhdGVwaWNrZXJDZWxsQ29udGVudH0gJHtvLmRhdGVwaWNrZXJDZWxsQ29udGVudExhcmdlfVwiPiR7X308L2Rpdj5cbiAgICAgICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgICBgO1xuICB9KS5qb2luKFwiXCIpfVxuICAgICAgICAgIDwvdHI+XG4gICAgICAgIGApLmpvaW4oXCJcIil9XG4gICAgYDtcbiAgcmV0dXJuIGBcbiAgICAgIDx0YWJsZSBjbGFzcz1cIiR7by5kYXRlcGlja2VyVGFibGV9XCI+XG4gICAgICAgIDx0Ym9keT5cbiAgICAgICAgICR7cH1cbiAgICAgICAgPC90Ym9keT5cbiAgICAgIDwvdGFibGU+XG4gICAgYDtcbn1cbmZ1bmN0aW9uIERmKHMsIHQpIHtcbiAgY29uc3QgZSA9IFtdO1xuICBsZXQgaSA9IFtdO1xuICBmb3IgKGxldCBuID0gMDsgbiA8IHMubW9udGhzU2hvcnQubGVuZ3RoOyBuKyspXG4gICAgaWYgKGkucHVzaChzLm1vbnRoc1Nob3J0W25dKSwgaS5sZW5ndGggPT09IHQpIHtcbiAgICAgIGNvbnN0IG8gPSBpO1xuICAgICAgZS5wdXNoKG8pLCBpID0gW107XG4gICAgfVxuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIGpzKHMsIHQsIGUsIGksIG4sIG8pIHtcbiAgY29uc3QgciA9ICRmKHMsIGksIG4pLCBhID0gQihCZSgpKSwgbCA9IGBcbiAgICAke3IubWFwKChwKSA9PiBgXG4gICAgICAgIDx0cj5cbiAgICAgICAgICAke3AubWFwKCh1KSA9PiBgXG4gICAgICAgICAgICAgIDx0ZCBjbGFzcz1cIiR7by5kYXRlcGlja2VyQ2VsbH0gJHtvLmRhdGVwaWNrZXJDZWxsTGFyZ2V9XCIgIGFyaWEtbGFiZWw9XCIke3V9XCIgZGF0YS10ZS15ZWFyPVwiJHt1fVwiXG4gICAgICAgICAgICAgICR7Qm8oXG4gICAgdSxcbiAgICBlLm1pbixcbiAgICBlLm1heCxcbiAgICBlLmRpc2FibGVQYXN0LFxuICAgIGUuZGlzYWJsZUZ1dHVyZVxuICApID8gXCJkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1kaXNhYmxlZFwiIDogXCJcIn1cbiAgICAgICAgICAgICAgJHt1ID09PSB0ID8gXCJkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1zZWxlY3RlZFwiIDogXCJcIn1cbiAgICAgICAgICAgICAgJHt1ID09PSBhID8gXCJkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1jdXJyZW50XCIgOiBcIlwifVxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIiR7by5kYXRlcGlja2VyQ2VsbENvbnRlbnR9ICR7by5kYXRlcGlja2VyQ2VsbENvbnRlbnRMYXJnZX1cIj4ke3V9PC9kaXY+XG4gICAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICBgKS5qb2luKFwiXCIpfVxuICAgICAgICA8L3RyPlxuICAgICAgYCkuam9pbihcIlwiKX1cbiAgYDtcbiAgcmV0dXJuIGBcbiAgICAgIDx0YWJsZSBjbGFzcz1cIiR7by5kYXRlcGlja2VyVGFibGV9XCI+XG4gICAgICAgIDx0Ym9keT5cbiAgICAgICAgJHtsfVxuICAgICAgICA8L3Rib2R5PlxuICAgICAgPC90YWJsZT5cbiAgICBgO1xufVxuZnVuY3Rpb24gJGYocywgdCwgZSkge1xuICBjb25zdCBpID0gW10sIG4gPSBCKHMpLCBvID0gV3MocywgdCksIHIgPSBuIC0gbztcbiAgbGV0IGEgPSBbXTtcbiAgZm9yIChsZXQgbCA9IDA7IGwgPCB0OyBsKyspXG4gICAgaWYgKGEucHVzaChyICsgbCksIGEubGVuZ3RoID09PSBlKSB7XG4gICAgICBjb25zdCBwID0gYTtcbiAgICAgIGkucHVzaChwKSwgYSA9IFtdO1xuICAgIH1cbiAgcmV0dXJuIGk7XG59XG5mdW5jdGlvbiBMZihzLCB0KSB7XG4gIHJldHVybiBgXG4gICAgPGJ1dHRvbiBpZD1cIiR7c31cIiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCIke3R9XCIgZGF0YS10ZS1kYXRlcGlja2VyLXRvZ2dsZS1idXR0b24tcmVmIGRhdGEtdGUtZGF0ZXBpY2tlci10b2dnbGUtcmVmPlxuICAgICAgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIGZpbGw9XCJjdXJyZW50Q29sb3JcIj5cbiAgICAgIDxwYXRoIGZpbGwtcnVsZT1cImV2ZW5vZGRcIiBkPVwiTTYuNzUgMi4yNUEuNzUuNzUgMCAwMTcuNSAzdjEuNWg5VjNBLjc1Ljc1IDAgMDExOCAzdjEuNWguNzVhMyAzIDAgMDEzIDN2MTEuMjVhMyAzIDAgMDEtMyAzSDUuMjVhMyAzIDAgMDEtMy0zVjcuNWEzIDMgMCAwMTMtM0g2VjNhLjc1Ljc1IDAgMDEuNzUtLjc1em0xMy41IDlhMS41IDEuNSAwIDAwLTEuNS0xLjVINS4yNWExLjUgMS41IDAgMDAtMS41IDEuNXY3LjVhMS41IDEuNSAwIDAwMS41IDEuNWgxMy41YTEuNSAxLjUgMCAwMDEuNS0xLjV2LTcuNXpcIiBjbGlwLXJ1bGU9XCJldmVub2RkXCIgLz5cbiAgICAgIDwvc3ZnPiAgXG4gICAgPC9idXR0b24+XG4gIGA7XG59XG5jb25zdCBIZSA9IDM3LCBhdCA9IDM4LCBWZSA9IDM5LCB6ID0gNDAsIFdlID0gMzYsIEZlID0gMzUsIHpuID0gMzMsIFVuID0gMzQsIGN0ID0gMTMsIEtzID0gMzIsIEZpID0gMjcsIFBpID0gOSwgTmYgPSA4LCBNZiA9IDQ2LCB2dCA9IDI0LCBscyA9IDQsIGNzID0gNCwgWG4gPSBcImRhdGVwaWNrZXJcIiwgenMgPSBcInRlLmRhdGVwaWNrZXJcIiwgZG4gPSBgLiR7enN9YCwgUmYgPSBcIi5kYXRhLWFwaVwiLCBQZiA9IGBjbG9zZSR7ZG59YCwgQmYgPSBgb3BlbiR7ZG59YCwgSGYgPSBgZGF0ZUNoYW5nZSR7ZG59YCwgaHMgPSBgY2xpY2ske2RufSR7UmZ9YCwgVWMgPSBcImRhdGEtdGUtZGF0ZXBpY2tlci1tb2RhbC1jb250YWluZXItcmVmXCIsIFhjID0gXCJkYXRhLXRlLWRhdGVwaWNrZXItZHJvcGRvd24tY29udGFpbmVyLXJlZlwiLCBkcyA9IFwiW2RhdGEtdGUtZGF0ZXBpY2tlci10b2dnbGUtcmVmXVwiLCBWZiA9IGBbJHtVY31dYCwgV2YgPSBgWyR7WGN9XWAsIEZmID0gXCJbZGF0YS10ZS1kYXRlcGlja2VyLXZpZXctY2hhbmdlLWJ1dHRvbi1yZWZdXCIsIFlmID0gXCJbZGF0YS10ZS1kYXRlcGlja2VyLXByZXZpb3VzLWJ1dHRvbi1yZWZdXCIsIGpmID0gXCJbZGF0YS10ZS1kYXRlcGlja2VyLW5leHQtYnV0dG9uLXJlZl1cIiwgS2YgPSBcIltkYXRhLXRlLWRhdGVwaWNrZXItb2stYnV0dG9uLXJlZl1cIiwgemYgPSBcIltkYXRhLXRlLWRhdGVwaWNrZXItY2FuY2VsLWJ1dHRvbi1yZWZdXCIsIFVmID0gXCJbZGF0YS10ZS1kYXRlcGlja2VyLWNsZWFyLWJ1dHRvbi1yZWZdXCIsIFhmID0gXCJbZGF0YS10ZS1kYXRlcGlja2VyLXZpZXctcmVmXVwiLCBHZiA9IFwiW2RhdGEtdGUtZGF0ZXBpY2tlci10b2dnbGUtYnV0dG9uLXJlZl1cIiwgcWYgPSBcIltkYXRhLXRlLWRhdGVwaWNrZXItZGF0ZS10ZXh0LXJlZl1cIiwgWmYgPSBcIltkYXRhLXRlLWRyb3Bkb3duLWJhY2tkcm9wLXJlZl1cIiwgUWYgPSBcImFuaW1hdGUtW2ZhZGUtaW5fMC4zc19ib3RoXSBweC1bYXV0b10gbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmUgbW90aW9uLXJlZHVjZTphbmltYXRlLW5vbmVcIiwgSmYgPSBcImFuaW1hdGUtW2ZhZGUtb3V0XzAuM3NfYm90aF0gcHgtW2F1dG9dIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIG1vdGlvbi1yZWR1Y2U6YW5pbWF0ZS1ub25lXCIsIHRtID0gXCJhbmltYXRlLVtmYWRlLWluXzAuMTVzX2JvdGhdIHB4LVthdXRvXSBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBtb3Rpb24tcmVkdWNlOmFuaW1hdGUtbm9uZVwiLCBlbSA9IFwiYW5pbWF0ZS1bZmFkZS1vdXRfMC4xNXNfYm90aF0gcHgtW2F1dG9dIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIG1vdGlvbi1yZWR1Y2U6YW5pbWF0ZS1ub25lXCIsIGltID0gXCJmbGV4IGZsZXgtY29sIGZpeGVkIHRvcC0xLzIgbGVmdC0xLzIgLXRyYW5zbGF0ZS14LTEvMiAtdHJhbnNsYXRlLXktMS8yIHctWzMyOHB4XSBoLVs1MTJweF0gYmctd2hpdGUgcm91bmRlZC1bMC42cmVtXSBzaGFkb3ctbGcgei1bMTA2Nl0geHM6bWF4LW1kOmxhbmRzY2FwZTp3LVs0NzVweF0geHM6bWF4LW1kOmxhbmRzY2FwZTpoLVszNjBweF0geHM6bWF4LW1kOmxhbmRzY2FwZTpmbGV4LXJvdyBkYXJrOmJnLXppbmMtNzAwXCIsIHNtID0gXCJ3LWZ1bGwgaC1mdWxsIGZpeGVkIHRvcC0wIHJpZ2h0LTAgbGVmdC0wIGJvdHRvbS0wIGJnLWJsYWNrLzQwIHotWzEwNjVdXCIsIG5tID0gXCJyZWxhdGl2ZSBoLWZ1bGxcIiwgb20gPSBcInhzOm1heC1tZDpsYW5kc2NhcGU6aC1mdWxsIGgtWzEyMHB4XSBweC02IGJnLXByaW1hcnkgZmxleCBmbGV4LWNvbCByb3VuZGVkLXQtbGcgZGFyazpiZy16aW5jLTgwMFwiLCBybSA9IFwiaC04IGZsZXggZmxleC1jb2wganVzdGlmeS1lbmRcIiwgYW0gPSBcInRleHQtWzEwcHhdIGZvbnQtbm9ybWFsIHVwcGVyY2FzZSB0cmFja2luZy1bMS43cHhdIHRleHQtd2hpdGVcIiwgbG0gPSBcInhzOm1heC1tZDpsYW5kc2NhcGU6bXQtMjQgaC1bNzJweF0gZmxleCBmbGV4LWNvbCBqdXN0aWZ5LWVuZFwiLCBjbSA9IFwidGV4dC1bMzRweF0gZm9udC1ub3JtYWwgdGV4dC13aGl0ZVwiLCBobSA9IFwib3V0bGluZS1ub25lIHB4LTNcIiwgZG0gPSBcInB4LTMgcHQtMi41IHBiLTAgZmxleCBqdXN0aWZ5LWJldHdlZW4gdGV4dC1ibGFjay9bNjRdXCIsIHVtID0gXCJmbGV4IGl0ZW1zLWNlbnRlciBvdXRsaW5lLW5vbmUgcC0yLjUgdGV4dC1uZXV0cmFsLTUwMCBmb250LW1lZGl1bSB0ZXh0LVswLjlyZW1dIHJvdW5kZWQteGwgc2hhZG93LW5vbmUgYmctdHJhbnNwYXJlbnQgbS0wIGJvcmRlci1ub25lIGhvdmVyOmJnLW5ldXRyYWwtMjAwIGZvY3VzOmJnLW5ldXRyYWwtMjAwICBkYXJrOnRleHQtd2hpdGUgZGFyazpob3ZlcjpiZy13aGl0ZS8xMCBkYXJrOmZvY3VzOmJnLXdoaXRlLzEwXCIsIHBtID0gXCJtdC0yLjVcIiwgX20gPSBcInAtMCB3LTEwIGgtMTAgbGVhZGluZy0xMCBib3JkZXItbm9uZSBvdXRsaW5lLW5vbmUgbS0wIHRleHQtZ3JheS02MDAgYmctdHJhbnNwYXJlbnQgbXItNiBob3ZlcjpiZy1uZXV0cmFsLTIwMCBob3Zlcjpyb3VuZGVkLVs1MCVdIGZvY3VzOmJnLW5ldXRyYWwtMjAwIGZvY3VzOnJvdW5kZWQtWzUwJV0gZGFyazp0ZXh0LXdoaXRlIGRhcms6aG92ZXI6Ymctd2hpdGUvMTAgZGFyazpmb2N1czpiZy13aGl0ZS8xMCBbJj5zdmddOnctNCBbJj5zdmddOmgtNCBbJj5zdmddOm14LWF1dG9cIiwgZm0gPSBcInAtMCB3LTEwIGgtMTAgbGVhZGluZy0xMCBib3JkZXItbm9uZSBvdXRsaW5lLW5vbmUgbS0wIHRleHQtZ3JheS02MDAgYmctdHJhbnNwYXJlbnQgaG92ZXI6YmctbmV1dHJhbC0yMDAgaG92ZXI6cm91bmRlZC1bNTAlXSBmb2N1czpiZy1uZXV0cmFsLTIwMCBmb2N1czpyb3VuZGVkLVs1MCVdIGRhcms6dGV4dC13aGl0ZSBkYXJrOmhvdmVyOmJnLXdoaXRlLzEwIGRhcms6Zm9jdXM6Ymctd2hpdGUvMTAgWyY+c3ZnXTp3LTQgWyY+c3ZnXTpoLTQgWyY+c3ZnXTpyb3RhdGUtMTgwIFsmPnN2Z106bXgtYXV0b1wiLCBtbSA9IFwiaC0xNCBmbGV4IGFic29sdXRlIHctZnVsbCBib3R0b20tMCBqdXN0aWZ5LWVuZCBpdGVtcy1jZW50ZXIgcHgtM1wiLCBnbSA9IFwib3V0bGluZS1ub25lIGJnLXdoaXRlIHRleHQtcHJpbWFyeSBib3JkZXItbm9uZSBjdXJzb3ItcG9pbnRlciBweS0wIHB4LTIuNSB1cHBlcmNhc2UgdGV4dC1bMC44cmVtXSBsZWFkaW5nLTEwIGZvbnQtbWVkaXVtIGgtMTAgdHJhY2tpbmctWy4xcmVtXSByb3VuZGVkLVsxMHB4XSBtYi0yLjUgaG92ZXI6YmctbmV1dHJhbC0yMDAgZm9jdXM6YmctbmV1dHJhbC0yMDAgZGFyazpiZy10cmFuc3BhcmVudCBkYXJrOnRleHQtd2hpdGUgZGFyazpob3ZlcjpiZy13aGl0ZS8xMCBkYXJrOmZvY3VzOmJnLXdoaXRlLzEwXCIsIGJtID0gXCJtci1hdXRvXCIsIHZtID0gXCJ3LTEwIGgtMTAgdGV4dC1jZW50ZXIgdGV4dC1bMTJweF0gZm9udC1ub3JtYWwgZGFyazp0ZXh0LXdoaXRlXCIsIFRtID0gXCJ0ZXh0LWNlbnRlciBkYXRhLVt0ZS1kYXRlcGlja2VyLWNlbGwtZGlzYWJsZWRdOnRleHQtbmV1dHJhbC0zMDAgZGF0YS1bdGUtZGF0ZXBpY2tlci1jZWxsLWRpc2FibGVkXTpjdXJzb3ItZGVmYXVsdCBkYXRhLVt0ZS1kYXRlcGlja2VyLWNlbGwtZGlzYWJsZWRdOnBvaW50ZXItZXZlbnRzLW5vbmUgZGF0YS1bdGUtZGF0ZXBpY2tlci1jZWxsLWRpc2FibGVkXTpob3ZlcjpjdXJzb3ItZGVmYXVsdCBob3ZlcjpjdXJzb3ItcG9pbnRlciBncm91cFwiLCBFbSA9IFwidy0xMCBoLTEwIHhzOm1heC1tZDpsYW5kc2NhcGU6dy04IHhzOm1heC1tZDpsYW5kc2NhcGU6aC04XCIsIENtID0gXCJ3LVs3NnB4XSBoLVs0MnB4XVwiLCBBbSA9IFwibXgtYXV0byBncm91cC1bOm5vdChbZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtZGlzYWJsZWRdKTpub3QoW2RhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLXNlbGVjdGVkXSk6aG92ZXJdOmJnLW5ldXRyYWwtMzAwIGdyb3VwLVtbZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtc2VsZWN0ZWRdXTpiZy1wcmltYXJ5IGdyb3VwLVtbZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtc2VsZWN0ZWRdXTp0ZXh0LXdoaXRlIGdyb3VwLVs6bm90KFtkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1zZWxlY3RlZF0pW2RhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLWZvY3VzZWRdXTpiZy1uZXV0cmFsLTEwMCBncm91cC1bW2RhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLWZvY3VzZWRdXTpkYXRhLVt0ZS1kYXRlcGlja2VyLWNlbGwtc2VsZWN0ZWRdOmJnLXByaW1hcnkgZ3JvdXAtW1tkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1jdXJyZW50XV06Ym9yZGVyLXNvbGlkIGdyb3VwLVtbZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtY3VycmVudF1dOmJvcmRlci1ibGFjayBncm91cC1bW2RhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLWN1cnJlbnRdXTpib3JkZXIgZGFyazpncm91cC1bOm5vdChbZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtZGlzYWJsZWRdKTpub3QoW2RhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLXNlbGVjdGVkXSk6aG92ZXJdOmJnLXdoaXRlLzEwIGRhcms6Z3JvdXAtW1tkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1jdXJyZW50XV06Ym9yZGVyLXdoaXRlIGRhcms6dGV4dC13aGl0ZSBkYXJrOmdyb3VwLVs6bm90KFtkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1zZWxlY3RlZF0pW2RhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLWZvY3VzZWRdXTpiZy13aGl0ZS8xMCBkYXJrOmdyb3VwLVtbZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtZGlzYWJsZWRdXTp0ZXh0LW5ldXRyYWwtNTAwXCIsIHltID0gXCJ3LTkgaC05IGxlYWRpbmctOSByb3VuZGVkLVs1MCVdIHRleHQtWzEzcHhdXCIsIHdtID0gXCJ3LVs3MnB4XSBoLTEwIGxlYWRpbmctMTAgcHktWzFweF0gcHgtMC41IHJvdW5kZWQtWzk5OXB4XVwiLCBrbSA9IFwibXgtYXV0byB3LVszMDRweF1cIiwgeG0gPSBcImZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY29udGVudC1jZW50ZXIgWyY+c3ZnXTp3LTUgWyY+c3ZnXTpoLTUgYWJzb2x1dGUgb3V0bGluZS1ub25lIGJvcmRlci1ub25lIGJnLXRyYW5zcGFyZW50IHJpZ2h0LTAuNSB0b3AtMS8yIC10cmFuc2xhdGUteC0xLzIgLXRyYW5zbGF0ZS15LTEvMiBob3Zlcjp0ZXh0LXByaW1hcnkgZm9jdXM6dGV4dC1wcmltYXJ5IGRhcms6aG92ZXI6dGV4dC1wcmltYXJ5LTQwMCBkYXJrOmZvY3VzOnRleHQtcHJpbWFyeS00MDAgZGFyazp0ZXh0LW5ldXRyYWwtMjAwXCIsIE9tID0gXCJpbmxpbmUtYmxvY2sgcG9pbnRlci1ldmVudHMtbm9uZSBtbC1bM3B4XSBbJj5zdmddOnctNCBbJj5zdmddOmgtNCBbJj5zdmddOmZpbGwtbmV1dHJhbC01MDAgZGFyazpbJj5zdmddOmZpbGwtd2hpdGVcIiwgU20gPSBcInctWzMyOHB4XSBoLVszODBweF0gYmctd2hpdGUgcm91bmRlZC1sZyBzaGFkb3ctWzBweF8ycHhfMTVweF8tM3B4X3JnYmEoMCwwLDAsLjA3KSxfMHB4XzEwcHhfMjBweF8tMnB4X3JnYmEoMCwwLDAsLjA0KV0gei1bMTA2Nl0gZGFyazpiZy16aW5jLTcwMFwiLCBJbSA9IHtcbiAgdGl0bGU6IFwiU2VsZWN0IGRhdGVcIixcbiAgY29udGFpbmVyOiBcImJvZHlcIixcbiAgZGlzYWJsZVBhc3Q6ICExLFxuICBkaXNhYmxlRnV0dXJlOiAhMSxcbiAgbW9udGhzRnVsbDogW1xuICAgIFwiSmFudWFyeVwiLFxuICAgIFwiRmVicnVhcnlcIixcbiAgICBcIk1hcmNoXCIsXG4gICAgXCJBcHJpbFwiLFxuICAgIFwiTWF5XCIsXG4gICAgXCJKdW5lXCIsXG4gICAgXCJKdWx5XCIsXG4gICAgXCJBdWd1c3RcIixcbiAgICBcIlNlcHRlbWJlclwiLFxuICAgIFwiT2N0b2JlclwiLFxuICAgIFwiTm92ZW1iZXJcIixcbiAgICBcIkRlY2VtYmVyXCJcbiAgXSxcbiAgbW9udGhzU2hvcnQ6IFtcbiAgICBcIkphblwiLFxuICAgIFwiRmViXCIsXG4gICAgXCJNYXJcIixcbiAgICBcIkFwclwiLFxuICAgIFwiTWF5XCIsXG4gICAgXCJKdW5cIixcbiAgICBcIkp1bFwiLFxuICAgIFwiQXVnXCIsXG4gICAgXCJTZXBcIixcbiAgICBcIk9jdFwiLFxuICAgIFwiTm92XCIsXG4gICAgXCJEZWNcIlxuICBdLFxuICB3ZWVrZGF5c0Z1bGw6IFtcbiAgICBcIlN1bmRheVwiLFxuICAgIFwiTW9uZGF5XCIsXG4gICAgXCJUdWVzZGF5XCIsXG4gICAgXCJXZWRuZXNkYXlcIixcbiAgICBcIlRodXJzZGF5XCIsXG4gICAgXCJGcmlkYXlcIixcbiAgICBcIlNhdHVyZGF5XCJcbiAgXSxcbiAgd2Vla2RheXNTaG9ydDogW1wiU3VuXCIsIFwiTW9uXCIsIFwiVHVlXCIsIFwiV2VkXCIsIFwiVGh1XCIsIFwiRnJpXCIsIFwiU2F0XCJdLFxuICB3ZWVrZGF5c05hcnJvdzogW1wiU1wiLCBcIk1cIiwgXCJUXCIsIFwiV1wiLCBcIlRcIiwgXCJGXCIsIFwiU1wiXSxcbiAgb2tCdG5UZXh0OiBcIk9rXCIsXG4gIGNsZWFyQnRuVGV4dDogXCJDbGVhclwiLFxuICBjYW5jZWxCdG5UZXh0OiBcIkNhbmNlbFwiLFxuICBva0J0bkxhYmVsOiBcIkNvbmZpcm0gc2VsZWN0aW9uXCIsXG4gIGNsZWFyQnRuTGFiZWw6IFwiQ2xlYXIgc2VsZWN0aW9uXCIsXG4gIGNhbmNlbEJ0bkxhYmVsOiBcIkNhbmNlbCBzZWxlY3Rpb25cIixcbiAgbmV4dE1vbnRoTGFiZWw6IFwiTmV4dCBtb250aFwiLFxuICBwcmV2TW9udGhMYWJlbDogXCJQcmV2aW91cyBtb250aFwiLFxuICBuZXh0WWVhckxhYmVsOiBcIk5leHQgeWVhclwiLFxuICBwcmV2WWVhckxhYmVsOiBcIlByZXZpb3VzIHllYXJcIixcbiAgY2hhbmdlTW9udGhJY29uVGVtcGxhdGU6IGA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIzXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgY2xhc3M9XCJ3LTYgaC02XCI+XG4gIDxwYXRoIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIGQ9XCJNMTUuNzUgMTkuNUw4LjI1IDEybDcuNS03LjVcIiAvPlxuICA8L3N2Zz5cbiAgYCxcbiAgbmV4dE11bHRpWWVhckxhYmVsOiBcIk5leHQgMjQgeWVhcnNcIixcbiAgcHJldk11bHRpWWVhckxhYmVsOiBcIlByZXZpb3VzIDI0IHllYXJzXCIsXG4gIHN3aXRjaFRvTXVsdGlZZWFyVmlld0xhYmVsOiBcIkNob29zZSB5ZWFyIGFuZCBtb250aFwiLFxuICBzd2l0Y2hUb01vbnRoVmlld0xhYmVsOiBcIkNob29zZSBkYXRlXCIsXG4gIHN3aXRjaFRvRGF5Vmlld0xhYmVsOiBcIkNob29zZSBkYXRlXCIsXG4gIHN0YXJ0RGF0ZTogbnVsbCxcbiAgc3RhcnREYXk6IDAsXG4gIGZvcm1hdDogXCJkZC9tbS95eXl5XCIsXG4gIHZpZXc6IFwiZGF5c1wiLFxuICB2aWV3Q2hhbmdlSWNvblRlbXBsYXRlOiBgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMFwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGNsYXNzPVwidy02IGgtNlwiPlxuICA8cGF0aCBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBkPVwiTTE5LjUgOC4yNWwtNy41IDcuNS03LjUtNy41XCIgLz5cbiAgPC9zdmc+XG4gIGAsXG4gIG1pbjogbnVsbCxcbiAgbWF4OiBudWxsLFxuICBmaWx0ZXI6IG51bGwsXG4gIGlubGluZTogITEsXG4gIHRvZ2dsZUJ1dHRvbjogITAsXG4gIGRpc2FibGVUb2dnbGVCdXR0b246ICExLFxuICBkaXNhYmxlSW5wdXQ6ICExLFxuICBhbmltYXRpb25zOiAhMCxcbiAgY29uZmlybURhdGVPblNlbGVjdDogITEsXG4gIHJlbW92ZU9rQnRuOiAhMSxcbiAgcmVtb3ZlQ2FuY2VsQnRuOiAhMSxcbiAgcmVtb3ZlQ2xlYXJCdG46ICExXG59LCBEbSA9IHtcbiAgdGl0bGU6IFwic3RyaW5nXCIsXG4gIGNvbnRhaW5lcjogXCJzdHJpbmdcIixcbiAgZGlzYWJsZVBhc3Q6IFwiYm9vbGVhblwiLFxuICBkaXNhYmxlRnV0dXJlOiBcImJvb2xlYW5cIixcbiAgbW9udGhzRnVsbDogXCJhcnJheVwiLFxuICBtb250aHNTaG9ydDogXCJhcnJheVwiLFxuICB3ZWVrZGF5c0Z1bGw6IFwiYXJyYXlcIixcbiAgd2Vla2RheXNTaG9ydDogXCJhcnJheVwiLFxuICB3ZWVrZGF5c05hcnJvdzogXCJhcnJheVwiLFxuICBva0J0blRleHQ6IFwic3RyaW5nXCIsXG4gIGNsZWFyQnRuVGV4dDogXCJzdHJpbmdcIixcbiAgY2FuY2VsQnRuVGV4dDogXCJzdHJpbmdcIixcbiAgb2tCdG5MYWJlbDogXCJzdHJpbmdcIixcbiAgY2xlYXJCdG5MYWJlbDogXCJzdHJpbmdcIixcbiAgY2FuY2VsQnRuTGFiZWw6IFwic3RyaW5nXCIsXG4gIG5leHRNb250aExhYmVsOiBcInN0cmluZ1wiLFxuICBwcmV2TW9udGhMYWJlbDogXCJzdHJpbmdcIixcbiAgbmV4dFllYXJMYWJlbDogXCJzdHJpbmdcIixcbiAgcHJldlllYXJMYWJlbDogXCJzdHJpbmdcIixcbiAgbmV4dE11bHRpWWVhckxhYmVsOiBcInN0cmluZ1wiLFxuICBwcmV2TXVsdGlZZWFyTGFiZWw6IFwic3RyaW5nXCIsXG4gIGNoYW5nZU1vbnRoSWNvblRlbXBsYXRlOiBcInN0cmluZ1wiLFxuICBzd2l0Y2hUb011bHRpWWVhclZpZXdMYWJlbDogXCJzdHJpbmdcIixcbiAgc3dpdGNoVG9Nb250aFZpZXdMYWJlbDogXCJzdHJpbmdcIixcbiAgc3dpdGNoVG9EYXlWaWV3TGFiZWw6IFwic3RyaW5nXCIsXG4gIHN0YXJ0RGF0ZTogXCIobnVsbHxzdHJpbmd8ZGF0ZSlcIixcbiAgc3RhcnREYXk6IFwibnVtYmVyXCIsXG4gIGZvcm1hdDogXCJzdHJpbmdcIixcbiAgdmlldzogXCJzdHJpbmdcIixcbiAgdmlld0NoYW5nZUljb25UZW1wbGF0ZTogXCJzdHJpbmdcIixcbiAgbWluOiBcIihudWxsfHN0cmluZ3xkYXRlKVwiLFxuICBtYXg6IFwiKG51bGx8c3RyaW5nfGRhdGUpXCIsXG4gIGZpbHRlcjogXCIobnVsbHxmdW5jdGlvbilcIixcbiAgaW5saW5lOiBcImJvb2xlYW5cIixcbiAgdG9nZ2xlQnV0dG9uOiBcImJvb2xlYW5cIixcbiAgZGlzYWJsZVRvZ2dsZUJ1dHRvbjogXCJib29sZWFuXCIsXG4gIGRpc2FibGVJbnB1dDogXCJib29sZWFuXCIsXG4gIGFuaW1hdGlvbnM6IFwiYm9vbGVhblwiLFxuICBjb25maXJtRGF0ZU9uU2VsZWN0OiBcImJvb2xlYW5cIixcbiAgcmVtb3ZlT2tCdG46IFwiYm9vbGVhblwiLFxuICByZW1vdmVDYW5jZWxCdG46IFwiYm9vbGVhblwiLFxuICByZW1vdmVDbGVhckJ0bjogXCJib29sZWFuXCJcbn0sICRtID0ge1xuICBmYWRlSW46IFFmLFxuICBmYWRlT3V0OiBKZixcbiAgZmFkZUluU2hvcnQ6IHRtLFxuICBmYWRlT3V0U2hvcnQ6IGVtLFxuICBtb2RhbENvbnRhaW5lcjogaW0sXG4gIGRhdGVwaWNrZXJCYWNrZHJvcDogc20sXG4gIGRhdGVwaWNrZXJNYWluOiBubSxcbiAgZGF0ZXBpY2tlckhlYWRlcjogb20sXG4gIGRhdGVwaWNrZXJUaXRsZTogcm0sXG4gIGRhdGVwaWNrZXJUaXRsZVRleHQ6IGFtLFxuICBkYXRlcGlja2VyRGF0ZTogbG0sXG4gIGRhdGVwaWNrZXJEYXRlVGV4dDogY20sXG4gIGRhdGVwaWNrZXJWaWV3OiBobSxcbiAgZGF0ZXBpY2tlckRhdGVDb250cm9sczogZG0sXG4gIGRhdGVwaWNrZXJWaWV3Q2hhbmdlQnV0dG9uOiB1bSxcbiAgZGF0ZXBpY2tlclZpZXdDaGFuZ2VJY29uOiBPbSxcbiAgZGF0ZXBpY2tlckFycm93Q29udHJvbHM6IHBtLFxuICBkYXRlcGlja2VyUHJldmlvdXNCdXR0b246IF9tLFxuICBkYXRlcGlja2VyTmV4dEJ1dHRvbjogZm0sXG4gIGRhdGVwaWNrZXJGb290ZXI6IG1tLFxuICBkYXRlcGlja2VyRm9vdGVyQnRuOiBnbSxcbiAgZGF0ZXBpY2tlckNsZWFyQnRuOiBibSxcbiAgZGF0ZXBpY2tlckRheUhlYWRpbmc6IHZtLFxuICBkYXRlcGlja2VyQ2VsbDogVG0sXG4gIGRhdGVwaWNrZXJDZWxsU21hbGw6IEVtLFxuICBkYXRlcGlja2VyQ2VsbExhcmdlOiBDbSxcbiAgZGF0ZXBpY2tlckNlbGxDb250ZW50OiBBbSxcbiAgZGF0ZXBpY2tlckNlbGxDb250ZW50U21hbGw6IHltLFxuICBkYXRlcGlja2VyQ2VsbENvbnRlbnRMYXJnZTogd20sXG4gIGRhdGVwaWNrZXJUYWJsZToga20sXG4gIGRhdGVwaWNrZXJUb2dnbGVCdXR0b246IHhtLFxuICBkYXRlcGlja2VyRHJvcGRvd25Db250YWluZXI6IFNtXG59LCBMbSA9IHtcbiAgZmFkZUluOiBcInN0cmluZ1wiLFxuICBmYWRlT3V0OiBcInN0cmluZ1wiLFxuICBmYWRlSW5TaG9ydDogXCJzdHJpbmdcIixcbiAgZmFkZU91dFNob3J0OiBcInN0cmluZ1wiLFxuICBtb2RhbENvbnRhaW5lcjogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlckJhY2tkcm9wOiBcInN0cmluZ1wiLFxuICBkYXRlcGlja2VyTWFpbjogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlckhlYWRlcjogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlclRpdGxlOiBcInN0cmluZ1wiLFxuICBkYXRlcGlja2VyVGl0bGVUZXh0OiBcInN0cmluZ1wiLFxuICBkYXRlcGlja2VyRGF0ZTogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlckRhdGVUZXh0OiBcInN0cmluZ1wiLFxuICBkYXRlcGlja2VyVmlldzogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlckRhdGVDb250cm9sczogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlclZpZXdDaGFuZ2VCdXR0b246IFwic3RyaW5nXCIsXG4gIGRhdGVwaWNrZXJBcnJvd0NvbnRyb2xzOiBcInN0cmluZ1wiLFxuICBkYXRlcGlja2VyUHJldmlvdXNCdXR0b246IFwic3RyaW5nXCIsXG4gIGRhdGVwaWNrZXJOZXh0QnV0dG9uOiBcInN0cmluZ1wiLFxuICBkYXRlcGlja2VyRm9vdGVyOiBcInN0cmluZ1wiLFxuICBkYXRlcGlja2VyRm9vdGVyQnRuOiBcInN0cmluZ1wiLFxuICBkYXRlcGlja2VyQ2xlYXJCdG46IFwic3RyaW5nXCIsXG4gIGRhdGVwaWNrZXJEYXlIZWFkaW5nOiBcInN0cmluZ1wiLFxuICBkYXRlcGlja2VyQ2VsbDogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlckNlbGxTbWFsbDogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlckNlbGxMYXJnZTogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlckNlbGxDb250ZW50OiBcInN0cmluZ1wiLFxuICBkYXRlcGlja2VyQ2VsbENvbnRlbnRTbWFsbDogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlckNlbGxDb250ZW50TGFyZ2U6IFwic3RyaW5nXCIsXG4gIGRhdGVwaWNrZXJUYWJsZTogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlclRvZ2dsZUJ1dHRvbjogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlckRyb3Bkb3duQ29udGFpbmVyOiBcInN0cmluZ1wiXG59O1xuY2xhc3MgTm0ge1xuICBjb25zdHJ1Y3Rvcih0LCBlLCBpKSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX2lucHV0ID0gZC5maW5kT25lKFwiaW5wdXRcIiwgdGhpcy5fZWxlbWVudCksIHRoaXMuX29wdGlvbnMgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX2NsYXNzZXMgPSB0aGlzLl9nZXRDbGFzc2VzKGkpLCB0aGlzLl9hY3RpdmVEYXRlID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksIHRoaXMuX3NlbGVjdGVkRGF0ZSA9IG51bGwsIHRoaXMuX3NlbGVjdGVkWWVhciA9IG51bGwsIHRoaXMuX3NlbGVjdGVkTW9udGggPSBudWxsLCB0aGlzLl9oZWFkZXJEYXRlID0gbnVsbCwgdGhpcy5faGVhZGVyWWVhciA9IG51bGwsIHRoaXMuX2hlYWRlck1vbnRoID0gbnVsbCwgdGhpcy5fdmlldyA9IHRoaXMuX29wdGlvbnMudmlldywgdGhpcy5fcG9wcGVyID0gbnVsbCwgdGhpcy5fZm9jdXNUcmFwID0gbnVsbCwgdGhpcy5faXNPcGVuID0gITEsIHRoaXMuX3RvZ2dsZUJ1dHRvbklkID0gcnQoXCJkYXRlcGlja2VyLXRvZ2dsZS1cIiksIHRoaXMuX2FuaW1hdGlvbnMgPSAhd2luZG93Lm1hdGNoTWVkaWEoXCIocHJlZmVycy1yZWR1Y2VkLW1vdGlvbjogcmVkdWNlKVwiKS5tYXRjaGVzICYmIHRoaXMuX29wdGlvbnMuYW5pbWF0aW9ucywgdGhpcy5fc2Nyb2xsQmFyID0gbmV3IHFlKCksIHRoaXMuX2VsZW1lbnQgJiYgeS5zZXREYXRhKHQsIHpzLCB0aGlzKSwgdGhpcy5faW5pdCgpLCB0aGlzLnRvZ2dsZUJ1dHRvbiAmJiB0aGlzLl9vcHRpb25zLmRpc2FibGVUb2dnbGUgJiYgKHRoaXMudG9nZ2xlQnV0dG9uLmRpc2FibGVkID0gXCJ0cnVlXCIpLCB0aGlzLl9vcHRpb25zLmRpc2FibGVJbnB1dCAmJiAodGhpcy5faW5wdXQuZGlzYWJsZWQgPSBcInRydWVcIik7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIFhuO1xuICB9XG4gIGdldCBjb250YWluZXIoKSB7XG4gICAgcmV0dXJuIGQuZmluZE9uZShcbiAgICAgIGBbJHtVY309JyR7dGhpcy5fdG9nZ2xlQnV0dG9uSWR9J11gXG4gICAgKSB8fCBkLmZpbmRPbmUoXG4gICAgICBgWyR7WGN9PScke3RoaXMuX3RvZ2dsZUJ1dHRvbklkfSddYFxuICAgICk7XG4gIH1cbiAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29wdGlvbnM7XG4gIH1cbiAgZ2V0IGFjdGl2ZUNlbGwoKSB7XG4gICAgbGV0IHQ7XG4gICAgcmV0dXJuIHRoaXMuX3ZpZXcgPT09IFwiZGF5c1wiICYmICh0ID0gdGhpcy5fZ2V0QWN0aXZlRGF5Q2VsbCgpKSwgdGhpcy5fdmlldyA9PT0gXCJtb250aHNcIiAmJiAodCA9IHRoaXMuX2dldEFjdGl2ZU1vbnRoQ2VsbCgpKSwgdGhpcy5fdmlldyA9PT0gXCJ5ZWFyc1wiICYmICh0ID0gdGhpcy5fZ2V0QWN0aXZlWWVhckNlbGwoKSksIHQ7XG4gIH1cbiAgZ2V0IGFjdGl2ZURheSgpIHtcbiAgICByZXR1cm4gWih0aGlzLl9hY3RpdmVEYXRlKTtcbiAgfVxuICBnZXQgYWN0aXZlTW9udGgoKSB7XG4gICAgcmV0dXJuIFkodGhpcy5fYWN0aXZlRGF0ZSk7XG4gIH1cbiAgZ2V0IGFjdGl2ZVllYXIoKSB7XG4gICAgcmV0dXJuIEIodGhpcy5fYWN0aXZlRGF0ZSk7XG4gIH1cbiAgZ2V0IGZpcnN0WWVhckluVmlldygpIHtcbiAgICByZXR1cm4gdGhpcy5hY3RpdmVZZWFyIC0gV3ModGhpcy5fYWN0aXZlRGF0ZSwgdnQpO1xuICB9XG4gIGdldCBsYXN0WWVhckluVmlldygpIHtcbiAgICByZXR1cm4gdGhpcy5maXJzdFllYXJJblZpZXcgKyB2dCAtIDE7XG4gIH1cbiAgZ2V0IHZpZXdDaGFuZ2VCdXR0b24oKSB7XG4gICAgcmV0dXJuIGQuZmluZE9uZShGZiwgdGhpcy5jb250YWluZXIpO1xuICB9XG4gIGdldCBwcmV2aW91c0J1dHRvbigpIHtcbiAgICByZXR1cm4gZC5maW5kT25lKFlmLCB0aGlzLmNvbnRhaW5lcik7XG4gIH1cbiAgZ2V0IG5leHRCdXR0b24oKSB7XG4gICAgcmV0dXJuIGQuZmluZE9uZShqZiwgdGhpcy5jb250YWluZXIpO1xuICB9XG4gIGdldCBva0J1dHRvbigpIHtcbiAgICByZXR1cm4gZC5maW5kT25lKEtmLCB0aGlzLmNvbnRhaW5lcik7XG4gIH1cbiAgZ2V0IGNhbmNlbEJ1dHRvbigpIHtcbiAgICByZXR1cm4gZC5maW5kT25lKHpmLCB0aGlzLmNvbnRhaW5lcik7XG4gIH1cbiAgZ2V0IGNsZWFyQnV0dG9uKCkge1xuICAgIHJldHVybiBkLmZpbmRPbmUoVWYsIHRoaXMuY29udGFpbmVyKTtcbiAgfVxuICBnZXQgZGF0ZXNDb250YWluZXIoKSB7XG4gICAgcmV0dXJuIGQuZmluZE9uZShYZiwgdGhpcy5jb250YWluZXIpO1xuICB9XG4gIGdldCB0b2dnbGVCdXR0b24oKSB7XG4gICAgcmV0dXJuIGQuZmluZE9uZShHZiwgdGhpcy5fZWxlbWVudCk7XG4gIH1cbiAgdXBkYXRlKHQgPSB7fSkge1xuICAgIHRoaXMuX29wdGlvbnMgPSB0aGlzLl9nZXRDb25maWcoeyAuLi50aGlzLl9vcHRpb25zLCAuLi50IH0pO1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIGNvbnN0IGUgPSBoLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIGlmICh0ID0ge1xuICAgICAgLi4uSW0sXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIEQoWG4sIHQsIERtKSwgdC5tYXggJiYgdHlwZW9mIHQubWF4ID09IFwic3RyaW5nXCIgJiYgKHQubWF4ID0gbmV3IERhdGUodC5tYXgpKSwgdC5taW4gJiYgdHlwZW9mIHQubWluID09IFwic3RyaW5nXCIgJiYgKHQubWluID0gbmV3IERhdGUodC5taW4pKSwgdC5zdGFydERheSAmJiB0LnN0YXJ0RGF5ICE9PSAwKSB7XG4gICAgICBjb25zdCBpID0gdGhpcy5fZ2V0TmV3RGF5c09yZGVyQXJyYXkodCk7XG4gICAgICB0LndlZWtkYXlzTmFycm93ID0gaTtcbiAgICB9XG4gICAgcmV0dXJuIHQ7XG4gIH1cbiAgX2dldENsYXNzZXModCkge1xuICAgIGNvbnN0IGUgPSBoLmdldERhdGFDbGFzc0F0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi4kbSxcbiAgICAgIC4uLmUsXG4gICAgICAuLi50XG4gICAgfSwgRChYbiwgdCwgTG0pLCB0O1xuICB9XG4gIF9nZXRDb250YWluZXIoKSB7XG4gICAgcmV0dXJuIGQuZmluZE9uZSh0aGlzLl9vcHRpb25zLmNvbnRhaW5lcik7XG4gIH1cbiAgX2dldE5ld0RheXNPcmRlckFycmF5KHQpIHtcbiAgICBjb25zdCBlID0gdC5zdGFydERheSwgaSA9IHQud2Vla2RheXNOYXJyb3c7XG4gICAgcmV0dXJuIGkuc2xpY2UoZSkuY29uY2F0KGkuc2xpY2UoMCwgZSkpO1xuICB9XG4gIF9pbml0KCkge1xuICAgICF0aGlzLnRvZ2dsZUJ1dHRvbiAmJiB0aGlzLl9vcHRpb25zLnRvZ2dsZUJ1dHRvbiAmJiAodGhpcy5fYXBwZW5kVG9nZ2xlQnV0dG9uKCksICh0aGlzLl9pbnB1dC5yZWFkT25seSB8fCB0aGlzLl9pbnB1dC5kaXNhYmxlZCkgJiYgKHRoaXMudG9nZ2xlQnV0dG9uLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcIm5vbmVcIikpLCB0aGlzLl9saXN0ZW5Ub1VzZXJJbnB1dCgpLCB0aGlzLl9saXN0ZW5Ub1RvZ2dsZUNsaWNrKCksIHRoaXMuX2xpc3RlblRvVG9nZ2xlS2V5ZG93bigpO1xuICB9XG4gIF9hcHBlbmRUb2dnbGVCdXR0b24oKSB7XG4gICAgY29uc3QgdCA9IExmKFxuICAgICAgdGhpcy5fdG9nZ2xlQnV0dG9uSWQsXG4gICAgICB0aGlzLl9jbGFzc2VzLmRhdGVwaWNrZXJUb2dnbGVCdXR0b25cbiAgICApO1xuICAgIHRoaXMuX2VsZW1lbnQuaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYmVmb3JlZW5kXCIsIHQpO1xuICB9XG4gIG9wZW4oKSB7XG4gICAgaWYgKHRoaXMuX2lucHV0LnJlYWRPbmx5IHx8IHRoaXMuX2lucHV0LmRpc2FibGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHQgPSBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgQmYpO1xuICAgIGlmICh0aGlzLl9pc09wZW4gfHwgdC5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX3NldEluaXRpYWxEYXRlKCk7XG4gICAgY29uc3QgZSA9IHhmKHRoaXMuX2NsYXNzZXMuZGF0ZXBpY2tlckJhY2tkcm9wKSwgaSA9IGtmKFxuICAgICAgdGhpcy5fYWN0aXZlRGF0ZSxcbiAgICAgIHRoaXMuX3NlbGVjdGVkRGF0ZSxcbiAgICAgIHRoaXMuX3NlbGVjdGVkWWVhcixcbiAgICAgIHRoaXMuX3NlbGVjdGVkTW9udGgsXG4gICAgICB0aGlzLl9vcHRpb25zLFxuICAgICAgY3MsXG4gICAgICB2dCxcbiAgICAgIGxzLFxuICAgICAgdGhpcy5fdG9nZ2xlQnV0dG9uSWQsXG4gICAgICB0aGlzLl9jbGFzc2VzXG4gICAgKTtcbiAgICB0aGlzLl9vcHRpb25zLmlubGluZSA/IHRoaXMuX29wZW5Ecm9wZG93bihpKSA6ICh0aGlzLl9vcGVuTW9kYWwoZSwgaSksIHRoaXMuX3Njcm9sbEJhci5oaWRlKCkpLCB0aGlzLl9hbmltYXRpb25zICYmIChoLmFkZENsYXNzKHRoaXMuY29udGFpbmVyLCB0aGlzLl9jbGFzc2VzLmZhZGVJbiksIGguYWRkQ2xhc3MoZSwgdGhpcy5fY2xhc3Nlcy5mYWRlSW5TaG9ydCkpLCB0aGlzLl9zZXRGb2N1c1RyYXAodGhpcy5jb250YWluZXIpLCB0aGlzLl9saXN0ZW5Ub0RhdGVTZWxlY3Rpb24oKSwgdGhpcy5fYWRkQ29udHJvbHNMaXN0ZW5lcnMoKSwgdGhpcy5fdXBkYXRlQ29udHJvbHNEaXNhYmxlZFN0YXRlKCksIHRoaXMuX2xpc3RlblRvRXNjYXBlQ2xpY2soKSwgdGhpcy5fbGlzdGVuVG9LZXlib2FyZE5hdmlnYXRpb24oKSwgdGhpcy5fbGlzdGVuVG9EYXRlc0NvbnRhaW5lckZvY3VzKCksIHRoaXMuX2xpc3RlblRvRGF0ZXNDb250YWluZXJCbHVyKCksIHRoaXMuX2FzeW5jRm9jdXNEYXRlc0NvbnRhaW5lcigpLCB0aGlzLl91cGRhdGVWaWV3Q29udHJvbHNBbmRBdHRyaWJ1dGVzKHRoaXMuX3ZpZXcpLCB0aGlzLl9pc09wZW4gPSAhMCwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLl9saXN0ZW5Ub091dHNpZGVDbGljaygpO1xuICAgIH0sIDApO1xuICB9XG4gIF9vcGVuRHJvcGRvd24odCkge1xuICAgIHRoaXMuX3BvcHBlciA9IENlKHRoaXMuX2lucHV0LCB0LCB7XG4gICAgICBwbGFjZW1lbnQ6IFwiYm90dG9tLXN0YXJ0XCJcbiAgICB9KSwgdGhpcy5fZ2V0Q29udGFpbmVyKCkuYXBwZW5kQ2hpbGQodCk7XG4gIH1cbiAgX29wZW5Nb2RhbCh0LCBlKSB7XG4gICAgY29uc3QgaSA9IHRoaXMuX2dldENvbnRhaW5lcigpO1xuICAgIGkuYXBwZW5kQ2hpbGQodCksIGkuYXBwZW5kQ2hpbGQoZSk7XG4gIH1cbiAgX3NldEZvY3VzVHJhcCh0KSB7XG4gICAgdGhpcy5fZm9jdXNUcmFwID0gbmV3IFdpKHQsIHtcbiAgICAgIGV2ZW50OiBcImtleWRvd25cIixcbiAgICAgIGNvbmRpdGlvbjogKGUpID0+IGUua2V5ID09PSBcIlRhYlwiXG4gICAgfSksIHRoaXMuX2ZvY3VzVHJhcC50cmFwKCk7XG4gIH1cbiAgX2xpc3RlblRvVXNlcklucHV0KCkge1xuICAgIGMub24odGhpcy5faW5wdXQsIFwiaW5wdXRcIiwgKHQpID0+IHtcbiAgICAgIHRoaXMuX2hhbmRsZVVzZXJJbnB1dCh0LnRhcmdldC52YWx1ZSk7XG4gICAgfSk7XG4gIH1cbiAgX2xpc3RlblRvVG9nZ2xlQ2xpY2soKSB7XG4gICAgYy5vbihcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBocyxcbiAgICAgIGRzLFxuICAgICAgKHQpID0+IHtcbiAgICAgICAgdC5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLm9wZW4oKTtcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIF9saXN0ZW5Ub1RvZ2dsZUtleWRvd24oKSB7XG4gICAgYy5vbihcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBcImtleWRvd25cIixcbiAgICAgIGRzLFxuICAgICAgKHQpID0+IHtcbiAgICAgICAgdC5rZXlDb2RlID09PSBjdCAmJiAhdGhpcy5faXNPcGVuICYmIHRoaXMub3BlbigpO1xuICAgICAgfVxuICAgICk7XG4gIH1cbiAgX2xpc3RlblRvRGF0ZVNlbGVjdGlvbigpIHtcbiAgICBjLm9uKHRoaXMuZGF0ZXNDb250YWluZXIsIFwiY2xpY2tcIiwgKHQpID0+IHtcbiAgICAgIHRoaXMuX2hhbmRsZURhdGVTZWxlY3Rpb24odCk7XG4gICAgfSk7XG4gIH1cbiAgX2hhbmRsZURhdGVTZWxlY3Rpb24odCkge1xuICAgIGNvbnN0IGUgPSB0LnRhcmdldC5ub2RlTmFtZSA9PT0gXCJESVZcIiA/IHQudGFyZ2V0LnBhcmVudE5vZGUuZGF0YXNldCA6IHQudGFyZ2V0LmRhdGFzZXQsIGkgPSB0LnRhcmdldC5ub2RlTmFtZSA9PT0gXCJESVZcIiA/IHQudGFyZ2V0LnBhcmVudE5vZGUgOiB0LnRhcmdldDtcbiAgICBpZiAoZS50ZURhdGUgJiYgdGhpcy5fcGlja0RheShlLnRlRGF0ZSwgaSksIGUudGVNb250aCAmJiBlLnRlWWVhcikge1xuICAgICAgY29uc3QgbiA9IHBhcnNlSW50KGUudGVNb250aCwgMTApLCBvID0gcGFyc2VJbnQoZS50ZVllYXIsIDEwKTtcbiAgICAgIHRoaXMuX3BpY2tNb250aChuLCBvKTtcbiAgICB9XG4gICAgaWYgKGUudGVZZWFyICYmICFlLnRlTW9udGgpIHtcbiAgICAgIGNvbnN0IG4gPSBwYXJzZUludChlLnRlWWVhciwgMTApO1xuICAgICAgdGhpcy5fcGlja1llYXIobik7XG4gICAgfVxuICAgIHRoaXMuX29wdGlvbnMuaW5saW5lIHx8IHRoaXMuX3VwZGF0ZUhlYWRlckRhdGUoXG4gICAgICB0aGlzLl9hY3RpdmVEYXRlLFxuICAgICAgdGhpcy5fb3B0aW9ucy5tb250aHNTaG9ydCxcbiAgICAgIHRoaXMuX29wdGlvbnMud2Vla2RheXNTaG9ydFxuICAgICk7XG4gIH1cbiAgX3VwZGF0ZUhlYWRlckRhdGUodCwgZSwgaSkge1xuICAgIGNvbnN0IG4gPSBkLmZpbmRPbmUoXG4gICAgICBxZixcbiAgICAgIHRoaXMuY29udGFpbmVyXG4gICAgKSwgbyA9IFkodCksIHIgPSBaKHQpLCBhID0gVnModCk7XG4gICAgbi5pbm5lckhUTUwgPSBgJHtpW2FdfSwgJHtlW29dfSAke3J9YDtcbiAgfVxuICBfYWRkQ29udHJvbHNMaXN0ZW5lcnMoKSB7XG4gICAgYy5vbih0aGlzLm5leHRCdXR0b24sIFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fdmlldyA9PT0gXCJkYXlzXCIgPyB0aGlzLm5leHRNb250aCgpIDogdGhpcy5fdmlldyA9PT0gXCJ5ZWFyc1wiID8gdGhpcy5uZXh0WWVhcnMoKSA6IHRoaXMubmV4dFllYXIoKSwgdGhpcy5fdXBkYXRlQ29udHJvbHNEaXNhYmxlZFN0YXRlKCk7XG4gICAgfSksIGMub24odGhpcy5wcmV2aW91c0J1dHRvbiwgXCJjbGlja1wiLCAoKSA9PiB7XG4gICAgICB0aGlzLl92aWV3ID09PSBcImRheXNcIiA/IHRoaXMucHJldmlvdXNNb250aCgpIDogdGhpcy5fdmlldyA9PT0gXCJ5ZWFyc1wiID8gdGhpcy5wcmV2aW91c1llYXJzKCkgOiB0aGlzLnByZXZpb3VzWWVhcigpLCB0aGlzLl91cGRhdGVDb250cm9sc0Rpc2FibGVkU3RhdGUoKTtcbiAgICB9KSwgYy5vbih0aGlzLnZpZXdDaGFuZ2VCdXR0b24sIFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fdmlldyA9PT0gXCJkYXlzXCIgPyB0aGlzLl9jaGFuZ2VWaWV3KFwieWVhcnNcIikgOiAodGhpcy5fdmlldyA9PT0gXCJ5ZWFyc1wiIHx8IHRoaXMuX3ZpZXcgPT09IFwibW9udGhzXCIpICYmIHRoaXMuX2NoYW5nZVZpZXcoXCJkYXlzXCIpO1xuICAgIH0pLCB0aGlzLl9vcHRpb25zLmlubGluZSB8fCB0aGlzLl9saXN0ZW5Ub0Zvb3RlckJ1dHRvbnNDbGljaygpO1xuICB9XG4gIF9saXN0ZW5Ub0Zvb3RlckJ1dHRvbnNDbGljaygpIHtcbiAgICBjLm9uKHRoaXMub2tCdXR0b24sIFwiY2xpY2tcIiwgKCkgPT4gdGhpcy5oYW5kbGVPaygpKSwgYy5vbih0aGlzLmNhbmNlbEJ1dHRvbiwgXCJjbGlja1wiLCAoKSA9PiB0aGlzLmhhbmRsZUNhbmNlbCgpKSwgYy5vbih0aGlzLmNsZWFyQnV0dG9uLCBcImNsaWNrXCIsICgpID0+IHRoaXMuaGFuZGxlQ2xlYXIoKSk7XG4gIH1cbiAgX2xpc3RlblRvT3V0c2lkZUNsaWNrKCkge1xuICAgIGMub24oZG9jdW1lbnQsIGhzLCAodCkgPT4ge1xuICAgICAgY29uc3QgZSA9IHQudGFyZ2V0ID09PSB0aGlzLmNvbnRhaW5lciwgaSA9IHRoaXMuY29udGFpbmVyICYmIHRoaXMuY29udGFpbmVyLmNvbnRhaW5zKHQudGFyZ2V0KTtcbiAgICAgICFlICYmICFpICYmIHRoaXMuY2xvc2UoKTtcbiAgICB9KTtcbiAgfVxuICBfbGlzdGVuVG9Fc2NhcGVDbGljaygpIHtcbiAgICBjLm9uKGRvY3VtZW50LCBcImtleWRvd25cIiwgKHQpID0+IHtcbiAgICAgIHQua2V5Q29kZSA9PT0gRmkgJiYgdGhpcy5faXNPcGVuICYmIHRoaXMuY2xvc2UoKTtcbiAgICB9KTtcbiAgfVxuICBfbGlzdGVuVG9LZXlib2FyZE5hdmlnYXRpb24oKSB7XG4gICAgYy5vbih0aGlzLmRhdGVzQ29udGFpbmVyLCBcImtleWRvd25cIiwgKHQpID0+IHtcbiAgICAgIHRoaXMuX2hhbmRsZUtleWRvd24odCk7XG4gICAgfSk7XG4gIH1cbiAgX2xpc3RlblRvRGF0ZXNDb250YWluZXJGb2N1cygpIHtcbiAgICBjLm9uKHRoaXMuZGF0ZXNDb250YWluZXIsIFwiZm9jdXNcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fZm9jdXNBY3RpdmVDZWxsKHRoaXMuYWN0aXZlQ2VsbCk7XG4gICAgfSk7XG4gIH1cbiAgX2xpc3RlblRvRGF0ZXNDb250YWluZXJCbHVyKCkge1xuICAgIGMub24odGhpcy5kYXRlc0NvbnRhaW5lciwgXCJibHVyXCIsICgpID0+IHtcbiAgICAgIHRoaXMuX3JlbW92ZUN1cnJlbnRGb2N1c1N0eWxlcygpO1xuICAgIH0pO1xuICB9XG4gIF9oYW5kbGVLZXlkb3duKHQpIHtcbiAgICB0aGlzLl92aWV3ID09PSBcImRheXNcIiAmJiB0aGlzLl9oYW5kbGVEYXlzVmlld0tleWRvd24odCksIHRoaXMuX3ZpZXcgPT09IFwibW9udGhzXCIgJiYgdGhpcy5faGFuZGxlTW9udGhzVmlld0tleWRvd24odCksIHRoaXMuX3ZpZXcgPT09IFwieWVhcnNcIiAmJiB0aGlzLl9oYW5kbGVZZWFyc1ZpZXdLZXlkb3duKHQpO1xuICB9XG4gIF9oYW5kbGVEYXlzVmlld0tleWRvd24odCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLl9hY3RpdmVEYXRlLCBpID0gdGhpcy5hY3RpdmVDZWxsO1xuICAgIHN3aXRjaCAodC5rZXlDb2RlKSB7XG4gICAgICBjYXNlIEhlOlxuICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0geGUodGhpcy5fYWN0aXZlRGF0ZSwgRigpID8gMSA6IC0xKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFZlOlxuICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0geGUodGhpcy5fYWN0aXZlRGF0ZSwgRigpID8gLTEgOiAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGF0OlxuICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0geGUodGhpcy5fYWN0aXZlRGF0ZSwgLTcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgejpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IHhlKHRoaXMuX2FjdGl2ZURhdGUsIDcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgV2U6XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSB4ZShcbiAgICAgICAgICB0aGlzLl9hY3RpdmVEYXRlLFxuICAgICAgICAgIDEgLSBaKHRoaXMuX2FjdGl2ZURhdGUpXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBGZTpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IHhlKFxuICAgICAgICAgIHRoaXMuX2FjdGl2ZURhdGUsXG4gICAgICAgICAgUG8odGhpcy5fYWN0aXZlRGF0ZSkgLSBaKHRoaXMuX2FjdGl2ZURhdGUpXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB6bjpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IG50KHRoaXMuX2FjdGl2ZURhdGUsIC0xKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFVuOlxuICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0gbnQodGhpcy5fYWN0aXZlRGF0ZSwgMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBjdDpcbiAgICAgIGNhc2UgS3M6XG4gICAgICAgIHRoaXMuX3NlbGVjdERhdGUodGhpcy5fYWN0aXZlRGF0ZSksIHRoaXMuX2hhbmRsZURhdGVTZWxlY3Rpb24odCksIHQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBEaShcbiAgICAgIGUsXG4gICAgICB0aGlzLl9hY3RpdmVEYXRlLFxuICAgICAgdGhpcy5fdmlldyxcbiAgICAgIHZ0LFxuICAgICAgdGhpcy5fb3B0aW9ucy5taW4sXG4gICAgICB0aGlzLl9vcHRpb25zLm1heFxuICAgICkgfHwgdGhpcy5fY2hhbmdlVmlldyhcImRheXNcIiksIHRoaXMuX3JlbW92ZUhpZ2hsaWdodEZyb21DZWxsKGkpLCB0aGlzLl9mb2N1c0FjdGl2ZUNlbGwodGhpcy5hY3RpdmVDZWxsKSwgdC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG4gIF9hc3luY0ZvY3VzRGF0ZXNDb250YWluZXIoKSB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmRhdGVzQ29udGFpbmVyLmZvY3VzKCk7XG4gICAgfSwgMCk7XG4gIH1cbiAgX2ZvY3VzQWN0aXZlQ2VsbCh0KSB7XG4gICAgdCAmJiB0LnNldEF0dHJpYnV0ZShcImRhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLWZvY3VzZWRcIiwgXCJcIik7XG4gIH1cbiAgX3JlbW92ZUhpZ2hsaWdodEZyb21DZWxsKHQpIHtcbiAgICB0ICYmIHQucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtZm9jdXNlZFwiKTtcbiAgfVxuICBfZ2V0QWN0aXZlRGF5Q2VsbCgpIHtcbiAgICBjb25zdCB0ID0gZC5maW5kKFwidGRcIiwgdGhpcy5kYXRlc0NvbnRhaW5lcik7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odCkuZmluZCgoaSkgPT4ge1xuICAgICAgY29uc3QgbiA9IE9hKGkuZGF0YXNldC50ZURhdGUpO1xuICAgICAgcmV0dXJuIGZlKG4sIHRoaXMuX2FjdGl2ZURhdGUpO1xuICAgIH0pO1xuICB9XG4gIF9oYW5kbGVNb250aHNWaWV3S2V5ZG93bih0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuX2FjdGl2ZURhdGUsIGkgPSB0aGlzLmFjdGl2ZUNlbGw7XG4gICAgc3dpdGNoICh0LmtleUNvZGUpIHtcbiAgICAgIGNhc2UgSGU6XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSBudCh0aGlzLl9hY3RpdmVEYXRlLCBGKCkgPyAxIDogLTEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVmU6XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSBudCh0aGlzLl9hY3RpdmVEYXRlLCBGKCkgPyAtMSA6IDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgYXQ6XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSBudCh0aGlzLl9hY3RpdmVEYXRlLCAtNCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB6OlxuICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0gbnQodGhpcy5fYWN0aXZlRGF0ZSwgNCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBXZTpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IG50KHRoaXMuX2FjdGl2ZURhdGUsIC10aGlzLmFjdGl2ZU1vbnRoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEZlOlxuICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0gbnQodGhpcy5fYWN0aXZlRGF0ZSwgMTEgLSB0aGlzLmFjdGl2ZU1vbnRoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHpuOlxuICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0gaXQodGhpcy5fYWN0aXZlRGF0ZSwgLTEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVW46XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSBpdCh0aGlzLl9hY3RpdmVEYXRlLCAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGN0OlxuICAgICAgY2FzZSBLczpcbiAgICAgICAgdGhpcy5fc2VsZWN0TW9udGgodGhpcy5hY3RpdmVNb250aCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgRGkoXG4gICAgICBlLFxuICAgICAgdGhpcy5fYWN0aXZlRGF0ZSxcbiAgICAgIHRoaXMuX3ZpZXcsXG4gICAgICB2dCxcbiAgICAgIHRoaXMuX29wdGlvbnMubWluLFxuICAgICAgdGhpcy5fb3B0aW9ucy5tYXhcbiAgICApIHx8IHRoaXMuX2NoYW5nZVZpZXcoXCJtb250aHNcIiksIHRoaXMuX3JlbW92ZUhpZ2hsaWdodEZyb21DZWxsKGkpLCB0aGlzLl9mb2N1c0FjdGl2ZUNlbGwodGhpcy5hY3RpdmVDZWxsKSwgdC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG4gIF9nZXRBY3RpdmVNb250aENlbGwoKSB7XG4gICAgY29uc3QgdCA9IGQuZmluZChcInRkXCIsIHRoaXMuZGF0ZXNDb250YWluZXIpO1xuICAgIHJldHVybiBBcnJheS5mcm9tKHQpLmZpbmQoKGkpID0+IHtcbiAgICAgIGNvbnN0IG4gPSBwYXJzZUludChpLmRhdGFzZXQudGVZZWFyLCAxMCksIG8gPSBwYXJzZUludChpLmRhdGFzZXQudGVNb250aCwgMTApO1xuICAgICAgcmV0dXJuIG4gPT09IHRoaXMuYWN0aXZlWWVhciAmJiBvID09PSB0aGlzLmFjdGl2ZU1vbnRoO1xuICAgIH0pO1xuICB9XG4gIF9oYW5kbGVZZWFyc1ZpZXdLZXlkb3duKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5fYWN0aXZlRGF0ZSwgaSA9IHRoaXMuYWN0aXZlQ2VsbCwgbiA9IDQsIG8gPSAyNDtcbiAgICBzd2l0Y2ggKHQua2V5Q29kZSkge1xuICAgICAgY2FzZSBIZTpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IGl0KHRoaXMuX2FjdGl2ZURhdGUsIEYoKSA/IDEgOiAtMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBWZTpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IGl0KHRoaXMuX2FjdGl2ZURhdGUsIEYoKSA/IC0xIDogMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBhdDpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IGl0KHRoaXMuX2FjdGl2ZURhdGUsIC1uKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHo6XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSBpdCh0aGlzLl9hY3RpdmVEYXRlLCBuKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFdlOlxuICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0gaXQoXG4gICAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSxcbiAgICAgICAgICAtV3ModGhpcy5fYWN0aXZlRGF0ZSwgbylcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEZlOlxuICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0gaXQoXG4gICAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSxcbiAgICAgICAgICBvIC0gV3ModGhpcy5fYWN0aXZlRGF0ZSwgbykgLSAxXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB6bjpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IGl0KHRoaXMuX2FjdGl2ZURhdGUsIC1vKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFVuOlxuICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0gaXQodGhpcy5fYWN0aXZlRGF0ZSwgbyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBjdDpcbiAgICAgIGNhc2UgS3M6XG4gICAgICAgIHRoaXMuX3NlbGVjdFllYXIodGhpcy5hY3RpdmVZZWFyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBEaShcbiAgICAgIGUsXG4gICAgICB0aGlzLl9hY3RpdmVEYXRlLFxuICAgICAgdGhpcy5fdmlldyxcbiAgICAgIHZ0LFxuICAgICAgdGhpcy5fb3B0aW9ucy5taW4sXG4gICAgICB0aGlzLl9vcHRpb25zLm1heFxuICAgICkgfHwgdGhpcy5fY2hhbmdlVmlldyhcInllYXJzXCIpLCB0aGlzLl9yZW1vdmVIaWdobGlnaHRGcm9tQ2VsbChpKSwgdGhpcy5fZm9jdXNBY3RpdmVDZWxsKHRoaXMuYWN0aXZlQ2VsbCksIHQucHJldmVudERlZmF1bHQoKTtcbiAgfVxuICBfZ2V0QWN0aXZlWWVhckNlbGwoKSB7XG4gICAgY29uc3QgdCA9IGQuZmluZChcInRkXCIsIHRoaXMuZGF0ZXNDb250YWluZXIpO1xuICAgIHJldHVybiBBcnJheS5mcm9tKHQpLmZpbmQoKGkpID0+IHBhcnNlSW50KGkuZGF0YXNldC50ZVllYXIsIDEwKSA9PT0gdGhpcy5hY3RpdmVZZWFyKTtcbiAgfVxuICBfc2V0SW5pdGlhbERhdGUoKSB7XG4gICAgdGhpcy5faW5wdXQudmFsdWUgPyB0aGlzLl9oYW5kbGVVc2VySW5wdXQodGhpcy5faW5wdXQudmFsdWUpIDogdGhpcy5fb3B0aW9ucy5zdGFydERhdGUgPyB0aGlzLl9hY3RpdmVEYXRlID0gbmV3IERhdGUodGhpcy5fb3B0aW9ucy5zdGFydERhdGUpIDogdGhpcy5fYWN0aXZlRGF0ZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICB9XG4gIGNsb3NlKCkge1xuICAgIGNvbnN0IHQgPSBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgUGYpO1xuICAgICF0aGlzLl9pc09wZW4gfHwgdC5kZWZhdWx0UHJldmVudGVkIHx8ICh0aGlzLl9yZW1vdmVEYXRlcGlja2VyTGlzdGVuZXJzKCksIHRoaXMuX2FuaW1hdGlvbnMgJiYgaC5hZGRDbGFzcyh0aGlzLmNvbnRhaW5lciwgdGhpcy5fY2xhc3Nlcy5mYWRlT3V0KSwgdGhpcy5fb3B0aW9ucy5pbmxpbmUgPyB0aGlzLl9jbG9zZURyb3Bkb3duKCkgOiB0aGlzLl9jbG9zZU1vZGFsKCksIHRoaXMuX2lzT3BlbiA9ICExLCB0aGlzLl92aWV3ID0gdGhpcy5fb3B0aW9ucy52aWV3LCB0aGlzLnRvZ2dsZUJ1dHRvbiA/IHRoaXMudG9nZ2xlQnV0dG9uLmZvY3VzKCkgOiB0aGlzLl9pbnB1dC5mb2N1cygpKTtcbiAgfVxuICBfY2xvc2VEcm9wZG93bigpIHtcbiAgICBjb25zdCB0ID0gZC5maW5kT25lKFdmKSwgZSA9IHRoaXMuX2dldENvbnRhaW5lcigpO1xuICAgIHdpbmRvdy5tYXRjaE1lZGlhKFwiKHByZWZlcnMtcmVkdWNlZC1tb3Rpb246IHJlZHVjZSlcIikubWF0Y2hlcyAmJiAodCAmJiBlLnJlbW92ZUNoaWxkKHQpLCB0aGlzLl9wb3BwZXIgJiYgdGhpcy5fcG9wcGVyLmRlc3Ryb3koKSksIHQuYWRkRXZlbnRMaXN0ZW5lcihcImFuaW1hdGlvbmVuZFwiLCAoKSA9PiB7XG4gICAgICB0ICYmIGUucmVtb3ZlQ2hpbGQodCksIHRoaXMuX3BvcHBlciAmJiB0aGlzLl9wb3BwZXIuZGVzdHJveSgpO1xuICAgIH0pLCB0aGlzLl9yZW1vdmVGb2N1c1RyYXAoKTtcbiAgfVxuICBfY2xvc2VNb2RhbCgpIHtcbiAgICBjb25zdCB0ID0gZC5maW5kT25lKFpmKSwgZSA9IGQuZmluZE9uZShWZik7XG4gICAgIWUgfHwgIXQgfHwgKHRoaXMuX2FuaW1hdGlvbnMgPyAoaC5hZGRDbGFzcyh0LCB0aGlzLl9jbGFzc2VzLmZhZGVPdXRTaG9ydCksIHQuYWRkRXZlbnRMaXN0ZW5lcihcImFuaW1hdGlvbmVuZFwiLCAoKSA9PiB7XG4gICAgICB0aGlzLl9yZW1vdmVQaWNrZXIodCwgZSksIHRoaXMuX3Njcm9sbEJhci5yZXNldCgpO1xuICAgIH0pKSA6ICh0aGlzLl9yZW1vdmVQaWNrZXIodCwgZSksIHRoaXMuX3Njcm9sbEJhci5yZXNldCgpKSk7XG4gIH1cbiAgX3JlbW92ZVBpY2tlcih0LCBlKSB7XG4gICAgY29uc3QgaSA9IHRoaXMuX2dldENvbnRhaW5lcigpO1xuICAgIGkucmVtb3ZlQ2hpbGQodCksIGkucmVtb3ZlQ2hpbGQoZSk7XG4gIH1cbiAgX3JlbW92ZUZvY3VzVHJhcCgpIHtcbiAgICB0aGlzLl9mb2N1c1RyYXAgJiYgKHRoaXMuX2ZvY3VzVHJhcC5kaXNhYmxlKCksIHRoaXMuX2ZvY3VzVHJhcCA9IG51bGwpO1xuICB9XG4gIF9yZW1vdmVEYXRlcGlja2VyTGlzdGVuZXJzKCkge1xuICAgIGMub2ZmKHRoaXMubmV4dEJ1dHRvbiwgXCJjbGlja1wiKSwgYy5vZmYodGhpcy5wcmV2aW91c0J1dHRvbiwgXCJjbGlja1wiKSwgYy5vZmYodGhpcy52aWV3Q2hhbmdlQnV0dG9uLCBcImNsaWNrXCIpLCBjLm9mZih0aGlzLm9rQnV0dG9uLCBcImNsaWNrXCIpLCBjLm9mZih0aGlzLmNhbmNlbEJ1dHRvbiwgXCJjbGlja1wiKSwgYy5vZmYodGhpcy5jbGVhckJ1dHRvbiwgXCJjbGlja1wiKSwgYy5vZmYodGhpcy5kYXRlc0NvbnRhaW5lciwgXCJjbGlja1wiKSwgYy5vZmYodGhpcy5kYXRlc0NvbnRhaW5lciwgXCJrZXlkb3duXCIpLCBjLm9mZih0aGlzLmRhdGVzQ29udGFpbmVyLCBcImZvY3VzXCIpLCBjLm9mZih0aGlzLmRhdGVzQ29udGFpbmVyLCBcImJsdXJcIiksIGMub2ZmKGRvY3VtZW50LCBocyk7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLl9pc09wZW4gJiYgdGhpcy5jbG9zZSgpLCB0aGlzLl9yZW1vdmVJbnB1dEFuZFRvZ2dsZUxpc3RlbmVycygpO1xuICAgIGNvbnN0IHQgPSBkLmZpbmRPbmUoXG4gICAgICBgIyR7dGhpcy5fdG9nZ2xlQnV0dG9uSWR9YFxuICAgICk7XG4gICAgdCAmJiB0aGlzLl9lbGVtZW50LnJlbW92ZUNoaWxkKHQpLCB5LnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgenMpLCB0aGlzLl9lbGVtZW50ID0gbnVsbCwgdGhpcy5faW5wdXQgPSBudWxsLCB0aGlzLl9vcHRpb25zID0gbnVsbCwgdGhpcy5fYWN0aXZlRGF0ZSA9IG51bGwsIHRoaXMuX3NlbGVjdGVkRGF0ZSA9IG51bGwsIHRoaXMuX3NlbGVjdGVkWWVhciA9IG51bGwsIHRoaXMuX3NlbGVjdGVkTW9udGggPSBudWxsLCB0aGlzLl9oZWFkZXJEYXRlID0gbnVsbCwgdGhpcy5faGVhZGVyWWVhciA9IG51bGwsIHRoaXMuX2hlYWRlck1vbnRoID0gbnVsbCwgdGhpcy5fdmlldyA9IG51bGwsIHRoaXMuX3BvcHBlciA9IG51bGwsIHRoaXMuX2ZvY3VzVHJhcCA9IG51bGw7XG4gIH1cbiAgX3JlbW92ZUlucHV0QW5kVG9nZ2xlTGlzdGVuZXJzKCkge1xuICAgIGMub2ZmKHRoaXMuX2lucHV0LCBcImlucHV0XCIpLCBjLm9mZihcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBocyxcbiAgICAgIGRzXG4gICAgKSwgYy5vZmYodGhpcy5fZWxlbWVudCwgXCJrZXlkb3duXCIsIGRzKTtcbiAgfVxuICBoYW5kbGVPaygpIHtcbiAgICB0aGlzLl9jb25maXJtU2VsZWN0aW9uKHRoaXMuX2hlYWRlckRhdGUpLCB0aGlzLmNsb3NlKCk7XG4gIH1cbiAgX3NlbGVjdERhdGUodCwgZSA9IHRoaXMuYWN0aXZlQ2VsbCkge1xuICAgIGNvbnN0IHsgbWluOiBpLCBtYXg6IG4sIGZpbHRlcjogbywgZGlzYWJsZVBhc3Q6IHIsIGRpc2FibGVGdXR1cmU6IGEgfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgbm4odCwgaSwgbiwgbywgciwgYSkgfHwgKHRoaXMuX3JlbW92ZUN1cnJlbnRTZWxlY3Rpb25TdHlsZXMoKSwgdGhpcy5fcmVtb3ZlQ3VycmVudEZvY3VzU3R5bGVzKCksIHRoaXMuX2FkZFNlbGVjdGVkU3R5bGVzKGUpLCB0aGlzLl9zZWxlY3RlZERhdGUgPSB0LCB0aGlzLl9zZWxlY3RlZFllYXIgPSBCKHQpLCB0aGlzLl9zZWxlY3RlZE1vbnRoID0gWSh0KSwgdGhpcy5faGVhZGVyRGF0ZSA9IHQsICh0aGlzLl9vcHRpb25zLmlubGluZSB8fCB0aGlzLm9wdGlvbnMuY29uZmlybURhdGVPblNlbGVjdCkgJiYgKHRoaXMuX2NvbmZpcm1TZWxlY3Rpb24odCksIHRoaXMuY2xvc2UoKSkpO1xuICB9XG4gIF9zZWxlY3RZZWFyKHQsIGUgPSB0aGlzLmFjdGl2ZUNlbGwpIHtcbiAgICB0aGlzLl9yZW1vdmVDdXJyZW50U2VsZWN0aW9uU3R5bGVzKCksIHRoaXMuX3JlbW92ZUN1cnJlbnRGb2N1c1N0eWxlcygpLCB0aGlzLl9hZGRTZWxlY3RlZFN0eWxlcyhlKSwgdGhpcy5faGVhZGVyWWVhciA9IHQsIHRoaXMuX2FzeW5jQ2hhbmdlVmlldyhcIm1vbnRoc1wiKTtcbiAgfVxuICBfc2VsZWN0TW9udGgodCwgZSA9IHRoaXMuYWN0aXZlQ2VsbCkge1xuICAgIHRoaXMuX3JlbW92ZUN1cnJlbnRTZWxlY3Rpb25TdHlsZXMoKSwgdGhpcy5fcmVtb3ZlQ3VycmVudEZvY3VzU3R5bGVzKCksIHRoaXMuX2FkZFNlbGVjdGVkU3R5bGVzKGUpLCB0aGlzLl9oZWFkZXJNb250aCA9IHQsIHRoaXMuX2FzeW5jQ2hhbmdlVmlldyhcImRheXNcIik7XG4gIH1cbiAgX3JlbW92ZVNlbGVjdGVkU3R5bGVzKHQpIHtcbiAgICB0ICYmIHQucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtc2VsZWN0ZWRcIik7XG4gIH1cbiAgX2FkZFNlbGVjdGVkU3R5bGVzKHQpIHtcbiAgICB0ICYmIHQuc2V0QXR0cmlidXRlKFwiZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtc2VsZWN0ZWRcIiwgXCJcIik7XG4gIH1cbiAgX2NvbmZpcm1TZWxlY3Rpb24odCkge1xuICAgIGlmICh0KSB7XG4gICAgICBjb25zdCBlID0gdGhpcy5mb3JtYXREYXRlKHQpO1xuICAgICAgdGhpcy5faW5wdXQudmFsdWUgPSBlLCBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgSGYsIHsgZGF0ZTogdCB9KSwgYy50cmlnZ2VyKHRoaXMuX2lucHV0LCBcImlucHV0XCIpO1xuICAgIH1cbiAgfVxuICBoYW5kbGVDYW5jZWwoKSB7XG4gICAgdGhpcy5fc2VsZWN0ZWREYXRlID0gbnVsbCwgdGhpcy5fc2VsZWN0ZWRZZWFyID0gbnVsbCwgdGhpcy5fc2VsZWN0ZWRNb250aCA9IG51bGwsIHRoaXMuY2xvc2UoKTtcbiAgfVxuICBoYW5kbGVDbGVhcigpIHtcbiAgICB0aGlzLl9zZWxlY3RlZERhdGUgPSBudWxsLCB0aGlzLl9zZWxlY3RlZE1vbnRoID0gbnVsbCwgdGhpcy5fc2VsZWN0ZWRZZWFyID0gbnVsbCwgdGhpcy5faGVhZGVyRGF0ZSA9IG51bGwsIHRoaXMuX2hlYWRlck1vbnRoID0gbnVsbCwgdGhpcy5faGVhZGVyWWVhciA9IG51bGwsIHRoaXMuX3JlbW92ZUN1cnJlbnRTZWxlY3Rpb25TdHlsZXMoKSwgdGhpcy5faW5wdXQudmFsdWUgPSBcIlwiLCB0aGlzLl9zZXRJbml0aWFsRGF0ZSgpLCB0aGlzLl9jaGFuZ2VWaWV3KFwiZGF5c1wiKSwgdGhpcy5fdXBkYXRlSGVhZGVyRGF0ZShcbiAgICAgIHRoaXMuX2FjdGl2ZURhdGUsXG4gICAgICB0aGlzLl9vcHRpb25zLm1vbnRoc1Nob3J0LFxuICAgICAgdGhpcy5fb3B0aW9ucy53ZWVrZGF5c1Nob3J0XG4gICAgKTtcbiAgfVxuICBfcmVtb3ZlQ3VycmVudFNlbGVjdGlvblN0eWxlcygpIHtcbiAgICBjb25zdCB0ID0gZC5maW5kT25lKFxuICAgICAgXCJbZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtc2VsZWN0ZWRdXCIsXG4gICAgICB0aGlzLmNvbnRhaW5lclxuICAgICk7XG4gICAgdCAmJiB0LnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLXNlbGVjdGVkXCIpO1xuICB9XG4gIF9yZW1vdmVDdXJyZW50Rm9jdXNTdHlsZXMoKSB7XG4gICAgY29uc3QgdCA9IGQuZmluZE9uZShcbiAgICAgIFwiW2RhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLWZvY3VzZWRdXCIsXG4gICAgICB0aGlzLmNvbnRhaW5lclxuICAgICk7XG4gICAgdCAmJiB0LnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLWZvY3VzZWRcIik7XG4gIH1cbiAgZm9ybWF0RGF0ZSh0KSB7XG4gICAgY29uc3QgZSA9IFoodCksIGkgPSB0aGlzLl9hZGRMZWFkaW5nWmVybyhaKHQpKSwgbiA9IHRoaXMuX29wdGlvbnMud2Vla2RheXNTaG9ydFtWcyh0KV0sIG8gPSB0aGlzLl9vcHRpb25zLndlZWtkYXlzRnVsbFtWcyh0KV0sIHIgPSBZKHQpICsgMSwgYSA9IHRoaXMuX2FkZExlYWRpbmdaZXJvKFkodCkgKyAxKSwgbCA9IHRoaXMuX29wdGlvbnMubW9udGhzU2hvcnRbWSh0KV0sIHAgPSB0aGlzLl9vcHRpb25zLm1vbnRoc0Z1bGxbWSh0KV0sIHUgPSBCKHQpLnRvU3RyaW5nKCkubGVuZ3RoID09PSAyID8gQih0KSA6IEIodCkudG9TdHJpbmcoKS5zbGljZSgyLCA0KSwgXyA9IEIodCksIGYgPSB0aGlzLl9vcHRpb25zLmZvcm1hdC5zcGxpdChcbiAgICAgIC8oZHsxLDR9fG17MSw0fXx5ezR9fHl5fCEuKS9nXG4gICAgKTtcbiAgICBsZXQgZyA9IFwiXCI7XG4gICAgcmV0dXJuIGYuZm9yRWFjaCgobSkgPT4ge1xuICAgICAgc3dpdGNoIChtKSB7XG4gICAgICAgIGNhc2UgXCJkZGRkXCI6XG4gICAgICAgICAgbSA9IG0ucmVwbGFjZShtLCBvKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImRkZFwiOlxuICAgICAgICAgIG0gPSBtLnJlcGxhY2UobSwgbik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJkZFwiOlxuICAgICAgICAgIG0gPSBtLnJlcGxhY2UobSwgaSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJkXCI6XG4gICAgICAgICAgbSA9IG0ucmVwbGFjZShtLCBlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm1tbW1cIjpcbiAgICAgICAgICBtID0gbS5yZXBsYWNlKG0sIHApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibW1tXCI6XG4gICAgICAgICAgbSA9IG0ucmVwbGFjZShtLCBsKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm1tXCI6XG4gICAgICAgICAgbSA9IG0ucmVwbGFjZShtLCBhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm1cIjpcbiAgICAgICAgICBtID0gbS5yZXBsYWNlKG0sIHIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwieXl5eVwiOlxuICAgICAgICAgIG0gPSBtLnJlcGxhY2UobSwgXyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ5eVwiOlxuICAgICAgICAgIG0gPSBtLnJlcGxhY2UobSwgdSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBnICs9IG07XG4gICAgfSksIGc7XG4gIH1cbiAgX2FkZExlYWRpbmdaZXJvKHQpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQodCwgMTApIDwgMTAgPyBgMCR7dH1gIDogdDtcbiAgfVxuICBfcGlja0RheSh0LCBlKSB7XG4gICAgY29uc3QgaSA9IE9hKHQpLCB7IG1pbjogbiwgbWF4OiBvLCBmaWx0ZXI6IHIsIGRpc2FibGVQYXN0OiBhLCBkaXNhYmxlRnV0dXJlOiBsIH0gPSB0aGlzLl9vcHRpb25zO1xuICAgIG5uKGksIG4sIG8sIHIsIGEsIGwpIHx8ICh0aGlzLl9hY3RpdmVEYXRlID0gaSwgdGhpcy5fc2VsZWN0RGF0ZShpLCBlKSk7XG4gIH1cbiAgX3BpY2tZZWFyKHQpIHtcbiAgICBjb25zdCB7IG1pbjogZSwgbWF4OiBpLCBkaXNhYmxlUGFzdDogbiwgZGlzYWJsZUZ1dHVyZTogbyB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICBpZiAoQm8odCwgZSwgaSwgbiwgbykpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgciA9IEV0KHQsIHRoaXMuYWN0aXZlTW9udGgsIHRoaXMuYWN0aXZlRGF5KTtcbiAgICB0aGlzLl9hY3RpdmVEYXRlID0gciwgdGhpcy5fc2VsZWN0ZWREYXRlID0gciwgdGhpcy5fc2VsZWN0WWVhcih0KTtcbiAgfVxuICBfcGlja01vbnRoKHQsIGUpIHtcbiAgICBjb25zdCB7IG1pbjogaSwgbWF4OiBuLCBkaXNhYmxlUGFzdDogbywgZGlzYWJsZUZ1dHVyZTogciB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICBpZiAoemModCwgZSwgaSwgbiwgbywgcikgfHwgQm8oZSwgaSwgbiwgbywgcikpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgYSA9IEV0KGUsIHQsIHRoaXMuYWN0aXZlRGF5KTtcbiAgICB0aGlzLl9hY3RpdmVEYXRlID0gYSwgdGhpcy5fc2VsZWN0TW9udGgodCk7XG4gIH1cbiAgbmV4dE1vbnRoKCkge1xuICAgIGNvbnN0IHQgPSBudCh0aGlzLl9hY3RpdmVEYXRlLCAxKSwgZSA9IEZzKFxuICAgICAgdCxcbiAgICAgIHRoaXMuX2hlYWRlckRhdGUsXG4gICAgICB0aGlzLl9vcHRpb25zLFxuICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICk7XG4gICAgdGhpcy5fYWN0aXZlRGF0ZSA9IHQsIHRoaXMudmlld0NoYW5nZUJ1dHRvbi50ZXh0Q29udGVudCA9IGAke3RoaXMuX29wdGlvbnMubW9udGhzRnVsbFt0aGlzLmFjdGl2ZU1vbnRoXX0gJHt0aGlzLmFjdGl2ZVllYXJ9YCwgdGhpcy52aWV3Q2hhbmdlQnV0dG9uLmlubmVySFRNTCArPSAkdChcbiAgICAgIHRoaXMuX29wdGlvbnMsXG4gICAgICB0aGlzLl9jbGFzc2VzXG4gICAgKSwgdGhpcy5kYXRlc0NvbnRhaW5lci5pbm5lckhUTUwgPSBlO1xuICB9XG4gIHByZXZpb3VzTW9udGgoKSB7XG4gICAgY29uc3QgdCA9IG50KHRoaXMuX2FjdGl2ZURhdGUsIC0xKTtcbiAgICB0aGlzLl9hY3RpdmVEYXRlID0gdDtcbiAgICBjb25zdCBlID0gRnMoXG4gICAgICB0LFxuICAgICAgdGhpcy5faGVhZGVyRGF0ZSxcbiAgICAgIHRoaXMuX29wdGlvbnMsXG4gICAgICB0aGlzLl9jbGFzc2VzXG4gICAgKTtcbiAgICB0aGlzLnZpZXdDaGFuZ2VCdXR0b24udGV4dENvbnRlbnQgPSBgJHt0aGlzLl9vcHRpb25zLm1vbnRoc0Z1bGxbdGhpcy5hY3RpdmVNb250aF19ICR7dGhpcy5hY3RpdmVZZWFyfWAsIHRoaXMudmlld0NoYW5nZUJ1dHRvbi5pbm5lckhUTUwgKz0gJHQoXG4gICAgICB0aGlzLl9vcHRpb25zLFxuICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICksIHRoaXMuZGF0ZXNDb250YWluZXIuaW5uZXJIVE1MID0gZTtcbiAgfVxuICBuZXh0WWVhcigpIHtcbiAgICBjb25zdCB0ID0gaXQodGhpcy5fYWN0aXZlRGF0ZSwgMSk7XG4gICAgdGhpcy5fYWN0aXZlRGF0ZSA9IHQsIHRoaXMudmlld0NoYW5nZUJ1dHRvbi50ZXh0Q29udGVudCA9IGAke3RoaXMuYWN0aXZlWWVhcn1gLCB0aGlzLnZpZXdDaGFuZ2VCdXR0b24uaW5uZXJIVE1MICs9ICR0KFxuICAgICAgdGhpcy5fb3B0aW9ucyxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApO1xuICAgIGNvbnN0IGUgPSBZcyhcbiAgICAgIHRoaXMuYWN0aXZlWWVhcixcbiAgICAgIHRoaXMuX3NlbGVjdGVkWWVhcixcbiAgICAgIHRoaXMuX3NlbGVjdGVkTW9udGgsXG4gICAgICB0aGlzLl9vcHRpb25zLFxuICAgICAgY3MsXG4gICAgICB0aGlzLl9jbGFzc2VzXG4gICAgKTtcbiAgICB0aGlzLmRhdGVzQ29udGFpbmVyLmlubmVySFRNTCA9IGU7XG4gIH1cbiAgcHJldmlvdXNZZWFyKCkge1xuICAgIGNvbnN0IHQgPSBpdCh0aGlzLl9hY3RpdmVEYXRlLCAtMSk7XG4gICAgdGhpcy5fYWN0aXZlRGF0ZSA9IHQsIHRoaXMudmlld0NoYW5nZUJ1dHRvbi50ZXh0Q29udGVudCA9IGAke3RoaXMuYWN0aXZlWWVhcn1gLCB0aGlzLnZpZXdDaGFuZ2VCdXR0b24uaW5uZXJIVE1MICs9ICR0KFxuICAgICAgdGhpcy5fb3B0aW9ucyxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApO1xuICAgIGNvbnN0IGUgPSBZcyhcbiAgICAgIHRoaXMuYWN0aXZlWWVhcixcbiAgICAgIHRoaXMuX3NlbGVjdGVkWWVhcixcbiAgICAgIHRoaXMuX3NlbGVjdGVkTW9udGgsXG4gICAgICB0aGlzLl9vcHRpb25zLFxuICAgICAgY3MsXG4gICAgICB0aGlzLl9jbGFzc2VzXG4gICAgKTtcbiAgICB0aGlzLmRhdGVzQ29udGFpbmVyLmlubmVySFRNTCA9IGU7XG4gIH1cbiAgbmV4dFllYXJzKCkge1xuICAgIGNvbnN0IHQgPSBpdCh0aGlzLl9hY3RpdmVEYXRlLCAyNCk7XG4gICAgdGhpcy5fYWN0aXZlRGF0ZSA9IHQ7XG4gICAgY29uc3QgZSA9IGpzKFxuICAgICAgdCxcbiAgICAgIHRoaXMuX3NlbGVjdGVkWWVhcixcbiAgICAgIHRoaXMuX29wdGlvbnMsXG4gICAgICB2dCxcbiAgICAgIGxzLFxuICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICk7XG4gICAgdGhpcy52aWV3Q2hhbmdlQnV0dG9uLnRleHRDb250ZW50ID0gYCR7dGhpcy5maXJzdFllYXJJblZpZXd9IC0gJHt0aGlzLmxhc3RZZWFySW5WaWV3fWAsIHRoaXMudmlld0NoYW5nZUJ1dHRvbi5pbm5lckhUTUwgKz0gJHQoXG4gICAgICB0aGlzLl9vcHRpb25zLFxuICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICksIHRoaXMuZGF0ZXNDb250YWluZXIuaW5uZXJIVE1MID0gZTtcbiAgfVxuICBwcmV2aW91c1llYXJzKCkge1xuICAgIGNvbnN0IHQgPSBpdCh0aGlzLl9hY3RpdmVEYXRlLCAtMjQpO1xuICAgIHRoaXMuX2FjdGl2ZURhdGUgPSB0O1xuICAgIGNvbnN0IGUgPSBqcyhcbiAgICAgIHQsXG4gICAgICB0aGlzLl9zZWxlY3RlZFllYXIsXG4gICAgICB0aGlzLl9vcHRpb25zLFxuICAgICAgdnQsXG4gICAgICBscyxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApO1xuICAgIHRoaXMudmlld0NoYW5nZUJ1dHRvbi50ZXh0Q29udGVudCA9IGAke3RoaXMuZmlyc3RZZWFySW5WaWV3fSAtICR7dGhpcy5sYXN0WWVhckluVmlld31gLCB0aGlzLnZpZXdDaGFuZ2VCdXR0b24uaW5uZXJIVE1MICs9ICR0KFxuICAgICAgdGhpcy5fb3B0aW9ucyxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApLCB0aGlzLmRhdGVzQ29udGFpbmVyLmlubmVySFRNTCA9IGU7XG4gIH1cbiAgX2FzeW5jQ2hhbmdlVmlldyh0KSB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLl9jaGFuZ2VWaWV3KHQpO1xuICAgIH0sIDApO1xuICB9XG4gIF9jaGFuZ2VWaWV3KHQpIHtcbiAgICB0aGlzLl92aWV3ID0gdCwgdGhpcy5kYXRlc0NvbnRhaW5lci5ibHVyKCksIHQgPT09IFwiZGF5c1wiICYmICh0aGlzLmRhdGVzQ29udGFpbmVyLmlubmVySFRNTCA9IEZzKFxuICAgICAgdGhpcy5fYWN0aXZlRGF0ZSxcbiAgICAgIHRoaXMuX2hlYWRlckRhdGUsXG4gICAgICB0aGlzLl9vcHRpb25zLFxuICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICkpLCB0ID09PSBcIm1vbnRoc1wiICYmICh0aGlzLmRhdGVzQ29udGFpbmVyLmlubmVySFRNTCA9IFlzKFxuICAgICAgdGhpcy5hY3RpdmVZZWFyLFxuICAgICAgdGhpcy5fc2VsZWN0ZWRZZWFyLFxuICAgICAgdGhpcy5fc2VsZWN0ZWRNb250aCxcbiAgICAgIHRoaXMuX29wdGlvbnMsXG4gICAgICBjcyxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApKSwgdCA9PT0gXCJ5ZWFyc1wiICYmICh0aGlzLmRhdGVzQ29udGFpbmVyLmlubmVySFRNTCA9IGpzKFxuICAgICAgdGhpcy5fYWN0aXZlRGF0ZSxcbiAgICAgIHRoaXMuX3NlbGVjdGVkWWVhcixcbiAgICAgIHRoaXMuX29wdGlvbnMsXG4gICAgICB2dCxcbiAgICAgIGxzLFxuICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICkpLCB0aGlzLmRhdGVzQ29udGFpbmVyLmZvY3VzKCksIHRoaXMuX3VwZGF0ZVZpZXdDb250cm9sc0FuZEF0dHJpYnV0ZXModCksIHRoaXMuX3VwZGF0ZUNvbnRyb2xzRGlzYWJsZWRTdGF0ZSgpO1xuICB9XG4gIF91cGRhdGVWaWV3Q29udHJvbHNBbmRBdHRyaWJ1dGVzKHQpIHtcbiAgICB0ID09PSBcImRheXNcIiAmJiAodGhpcy52aWV3Q2hhbmdlQnV0dG9uLnRleHRDb250ZW50ID0gYCR7dGhpcy5fb3B0aW9ucy5tb250aHNGdWxsW3RoaXMuYWN0aXZlTW9udGhdfSAke3RoaXMuYWN0aXZlWWVhcn1gLCB0aGlzLnZpZXdDaGFuZ2VCdXR0b24uaW5uZXJIVE1MICs9ICR0KFxuICAgICAgdGhpcy5fb3B0aW9ucyxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApLCB0aGlzLnZpZXdDaGFuZ2VCdXR0b24uc2V0QXR0cmlidXRlKFxuICAgICAgXCJhcmlhLWxhYmVsXCIsXG4gICAgICB0aGlzLl9vcHRpb25zLnN3aXRjaFRvTXVsdGlZZWFyVmlld0xhYmVsXG4gICAgKSwgdGhpcy5wcmV2aW91c0J1dHRvbi5zZXRBdHRyaWJ1dGUoXG4gICAgICBcImFyaWEtbGFiZWxcIixcbiAgICAgIHRoaXMuX29wdGlvbnMucHJldk1vbnRoTGFiZWxcbiAgICApLCB0aGlzLm5leHRCdXR0b24uc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCB0aGlzLl9vcHRpb25zLm5leHRNb250aExhYmVsKSksIHQgPT09IFwibW9udGhzXCIgJiYgKHRoaXMudmlld0NoYW5nZUJ1dHRvbi50ZXh0Q29udGVudCA9IGAke3RoaXMuYWN0aXZlWWVhcn1gLCB0aGlzLnZpZXdDaGFuZ2VCdXR0b24uaW5uZXJIVE1MICs9ICR0KFxuICAgICAgdGhpcy5fb3B0aW9ucyxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApLCB0aGlzLnZpZXdDaGFuZ2VCdXR0b24uc2V0QXR0cmlidXRlKFxuICAgICAgXCJhcmlhLWxhYmVsXCIsXG4gICAgICB0aGlzLl9vcHRpb25zLnN3aXRjaFRvRGF5Vmlld0xhYmVsXG4gICAgKSwgdGhpcy5wcmV2aW91c0J1dHRvbi5zZXRBdHRyaWJ1dGUoXG4gICAgICBcImFyaWEtbGFiZWxcIixcbiAgICAgIHRoaXMuX29wdGlvbnMucHJldlllYXJMYWJlbFxuICAgICksIHRoaXMubmV4dEJ1dHRvbi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIHRoaXMuX29wdGlvbnMubmV4dFllYXJMYWJlbCkpLCB0ID09PSBcInllYXJzXCIgJiYgKHRoaXMudmlld0NoYW5nZUJ1dHRvbi50ZXh0Q29udGVudCA9IGAke3RoaXMuZmlyc3RZZWFySW5WaWV3fSAtICR7dGhpcy5sYXN0WWVhckluVmlld31gLCB0aGlzLnZpZXdDaGFuZ2VCdXR0b24uaW5uZXJIVE1MICs9ICR0KFxuICAgICAgdGhpcy5fb3B0aW9ucyxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApLCB0aGlzLnZpZXdDaGFuZ2VCdXR0b24uc2V0QXR0cmlidXRlKFxuICAgICAgXCJhcmlhLWxhYmVsXCIsXG4gICAgICB0aGlzLl9vcHRpb25zLnN3aXRjaFRvTW9udGhWaWV3TGFiZWxcbiAgICApLCB0aGlzLnByZXZpb3VzQnV0dG9uLnNldEF0dHJpYnV0ZShcbiAgICAgIFwiYXJpYS1sYWJlbFwiLFxuICAgICAgdGhpcy5fb3B0aW9ucy5wcmV2TXVsdGlZZWFyTGFiZWxcbiAgICApLCB0aGlzLm5leHRCdXR0b24uc2V0QXR0cmlidXRlKFxuICAgICAgXCJhcmlhLWxhYmVsXCIsXG4gICAgICB0aGlzLl9vcHRpb25zLm5leHRNdWx0aVllYXJMYWJlbFxuICAgICkpO1xuICB9XG4gIF91cGRhdGVDb250cm9sc0Rpc2FibGVkU3RhdGUoKSB7XG4gICAgX2YoXG4gICAgICB0aGlzLl9vcHRpb25zLmRpc2FibGVGdXR1cmUsXG4gICAgICB0aGlzLl9hY3RpdmVEYXRlLFxuICAgICAgdGhpcy5fdmlldyxcbiAgICAgIHZ0LFxuICAgICAgdGhpcy5fb3B0aW9ucy5taW4sXG4gICAgICB0aGlzLl9vcHRpb25zLm1heCxcbiAgICAgIHRoaXMubGFzdFllYXJJblZpZXcsXG4gICAgICB0aGlzLmZpcnN0WWVhckluVmlld1xuICAgICkgPyB0aGlzLm5leHRCdXR0b24uZGlzYWJsZWQgPSAhMCA6IHRoaXMubmV4dEJ1dHRvbi5kaXNhYmxlZCA9ICExLCBmZihcbiAgICAgIHRoaXMuX29wdGlvbnMuZGlzYWJsZVBhc3QsXG4gICAgICB0aGlzLl9hY3RpdmVEYXRlLFxuICAgICAgdGhpcy5fdmlldyxcbiAgICAgIHZ0LFxuICAgICAgdGhpcy5fb3B0aW9ucy5taW4sXG4gICAgICB0aGlzLl9vcHRpb25zLm1heCxcbiAgICAgIHRoaXMubGFzdFllYXJJblZpZXcsXG4gICAgICB0aGlzLmZpcnN0WWVhckluVmlld1xuICAgICkgPyB0aGlzLnByZXZpb3VzQnV0dG9uLmRpc2FibGVkID0gITAgOiB0aGlzLnByZXZpb3VzQnV0dG9uLmRpc2FibGVkID0gITE7XG4gIH1cbiAgX2hhbmRsZVVzZXJJbnB1dCh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuX2dldERlbGltZXRlcnModGhpcy5fb3B0aW9ucy5mb3JtYXQpLCBpID0gdGhpcy5fcGFyc2VEYXRlKHQsIHRoaXMuX29wdGlvbnMuZm9ybWF0LCBlKTtcbiAgICBkZihpKSA/ICh0aGlzLl9hY3RpdmVEYXRlID0gaSwgdGhpcy5fc2VsZWN0ZWREYXRlID0gaSwgdGhpcy5fc2VsZWN0ZWRZZWFyID0gQihpKSwgdGhpcy5fc2VsZWN0ZWRNb250aCA9IFkoaSksIHRoaXMuX2hlYWRlckRhdGUgPSBpKSA6ICh0aGlzLl9hY3RpdmVEYXRlID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksIHRoaXMuX3NlbGVjdGVkRGF0ZSA9IG51bGwsIHRoaXMuX3NlbGVjdGVkTW9udGggPSBudWxsLCB0aGlzLl9zZWxlY3RlZFllYXIgPSBudWxsLCB0aGlzLl9oZWFkZXJEYXRlID0gbnVsbCwgdGhpcy5faGVhZGVyTW9udGggPSBudWxsLCB0aGlzLl9oZWFkZXJZZWFyID0gbnVsbCk7XG4gIH1cbiAgX2dldERlbGltZXRlcnModCkge1xuICAgIHJldHVybiB0Lm1hdGNoKC9bXihkbXkpXXsxLH0vZyk7XG4gIH1cbiAgX3BhcnNlRGF0ZSh0LCBlLCBpKSB7XG4gICAgbGV0IG47XG4gICAgaVswXSAhPT0gaVsxXSA/IG4gPSBpWzBdICsgaVsxXSA6IG4gPSBpWzBdO1xuICAgIGNvbnN0IG8gPSBuZXcgUmVnRXhwKGBbJHtufV1gKSwgciA9IHQuc3BsaXQobyksIGEgPSBlLnNwbGl0KG8pLCBsID0gZS5pbmRleE9mKFwibW1tXCIpICE9PSAtMSwgcCA9IFtdO1xuICAgIGZvciAobGV0IGIgPSAwOyBiIDwgYS5sZW5ndGg7IGIrKylcbiAgICAgIGFbYl0uaW5kZXhPZihcInl5XCIpICE9PSAtMSAmJiAocFswXSA9IHsgdmFsdWU6IHJbYl0sIGZvcm1hdDogYVtiXSB9KSwgYVtiXS5pbmRleE9mKFwibVwiKSAhPT0gLTEgJiYgKHBbMV0gPSB7IHZhbHVlOiByW2JdLCBmb3JtYXQ6IGFbYl0gfSksIGFbYl0uaW5kZXhPZihcImRcIikgIT09IC0xICYmIGFbYl0ubGVuZ3RoIDw9IDIgJiYgKHBbMl0gPSB7IHZhbHVlOiByW2JdLCBmb3JtYXQ6IGFbYl0gfSk7XG4gICAgbGV0IHU7XG4gICAgZS5pbmRleE9mKFwibW1tbVwiKSAhPT0gLTEgPyB1ID0gdGhpcy5fb3B0aW9ucy5tb250aHNGdWxsIDogdSA9IHRoaXMuX29wdGlvbnMubW9udGhzU2hvcnQ7XG4gICAgY29uc3QgXyA9IE51bWJlcihwWzBdLnZhbHVlKSwgZiA9IGwgPyB0aGlzLmdldE1vbnRoTnVtYmVyQnlNb250aE5hbWUocFsxXS52YWx1ZSwgdSkgOiBOdW1iZXIocFsxXS52YWx1ZSkgLSAxLCBnID0gTnVtYmVyKHBbMl0udmFsdWUpO1xuICAgIHJldHVybiBFdChfLCBmLCBnKTtcbiAgfVxuICBnZXRNb250aE51bWJlckJ5TW9udGhOYW1lKHQsIGUpIHtcbiAgICByZXR1cm4gZS5maW5kSW5kZXgoKGkpID0+IGkgPT09IHQpO1xuICB9XG4gIHN0YXRpYyBnZXRJbnN0YW5jZSh0KSB7XG4gICAgcmV0dXJuIHkuZ2V0RGF0YSh0LCB6cyk7XG4gIH1cbiAgc3RhdGljIGdldE9yQ3JlYXRlSW5zdGFuY2UodCwgZSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UodCkgfHwgbmV3IHRoaXModCwgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiA/IGUgOiBudWxsKTtcbiAgfVxufVxuY29uc3QgTW0gPSAoe1xuICBmb3JtYXQyNDogcyxcbiAgb2tMYWJlbDogdCxcbiAgY2FuY2VsTGFiZWw6IGUsXG4gIGhlYWRJRDogaSxcbiAgZm9vdGVySUQ6IG4sXG4gIGJvZHlJRDogbyxcbiAgcGlja2VySUQ6IHIsXG4gIGNsZWFyTGFiZWw6IGEsXG4gIGlubGluZTogbCxcbiAgc2hvd0NsZWFyQnRuOiBwLFxuICBhbUxhYmVsOiB1LFxuICBwbUxhYmVsOiBfXG59LCBmKSA9PiB7XG4gIGNvbnN0IGcgPSBgPGRpdiBpZD0nJHtyfScgY2xhc3M9JyR7Zi50aW1lcGlja2VyV3JhcHBlcn0nIGRhdGEtdGUtdGltZXBpY2tlci13cmFwcGVyPlxuICAgICAgPGRpdiBjbGFzcz1cIiR7Zi50aW1lcGlja2VyQ29udGFpbmVyfVwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiJHtmLnRpbWVwaWNrZXJFbGVtZW50c31cIiBkYXRhLXRlLXRpbWVwaWNrZXItZWxlbWVudHMtd3JhcHBlcj5cbiAgICAgICAgPGRpdiBpZD0nJHtpfScgY2xhc3M9JyR7Zi50aW1lcGlja2VySGVhZH0nIHN0eWxlPSdwYWRkaW5nLXJpZ2h0OiR7cyA/IDUwIDogMTB9cHgnPlxuICAgICAgICA8ZGl2IGNsYXNzPScke2YudGltZXBpY2tlckhlYWRDb250ZW50fSc+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiJHtmLnRpbWVwaWNrZXJDdXJyZW50V3JhcHBlcn1cIj5cbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCIke2YudGltZXBpY2tlckN1cnJlbnRCdXR0b25XcmFwcGVyfVwiPlxuICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT0nYnV0dG9uJyBjbGFzcz0nJHtmLnRpbWVwaWNrZXJDdXJyZW50QnV0dG9ufScgdGFiaW5kZXg9XCIwXCIgZGF0YS10ZS10aW1lcGlja2VyLWFjdGl2ZSBkYXRhLXRlLXRpbWVwaWNrZXItY3VycmVudCBkYXRhLXRlLXRpbWVwaWNrZXItaG91ciBkYXRhLXRlLXJpcHBsZS1pbml0PjIxPC9idXR0b24+XG4gICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPSdidXR0b24nIGNsYXNzPScke2YudGltZXBpY2tlckRvdH0nIGRpc2FibGVkPjo8L2J1dHRvbj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiJHtmLnRpbWVwaWNrZXJDdXJyZW50QnV0dG9uV3JhcHBlcn1cIj5cbiAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPSdidXR0b24nIGNsYXNzPScke2YudGltZXBpY2tlckN1cnJlbnRCdXR0b259JyB0YWJpbmRleD1cIjBcIiBkYXRhLXRlLXRpbWVwaWNrZXItY3VycmVudCBkYXRhLXRlLXRpbWVwaWNrZXItbWludXRlIGRhdGEtdGUtcmlwcGxlLWluaXQ+MjE8L2J1dHRvbj5cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgJHtzID8gXCJcIiA6IGA8ZGl2IGNsYXNzPVwiJHtmLnRpbWVwaWNrZXJNb2RlV3JhcHBlcn1cIj5cbiAgICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT0nYnV0dG9uJyBjbGFzcz1cIiR7Zi50aW1lcGlja2VyTW9kZUFtfVwiIHRhYmluZGV4PVwiMFwiIGRhdGEtdGUtdGltZXBpY2tlci1hbSBkYXRhLXRlLXRpbWVwaWNrZXItaG91ci1tb2RlIGRhdGEtdGUtcmlwcGxlLWluaXQ+JHt1fTwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cIiR7Zi50aW1lcGlja2VyTW9kZVBtfVwiIHRhYmluZGV4PVwiMFwiIGRhdGEtdGUtdGltZXBpY2tlci1wbSBkYXRhLXRlLXRpbWVwaWNrZXItaG91ci1tb2RlIGRhdGEtdGUtcmlwcGxlLWluaXQ+JHtffTwvYnV0dG9uPlxuICAgICAgICAgICAgICAgIDwvZGl2PmB9XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgICAke2wgPyBcIlwiIDogYDxkaXYgaWQ9JyR7b30nIGNsYXNzPScke2YudGltZXBpY2tlckNsb2NrV3JhcHBlcn0nIGRhdGEtdGUtdGltZXBpY2tlci1jbG9jay13cmFwcGVyPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz0nJHtmLnRpbWVwaWNrZXJDbG9ja30nIGRhdGEtdGUtdGltZXBpY2tlci1jbG9jaz5cbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9JyR7Zi50aW1lcGlja2VyTWlkZGxlRG90fScgZGF0YS10ZS10aW1lcGlja2VyLW1pZGRsZS1kb3Q+PC9zcGFuPlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPScke2YudGltZXBpY2tlckhhbmRQb2ludGVyfScgZGF0YS10ZS10aW1lcGlja2VyLWhhbmQtcG9pbnRlcj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPScke2YudGltZXBpY2tlclBvaW50ZXJDaXJjbGV9JyBkYXRhLXRlLXRpbWVwaWNrZXItY2lyY2xlPjwvZGl2PlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgJHtzID8gJzxkaXYgY2xhc3M9XCInICsgZi50aW1lcGlja2VyQ2xvY2tJbm5lciArICdcIiBkYXRhLXRlLXRpbWVwaWNrZXItY2xvY2staW5uZXI+PC9kaXY+JyA6IFwiXCJ9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5gfVxuICAgIDwvZGl2PlxuICAgIDxkaXYgaWQ9JyR7bn0nIGNsYXNzPScke2YudGltZXBpY2tlckZvb3RlcldyYXBwZXJ9Jz5cbiAgICAgIDxkaXYgY2xhc3M9XCIke2YudGltZXBpY2tlckZvb3Rlcn1cIj5cbiAgICAgICAgJHtwID8gYDxidXR0b24gdHlwZT0nYnV0dG9uJyBjbGFzcz0nJHtmLnRpbWVwaWNrZXJGb290ZXJCdXR0b259JyBkYXRhLXRlLXRpbWVwaWNrZXItY2xlYXIgdGFiaW5kZXg9XCIwXCIgZGF0YS10ZS1yaXBwbGUtaW5pdD4ke2F9PC9idXR0b24+YCA6IFwiXCJ9XG4gICAgICAgIDxidXR0b24gdHlwZT0nYnV0dG9uJyBjbGFzcz0nJHtmLnRpbWVwaWNrZXJGb290ZXJCdXR0b259JyBkYXRhLXRlLXRpbWVwaWNrZXItY2FuY2VsIHRhYmluZGV4PVwiMFwiIGRhdGEtdGUtcmlwcGxlLWluaXQ+JHtlfTwvYnV0dG9uPlxuICAgICAgICA8YnV0dG9uIHR5cGU9J2J1dHRvbicgY2xhc3M9JyR7Zi50aW1lcGlja2VyRm9vdGVyQnV0dG9ufScgZGF0YS10ZS10aW1lcGlja2VyLXN1Ym1pdCB0YWJpbmRleD1cIjBcIiBkYXRhLXRlLXJpcHBsZS1pbml0PiR7dH08L2J1dHRvbj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvZGl2PmAsIG0gPSBgPGRpdiBpZD0nJHtyfScgY2xhc3M9JyR7Zi50aW1lcGlja2VySW5saW5lV3JhcHBlcn0nIGRhdGEtdGUtdGltZXBpY2tlci13cmFwcGVyPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiJHtmLnRpbWVwaWNrZXJJbmxpbmVDb250YWluZXJ9XCI+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cIiR7Zi50aW1lcGlja2VySW5saW5lRWxlbWVudHN9XCIgZGF0YS10ZS10aW1lcGlja2VyLWVsZW1lbnRzLXdyYXBwZXI+XG4gICAgICAgICAgPGRpdiBpZD0nJHtpfScgY2xhc3M9JyR7Zi50aW1lcGlja2VySW5saW5lSGVhZH0nXG4gICAgICAgICAgc3R5bGU9J3BhZGRpbmctcmlnaHQ6MTBweCc+XG4gICAgICAgICAgPGRpdiBjbGFzcz0nJHtmLnRpbWVwaWNrZXJJbmxpbmVIZWFkQ29udGVudH0nPlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiJHtmLnRpbWVwaWNrZXJDdXJyZW50V3JhcHBlcn1cIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cIiR7Zi50aW1lcGlja2VySW5saW5lSG91cldyYXBwZXJ9XCIgZGF0YS10ZS10aW1lcGlja2VyLWlubGluZS1ob3VyLWljb25zPlxuICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCIke2YudGltZXBpY2tlcklubGluZUljb25VcH1cIiBkYXRhLXRlLXRpbWVwaWNrZXItaWNvbi11cCBkYXRhLXRlLXRpbWVwaWNrZXItaWNvbi1pbmxpbmUtaG91cj5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCIke2YudGltZXBpY2tlcklubGluZUljb25Tdmd9XCI+XG4gICAgICAgICAgICAgICAgICAgICAgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMS41XCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgY2xhc3M9XCJ3LTUgaC01XCI+XG4gICAgICAgICAgICAgICAgICAgICAgPHBhdGggc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgZD1cIk00LjUgMTUuNzVsNy41LTcuNSA3LjUgNy41XCIgLz5cbiAgICAgICAgICAgICAgICAgICAgICA8L3N2Zz4gICBcbiAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPSdidXR0b24nIGNsYXNzPScke2YudGltZXBpY2tlcklubGluZUN1cnJlbnRCdXR0b259JyBkYXRhLXRlLXRpbWVwaWNrZXItaG91ciBkYXRhLXRlLXRpbWVwaWNrZXItY3VycmVudCBkYXRhLXRlLXRpbWVwaWNrZXItY3VycmVudC1pbmxpbmUgdGFiaW5kZXg9XCIwXCIgZGF0YS10ZS1yaXBwbGUtaW5pdD4yMTwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCIke2YudGltZXBpY2tlcklubGluZUljb25Eb3dufVwiIGRhdGEtdGUtdGltZXBpY2tlci1pY29uLWlubGluZS1ob3VyIGRhdGEtdGUtdGltZXBpY2tlci1pY29uLWRvd24+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiJHtmLnRpbWVwaWNrZXJJbmxpbmVJY29uU3ZnfVwiPlxuICAgICAgICAgICAgICAgICAgICAgIDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjEuNVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGNsYXNzPVwidy01IGgtNVwiPlxuICAgICAgICAgICAgICAgICAgICAgIDxwYXRoIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIGQ9XCJNMTkuNSA4LjI1bC03LjUgNy41LTcuNS03LjVcIiAvPlxuICAgICAgICAgICAgICAgICAgICAgIDwvc3ZnPiAgXG4gICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPSdidXR0b24nIGNsYXNzPScke2YudGltZXBpY2tlcklubGluZURvdH0nIGRhdGEtdGUtdGltZXBpY2tlci1jdXJyZW50LWlubGluZSBkaXNhYmxlZD46PC9idXR0b24+XG4gICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiJHtmLnRpbWVwaWNrZXJDdXJyZW50TWludXRlV3JhcHBlcn1cIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cIiR7Zi50aW1lcGlja2VySW5saW5lSWNvblVwfVwiIGRhdGEtdGUtdGltZXBpY2tlci1pY29uLXVwIGRhdGEtdGUtdGltZXBpY2tlci1pY29uLWlubGluZS1taW51dGU+XG4gICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cIiR7Zi50aW1lcGlja2VySW5saW5lSWNvblN2Z31cIj5cbiAgICAgICAgICAgICAgICAgICAgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMS41XCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgY2xhc3M9XCJ3LTUgaC01XCI+XG4gICAgICAgICAgICAgICAgICAgIDxwYXRoIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIGQ9XCJNNC41IDE1Ljc1bDcuNS03LjUgNy41IDcuNVwiIC8+XG4gICAgICAgICAgICAgICAgICAgIDwvc3ZnPlxuICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9J2J1dHRvbicgY2xhc3M9JyR7Zi50aW1lcGlja2VySW5saW5lQ3VycmVudEJ1dHRvbn0nIGRhdGEtdGUtdGltZXBpY2tlci1taW51dGUgZGF0YS10ZS10aW1lcGlja2VyLWN1cnJlbnQgZGF0YS10ZS10aW1lcGlja2VyLWN1cnJlbnQtaW5saW5lIHRhYmluZGV4PVwiMFwiIGRhdGEtdGUtcmlwcGxlLWluaXQ+MjE8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cIiR7Zi50aW1lcGlja2VySW5saW5lSWNvbkRvd259XCIgZGF0YS10ZS10aW1lcGlja2VyLWljb24taW5saW5lLW1pbnV0ZSBkYXRhLXRlLXRpbWVwaWNrZXItaWNvbi1kb3duPlxuICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCIke2YudGltZXBpY2tlcklubGluZUljb25Tdmd9XCI+XG4gICAgICAgICAgICAgICAgICAgIDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjEuNVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGNsYXNzPVwidy01IGgtNVwiPlxuICAgICAgICAgICAgICAgICAgICA8cGF0aCBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBkPVwiTTE5LjUgOC4yNWwtNy41IDcuNS03LjUtNy41XCIgLz5cbiAgICAgICAgICAgICAgICAgICAgPC9zdmc+IFxuICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgJHtzID8gXCJcIiA6IGA8ZGl2IGNsYXNzPVwiJHtmLnRpbWVwaWNrZXJJbmxpbmVNb2RlV3JhcHBlcn1cIj5cbiAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9J2J1dHRvbicgY2xhc3M9XCIke2YudGltZXBpY2tlcklubGluZU1vZGVBbX1cIiBkYXRhLXRlLXRpbWVwaWNrZXItYW0gZGF0YS10ZS10aW1lcGlja2VyLWhvdXItbW9kZSB0YWJpbmRleD1cIjBcIiBkYXRhLXRlLXJpcHBsZS1pbml0PiR7dX08L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiJHtmLnRpbWVwaWNrZXJJbmxpbmVNb2RlUG19XCIgZGF0YS10ZS10aW1lcGlja2VyLWhvdXItbW9kZSBkYXRhLXRlLXRpbWVwaWNrZXItcG0gdGFiaW5kZXg9XCIwXCIgZGF0YS10ZS1yaXBwbGUtaW5pdD4ke199PC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPSdidXR0b24nIGNsYXNzPScke2YudGltZXBpY2tlcklubGluZVN1Ym1pdEJ1dHRvbn0nIGRhdGEtdGUtdGltZXBpY2tlci1zdWJtaXQgdGFiaW5kZXg9XCIwXCIgZGF0YS10ZS1yaXBwbGUtaW5pdD4ke3R9PC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PmB9XG4gICAgICAgICAgICAgICR7cyA/IGA8YnV0dG9uIGNsYXNzPScke2YudGltZXBpY2tlcklubGluZVN1Ym1pdEJ1dHRvbn0nIGRhdGEtdGUtdGltZXBpY2tlci1zdWJtaXQgdGFiaW5kZXg9XCIwXCIgZGF0YS10ZS1yaXBwbGUtaW5pdD4ke3R9PC9idXR0b24+YCA6IFwiXCJ9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG48L2Rpdj5gO1xuICByZXR1cm4gbCA/IG0gOiBnO1xufSwgUm0gPSAocywgdCwgZSkgPT4ge1xuICBjb25zdCB7IGljb25TVkc6IGkgfSA9IHM7XG4gIHJldHVybiBgXG4gIDxidXR0b24gaWQ9XCIke3R9XCIgdGFiaW5kZXg9XCIwXCIgdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiJHtlLnRpbWVwaWNrZXJUb2dnbGVCdXR0b259XCIgZGF0YS10ZS10b2dnbGU9XCJ0aW1lcGlja2VyXCIgZGF0YS10ZS10aW1lcGlja2VyLXRvZ2dsZS1idXR0b24gZGF0YS10ZS10aW1lcGlja2VyLWljb24+XG4gICAgJHtpfVxuICA8L2J1dHRvbj5cbmA7XG59LCB1biA9IFwiZGF0YS10ZS10aW1lcGlja2VyLWRpc2FibGVkXCIsIHVzID0gXCJkYXRhLXRlLXRpbWVwaWNrZXItYWN0aXZlXCIsIHZlID0gKHMpID0+IHtcbiAgaWYgKHMgPT09IFwiXCIpXG4gICAgcmV0dXJuO1xuICBsZXQgdCwgZSwgaSwgbjtcbiAgcmV0dXJuIEdjKHMpID8gKHQgPSBzLmdldEhvdXJzKCksIG4gPSB0LCBlID0gcy5nZXRNaW51dGVzKCksIHQgJT0gMTIsIG4gPT09IDAgJiYgdCA9PT0gMCAmJiAoaSA9IFwiQU1cIiksIHQgPSB0IHx8IDEyLCBpID09PSB2b2lkIDAgJiYgKGkgPSBOdW1iZXIobikgPj0gMTIgPyBcIlBNXCIgOiBcIkFNXCIpLCBlID0gZSA8IDEwID8gYDAke2V9YCA6IGUpIDogKFt0LCBlLCBpXSA9IFIocywgITEpLCBuID0gdCwgdCAlPSAxMiwgbiA9PT0gMCAmJiB0ID09PSAwICYmIChpID0gXCJBTVwiKSwgdCA9IHQgfHwgMTIsIGkgPT09IHZvaWQgMCAmJiAoaSA9IE51bWJlcihuKSA+PSAxMiA/IFwiUE1cIiA6IFwiQU1cIikpLCB7XG4gICAgaG91cnM6IHQsXG4gICAgbWludXRlczogZSxcbiAgICBhbU9yUG06IGlcbiAgfTtcbn0sIEdjID0gKHMpID0+IHMgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHMpID09PSBcIltvYmplY3QgRGF0ZV1cIiAmJiAhTnVtYmVyLmlzTmFOKHMpLCBMYSA9IChzKSA9PiB7XG4gIGlmIChzID09PSBcIlwiKVxuICAgIHJldHVybjtcbiAgbGV0IHQsIGU7XG4gIHJldHVybiBHYyhzKSA/ICh0ID0gcy5nZXRIb3VycygpLCBlID0gcy5nZXRNaW51dGVzKCkpIDogW3QsIGVdID0gUihzLCAhMSksIGUgPSBOdW1iZXIoZSkgPCAxMCA/IGAwJHtOdW1iZXIoZSl9YCA6IGUsIHtcbiAgICBob3VyczogdCxcbiAgICBtaW51dGVzOiBlXG4gIH07XG59LCBQbSA9IChzLCB0LCBlKSA9PiBjLm9uKGRvY3VtZW50LCBzLCB0LCAoeyB0YXJnZXQ6IGkgfSkgPT4ge1xuICBpZiAoaS5oYXNBdHRyaWJ1dGUodXMpKVxuICAgIHJldHVybjtcbiAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCh0KS5mb3JFYWNoKChvKSA9PiB7XG4gICAgby5oYXNBdHRyaWJ1dGUodXMpICYmIChoLnJlbW92ZUNsYXNzKG8sIGUub3BhY2l0eSksIG8ucmVtb3ZlQXR0cmlidXRlKHVzKSk7XG4gIH0pLCBoLmFkZENsYXNzKGksIGUub3BhY2l0eSksIGkuc2V0QXR0cmlidXRlKHVzLCBcIlwiKTtcbn0pLCBOYSA9ICh7IGNsaWVudFg6IHMsIGNsaWVudFk6IHQsIHRvdWNoZXM6IGUgfSwgaSwgbiA9ICExKSA9PiB7XG4gIGNvbnN0IHsgbGVmdDogbywgdG9wOiByIH0gPSBpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBsZXQgYSA9IHt9O1xuICByZXR1cm4gIW4gfHwgIWUgPyBhID0ge1xuICAgIHg6IHMgLSBvLFxuICAgIHk6IHQgLSByXG4gIH0gOiBuICYmIE9iamVjdC5rZXlzKGUpLmxlbmd0aCA+IDAgJiYgKGEgPSB7XG4gICAgeDogZVswXS5jbGllbnRYIC0gbyxcbiAgICB5OiBlWzBdLmNsaWVudFkgLSByXG4gIH0pLCBhO1xufSwgcHMgPSAoKSA9PiBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgJiYgbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID4gMiAmJiAvTWFjSW50ZWwvLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKSB8fCAvQW5kcm9pZHx3ZWJPU3xpUGhvbmV8aVBhZHxpUG9kfEJsYWNrQmVycnl8SUVNb2JpbGV8T3BlcmEgTWluaS9pLnRlc3QoXG4gIG5hdmlnYXRvci51c2VyQWdlbnRcbiksIFIgPSAocywgdCA9ICEwKSA9PiB0ID8gcy52YWx1ZS5yZXBsYWNlKC86L2dpLCBcIiBcIikuc3BsaXQoXCIgXCIpIDogcy5yZXBsYWNlKC86L2dpLCBcIiBcIikuc3BsaXQoXCIgXCIpLCBxYyA9IChzLCB0KSA9PiB7XG4gIGNvbnN0IFtlLCBpLCBuXSA9IFIocywgITEpLCBbbywgciwgYV0gPSBSKHQsICExKTtcbiAgcmV0dXJuIG4gPT09IFwiUE1cIiAmJiBhID09PSBcIkFNXCIgfHwgbiA9PT0gYSAmJiBlID4gbyB8fCBpID4gcjtcbn0sIFpjID0gKCkgPT4ge1xuICBjb25zdCBzID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksIHQgPSBzLmdldEhvdXJzKCksIGUgPSBzLmdldE1pbnV0ZXMoKTtcbiAgcmV0dXJuIGAke3R9OiR7ZSA8IDEwID8gYDAke2V9YCA6IGV9YDtcbn0sIFh0ID0gKHMsIHQsIGUpID0+IHtcbiAgaWYgKCF0KVxuICAgIHJldHVybiBzO1xuICBsZXQgaSA9IFpjKCk7XG4gIHJldHVybiBlICYmIChpID0gYCR7dmUoaSkuaG91cnN9OiR7dmUoaSkubWludXRlc30gJHt2ZShpKS5hbU9yUG19YCksIChzICE9PSBcIlwiICYmIHFjKGksIHMpIHx8IHMgPT09IFwiXCIpICYmIChzID0gaSksIHM7XG59LCBHdCA9IChzLCB0LCBlKSA9PiB7XG4gIGlmICghdClcbiAgICByZXR1cm4gcztcbiAgbGV0IGkgPSBaYygpO1xuICByZXR1cm4gZSAmJiAoaSA9IGAke3ZlKGkpLmhvdXJzfToke3ZlKGkpLm1pbnV0ZXN9ICR7dmUoaSkuYW1PclBtfWApLCAocyAhPT0gXCJcIiAmJiAhcWMoaSwgcykgfHwgcyA9PT0gXCJcIikgJiYgKHMgPSBpKSwgcztcbn0sIEJtID0gKHsgZm9ybWF0MTI6IHMsIG1heFRpbWU6IHQsIG1pblRpbWU6IGUsIGRpc2FibGVQYXN0OiBpLCBkaXNhYmxlRnV0dXJlOiBuIH0sIG8sIHIpID0+IHtcbiAgY29uc3QgYSA9IFIobylbMV07XG4gIGUgPSBYdChlLCBpLCBzKSwgdCA9IEd0KHQsIG4sIHMpO1xuICBjb25zdCBbbCwgcCwgdV0gPSBSKHQsICExKSwgW18sIGYsIGddID0gUihlLCAhMSk7XG4gIGlmICh1ICE9PSB2b2lkIDAgfHwgZyAhPT0gdm9pZCAwKVxuICAgIHJldHVybiBbciwgYV07XG4gIGlmICghKGwgIT09IFwiXCIgJiYgXyA9PT0gXCJcIiAmJiBOdW1iZXIocikgPiBOdW1iZXIobCkpICYmICEobCA9PT0gXCJcIiAmJiBfICE9PSBcIlwiICYmIHAgPT09IHZvaWQgMCAmJiBmICE9PSBcIlwiICYmIE51bWJlcihyKSA8IE51bWJlcihfKSkpXG4gICAgcmV0dXJuIFtyLCBhXTtcbn0sIE1hID0gKHMsIHQsIGUsIGkpID0+IHtcbiAgcy5mb3JFYWNoKChuKSA9PiB7XG4gICAgdCA9IHQgPT09IFwiMTJcIiAmJiBpID8gXCIwXCIgOiB0LCAobi50ZXh0Q29udGVudCA9PT0gXCIwMFwiIHx8IE51bWJlcihuLnRleHRDb250ZW50ID09PSBcIjEyXCIgJiYgaSA/IFwiMFwiIDogbi50ZXh0Q29udGVudCkgPiB0KSAmJiAoaC5hZGRDbGFzcyhuLCBlLnRpcHNEaXNhYmxlZCksIG4uc2V0QXR0cmlidXRlKHVuLCBcIlwiKSk7XG4gIH0pO1xufSwgUmEgPSAocywgdCwgZSwgaSkgPT4ge1xuICBzLmZvckVhY2goKG4pID0+IHtcbiAgICB0ID0gdCA9PT0gXCIxMlwiICYmIGkgPyBcIjBcIiA6IHQsIG4udGV4dENvbnRlbnQgIT09IFwiMDBcIiAmJiBOdW1iZXIobi50ZXh0Q29udGVudCA9PT0gXCIxMlwiICYmIGkgPyBcIjBcIiA6IG4udGV4dENvbnRlbnQpIDwgTnVtYmVyKHQpICYmIChoLmFkZENsYXNzKG4sIGUudGlwc0Rpc2FibGVkKSwgbi5zZXRBdHRyaWJ1dGUodW4sIFwiXCIpKTtcbiAgfSk7XG59LCBRYyA9IChzLCB0LCBlLCBpKSA9PiB7XG4gIGlmICh0ID09PSBcIjEyXCIgfHwgdCA9PT0gXCIyNFwiKVxuICAgIHJldHVybjtcbiAgY29uc3QgbiA9IGUgPyAxMiA6IDI0O1xuICByZXR1cm4gaSA9PT0gXCJtYXhcIiA/IChOdW1iZXIocykgPT09IG4gPyAwIDogTnVtYmVyKHMpKSA+IE51bWJlcih0KSA6IChOdW1iZXIocykgPT09IG4gPyAwIDogTnVtYmVyKHMpKSA8IE51bWJlcih0KTtcbn0sIEhtID0gKHMsIHQsIGUsIGksIG4sIG8pID0+IHtcbiAgcy5mb3JFYWNoKChyKSA9PiB7XG4gICAgKFFjKGksIGUsIG8sIFwibWF4XCIpIHx8IE51bWJlcihyLnRleHRDb250ZW50KSA+IHQgJiYgTnVtYmVyKGkpID09PSBOdW1iZXIoZSkpICYmIChoLmFkZENsYXNzKHIsIG4udGlwc0Rpc2FibGVkKSwgci5zZXRBdHRyaWJ1dGUodW4sIFwiXCIpKTtcbiAgfSk7XG59LCBWbSA9IChzLCB0LCBlLCBpLCBuLCBvKSA9PiB7XG4gIHMuZm9yRWFjaCgocikgPT4ge1xuICAgIChRYyhpLCBlLCBvLCBcIm1pblwiKSB8fCBOdW1iZXIoci50ZXh0Q29udGVudCkgPCB0ICYmIE51bWJlcihpKSA9PT0gTnVtYmVyKGUpKSAmJiAoaC5hZGRDbGFzcyhyLCBuLnRpcHNEaXNhYmxlZCksIHIuc2V0QXR0cmlidXRlKHVuLCBcIlwiKSk7XG4gIH0pO1xufSwgV20gPSAocykgPT4gcy5zdGFydHNXaXRoKFwiMFwiKSA/IE51bWJlcihzLnNsaWNlKDEpKSA6IE51bWJlcihzKSwgJGkgPSBcInRpbWVwaWNrZXJcIiwgTSA9IGBkYXRhLXRlLSR7JGl9YCwgUGEgPSBcIltkYXRhLXRlLXRvZ2dsZV1cIiwgVXMgPSBgdGUuJHskaX1gLCBSdCA9IGAuJHtVc31gLCBQdCA9IFwiLmRhdGEtYXBpXCIsIEJhID0gYGNsaWNrJHtSdH0ke1B0fWAsIF9zID0gYGtleWRvd24ke1J0fSR7UHR9YCwgSGEgPSBgbW91c2Vkb3duJHtSdH0ke1B0fWAsIFZhID0gYG1vdXNldXAke1J0fSR7UHR9YCwgV2EgPSBgbW91c2Vtb3ZlJHtSdH0ke1B0fWAsIEZhID0gYG1vdXNlbGVhdmUke1J0fSR7UHR9YCwgWWEgPSBgbW91c2VvdmVyJHtSdH0ke1B0fWAsIGphID0gYHRvdWNobW92ZSR7UnR9JHtQdH1gLCBLYSA9IGB0b3VjaGVuZCR7UnR9JHtQdH1gLCB6YSA9IGB0b3VjaHN0YXJ0JHtSdH0ke1B0fWAsIEZtID0gYFske019LWFtXWAsIFltID0gYFske019LXBtXWAsIGptID0gYFske019LWZvcm1hdDI0XWAsIGZzID0gYFske019LWN1cnJlbnRdYCwgbXMgPSBgWyR7TX0taG91ci1tb2RlXWAsIEttID0gYFske019LXRvZ2dsZS1idXR0b25dYCwgR24gPSBgJHtNfS1jYW5jZWxgLCBVYSA9IGAke019LWNsZWFyYCwgcW4gPSBgJHtNfS1zdWJtaXRgLCB6bSA9IGAke019LWljb25gLCBabiA9IGAke019LWljb24tdXBgLCBRbiA9IGAke019LWljb24tZG93bmAsIFVtID0gYCR7TX0taWNvbi1pbmxpbmUtaG91cmAsIFhtID0gYCR7TX0taWNvbi1pbmxpbmUtbWludXRlYCwgWGEgPSBgJHtNfS1pbmxpbmUtaG91ci1pY29uc2AsIEdtID0gYCR7TX0tY3VycmVudC1pbmxpbmVgLCBxbSA9IFwicmVhZG9ubHlcIiwgWm0gPSBgJHtNfS1pbnZhbGlkLWZlZWRiYWNrYCwgSm4gPSBgJHtNfS1pcy1pbnZhbGlkYCwgWXQgPSBgJHtNfS1kaXNhYmxlZGAsIEggPSBgJHtNfS1hY3RpdmVgLCBRbSA9IGAke019LWlucHV0YCwgcGUgPSBgJHtNfS1jbG9ja2AsIGRpID0gYCR7TX0tY2xvY2staW5uZXJgLCB0byA9IGAke019LXdyYXBwZXJgLCBHYSA9IGAke019LWNsb2NrLXdyYXBwZXJgLCBncyA9IGAke019LWhvdXJgLCBlbyA9IGAke019LW1pbnV0ZWAsIGJzID0gYCR7TX0tdGlwcy1lbGVtZW50YCwgSyA9IGAke019LXRpcHMtaG91cnNgLCBYID0gYCR7TX0tdGlwcy1taW51dGVzYCwgbHQgPSBgJHtNfS10aXBzLWlubmVyYCwgdnMgPSBgJHtNfS10aXBzLWlubmVyLWVsZW1lbnRgLCBxYSA9IGAke019LW1pZGRsZS1kb3RgLCBpbyA9IGAke019LWhhbmQtcG9pbnRlcmAsIHNvID0gYCR7TX0tY2lyY2xlYCwgWmEgPSBgJHtNfS1tb2RhbGAsIEptID0gYDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjEuNVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiPlxuICA8cGF0aCBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBkPVwiTTEyIDZ2Nmg0LjVtNC41IDBhOSA5IDAgMTEtMTggMCA5IDkgMCAwMTE4IDB6XCIgLz5cbjwvc3ZnPmAsIHRnID0ge1xuICBhcHBlbmRWYWxpZGF0aW9uSW5mbzogITAsXG4gIGJvZHlJRDogXCJcIixcbiAgY2FuY2VsTGFiZWw6IFwiQ2FuY2VsXCIsXG4gIGNsZWFyTGFiZWw6IFwiQ2xlYXJcIixcbiAgY2xvc2VNb2RhbE9uQmFja2Ryb3BDbGljazogITAsXG4gIGNsb3NlTW9kYWxPbk1pbnV0ZXNDbGljazogITEsXG4gIGNvbnRhaW5lcjogXCJib2R5XCIsXG4gIGRlZmF1bHRUaW1lOiBcIlwiLFxuICBkaXNhYmxlZDogITEsXG4gIGRpc2FibGVQYXN0OiAhMSxcbiAgZGlzYWJsZUZ1dHVyZTogITEsXG4gIGVuYWJsZVZhbGlkYXRpb246ICEwLFxuICBmb2N1c0lucHV0QWZ0ZXJBcHByb3ZlOiAhMSxcbiAgZm9vdGVySUQ6IFwiXCIsXG4gIGZvcm1hdDEyOiAhMCxcbiAgZm9ybWF0MjQ6ICExLFxuICBoZWFkSUQ6IFwiXCIsXG4gIGluY3JlbWVudDogITEsXG4gIGlubGluZTogITEsXG4gIGludmFsaWRMYWJlbDogXCJJbnZhbGlkIFRpbWUgRm9ybWF0XCIsXG4gIG1heFRpbWU6IFwiXCIsXG4gIG1pblRpbWU6IFwiXCIsXG4gIG1vZGFsSUQ6IFwiXCIsXG4gIG9rTGFiZWw6IFwiT2tcIixcbiAgb3ZlcmZsb3dIaWRkZW46ICEwLFxuICBwaWNrZXJJRDogXCJcIixcbiAgcmVhZE9ubHk6ICExLFxuICBzaG93Q2xlYXJCdG46ICEwLFxuICBzd2l0Y2hIb3Vyc1RvTWludXRlc09uQ2xpY2s6ICEwLFxuICBpY29uU1ZHOiBKbSxcbiAgd2l0aEljb246ICEwLFxuICBwbUxhYmVsOiBcIlBNXCIsXG4gIGFtTGFiZWw6IFwiQU1cIixcbiAgYW5pbWF0aW9uczogITBcbn0sIGVnID0ge1xuICBhcHBlbmRWYWxpZGF0aW9uSW5mbzogXCJib29sZWFuXCIsXG4gIGJvZHlJRDogXCJzdHJpbmdcIixcbiAgY2FuY2VsTGFiZWw6IFwic3RyaW5nXCIsXG4gIGNsZWFyTGFiZWw6IFwic3RyaW5nXCIsXG4gIGNsb3NlTW9kYWxPbkJhY2tkcm9wQ2xpY2s6IFwiYm9vbGVhblwiLFxuICBjbG9zZU1vZGFsT25NaW51dGVzQ2xpY2s6IFwiYm9vbGVhblwiLFxuICBjb250YWluZXI6IFwic3RyaW5nXCIsXG4gIGRpc2FibGVkOiBcImJvb2xlYW5cIixcbiAgZGlzYWJsZVBhc3Q6IFwiYm9vbGVhblwiLFxuICBkaXNhYmxlRnV0dXJlOiBcImJvb2xlYW5cIixcbiAgZW5hYmxlVmFsaWRhdGlvbjogXCJib29sZWFuXCIsXG4gIGZvb3RlcklEOiBcInN0cmluZ1wiLFxuICBmb3JtYXQxMjogXCJib29sZWFuXCIsXG4gIGZvcm1hdDI0OiBcImJvb2xlYW5cIixcbiAgaGVhZElEOiBcInN0cmluZ1wiLFxuICBpbmNyZW1lbnQ6IFwiYm9vbGVhblwiLFxuICBpbmxpbmU6IFwiYm9vbGVhblwiLFxuICBpbnZhbGlkTGFiZWw6IFwic3RyaW5nXCIsXG4gIG1vZGFsSUQ6IFwic3RyaW5nXCIsXG4gIG9rTGFiZWw6IFwic3RyaW5nXCIsXG4gIG92ZXJmbG93SGlkZGVuOiBcImJvb2xlYW5cIixcbiAgcGlja2VySUQ6IFwic3RyaW5nXCIsXG4gIHJlYWRPbmx5OiBcImJvb2xlYW5cIixcbiAgc2hvd0NsZWFyQnRuOiBcImJvb2xlYW5cIixcbiAgc3dpdGNoSG91cnNUb01pbnV0ZXNPbkNsaWNrOiBcImJvb2xlYW5cIixcbiAgZGVmYXVsdFRpbWU6IFwiKHN0cmluZ3xkYXRlfG51bWJlcilcIixcbiAgaWNvblNWRzogXCJzdHJpbmdcIixcbiAgd2l0aEljb246IFwiYm9vbGVhblwiLFxuICBwbUxhYmVsOiBcInN0cmluZ1wiLFxuICBhbUxhYmVsOiBcInN0cmluZ1wiLFxuICBhbmltYXRpb25zOiBcImJvb2xlYW5cIlxufSwgaWcgPSB7XG4gIHRpcHM6IFwiYWJzb2x1dGUgcm91bmRlZC1bMTAwJV0gdy1bMzJweF0gaC1bMzJweF0gdGV4dC1jZW50ZXIgY3Vyc29yLXBvaW50ZXIgdGV4dC1bMS4xcmVtXSByb3VuZGVkLVsxMDAlXSBiZy10cmFuc3BhcmVudCBmbGV4IGp1c3RpZnktY2VudGVyIGl0ZW1zLWNlbnRlciBmb250LWxpZ2h0IGZvY3VzOm91dGxpbmUtbm9uZSBzZWxlY3Rpb246YmctdHJhbnNwYXJlbnRcIixcbiAgdGlwc0FjdGl2ZTogXCJ0ZXh0LXdoaXRlIGJnLVsjM2I3MWNhXSBmb250LW5vcm1hbFwiLFxuICB0aXBzRGlzYWJsZWQ6IFwidGV4dC1bI2IzYWZhZl0gcG9pbnRlci1ldmVudHMtbm9uZSBiZy10cmFuc3BhcmVudFwiLFxuICB0cmFuc2Zvcm06IFwidHJhbnNpdGlvbi1bdHJhbnNmb3JtLGhlaWdodF0gZWFzZS1pbi1vdXQgZHVyYXRpb24tWzQwMG1zXVwiLFxuICBtb2RhbDogXCJ6LVsxMDY1XVwiLFxuICBjbG9ja0FuaW1hdGlvbjogXCJhbmltYXRlLVtzaG93LXVwLWNsb2NrXzM1MG1zX2xpbmVhcl1cIixcbiAgb3BhY2l0eTogXCIhb3BhY2l0eS0xMDBcIixcbiAgdGltZXBpY2tlcldyYXBwZXI6IFwidG91Y2gtbm9uZSBvcGFjaXR5LTEwMCB6LVsxMDY1XSBpbnNldC0wIGJnLVsjMDAwMDAwNjZdIGgtZnVsbCBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBmbGV4LWNvbCBmaXhlZFwiLFxuICB0aW1lcGlja2VyQ29udGFpbmVyOiBcImZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIGZsZXgtY29sIG1heC1oLVtjYWxjKDEwMCUtNjRweCldIG92ZXJmbG93LXktYXV0byBzaGFkb3ctWzBfMTBweF8xNXB4Xy0zcHhfcmdiYSgwLDAsMCwwLjA3KSwwXzRweF82cHhfLTJweF9yZ2JhKDAsMCwwLDAuMDUpXSBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6cm91bmRlZC1sZ1wiLFxuICB0aW1lcGlja2VyRWxlbWVudHM6IFwiZmxleCBmbGV4LWNvbCBtaW4tdy1bMzEwcHhdIG1pbi1oLVszMjVweF0gYmctd2hpdGUgcm91bmRlZC10LVswLjZyZW1dIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTohZmxleC1yb3cgbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOm1pbi13LVthdXRvXSBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6bWluLWgtW2F1dG9dIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTpvdmVyZmxvdy15LWF1dG8ganVzdGlmeS1hcm91bmRcIixcbiAgdGltZXBpY2tlckhlYWQ6IFwiYmctWyMzYjcxY2FdIGRhcms6YmctemluYy03MDAgaC1bMTAwcHhdIHJvdW5kZWQtdC1sZyBwci1bMjRweF0gcGwtWzUwcHhdIHB5LVsxMHB4XSBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6cm91bmRlZC10ci1ub25lIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTpyb3VuZGVkLWJsLW5vbmUgbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOnAtWzEwcHhdIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTpwci1bMTBweF0gbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOmgtYXV0byBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6bWluLWgtWzMwNXB4XSBmbGV4IGZsZXgtcm93IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlclwiLFxuICB0aW1lcGlja2VySGVhZENvbnRlbnQ6IFwibWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOmZsZXgtY29sIGZsZXggdy1mdWxsIGp1c3RpZnktZXZlbmx5XCIsXG4gIHRpbWVwaWNrZXJDdXJyZW50V3JhcHBlcjogXCJbZGlyZWN0aW9uOmx0cl0gcnRsOltkaXJlY3Rpb246cnRsXVwiLFxuICB0aW1lcGlja2VyQ3VycmVudEJ1dHRvbldyYXBwZXI6IFwicmVsYXRpdmUgaC1mdWxsXCIsXG4gIHRpbWVwaWNrZXJDdXJyZW50QnV0dG9uOiBcInRleHQtWzMuNzVyZW1dIGZvbnQtbGlnaHQgbGVhZGluZy1bMS4yXSB0cmFja2luZy1bLTAuMDA4MzNlbV0gdGV4dC13aGl0ZSBvcGFjaXR5LVsuNTRdIGJvcmRlci1ub25lIGJnLXRyYW5zcGFyZW50IHAtMCBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6dGV4dC01eGwgbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOmZvbnQtbm9ybWFsIGN1cnNvci1wb2ludGVyIGhvdmVyOmJnLVsjMDAwMDAwMjZdIGhvdmVyOm91dGxpbmUtbm9uZSBmb2N1czpiZy1bIzAwMDAwMDI2XSBmb2N1czpvdXRsaW5lLW5vbmUgXCIsXG4gIHRpbWVwaWNrZXJEb3Q6IFwiZm9udC1saWdodCBsZWFkaW5nLVsxLjJdIHRyYWNraW5nLVstMC4wMDgzM2VtXSB0ZXh0LVszLjc1cmVtXSBvcGFjaXR5LVsuNTRdIGJvcmRlci1ub25lIGJnLXRyYW5zcGFyZW50IHAtMCB0ZXh0LXdoaXRlIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTp0ZXh0LVszcmVtXSBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6Zm9udC1ub3JtYWxcIixcbiAgdGltZXBpY2tlck1vZGVXcmFwcGVyOiBcImZsZXggZmxleC1jb2wganVzdGlmeS1jZW50ZXIgdGV4dC1bMThweF0gdGV4dC1bI2ZmZmZmZjhhXSBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6IWp1c3RpZnktYXJvdW5kIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTohZmxleC1yb3dcIixcbiAgdGltZXBpY2tlck1vZGVBbTogXCJwLTAgYmctdHJhbnNwYXJlbnQgYm9yZGVyLW5vbmUgdGV4dC13aGl0ZSBvcGFjaXR5LVsuNTRdIGN1cnNvci1wb2ludGVyIGhvdmVyOmJnLVsjMDAwMDAwMjZdIGhvdmVyOm91dGxpbmUtbm9uZSBmb2N1czpiZy1bIzAwMDAwMDI2XSBmb2N1czpvdXRsaW5lLW5vbmVcIixcbiAgdGltZXBpY2tlck1vZGVQbTogXCJwLTAgYmctdHJhbnNwYXJlbnQgYm9yZGVyLW5vbmUgdGV4dC13aGl0ZSBvcGFjaXR5LVsuNTRdIGN1cnNvci1wb2ludGVyIGhvdmVyOmJnLVsjMDAwMDAwMjZdIGhvdmVyOm91dGxpbmUtbm9uZSBmb2N1czpiZy1bIzAwMDAwMDI2XSBmb2N1czpvdXRsaW5lLW5vbmVcIixcbiAgdGltZXBpY2tlckNsb2NrV3JhcHBlcjogXCJtaW4tdy1bMzEwcHhdIG1heC13LVszMjVweF0gbWluLWgtWzMwNXB4XSBvdmVyZmxvdy14LWhpZGRlbiBoLWZ1bGwgZmxleCBqdXN0aWZ5LWNlbnRlciBmbGV4LWNvbCBpdGVtcy1jZW50ZXIgZGFyazpiZy16aW5jLTUwMFwiLFxuICB0aW1lcGlja2VyQ2xvY2s6IFwicmVsYXRpdmUgcm91bmRlZC1bMTAwJV0gdy1bMjYwcHhdIGgtWzI2MHB4XSBjdXJzb3ItZGVmYXVsdCBteS0wIG14LWF1dG8gYmctWyMwMDAwMDAxMl0gZGFyazpiZy16aW5jLTYwMC81MFwiLFxuICB0aW1lcGlja2VyTWlkZGxlRG90OiBcInRvcC0xLzIgbGVmdC0xLzIgdy1bNnB4XSBoLVs2cHhdIC10cmFuc2xhdGUteS0xLzIgLXRyYW5zbGF0ZS14LTEvMiByb3VuZGVkLVs1MCVdIGJnLVsjM2I3MWNhXSBhYnNvbHV0ZVwiLFxuICB0aW1lcGlja2VySGFuZFBvaW50ZXI6IFwiYmctWyMzYjcxY2FdIGJvdHRvbS0xLzIgaC0yLzUgbGVmdC1bY2FsYyg1MCUtMXB4KV0gcnRsOiFsZWZ0LWF1dG8gb3JpZ2luLVtjZW50ZXJfYm90dG9tXzBdIHJ0bDohb3JpZ2luLVs1MCVfNTAlXzBdIHctWzJweF0gYWJzb2x1dGVcIixcbiAgdGltZXBpY2tlclBvaW50ZXJDaXJjbGU6IFwiLXRvcC1bMjFweF0gLWxlZnQtWzE1cHhdIHctWzRweF0gYm9yZGVyLVsxNHB4XSBib3JkZXItc29saWQgYm9yZGVyLVsjM2I3MWNhXSBoLVs0cHhdIGJveC1jb250ZW50IHJvdW5kZWQtWzEwMCVdIGFic29sdXRlXCIsXG4gIHRpbWVwaWNrZXJDbG9ja0lubmVyOiBcImFic29sdXRlIHRvcC0xLzIgbGVmdC0xLzIgLXRyYW5zbGF0ZS15LTEvMiAtdHJhbnNsYXRlLXgtMS8yIHctWzE2MHB4XSBoLVsxNjBweF0gcm91bmRlZC1bMTAwJV1cIixcbiAgdGltZXBpY2tlckZvb3RlcldyYXBwZXI6IFwicm91bmRlZC1iLWxnIGZsZXgganVzdGlmeS1iZXR3ZWVuIGl0ZW1zLWNlbnRlciB3LWZ1bGwgaC1bNTZweF0gcHgtWzEycHhdIGJnLXdoaXRlIGRhcms6YmctemluYy01MDBcIixcbiAgdGltZXBpY2tlckZvb3RlcjogXCJ3LWZ1bGwgZmxleCBqdXN0aWZ5LWJldHdlZW5cIixcbiAgdGltZXBpY2tlckZvb3RlckJ1dHRvbjogXCJ0ZXh0LVswLjhyZW1dIG1pbi13LVs2NHB4XSBib3gtYm9yZGVyIGZvbnQtbWVkaXVtIGxlYWRpbmctWzQwcHhdIHJvdW5kZWQtWzEwcHhdIHRyYWNraW5nLVswLjFyZW1dIHVwcGVyY2FzZSB0ZXh0LVsjM2I3MWNhXSBkYXJrOnRleHQtd2hpdGUgYm9yZGVyLW5vbmUgYmctdHJhbnNwYXJlbnQgdHJhbnNpdGlvbi1bYmFja2dyb3VuZC1jb2xvcixib3gtc2hhZG93LGJvcmRlcl0gZHVyYXRpb24tWzI1MG1zXSBlYXNlLVtjdWJpYy1iZXppZXIoMC40LDAsMC4yLDEpXSBkZWxheS1bMG1zXSBvdXRsaW5lLW5vbmUgcHktMCBweC1bMTBweF0gaC1bNDBweF0gbWItWzEwcHhdIGhvdmVyOmJnLVsjMDAwMDAwMTRdIGZvY3VzOmJnLVsjMDAwMDAwMTRdIGZvY3VzOm91dGxpbmUtbm9uZVwiLFxuICB0aW1lcGlja2VySW5saW5lV3JhcHBlcjogXCJ0b3VjaC1ub25lIG9wYWNpdHktMTAwIHotWzEwNjVdIGluc2V0LTAgYmctWyMwMDAwMDA2Nl0gaC1mdWxsIGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIGZsZXgtY29sIHJvdW5kZWQtbGdcIixcbiAgdGltZXBpY2tlcklubGluZUNvbnRhaW5lcjogXCJmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBmbGV4LWNvbCBtYXgtaC1bY2FsYygxMDAlLTY0cHgpXSBvdmVyZmxvdy15LWF1dG8gc2hhZG93LVswXzEwcHhfMTVweF8tM3B4X3JnYmEoMCwwLDAsMC4wNyksMF80cHhfNnB4Xy0ycHhfcmdiYSgwLDAsMCwwLjA1KV1cIixcbiAgdGltZXBpY2tlcklubGluZUVsZW1lbnRzOiBcImZsZXggZmxleC1jb2wgbWluLWgtW2F1dG9dIG1pbi13LVszMTBweF0gYmctd2hpdGUgcm91bmRlZC1bMC42cmVtXSBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6IWZsZXgtcm93IG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTpyb3VuZGVkLWJsLWxnIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTptaW4tdy1bYXV0b10gbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOjptaW4taC1bYXV0b10gbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOm92ZXJmbG93LXktYXV0byBqdXN0aWZ5LWFyb3VuZFwiLFxuICB0aW1lcGlja2VySW5saW5lSGVhZDogXCJiZy1bIzNiNzFjYV0gZGFyazpiZy16aW5jLTcwMCBoLVsxMDBweF0gcm91bmRlZC10LWxnIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTpyb3VuZGVkLXRyLW5vbmUgbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOnJvdW5kZWQtYmwtbm9uZSBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6cC1bMTBweF0gbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOnByLVsxMHB4XSBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6aC1hdXRvIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTptaW4taC1bMzA1cHhdIGZsZXggZmxleC1yb3cgaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIHAtMCByb3VuZGVkLWItbGdcIixcbiAgdGltZXBpY2tlcklubGluZUhlYWRDb250ZW50OiBcIm1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTpmbGV4LWNvbCBmbGV4IHctZnVsbCBqdXN0aWZ5LWV2ZW5seSBpdGVtcy1jZW50ZXJcIixcbiAgdGltZXBpY2tlcklubGluZUhvdXJXcmFwcGVyOiBcInJlbGF0aXZlIGgtZnVsbCAhb3BhY2l0eS0xMDBcIixcbiAgdGltZXBpY2tlckN1cnJlbnRNaW51dGVXcmFwcGVyOiBcInJlbGF0aXZlIGgtZnVsbFwiLFxuICB0aW1lcGlja2VySW5saW5lSWNvblVwOiBcImFic29sdXRlIHRleHQtd2hpdGUgLXRvcC1bMzVweF0gb3BhY2l0eS0wIGhvdmVyOm9wYWNpdHktMTAwIHRyYW5zaXRpb24tYWxsIGR1cmF0aW9uLTIwMCBlYXNlLVtlYXNlXSBjdXJzb3ItcG9pbnRlciAtdHJhbnNsYXRlLXgtMS8yIC10cmFuc2xhdGUteS0xLzIgbGVmdC0xLzIgdy1bMzBweF0gaC1bMzBweF0gZmxleCBqdXN0aWZ5LWNlbnRlciBpdGVtcy1jZW50ZXJcIixcbiAgdGltZXBpY2tlcklubGluZUljb25Tdmc6IFwiaC00IHctNFwiLFxuICB0aW1lcGlja2VySW5saW5lQ3VycmVudEJ1dHRvbjogXCJmb250LWxpZ2h0IGxlYWRpbmctWzEuMl0gdHJhY2tpbmctWy0wLjAwODMzZW1dIHRleHQtd2hpdGUgYm9yZGVyLW5vbmUgYmctdHJhbnNwYXJlbnQgcC0wIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTp0ZXh0LTV4bCBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6Zm9udC1ub3JtYWwgIW9wYWNpdHktMTAwIGN1cnNvci1wb2ludGVyIGZvY3VzOmJnLVsjMDAwMDAwMjZdIGhvdmVyOm91dGxpbmUtbm9uZSBmb2N1czpvdXRsaW5lLW5vbmUgdGV4dC1bMi41cmVtXSBob3ZlcjpiZy1bdW5zZXRdXCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVJY29uRG93bjogXCJhYnNvbHV0ZSB0ZXh0LXdoaXRlIC1ib3R0b20tWzQ3cHhdIG9wYWNpdHktMCBob3ZlcjpvcGFjaXR5LTEwMCB0cmFuc2l0aW9uLWFsbCBkdXJhdGlvbi0yMDAgZWFzZS1bZWFzZV0gY3Vyc29yLXBvaW50ZXIgLXRyYW5zbGF0ZS14LTEvMiAtdHJhbnNsYXRlLXktMS8yIGxlZnQtMS8yIHctWzMwcHhdIGgtWzMwcHhdIGZsZXgganVzdGlmeS1jZW50ZXIgaXRlbXMtY2VudGVyXCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVEb3Q6IFwiZm9udC1saWdodCBsZWFkaW5nLVsxLjJdIHRyYWNraW5nLVstMC4wMDgzM2VtXSBvcGFjaXR5LVsuNTRdIGJvcmRlci1ub25lIGJnLXRyYW5zcGFyZW50IHAtMCB0ZXh0LXdoaXRlIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTp0ZXh0LVszcmVtXSBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6Zm9udC1ub3JtYWwgdGV4dC1bMi41cmVtXVwiLFxuICB0aW1lcGlja2VySW5saW5lTW9kZVdyYXBwZXI6IFwiZmxleCBqdXN0aWZ5LWNlbnRlciB0ZXh0LVsxOHB4XSB0ZXh0LVsjZmZmZmZmOGFdIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTohanVzdGlmeS1hcm91bmQgbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOiFmbGV4LXJvd1wiLFxuICB0aW1lcGlja2VySW5saW5lTW9kZUFtOiBcImhvdmVyOmJnLVsjMDAwMDAwMjZdIGhvdmVyOm91dGxpbmUtbm9uZSBmb2N1czpiZy1bIzAwMDAwMDI2XSBmb2N1czpvdXRsaW5lLW5vbmUgcC0wIGJnLXRyYW5zcGFyZW50IGJvcmRlci1ub25lIHRleHQtd2hpdGUgb3BhY2l0eS1bLjU0XSBjdXJzb3ItcG9pbnRlciBtci0yIG1sLTZcIixcbiAgdGltZXBpY2tlcklubGluZU1vZGVQbTogXCJob3ZlcjpiZy1bIzAwMDAwMDI2XSBob3ZlcjpvdXRsaW5lLW5vbmUgZm9jdXM6YmctWyMwMDAwMDAyNl0gZm9jdXM6b3V0bGluZS1ub25lIHAtMCBiZy10cmFuc3BhcmVudCBib3JkZXItbm9uZSB0ZXh0LXdoaXRlIG9wYWNpdHktWy41NF0gY3Vyc29yLXBvaW50ZXJcIixcbiAgdGltZXBpY2tlcklubGluZVN1Ym1pdEJ1dHRvbjogXCJob3ZlcjpiZy1bIzAwMDAwMDE0XSBmb2N1czpiZy1bIzAwMDAwMDE0XSBmb2N1czpvdXRsaW5lLW5vbmUgdGV4dC1bMC44cmVtXSBib3gtYm9yZGVyIGZvbnQtbWVkaXVtIGxlYWRpbmctWzQwcHhdIHRyYWNraW5nLVsuMXJlbV0gdXBwZXJjYXNlIGJvcmRlci1ub25lIGJnLXRyYW5zcGFyZW50IFt0cmFuc2l0aW9uOmJhY2tncm91bmQtY29sb3JfMjUwbXNfY3ViaWMtYmV6aWVyKDAuNCwwLDAuMiwxKV8wbXMsYm94LXNoYWRvd18yNTBtc19jdWJpYy1iZXppZXIoMC40LDAsMC4yLDEpXzBtcyxib3JkZXJfMjUwbXNfY3ViaWMtYmV6aWVyKDAuNCwwLDAuMiwxKV8wbXNdIG91dGxpbmUtbm9uZSByb3VuZGVkLVsxMDAlXSBoLVs0OHB4XSBtaW4tdy1bNDhweF0gaW5saW5lLWJsb2NrIG1sLVszMHB4XSB0ZXh0LXdoaXRlIHB5LTEgcHgtMiBtYi0wXCIsXG4gIHRpbWVwaWNrZXJUb2dnbGVCdXR0b246IFwiaC00IHctNCBtbC1hdXRvIGFic29sdXRlIG91dGxpbmUtbm9uZSBib3JkZXItbm9uZSBiZy10cmFuc3BhcmVudCByaWdodC0xLjUgdG9wLTEvMiAtdHJhbnNsYXRlLXgtMS8yIC10cmFuc2xhdGUteS0xLzIgdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tMzAwIGVhc2UtW2N1YmljLWJlemllcigwLjI1LDAuMSwwLjI1LDEpXSBjdXJzb3ItcG9pbnRlciBob3Zlcjp0ZXh0LVsjM2I3MWNhXSBmb2N1czp0ZXh0LVsjM2I3MWNhXSBkYXJrOmhvdmVyOnRleHQtWyMzYjcxY2FdIGRhcms6Zm9jdXM6dGV4dC1bIzNiNzFjYV0gZGFyazp0ZXh0LXdoaXRlXCJcbn0sIHNnID0ge1xuICB0aXBzOiBcInN0cmluZ1wiLFxuICB0aXBzQWN0aXZlOiBcInN0cmluZ1wiLFxuICB0aXBzRGlzYWJsZWQ6IFwic3RyaW5nXCIsXG4gIHRyYW5zZm9ybTogXCJzdHJpbmdcIixcbiAgbW9kYWw6IFwic3RyaW5nXCIsXG4gIGNsb2NrQW5pbWF0aW9uOiBcInN0cmluZ1wiLFxuICBvcGFjaXR5OiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VyV3JhcHBlcjogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlckNvbnRhaW5lcjogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlckVsZW1lbnRzOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VySGVhZDogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlckhlYWRDb250ZW50OiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VyQ3VycmVudFdyYXBwZXI6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJDdXJyZW50QnV0dG9uV3JhcHBlcjogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlckN1cnJlbnRCdXR0b246IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJEb3Q6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJNb2RlV3JhcHBlcjogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlck1vZGVBbTogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlck1vZGVQbTogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlckNsb2NrV3JhcHBlcjogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlckNsb2NrOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VyTWlkZGxlRG90OiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VySGFuZFBvaW50ZXI6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJQb2ludGVyQ2lyY2xlOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VyQ2xvY2tJbm5lcjogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlckZvb3RlcldyYXBwZXI6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJGb290ZXJCdXR0b246IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVXcmFwcGVyOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VySW5saW5lQ29udGFpbmVyOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VySW5saW5lRWxlbWVudHM6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVIZWFkOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VySW5saW5lSGVhZENvbnRlbnQ6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVIb3VyV3JhcHBlcjogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlckN1cnJlbnRNaW51dGVXcmFwcGVyOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VySW5saW5lSWNvblVwOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VySW5saW5lSWNvblN2ZzogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlcklubGluZUN1cnJlbnRCdXR0b246IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVJY29uRG93bjogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlcklubGluZURvdDogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlcklubGluZU1vZGVXcmFwcGVyOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VySW5saW5lTW9kZUFtOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VySW5saW5lTW9kZVBtOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VySW5saW5lU3VibWl0QnV0dG9uOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VyVG9nZ2xlQnV0dG9uOiBcInN0cmluZ1wiXG59O1xuY2xhc3Mgbmcge1xuICBjb25zdHJ1Y3Rvcih0LCBlID0ge30sIGkpIHtcbiAgICB5dCh0aGlzLCBcIl90b2dnbGVBbVBtXCIsICh0KSA9PiB7XG4gICAgICB0ID09PSBcIlBNXCIgPyAodGhpcy5faXNQbUVuYWJsZWQgPSAhMCwgdGhpcy5faXNBbUVuYWJsZWQgPSAhMSkgOiB0ID09PSBcIkFNXCIgJiYgKHRoaXMuX2lzUG1FbmFibGVkID0gITEsIHRoaXMuX2lzQW1FbmFibGVkID0gITApO1xuICAgIH0pO1xuICAgIHl0KHRoaXMsIFwiX3RvZ2dsZUJhY2tncm91bmRDb2xvckNpcmNsZVwiLCAodCkgPT4ge1xuICAgICAgaWYgKHRoaXMuX21vZGFsLnF1ZXJ5U2VsZWN0b3IoYCR7dH1bJHtIfV1gKSAhPT0gbnVsbCkge1xuICAgICAgICBoLmFkZFN0eWxlKHRoaXMuX2NpcmNsZSwge1xuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjMTk3NmQyXCJcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGguYWRkU3R5bGUodGhpcy5fY2lyY2xlLCB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCJ0cmFuc3BhcmVudFwiXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB5dCh0aGlzLCBcIl90b2dnbGVDbGFzc0FjdGl2ZVwiLCAodCwgeyB0ZXh0Q29udGVudDogZSB9LCBpKSA9PiB7XG4gICAgICBjb25zdCBuID0gWy4uLnRdLmZpbmQoXG4gICAgICAgIChvKSA9PiBOdW1iZXIobykgPT09IE51bWJlcihlKVxuICAgICAgKTtcbiAgICAgIHJldHVybiBpLmZvckVhY2goKG8pID0+IHtcbiAgICAgICAgaWYgKCFvLmhhc0F0dHJpYnV0ZShZdCkpIHtcbiAgICAgICAgICBpZiAoby50ZXh0Q29udGVudCA9PT0gbikge1xuICAgICAgICAgICAgaC5hZGRDbGFzcyhvLCB0aGlzLl9jbGFzc2VzLnRpcHNBY3RpdmUpLCBvLnNldEF0dHJpYnV0ZShILCBcIlwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaC5yZW1vdmVDbGFzcyhvLCB0aGlzLl9jbGFzc2VzLnRpcHNBY3RpdmUpLCBvLnJlbW92ZUF0dHJpYnV0ZShIKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgeXQodGhpcywgXCJfbWFrZU1pbnV0ZXNEZWdyZWVzXCIsICh0LCBlKSA9PiB7XG4gICAgICBjb25zdCB7IGluY3JlbWVudDogaSB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICAgIHJldHVybiB0IDwgMCA/IChlID0gTWF0aC5yb3VuZCgzNjAgKyB0IC8gNikgJSA2MCwgdCA9IDM2MCArIE1hdGgucm91bmQodCAvIDYpICogNikgOiAoZSA9IE1hdGgucm91bmQodCAvIDYpICUgNjAsIHQgPSBNYXRoLnJvdW5kKHQgLyA2KSAqIDYpLCBpICYmICh0ID0gTWF0aC5yb3VuZCh0IC8gMzApICogMzAsIGUgPSBNYXRoLnJvdW5kKHQgLyA2KSAqIDYgLyA2LCBlID09PSA2MCAmJiAoZSA9IFwiMDBcIikpLCB0ID49IDM2MCAmJiAodCA9IDApLCB7XG4gICAgICAgIGRlZ3JlZXM6IHQsXG4gICAgICAgIG1pbnV0ZTogZSxcbiAgICAgICAgYWRkRGVncmVlczogaSA/IDMwIDogNlxuICAgICAgfTtcbiAgICB9KTtcbiAgICB5dCh0aGlzLCBcIl9tYWtlSG91ckRlZ3JlZXNcIiwgKHQsIGUsIGkpID0+IHtcbiAgICAgIGlmICh0KVxuICAgICAgICByZXR1cm4gdGhpcy5faGFzVGFyZ2V0SW5uZXJDbGFzcyh0KSA/IGUgPCAwID8gKGkgPSBNYXRoLnJvdW5kKDM2MCArIGUgLyAzMCkgJSAyNCwgZSA9IDM2MCArIGUpIDogKGkgPSBNYXRoLnJvdW5kKGUgLyAzMCkgKyAxMiwgaSA9PT0gMTIgJiYgKGkgPSBcIjAwXCIpKSA6IGUgPCAwID8gKGkgPSBNYXRoLnJvdW5kKDM2MCArIGUgLyAzMCkgJSAxMiwgZSA9IDM2MCArIGUpIDogKGkgPSBNYXRoLnJvdW5kKGUgLyAzMCkgJSAxMiwgKGkgPT09IDAgfHwgaSA+IDEyKSAmJiAoaSA9IDEyKSksIGUgPj0gMzYwICYmIChlID0gMCksIHtcbiAgICAgICAgICBkZWdyZWVzOiBlLFxuICAgICAgICAgIGhvdXI6IGksXG4gICAgICAgICAgYWRkRGVncmVlczogMzBcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICB5dCh0aGlzLCBcIl9tYWtlSW5uZXJIb3Vyc0RlZ3JlZXNcIiwgKHQsIGUpID0+ICh0IDwgMCA/IChlID0gTWF0aC5yb3VuZCgzNjAgKyB0IC8gMzApICUgMjQsIHQgPSAzNjAgKyB0KSA6IChlID0gTWF0aC5yb3VuZCh0IC8gMzApICsgMTIsIGUgPT09IDEyICYmIChlID0gXCIwMFwiKSksIHtcbiAgICAgIGRlZ3JlZXM6IHQsXG4gICAgICBob3VyOiBlLFxuICAgICAgYWRkRGVncmVlczogMzBcbiAgICB9KSk7XG4gICAgeXQodGhpcywgXCJfZ2V0QXBwZW5kQ2xvY2tcIiwgKHQgPSBbXSwgZSA9IGBbJHtwZX1dYCwgaSkgPT4ge1xuICAgICAgbGV0IHsgbWluVGltZTogbiwgbWF4VGltZTogbyB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICAgIGNvbnN0IHsgaW5saW5lOiByLCBmb3JtYXQxMjogYSwgZGlzYWJsZVBhc3Q6IGwsIGRpc2FibGVGdXR1cmU6IHAgfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgICBuID0gWHQobiwgbCwgYSksIG8gPSBHdChvLCBwLCBhKTtcbiAgICAgIGNvbnN0IFt1LCBfLCBmXSA9IFIoXG4gICAgICAgIG8sXG4gICAgICAgICExXG4gICAgICApLCBbZywgbSwgYl0gPSBSKFxuICAgICAgICBuLFxuICAgICAgICAhMVxuICAgICAgKTtcbiAgICAgICFyICYmIGEgJiYgdGhpcy5faXNJbnZhbGlkVGltZUZvcm1hdCAmJiAhdGhpcy5fQU0uaGFzQXR0cmlidXRlKEgpICYmIChoLmFkZENsYXNzKHRoaXMuX1BNLCB0aGlzLl9jbGFzc2VzLm9wYWNpdHkpLCB0aGlzLl9QTS5zZXRBdHRyaWJ1dGUoSCwgXCJcIikpO1xuICAgICAgY29uc3QgdiA9IGQuZmluZE9uZShlKSwgQyA9IDM2MCAvIHQubGVuZ3RoO1xuICAgICAgZnVuY3Rpb24gdyhrKSB7XG4gICAgICAgIHJldHVybiBrICogKE1hdGguUEkgLyAxODApO1xuICAgICAgfVxuICAgICAgaWYgKHYgPT09IG51bGwpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IEUgPSAodi5vZmZzZXRXaWR0aCAtIDMyKSAvIDIsIFQgPSAodi5vZmZzZXRIZWlnaHQgLSAzMikgLyAyLCBBID0gRSAtIDQ7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgbGV0IGs7XG4gICAgICAgIGEgJiYgKGsgPSBkLmZpbmRPbmUoXG4gICAgICAgICAgYCR7bXN9WyR7SH1dYFxuICAgICAgICApLnRleHRDb250ZW50KSwgdGhpcy5faGFuZGxlRGlzYWJsaW5nVGlwc01pblRpbWUoXG4gICAgICAgICAgayxcbiAgICAgICAgICBiLFxuICAgICAgICAgIG0sXG4gICAgICAgICAgZ1xuICAgICAgICApLCB0aGlzLl9oYW5kbGVEaXNhYmxpbmdUaXBzTWF4VGltZShcbiAgICAgICAgICBrLFxuICAgICAgICAgIGYsXG4gICAgICAgICAgXyxcbiAgICAgICAgICB1XG4gICAgICAgICk7XG4gICAgICB9LCAwKSwgWy4uLnRdLmZvckVhY2goKGssIEkpID0+IHtcbiAgICAgICAgY29uc3QgTyA9IHcoSSAqIEMpLCB4ID0gJChcInNwYW5cIiksIEwgPSAkKFwic3BhblwiKTtcbiAgICAgICAgTC5pbm5lckhUTUwgPSBrLCBoLmFkZENsYXNzKHgsIHRoaXMuX2NsYXNzZXMudGlwcyksIHguc2V0QXR0cmlidXRlKGksIFwiXCIpO1xuICAgICAgICBjb25zdCBTID0geC5vZmZzZXRXaWR0aCwgTiA9IHgub2Zmc2V0SGVpZ2h0O1xuICAgICAgICByZXR1cm4gaC5hZGRTdHlsZSh4LCB7XG4gICAgICAgICAgbGVmdDogYCR7RSArIE1hdGguc2luKE8pICogQSAtIFN9cHhgLFxuICAgICAgICAgIGJvdHRvbTogYCR7VCArIE1hdGguY29zKE8pICogQSAtIE59cHhgXG4gICAgICAgIH0pLCB0LmluY2x1ZGVzKFwiMDVcIikgJiYgeC5zZXRBdHRyaWJ1dGUoWCwgXCJcIiksIHQuaW5jbHVkZXMoXCIxM1wiKSA/IEwuc2V0QXR0cmlidXRlKHZzLCBcIlwiKSA6IEwuc2V0QXR0cmlidXRlKGJzLCBcIlwiKSwgeC5hcHBlbmRDaGlsZChMKSwgdi5hcHBlbmRDaGlsZCh4KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHRoaXMuX2VsZW1lbnQgPSB0LCB0aGlzLl9lbGVtZW50ICYmIHkuc2V0RGF0YSh0LCBVcywgdGhpcyksIHRoaXMuX2RvY3VtZW50ID0gZG9jdW1lbnQsIHRoaXMuX29wdGlvbnMgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX2NsYXNzZXMgPSB0aGlzLl9nZXRDbGFzc2VzKGkpLCB0aGlzLl9jdXJyZW50VGltZSA9IG51bGwsIHRoaXMuX3RvZ2dsZUJ1dHRvbklkID0gcnQoXCJ0aW1lcGlja2VyLXRvZ2dsZS1cIiksIHRoaXMuaG91cnNBcnJheSA9IFtcbiAgICAgIFwiMTJcIixcbiAgICAgIFwiMVwiLFxuICAgICAgXCIyXCIsXG4gICAgICBcIjNcIixcbiAgICAgIFwiNFwiLFxuICAgICAgXCI1XCIsXG4gICAgICBcIjZcIixcbiAgICAgIFwiN1wiLFxuICAgICAgXCI4XCIsXG4gICAgICBcIjlcIixcbiAgICAgIFwiMTBcIixcbiAgICAgIFwiMTFcIlxuICAgIF0sIHRoaXMuaW5uZXJIb3VycyA9IFtcbiAgICAgIFwiMDBcIixcbiAgICAgIFwiMTNcIixcbiAgICAgIFwiMTRcIixcbiAgICAgIFwiMTVcIixcbiAgICAgIFwiMTZcIixcbiAgICAgIFwiMTdcIixcbiAgICAgIFwiMThcIixcbiAgICAgIFwiMTlcIixcbiAgICAgIFwiMjBcIixcbiAgICAgIFwiMjFcIixcbiAgICAgIFwiMjJcIixcbiAgICAgIFwiMjNcIlxuICAgIF0sIHRoaXMubWludXRlc0FycmF5ID0gW1xuICAgICAgXCIwMFwiLFxuICAgICAgXCIwNVwiLFxuICAgICAgXCIxMFwiLFxuICAgICAgXCIxNVwiLFxuICAgICAgXCIyMFwiLFxuICAgICAgXCIyNVwiLFxuICAgICAgXCIzMFwiLFxuICAgICAgXCIzNVwiLFxuICAgICAgXCI0MFwiLFxuICAgICAgXCI0NVwiLFxuICAgICAgXCI1MFwiLFxuICAgICAgXCI1NVwiXG4gICAgXSwgdGhpcy5pbnB1dCA9IGQuZmluZE9uZShcImlucHV0XCIsIHRoaXMuX2VsZW1lbnQpLCB0aGlzLmRhdGFXaXRoSWNvbiA9IHQuZGF0YXNldC53aXRoSWNvbiwgdGhpcy5kYXRhVG9nZ2xlID0gdC5kYXRhc2V0LnRvZ2dsZSwgdGhpcy5jdXN0b21JY29uID0gZC5maW5kT25lKFxuICAgICAgS20sXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKSwgdGhpcy5fY2hlY2tUb2dnbGVCdXR0b24oKSwgdGhpcy5pbnB1dEZvcm1hdFNob3cgPSBkLmZpbmRPbmUoXG4gICAgICBqbSxcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApLCB0aGlzLmlucHV0Rm9ybWF0ID0gdGhpcy5pbnB1dEZvcm1hdFNob3cgPT09IG51bGwgPyBcIlwiIDogT2JqZWN0LnZhbHVlcyh0aGlzLmlucHV0Rm9ybWF0U2hvdy5kYXRhc2V0KVswXSwgdGhpcy5lbGVtZW50VG9nZ2xlID0gZC5maW5kT25lKFxuICAgICAgUGEsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKSwgdGhpcy50b2dnbGVFbGVtZW50ID0gT2JqZWN0LnZhbHVlcyhcbiAgICAgIHQucXVlcnlTZWxlY3RvcihQYSkuZGF0YXNldFxuICAgIClbMF0sIHRoaXMuX2hvdXIgPSBudWxsLCB0aGlzLl9taW51dGVzID0gbnVsbCwgdGhpcy5fQU0gPSBudWxsLCB0aGlzLl9QTSA9IG51bGwsIHRoaXMuX3dyYXBwZXIgPSBudWxsLCB0aGlzLl9tb2RhbCA9IG51bGwsIHRoaXMuX2hhbmQgPSBudWxsLCB0aGlzLl9jaXJjbGUgPSBudWxsLCB0aGlzLl9mb2N1c1RyYXAgPSBudWxsLCB0aGlzLl9wb3BwZXIgPSBudWxsLCB0aGlzLl9pbnRlcnZhbCA9IG51bGwsIHRoaXMuX3RpbWVvdXRJbnRlcnZhbCA9IG51bGwsIHRoaXMuX2lucHV0VmFsdWUgPSB0aGlzLl9vcHRpb25zLmRlZmF1bHRUaW1lICE9PSBcIlwiID8gdGhpcy5fb3B0aW9ucy5kZWZhdWx0VGltZSA6IHRoaXMuaW5wdXQudmFsdWUsIHRoaXMuX29wdGlvbnMuZm9ybWF0MjQgJiYgKHRoaXMuX29wdGlvbnMuZm9ybWF0MTIgPSAhMSwgdGhpcy5fY3VycmVudFRpbWUgPSBMYSh0aGlzLl9pbnB1dFZhbHVlKSksIHRoaXMuX29wdGlvbnMuZm9ybWF0MTIgJiYgKHRoaXMuX29wdGlvbnMuZm9ybWF0MjQgPSAhMSwgdGhpcy5fY3VycmVudFRpbWUgPSB2ZSh0aGlzLl9pbnB1dFZhbHVlKSksIHRoaXMuX29wdGlvbnMucmVhZE9ubHkgJiYgdGhpcy5pbnB1dC5zZXRBdHRyaWJ1dGUocW0sICEwKSwgdGhpcy5pbnB1dEZvcm1hdCA9PT0gXCJ0cnVlXCIgJiYgdGhpcy5pbnB1dEZvcm1hdCAhPT0gXCJcIiAmJiAodGhpcy5fb3B0aW9ucy5mb3JtYXQxMiA9ICExLCB0aGlzLl9vcHRpb25zLmZvcm1hdDI0ID0gITAsIHRoaXMuX2N1cnJlbnRUaW1lID0gTGEodGhpcy5faW5wdXRWYWx1ZSkpLCB0aGlzLl9hbmltYXRpb25zID0gIXdpbmRvdy5tYXRjaE1lZGlhKFwiKHByZWZlcnMtcmVkdWNlZC1tb3Rpb246IHJlZHVjZSlcIikubWF0Y2hlcyAmJiB0aGlzLl9vcHRpb25zLmFuaW1hdGlvbnMsIHRoaXMuaW5pdCgpLCB0aGlzLl9pc0hvdXJzID0gITAsIHRoaXMuX2lzTWludXRlcyA9ICExLCB0aGlzLl9pc0ludmFsaWRUaW1lRm9ybWF0ID0gITEsIHRoaXMuX2lzTW91c2VNb3ZlID0gITEsIHRoaXMuX2lzSW5uZXIgPSAhMSwgdGhpcy5faXNBbUVuYWJsZWQgPSAhMSwgdGhpcy5faXNQbUVuYWJsZWQgPSAhMSwgdGhpcy5fb3B0aW9ucy5mb3JtYXQxMiAmJiAhdGhpcy5fb3B0aW9ucy5kZWZhdWx0VGltZSAmJiAodGhpcy5faXNQbUVuYWJsZWQgPSAhMCksIHRoaXMuX29ialdpdGhEYXRhT25DaGFuZ2UgPSB7IGRlZ3JlZXM6IG51bGwgfSwgdGhpcy5fc2Nyb2xsQmFyID0gbmV3IHFlKCk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuICRpO1xuICB9XG4gIC8vIFB1YmxpY1xuICBpbml0KCkge1xuICAgIGNvbnN0IHsgZm9ybWF0MTI6IHQsIGZvcm1hdDI0OiBlLCBlbmFibGVWYWxpZGF0aW9uOiBpIH0gPSB0aGlzLl9vcHRpb25zO1xuICAgIGxldCBuLCBvLCByO1xuICAgIGlmICh0aGlzLmlucHV0LnNldEF0dHJpYnV0ZShRbSwgXCJcIiksIHRoaXMuX2N1cnJlbnRUaW1lICE9PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IHsgaG91cnM6IGEsIG1pbnV0ZXM6IGwsIGFtT3JQbTogcCB9ID0gdGhpcy5fY3VycmVudFRpbWU7XG4gICAgICBuID0gTnVtYmVyKGEpIDwgMTAgPyAwIDogXCJcIiwgbyA9IGAke259JHtOdW1iZXIoYSl9OiR7bH1gLCByID0gcCwgdCA/IHRoaXMuaW5wdXQudmFsdWUgPSBgJHtvfSAke3J9YCA6IGUgJiYgKHRoaXMuaW5wdXQudmFsdWUgPSBgJHtvfWApO1xuICAgIH0gZWxzZVxuICAgICAgbiA9IFwiXCIsIG8gPSBcIlwiLCByID0gXCJcIiwgdGhpcy5pbnB1dC52YWx1ZSA9IFwiXCI7XG4gICAgdGhpcy5pbnB1dC52YWx1ZS5sZW5ndGggPiAwICYmIHRoaXMuaW5wdXQudmFsdWUgIT09IFwiXCIgJiYgKHRoaXMuaW5wdXQuc2V0QXR0cmlidXRlKEgsIFwiXCIpLCBjLnRyaWdnZXIodGhpcy5pbnB1dCwgXCJpbnB1dFwiKSksICEodGhpcy5fb3B0aW9ucyA9PT0gbnVsbCAmJiB0aGlzLl9lbGVtZW50ID09PSBudWxsKSAmJiAoaSAmJiB0aGlzLl9nZXRWYWxpZGF0ZShcImtleWRvd24gY2hhbmdlIGJsdXIgZm9jdXNcIiksIHRoaXMuX2hhbmRsZU9wZW4oKSwgdGhpcy5fbGlzdGVuVG9Ub2dnbGVLZXlkb3duKCkpO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5fcmVtb3ZlTW9kYWwoKSwgdGhpcy5fZWxlbWVudCAhPT0gbnVsbCAmJiB5LnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgVXMpLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuX2VsZW1lbnQgPSBudWxsLCB0aGlzLl9vcHRpb25zID0gbnVsbCwgdGhpcy5pbnB1dCA9IG51bGwsIHRoaXMuX2ZvY3VzVHJhcCA9IG51bGw7XG4gICAgfSwgMzUwKSwgYy5vZmYoXG4gICAgICB0aGlzLl9kb2N1bWVudCxcbiAgICAgIFwiY2xpY2tcIixcbiAgICAgIGBbZGF0YS10ZS10b2dnbGU9JyR7dGhpcy50b2dnbGVFbGVtZW50fSddYFxuICAgICksIGMub2ZmKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIFwia2V5ZG93blwiLFxuICAgICAgYFtkYXRhLXRlLXRvZ2dsZT0nJHt0aGlzLnRvZ2dsZUVsZW1lbnR9J11gXG4gICAgKTtcbiAgfVxuICB1cGRhdGUodCA9IHt9KSB7XG4gICAgdGhpcy5fb3B0aW9ucyA9IHRoaXMuX2dldENvbmZpZyh7IC4uLnRoaXMuX29wdGlvbnMsIC4uLnQgfSk7XG4gIH1cbiAgLy8gcHJpdmF0ZVxuICBfY2hlY2tUb2dnbGVCdXR0b24oKSB7XG4gICAgdGhpcy5jdXN0b21JY29uID09PSBudWxsICYmICh0aGlzLmRhdGFXaXRoSWNvbiAhPT0gdm9pZCAwICYmICh0aGlzLl9vcHRpb25zLndpdGhJY29uID0gbnVsbCwgdGhpcy5kYXRhV2l0aEljb24gPT09IFwidHJ1ZVwiICYmIHRoaXMuX2FwcGVuZFRvZ2dsZUJ1dHRvbih0aGlzLl9vcHRpb25zKSksIHRoaXMuX29wdGlvbnMud2l0aEljb24gJiYgdGhpcy5fYXBwZW5kVG9nZ2xlQnV0dG9uKHRoaXMuX29wdGlvbnMpKTtcbiAgfVxuICBfYXBwZW5kVG9nZ2xlQnV0dG9uKCkge1xuICAgIGNvbnN0IHQgPSBSbShcbiAgICAgIHRoaXMuX29wdGlvbnMsXG4gICAgICB0aGlzLl90b2dnbGVCdXR0b25JZCxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApO1xuICAgIHRoaXMuaW5wdXQuaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYWZ0ZXJlbmRcIiwgdCk7XG4gIH1cbiAgX2dldERvbUVsZW1lbnRzKCkge1xuICAgIHRoaXMuX2hvdXIgPSBkLmZpbmRPbmUoYFske2dzfV1gKSwgdGhpcy5fbWludXRlcyA9IGQuZmluZE9uZShgWyR7ZW99XWApLCB0aGlzLl9BTSA9IGQuZmluZE9uZShGbSksIHRoaXMuX1BNID0gZC5maW5kT25lKFltKSwgdGhpcy5fd3JhcHBlciA9IGQuZmluZE9uZShgWyR7dG99XWApLCB0aGlzLl9tb2RhbCA9IGQuZmluZE9uZShgWyR7WmF9XWApLCB0aGlzLl9oYW5kID0gZC5maW5kT25lKGBbJHtpb31dYCksIHRoaXMuX2NpcmNsZSA9IGQuZmluZE9uZShgWyR7c299XWApLCB0aGlzLl9jbG9jayA9IGQuZmluZE9uZShgWyR7cGV9XWApLCB0aGlzLl9jbG9ja0lubmVyID0gZC5maW5kT25lKFxuICAgICAgYFske2RpfV1gXG4gICAgKTtcbiAgfVxuICBfaGFuZGxlck1heE1pbkhvdXJzT3B0aW9ucyh0LCBlLCBpLCBuLCBvLCByKSB7XG4gICAgaWYgKCFlICYmICFpKVxuICAgICAgcmV0dXJuICEwO1xuICAgIGNvbnN0IHsgZm9ybWF0MjQ6IGEsIGZvcm1hdDEyOiBsLCBkaXNhYmxlUGFzdDogcCwgZGlzYWJsZUZ1dHVyZTogdSB9ID0gdGhpcy5fb3B0aW9ucywgeyBfaXNBbUVuYWJsZWQ6IF8sIF9pc1BtRW5hYmxlZDogZiB9ID0gdGhpcywgZyA9IHIua2V5Q29kZSwgbSA9IHIudGFyZ2V0Lmhhc0F0dHJpYnV0ZShkaSkgfHwgci50YXJnZXQuaGFzQXR0cmlidXRlKGx0KSB8fCByLnRhcmdldC5oYXNBdHRyaWJ1dGUodnMpO1xuICAgIGkgPSBYdChpLCBwLCBsKSwgZSA9IEd0KGUsIHUsIGwpLCB0eXBlb2YgZSAhPSBcIm51bWJlclwiICYmIChlID0gUihlLCAhMSlbMF0pO1xuICAgIGNvbnN0IGIgPSBlICE9PSBcIlwiID8gZSAqIDMwIDogXCJcIiwgdiA9IGkgIT09IFwiXCIgPyBpICogMzAgOiBcIlwiO1xuICAgIHQgPCAwICYmICh0ID0gMzYwICsgdCksIHQgPSB0ID09PSAzNjAgPyAwIDogdDtcbiAgICBjb25zdCBDID0gKCkgPT4ge1xuICAgICAgY29uc3QgSSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXG4gICAgICAgIGBbJHtic31dYFxuICAgICAgKSwgTyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXG4gICAgICAgIGBbJHt2c31dYFxuICAgICAgKSwgeCA9IFdtKHRoaXMuX2hvdXIuaW5uZXJUZXh0KTtcbiAgICAgIGxldCBMLCBTLCBOO1xuICAgICAgcmV0dXJuIGcgPT09IGF0ID8gUyA9IDEgOiBnID09PSB6ICYmIChTID0gLTEpLCB4ID09PSAxMiAmJiBnID09PSBhdCA/IE4gPSAxIDogeCA9PT0gMCAmJiBnID09PSBhdCA/IE4gPSAxMyA6IHggPT09IDAgJiYgZyA9PT0geiA/IE4gPSAyMyA6IHggPT09IDEzICYmIGcgPT09IHogPyBOID0gMCA6IHggPT09IDEgJiYgZyA9PT0geiA/IE4gPSAxMiA6IE4gPSB4ICsgUywgSS5mb3JFYWNoKChQKSA9PiB7XG4gICAgICAgIE51bWJlcihQLnRleHRDb250ZW50KSA9PT0gTiAmJiAoTCA9IFApO1xuICAgICAgfSksIE8uZm9yRWFjaCgoUCkgPT4ge1xuICAgICAgICBOdW1iZXIoUC50ZXh0Q29udGVudCkgPT09IE4gJiYgKEwgPSBQKTtcbiAgICAgIH0pLCAhTC5wYXJlbnRFbGVtZW50Lmhhc0F0dHJpYnV0ZShZdCk7XG4gICAgfSwgdyA9ICgpID0+IHtcbiAgICAgIGNvbnN0IEkgPSBpICE9PSBcIlwiICYmIGkgPiAxMiA/IChpIC0gMTIpICogMzAgOiBcIlwiLCBPID0gZSAhPT0gXCJcIiAmJiBlID4gMTIgPyAoZSAtIDEyKSAqIDMwIDogXCJcIjtcbiAgICAgIGlmICghKEkgJiYgdCA8IEkgfHwgTyAmJiB0ID4gTyB8fCBlICYmIGUgPCAxMikpXG4gICAgICAgIHJldHVybiAhMDtcbiAgICB9O1xuICAgIGlmIChhICYmIHIudHlwZSAhPT0gXCJrZXlkb3duXCIgJiYgbSlcbiAgICAgIHJldHVybiB3KCk7XG4gICAgaWYgKHIudHlwZSA9PT0gXCJrZXlkb3duXCIpXG4gICAgICByZXR1cm4gQygpO1xuICAgIGNvbnN0IEUgPSAhbyB8fCBvID09PSBcIlBNXCIgJiYgZiB8fCBpICE9PSBcIlwiICYmIG8gPT09IFwiQU1cIiAmJiBfLCBUID0gIW4gfHwgbiA9PT0gXCJQTVwiICYmIGYgfHwgZSAhPT0gXCJcIiAmJiBuID09PSBcIkFNXCIgJiYgXywgQSA9ICgpID0+IHtcbiAgICAgIGNvbnN0IEkgPSB2ID09PSAzNjAgJiYgbCA/IDAgOiB2O1xuICAgICAgaWYgKGkpIHtcbiAgICAgICAgaWYgKG8gPT09IFwiUE1cIiAmJiBfIHx8IEUgJiYgdCA8IEkpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlXG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIHJldHVybiAhMDtcbiAgICB9LCBrID0gKCkgPT4ge1xuICAgICAgY29uc3QgSSA9IGIgPT09IDM2MCAmJiBsID8gMCA6IGI7XG4gICAgICBpZiAoZSkge1xuICAgICAgICBpZiAobiA9PT0gXCJBTVwiICYmIGYgfHwgVCAmJiB0ID4gSSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2VcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgcmV0dXJuICEwO1xuICAgIH07XG4gICAgcmV0dXJuIEEoKSAmJiBrKCk7XG4gIH1cbiAgX2hhbmRsZUtleWJvYXJkKCkge1xuICAgIGMub24odGhpcy5fZG9jdW1lbnQsIF9zLCBcIlwiLCAodCkgPT4ge1xuICAgICAgbGV0IGUsIGksIG47XG4gICAgICBjb25zdCB7XG4gICAgICAgIGluY3JlbWVudDogbyxcbiAgICAgICAgbWF4VGltZTogcixcbiAgICAgICAgbWluVGltZTogYSxcbiAgICAgICAgZm9ybWF0MTI6IGwsXG4gICAgICAgIGRpc2FibGVQYXN0OiBwLFxuICAgICAgICBkaXNhYmxlRnV0dXJlOiB1XG4gICAgICB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICAgIGxldCBfID0gUihhLCAhMSlbMF0sIGYgPSBSKHIsICExKVswXTtcbiAgICAgIGNvbnN0IGcgPSBSKGEsICExKVsyXSwgbSA9IFIociwgITEpWzJdO1xuICAgICAgXyA9IFh0KF8sIHAsIGwpLCBmID0gR3QoZiwgdSwgbCksIHR5cGVvZiBmICE9IFwibnVtYmVyXCIgJiYgKGYgPSBSKGYsICExKVswXSk7XG4gICAgICBjb25zdCBiID0gZC5maW5kT25lKGBbJHtYfV1gKSA9PT0gbnVsbCwgdiA9IGQuZmluZE9uZShgWyR7bHR9XWApICE9PSBudWxsLCBDID0gTnVtYmVyKHRoaXMuX2hhbmQuc3R5bGUudHJhbnNmb3JtLnJlcGxhY2UoL1teXFxkLV0vZywgXCJcIikpLCB3ID0gZC5maW5kKFxuICAgICAgICBgWyR7WH1dYCxcbiAgICAgICAgdGhpcy5fbW9kYWxcbiAgICAgICksIEUgPSBkLmZpbmQoXG4gICAgICAgIGBbJHtLfV1gLFxuICAgICAgICB0aGlzLl9tb2RhbFxuICAgICAgKSwgVCA9IGQuZmluZChcbiAgICAgICAgYFske2x0fV1gLFxuICAgICAgICB0aGlzLl9tb2RhbFxuICAgICAgKTtcbiAgICAgIGxldCBBID0gdGhpcy5fbWFrZUhvdXJEZWdyZWVzKHQudGFyZ2V0LCBDLCBlKS5ob3VyO1xuICAgICAgY29uc3QgeyBkZWdyZWVzOiBrLCBhZGREZWdyZWVzOiBJIH0gPSB0aGlzLl9tYWtlSG91ckRlZ3JlZXMoXG4gICAgICAgIHQudGFyZ2V0LFxuICAgICAgICBDLFxuICAgICAgICBlXG4gICAgICApO1xuICAgICAgbGV0IHsgbWludXRlOiBPLCBkZWdyZWVzOiB4IH0gPSB0aGlzLl9tYWtlTWludXRlc0RlZ3JlZXMoQywgaSk7XG4gICAgICBjb25zdCBMID0gdGhpcy5fbWFrZU1pbnV0ZXNEZWdyZWVzKFxuICAgICAgICBDLFxuICAgICAgICBpXG4gICAgICApLmFkZERlZ3JlZXM7XG4gICAgICBsZXQgeyBob3VyOiBTIH0gPSB0aGlzLl9tYWtlSW5uZXJIb3Vyc0RlZ3JlZXMoXG4gICAgICAgIEMsXG4gICAgICAgIG5cbiAgICAgICk7XG4gICAgICBpZiAodC5rZXlDb2RlID09PSBGaSkge1xuICAgICAgICBjb25zdCBOID0gZC5maW5kT25lKFxuICAgICAgICAgIGBbJHtHbn1dYCxcbiAgICAgICAgICB0aGlzLl9tb2RhbFxuICAgICAgICApO1xuICAgICAgICBjLnRyaWdnZXIoTiwgXCJjbGlja1wiKTtcbiAgICAgIH0gZWxzZSBpZiAoYikge1xuICAgICAgICBpZiAodiAmJiAodC5rZXlDb2RlID09PSBWZSAmJiAodGhpcy5faXNJbm5lciA9ICExLCBoLmFkZFN0eWxlKHRoaXMuX2hhbmQsIHtcbiAgICAgICAgICBoZWlnaHQ6IFwiY2FsYyg0MCUgKyAxcHgpXCJcbiAgICAgICAgfSksIHRoaXMuX2hvdXIudGV4dENvbnRlbnQgPSB0aGlzLl9zZXRIb3VyT3JNaW51dGUoXG4gICAgICAgICAgQSA+IDEyID8gMSA6IEFcbiAgICAgICAgKSwgdGhpcy5fdG9nZ2xlQ2xhc3NBY3RpdmUodGhpcy5ob3Vyc0FycmF5LCB0aGlzLl9ob3VyLCBFKSwgdGhpcy5fdG9nZ2xlQ2xhc3NBY3RpdmUodGhpcy5pbm5lckhvdXJzLCB0aGlzLl9ob3VyLCBUKSksIHQua2V5Q29kZSA9PT0gSGUgJiYgKHRoaXMuX2lzSW5uZXIgPSAhMCwgaC5hZGRTdHlsZSh0aGlzLl9oYW5kLCB7XG4gICAgICAgICAgaGVpZ2h0OiBcIjIxLjUlXCJcbiAgICAgICAgfSksIHRoaXMuX2hvdXIudGV4dENvbnRlbnQgPSB0aGlzLl9zZXRIb3VyT3JNaW51dGUoXG4gICAgICAgICAgUyA+PSAyNCB8fCBTID09PSBcIjAwXCIgPyAwIDogU1xuICAgICAgICApLCB0aGlzLl90b2dnbGVDbGFzc0FjdGl2ZSh0aGlzLmlubmVySG91cnMsIHRoaXMuX2hvdXIsIFQpLCB0aGlzLl90b2dnbGVDbGFzc0FjdGl2ZShcbiAgICAgICAgICB0aGlzLmhvdXJzQXJyYXksXG4gICAgICAgICAgdGhpcy5faG91ciAtIDEsXG4gICAgICAgICAgRVxuICAgICAgICApKSksIHQua2V5Q29kZSA9PT0gYXQpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuX2hhbmRsZXJNYXhNaW5Ib3Vyc09wdGlvbnMoXG4gICAgICAgICAgICBrICsgMzAsXG4gICAgICAgICAgICBmLFxuICAgICAgICAgICAgXyxcbiAgICAgICAgICAgIG0sXG4gICAgICAgICAgICBnLFxuICAgICAgICAgICAgdFxuICAgICAgICAgICkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgaC5hZGRTdHlsZSh0aGlzLl9oYW5kLCB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IGByb3RhdGVaKCR7ayArIEl9ZGVnKWBcbiAgICAgICAgICB9KSwgdGhpcy5faXNJbm5lciA/IChTICs9IDEsIFMgPT09IDI0ID8gUyA9IDAgOiAoUyA9PT0gMjUgfHwgUyA9PT0gXCIwMDFcIikgJiYgKFMgPSAxMyksIHRoaXMuX2hvdXIudGV4dENvbnRlbnQgPSB0aGlzLl9zZXRIb3VyT3JNaW51dGUoUyksIHRoaXMuX3RvZ2dsZUNsYXNzQWN0aXZlKHRoaXMuaW5uZXJIb3VycywgdGhpcy5faG91ciwgVCkpIDogKEEgKz0gMSwgdGhpcy5faG91ci50ZXh0Q29udGVudCA9IHRoaXMuX3NldEhvdXJPck1pbnV0ZShcbiAgICAgICAgICAgIEEgPiAxMiA/IDEgOiBBXG4gICAgICAgICAgKSwgdGhpcy5fdG9nZ2xlQ2xhc3NBY3RpdmUodGhpcy5ob3Vyc0FycmF5LCB0aGlzLl9ob3VyLCBFKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHQua2V5Q29kZSA9PT0geikge1xuICAgICAgICAgIGlmICghdGhpcy5faGFuZGxlck1heE1pbkhvdXJzT3B0aW9ucyhcbiAgICAgICAgICAgIGsgLSAzMCxcbiAgICAgICAgICAgIGYsXG4gICAgICAgICAgICBfLFxuICAgICAgICAgICAgbSxcbiAgICAgICAgICAgIGcsXG4gICAgICAgICAgICB0XG4gICAgICAgICAgKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBoLmFkZFN0eWxlKHRoaXMuX2hhbmQsIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogYHJvdGF0ZVooJHtrIC0gSX1kZWcpYFxuICAgICAgICAgIH0pLCB0aGlzLl9pc0lubmVyID8gKFMgLT0gMSwgUyA9PT0gMTIgPyBTID0gMCA6IFMgPT09IC0xICYmIChTID0gMjMpLCB0aGlzLl9ob3VyLnRleHRDb250ZW50ID0gdGhpcy5fc2V0SG91ck9yTWludXRlKFMpLCB0aGlzLl90b2dnbGVDbGFzc0FjdGl2ZSh0aGlzLmlubmVySG91cnMsIHRoaXMuX2hvdXIsIFQpKSA6IChBIC09IDEsIHRoaXMuX2hvdXIudGV4dENvbnRlbnQgPSB0aGlzLl9zZXRIb3VyT3JNaW51dGUoXG4gICAgICAgICAgICBBID09PSAwID8gMTIgOiBBXG4gICAgICAgICAgKSwgdGhpcy5fdG9nZ2xlQ2xhc3NBY3RpdmUodGhpcy5ob3Vyc0FycmF5LCB0aGlzLl9ob3VyLCBFKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZVxuICAgICAgICB0LmtleUNvZGUgPT09IGF0ICYmICh4ICs9IEwsIGguYWRkU3R5bGUodGhpcy5faGFuZCwge1xuICAgICAgICAgIHRyYW5zZm9ybTogYHJvdGF0ZVooJHt4fWRlZylgXG4gICAgICAgIH0pLCBPICs9IDEsIG8gJiYgKE8gKz0gNCwgTyA9PT0gXCIwMDE0XCIgJiYgKE8gPSA1KSksIHRoaXMuX21pbnV0ZXMudGV4dENvbnRlbnQgPSB0aGlzLl9zZXRIb3VyT3JNaW51dGUoXG4gICAgICAgICAgTyA+IDU5ID8gMCA6IE9cbiAgICAgICAgKSwgdGhpcy5fdG9nZ2xlQ2xhc3NBY3RpdmUoXG4gICAgICAgICAgdGhpcy5taW51dGVzQXJyYXksXG4gICAgICAgICAgdGhpcy5fbWludXRlcyxcbiAgICAgICAgICB3XG4gICAgICAgICksIHRoaXMuX3RvZ2dsZUJhY2tncm91bmRDb2xvckNpcmNsZShcbiAgICAgICAgICBgWyR7WH1dYFxuICAgICAgICApKSwgdC5rZXlDb2RlID09PSB6ICYmICh4IC09IEwsIGguYWRkU3R5bGUodGhpcy5faGFuZCwge1xuICAgICAgICAgIHRyYW5zZm9ybTogYHJvdGF0ZVooJHt4fWRlZylgXG4gICAgICAgIH0pLCBvID8gTyAtPSA1IDogTyAtPSAxLCBPID09PSAtMSA/IE8gPSA1OSA6IE8gPT09IC01ICYmIChPID0gNTUpLCB0aGlzLl9taW51dGVzLnRleHRDb250ZW50ID0gdGhpcy5fc2V0SG91ck9yTWludXRlKE8pLCB0aGlzLl90b2dnbGVDbGFzc0FjdGl2ZShcbiAgICAgICAgICB0aGlzLm1pbnV0ZXNBcnJheSxcbiAgICAgICAgICB0aGlzLl9taW51dGVzLFxuICAgICAgICAgIHdcbiAgICAgICAgKSwgdGhpcy5fdG9nZ2xlQmFja2dyb3VuZENvbG9yQ2lyY2xlKFxuICAgICAgICAgIGBbJHtYfV1gXG4gICAgICAgICkpO1xuICAgIH0pO1xuICB9XG4gIF9zZXRBY3RpdmVDbGFzc1RvVGlwc09uT3Blbih0LCAuLi5lKSB7XG4gICAgaWYgKCF0aGlzLl9pc0ludmFsaWRUaW1lRm9ybWF0KVxuICAgICAgaWYgKHRoaXMuX29wdGlvbnMuZm9ybWF0MjQpIHtcbiAgICAgICAgY29uc3QgaSA9IGQuZmluZChcbiAgICAgICAgICBgWyR7S31dYCxcbiAgICAgICAgICB0aGlzLl9tb2RhbFxuICAgICAgICApLCBuID0gZC5maW5kKFxuICAgICAgICAgIGBbJHtsdH1dYCxcbiAgICAgICAgICB0aGlzLl9tb2RhbFxuICAgICAgICApO1xuICAgICAgICB0aGlzLl9hZGRBY3RpdmVDbGFzc1RvVGlwKGksIHQpLCB0aGlzLl9hZGRBY3RpdmVDbGFzc1RvVGlwKG4sIHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgWy4uLmVdLmZpbHRlcigobikgPT4gKG4gPT09IFwiUE1cIiA/IChoLmFkZENsYXNzKHRoaXMuX1BNLCB0aGlzLl9jbGFzc2VzLm9wYWNpdHkpLCB0aGlzLl9QTS5zZXRBdHRyaWJ1dGUoSCwgXCJcIikpIDogbiA9PT0gXCJBTVwiID8gKGguYWRkQ2xhc3ModGhpcy5fQU0sIHRoaXMuX2NsYXNzZXMub3BhY2l0eSksIHRoaXMuX0FNLnNldEF0dHJpYnV0ZShILCBcIlwiKSkgOiAoaC5yZW1vdmVDbGFzcyh0aGlzLl9BTSwgdGhpcy5fY2xhc3Nlcy5vcGFjaXR5KSwgaC5yZW1vdmVDbGFzcyh0aGlzLl9QTSwgdGhpcy5fY2xhc3Nlcy5vcGFjaXR5KSwgdGhpcy5fQU0ucmVtb3ZlQXR0cmlidXRlKEgpLCB0aGlzLl9QTS5yZW1vdmVBdHRyaWJ1dGUoSCkpLCBuKSk7XG4gICAgICAgIGNvbnN0IGkgPSBkLmZpbmQoXG4gICAgICAgICAgYFske0t9XWAsXG4gICAgICAgICAgdGhpcy5fbW9kYWxcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5fYWRkQWN0aXZlQ2xhc3NUb1RpcChpLCB0KTtcbiAgICAgIH1cbiAgfVxuICBfc2V0VGlwc0FuZFRpbWVzRGVwZW5kT25JbnB1dFZhbHVlKHQsIGUpIHtcbiAgICBjb25zdCB7IGlubGluZTogaSwgZm9ybWF0MTI6IG4gfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgaWYgKHRoaXMuX2lzSW52YWxpZFRpbWVGb3JtYXQpXG4gICAgICB0aGlzLl9ob3VyLnRleHRDb250ZW50ID0gXCIxMlwiLCB0aGlzLl9taW51dGVzLnRleHRDb250ZW50ID0gXCIwMFwiLCBpIHx8IGguYWRkU3R5bGUodGhpcy5faGFuZCwge1xuICAgICAgICB0cmFuc2Zvcm06IFwicm90YXRlWigwZGVnKVwiXG4gICAgICB9KSwgbiAmJiAoaC5hZGRDbGFzcyh0aGlzLl9QTSwgdGhpcy5fY2xhc3Nlcy5vcGFjaXR5KSwgdGhpcy5fUE0uc2V0QXR0cmlidXRlKEgsIFwiXCIpKTtcbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IG8gPSB0ID4gMTIgPyB0ICogMzAgLSAzNjAgOiB0ICogMzA7XG4gICAgICB0aGlzLl9ob3VyLnRleHRDb250ZW50ID0gdCwgdGhpcy5fbWludXRlcy50ZXh0Q29udGVudCA9IGUsIGkgfHwgKGguYWRkU3R5bGUodGhpcy5faGFuZCwge1xuICAgICAgICB0cmFuc2Zvcm06IGByb3RhdGVaKCR7b31kZWcpYFxuICAgICAgfSksIGguYWRkU3R5bGUodGhpcy5fY2lyY2xlLCB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjMTk3NmQyXCJcbiAgICAgIH0pLCAoTnVtYmVyKHQpID4gMTIgfHwgdCA9PT0gXCIwMFwiKSAmJiBoLmFkZFN0eWxlKHRoaXMuX2hhbmQsIHtcbiAgICAgICAgaGVpZ2h0OiBcIjIxLjUlXCJcbiAgICAgIH0pKTtcbiAgICB9XG4gIH1cbiAgX2xpc3RlblRvVG9nZ2xlS2V5ZG93bigpIHtcbiAgICBjLm9uKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIFwia2V5ZG93blwiLFxuICAgICAgYFtkYXRhLXRlLXRvZ2dsZT0nJHt0aGlzLnRvZ2dsZUVsZW1lbnR9J11gLFxuICAgICAgKHQpID0+IHtcbiAgICAgICAgdC5rZXlDb2RlID09PSBjdCAmJiAodC5wcmV2ZW50RGVmYXVsdCgpLCBjLnRyaWdnZXIodGhpcy5lbGVtZW50VG9nZ2xlLCBcImNsaWNrXCIpKTtcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIF9oYW5kbGVPcGVuKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9nZXRDb250YWluZXIoKTtcbiAgICByZS5vbihcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBcImNsaWNrXCIsXG4gICAgICBgW2RhdGEtdGUtdG9nZ2xlPScke3RoaXMudG9nZ2xlRWxlbWVudH0nXWAsXG4gICAgICAoZSkgPT4ge1xuICAgICAgICBpZiAodGhpcy5fb3B0aW9ucyA9PT0gbnVsbClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGkgPSBoLmdldERhdGFBdHRyaWJ1dGUodGhpcy5pbnB1dCwgXCJ0b2dnbGVcIikgIT09IG51bGwgPyAyMDAgOiAwO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBoLmFkZFN0eWxlKHRoaXMuZWxlbWVudFRvZ2dsZSwge1xuICAgICAgICAgICAgcG9pbnRlckV2ZW50czogXCJub25lXCJcbiAgICAgICAgICB9KSwgdGhpcy5lbGVtZW50VG9nZ2xlLmJsdXIoKTtcbiAgICAgICAgICBsZXQgbjtcbiAgICAgICAgICBSKHRoaXMuaW5wdXQpWzBdID09PSBcIlwiID8gbiA9IFtcIjEyXCIsIFwiMDBcIiwgXCJQTVwiXSA6IG4gPSBSKHRoaXMuaW5wdXQpO1xuICAgICAgICAgIGNvbnN0IHsgbW9kYWxJRDogbywgaW5saW5lOiByLCBmb3JtYXQxMjogYSB9ID0gdGhpcy5fb3B0aW9ucywgW2wsIHAsIHVdID0gbiwgXyA9ICQoXCJkaXZcIik7XG4gICAgICAgICAgaWYgKChOdW1iZXIobCkgPiAxMiB8fCBsID09PSBcIjAwXCIpICYmICh0aGlzLl9pc0lubmVyID0gITApLCB0aGlzLmlucHV0LmJsdXIoKSwgZS50YXJnZXQuYmx1cigpLCBfLmlubmVySFRNTCA9IE1tKHRoaXMuX29wdGlvbnMsIHRoaXMuX2NsYXNzZXMpLCBoLmFkZENsYXNzKF8sIHRoaXMuX2NsYXNzZXMubW9kYWwpLCBfLnNldEF0dHJpYnV0ZShaYSwgXCJcIiksIF8uc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcImRpYWxvZ1wiKSwgXy5zZXRBdHRyaWJ1dGUoXCJ0YWJJbmRleFwiLCBcIi0xXCIpLCBfLnNldEF0dHJpYnV0ZShcImlkXCIsIG8pLCByID8gKHRoaXMuX3BvcHBlciA9IENlKHRoaXMuaW5wdXQsIF8sIHtcbiAgICAgICAgICAgIHBsYWNlbWVudDogXCJib3R0b20tc3RhcnRcIlxuICAgICAgICAgIH0pLCB0LmFwcGVuZENoaWxkKF8pKSA6ICh0LmFwcGVuZENoaWxkKF8pLCB0aGlzLl9zY3JvbGxCYXIuaGlkZSgpKSwgdGhpcy5fZ2V0RG9tRWxlbWVudHMoKSwgdGhpcy5fYW5pbWF0aW9ucyA/IHRoaXMuX3RvZ2dsZUJhY2tkcm9wQW5pbWF0aW9uKCkgOiBoLmFkZENsYXNzKHRoaXMuX3dyYXBwZXIsIHRoaXMuX2NsYXNzZXMub3BhY2l0eSksIHRoaXMuX3NldEFjdGl2ZUNsYXNzVG9UaXBzT25PcGVuKGwsIHAsIHUpLCB0aGlzLl9hcHBlbmRUaW1lcygpLCB0aGlzLl9zZXRBY3RpdmVDbGFzc1RvVGlwc09uT3BlbihsLCBwLCB1KSwgdGhpcy5fc2V0VGlwc0FuZFRpbWVzRGVwZW5kT25JbnB1dFZhbHVlKGwsIHApLCB0aGlzLmlucHV0LnZhbHVlID09PSBcIlwiKSB7XG4gICAgICAgICAgICBjb25zdCBmID0gZC5maW5kKFxuICAgICAgICAgICAgICBgWyR7S31dYCxcbiAgICAgICAgICAgICAgdGhpcy5fbW9kYWxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBhICYmIChoLmFkZENsYXNzKHRoaXMuX1BNLCB0aGlzLl9jbGFzc2VzLm9wYWNpdHkpLCB0aGlzLl9QTS5zZXRBdHRyaWJ1dGUoSCwgXCJcIikpLCB0aGlzLl9ob3VyLnRleHRDb250ZW50ID0gXCIxMlwiLCB0aGlzLl9taW51dGVzLnRleHRDb250ZW50ID0gXCIwMFwiLCB0aGlzLl9hZGRBY3RpdmVDbGFzc1RvVGlwKFxuICAgICAgICAgICAgICBmLFxuICAgICAgICAgICAgICBOdW1iZXIodGhpcy5faG91ci50ZXh0Q29udGVudClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLl9oYW5kbGVTd2l0Y2hUaW1lTW9kZSgpLCB0aGlzLl9oYW5kbGVPa0J1dHRvbigpLCB0aGlzLl9oYW5kbGVDbG9zZSgpLCByKVxuICAgICAgICAgICAgdGhpcy5faGFuZGxlSG92ZXJJbmxpbmVCdG4oKSwgdGhpcy5faGFuZGxlRG9jdW1lbnRDbGlja0lubGluZSgpLCB0aGlzLl9oYW5kbGVJbmxpbmVDbGlja3MoKTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZVN3aXRjaEhvdXJNaW51dGUoKSwgdGhpcy5faGFuZGxlQ2xvY2tDbGljaygpLCB0aGlzLl9oYW5kbGVLZXlib2FyZCgpO1xuICAgICAgICAgICAgY29uc3QgZiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgICAgICAgIGAke2ZzfVske0h9XWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBoLmFkZENsYXNzKGYsIHRoaXMuX2NsYXNzZXMub3BhY2l0eSksIGguYWRkU3R5bGUodGhpcy5faG91ciwge1xuICAgICAgICAgICAgICBwb2ludGVyRXZlbnRzOiBcIm5vbmVcIlxuICAgICAgICAgICAgfSksIGguYWRkU3R5bGUodGhpcy5fbWludXRlcywge1xuICAgICAgICAgICAgICBwb2ludGVyRXZlbnRzOiBcIlwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fZm9jdXNUcmFwID0gbmV3IFdpKHRoaXMuX3dyYXBwZXIsIHtcbiAgICAgICAgICAgIGV2ZW50OiBcImtleWRvd25cIixcbiAgICAgICAgICAgIGNvbmRpdGlvbjogKHsga2V5OiBmIH0pID0+IGYgPT09IFwiVGFiXCJcbiAgICAgICAgICB9KSwgdGhpcy5fZm9jdXNUcmFwLnRyYXAoKTtcbiAgICAgICAgfSwgaSk7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBfaGFuZGxlSW5saW5lQ2xpY2tzKCkge1xuICAgIGxldCB0LCBlO1xuICAgIGNvbnN0IGkgPSAoZykgPT4ge1xuICAgICAgbGV0IG0gPSBnO1xuICAgICAgcmV0dXJuIG0gPiA1OSA/IG0gPSAwIDogbSA8IDAgJiYgKG0gPSA1OSksIG07XG4gICAgfSwgbiA9IChnKSA9PiB7XG4gICAgICBsZXQgbSA9IGc7XG4gICAgICByZXR1cm4gdGhpcy5fb3B0aW9ucy5mb3JtYXQyNCA/IChtID4gMjQgPyBtID0gMSA6IG0gPCAwICYmIChtID0gMjMpLCBtID4gMjMgJiYgKG0gPSAwKSkgOiAobSA+IDEyID8gbSA9IDEgOiBtIDwgMSAmJiAobSA9IDEyKSwgbSA+IDEyICYmIChtID0gMSkpLCBtO1xuICAgIH0sIG8gPSAoZykgPT4ge1xuICAgICAgY29uc3QgbSA9IG4oZyk7XG4gICAgICB0aGlzLl9ob3VyLnRleHRDb250ZW50ID0gdGhpcy5fc2V0SG91ck9yTWludXRlKG0pO1xuICAgIH0sIHIgPSAoZykgPT4ge1xuICAgICAgY29uc3QgbSA9IGkoZyk7XG4gICAgICB0aGlzLl9taW51dGVzLnRleHRDb250ZW50ID0gdGhpcy5fc2V0SG91ck9yTWludXRlKG0pO1xuICAgIH0sIGEgPSAoKSA9PiB7XG4gICAgICB0ID0gbih0KSArIDEsIG8odCk7XG4gICAgfSwgbCA9ICgpID0+IHtcbiAgICAgIGUgPSBpKGUpICsgMSwgcihlKTtcbiAgICB9LCBwID0gKCkgPT4ge1xuICAgICAgdCA9IG4odCkgLSAxLCBvKHQpO1xuICAgIH0sIHUgPSAoKSA9PiB7XG4gICAgICBlID0gaShlKSAtIDEsIHIoZSk7XG4gICAgfSwgXyA9ICgpID0+IHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWwpLCBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dEludGVydmFsKTtcbiAgICB9LCBmID0gKGcpID0+IHtcbiAgICAgIF8oKSwgdGhpcy5fdGltZW91dEludGVydmFsID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuX2ludGVydmFsID0gc2V0SW50ZXJ2YWwoZywgMTAwKTtcbiAgICAgIH0sIDUwMCk7XG4gICAgfTtcbiAgICByZS5vbihcbiAgICAgIHRoaXMuX21vZGFsLFxuICAgICAgXCJjbGljayBtb3VzZWRvd24gbW91c2V1cCB0b3VjaHN0YXJ0IHRvdWNoZW5kIGNvbnRleHRtZW51XCIsXG4gICAgICBgWyR7Wm59XSwgWyR7UW59XWAsXG4gICAgICAoZykgPT4ge1xuICAgICAgICB0ID0gTnVtYmVyKHRoaXMuX2hvdXIudGV4dENvbnRlbnQpLCBlID0gTnVtYmVyKHRoaXMuX21pbnV0ZXMudGV4dENvbnRlbnQpO1xuICAgICAgICBjb25zdCB7IHRhcmdldDogbSwgdHlwZTogYiB9ID0gZywgdiA9IGIgPT09IFwibW91c2Vkb3duXCIgfHwgYiA9PT0gXCJ0b3VjaHN0YXJ0XCI7XG4gICAgICAgIG0uY2xvc2VzdChgWyR7Wm59XWApID8gbS5jbG9zZXN0KGBbJHtabn1dYCkucGFyZW50Tm9kZS5oYXNBdHRyaWJ1dGUoWGEpID8gdiA/IGYoYSkgOiBiID09PSBcIm1vdXNldXBcIiB8fCBiID09PSBcInRvdWNoZW5kXCIgfHwgYiA9PT0gXCJjb250ZXh0bWVudVwiID8gXygpIDogYSgpIDogdiA/IGYobCkgOiBiID09PSBcIm1vdXNldXBcIiB8fCBiID09PSBcInRvdWNoZW5kXCIgfHwgYiA9PT0gXCJjb250ZXh0bWVudVwiID8gXygpIDogbCgpIDogbS5jbG9zZXN0KGBbJHtRbn1dYCkgJiYgKG0uY2xvc2VzdChgWyR7UW59XWApLnBhcmVudE5vZGUuaGFzQXR0cmlidXRlKFhhKSA/IHYgPyBmKHApIDogYiA9PT0gXCJtb3VzZXVwXCIgfHwgYiA9PT0gXCJ0b3VjaGVuZFwiID8gXygpIDogcCgpIDogdiA/IGYodSkgOiBiID09PSBcIm1vdXNldXBcIiB8fCBiID09PSBcInRvdWNoZW5kXCIgPyBfKCkgOiB1KCkpO1xuICAgICAgfVxuICAgICksIGMub24od2luZG93LCBfcywgKGcpID0+IHtcbiAgICAgIGNvbnN0IG0gPSBnLmNvZGUsIGIgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50Lmhhc0F0dHJpYnV0ZShncyksIHYgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50Lmhhc0F0dHJpYnV0ZShcbiAgICAgICAgZW9cbiAgICAgICksIEMgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBkb2N1bWVudC5ib2R5O1xuICAgICAgc3dpdGNoICh0ID0gTnVtYmVyKHRoaXMuX2hvdXIudGV4dENvbnRlbnQpLCBlID0gTnVtYmVyKHRoaXMuX21pbnV0ZXMudGV4dENvbnRlbnQpLCBtKSB7XG4gICAgICAgIGNhc2UgXCJBcnJvd1VwXCI6XG4gICAgICAgICAgZy5wcmV2ZW50RGVmYXVsdCgpLCBDIHx8IGIgPyAodGhpcy5faG91ci5mb2N1cygpLCBhKCkpIDogdiAmJiBsKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJBcnJvd0Rvd25cIjpcbiAgICAgICAgICBnLnByZXZlbnREZWZhdWx0KCksIEMgfHwgYiA/ICh0aGlzLl9ob3VyLmZvY3VzKCksIHAoKSkgOiB2ICYmIHUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBfaGFuZGxlQ2xvc2UoKSB7XG4gICAgYy5vbihcbiAgICAgIHRoaXMuX21vZGFsLFxuICAgICAgXCJjbGlja1wiLFxuICAgICAgYFske3RvfV0sIFske0dufV0sIFske1VhfV1gLFxuICAgICAgKHsgdGFyZ2V0OiB0IH0pID0+IHtcbiAgICAgICAgY29uc3QgeyBjbG9zZU1vZGFsT25CYWNrZHJvcENsaWNrOiBlIH0gPSB0aGlzLl9vcHRpb25zLCBpID0gKCkgPT4ge1xuICAgICAgICAgIHZhciBuO1xuICAgICAgICAgIGguYWRkU3R5bGUodGhpcy5lbGVtZW50VG9nZ2xlLCB7XG4gICAgICAgICAgICBwb2ludGVyRXZlbnRzOiBcImF1dG9cIlxuICAgICAgICAgIH0pLCB0aGlzLl9hbmltYXRpb25zICYmIHRoaXMuX3RvZ2dsZUJhY2tkcm9wQW5pbWF0aW9uKCEwKSwgdGhpcy5fcmVtb3ZlTW9kYWwoKSwgKG4gPSB0aGlzLl9mb2N1c1RyYXApID09IG51bGwgfHwgbi5kaXNhYmxlKCksIHRoaXMuX2ZvY3VzVHJhcCA9IG51bGwsIHRoaXMuZWxlbWVudFRvZ2dsZSA/IHRoaXMuZWxlbWVudFRvZ2dsZS5mb2N1cygpIDogdGhpcy5pbnB1dCAmJiB0aGlzLmlucHV0LmZvY3VzKCk7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0Lmhhc0F0dHJpYnV0ZShVYSkpIHtcbiAgICAgICAgICB0aGlzLl90b2dnbGVBbVBtKFwiUE1cIiksIHRoaXMuaW5wdXQudmFsdWUgPSBcIlwiLCB0aGlzLmlucHV0LnJlbW92ZUF0dHJpYnV0ZShIKTtcbiAgICAgICAgICBsZXQgbjtcbiAgICAgICAgICBSKHRoaXMuaW5wdXQpWzBdID09PSBcIlwiID8gbiA9IFtcIjEyXCIsIFwiMDBcIiwgXCJQTVwiXSA6IG4gPSBSKHRoaXMuaW5wdXQpO1xuICAgICAgICAgIGNvbnN0IFtvLCByLCBhXSA9IG47XG4gICAgICAgICAgdGhpcy5fc2V0VGlwc0FuZFRpbWVzRGVwZW5kT25JbnB1dFZhbHVlKFwiMTJcIiwgXCIwMFwiKSwgdGhpcy5fc2V0QWN0aXZlQ2xhc3NUb1RpcHNPbk9wZW4obywgciwgYSksIHRoaXMuX2hvdXIuY2xpY2soKTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgKHQuaGFzQXR0cmlidXRlKEduKSB8fCB0Lmhhc0F0dHJpYnV0ZShxbikgfHwgdC5oYXNBdHRyaWJ1dGUodG8pICYmIGUpICYmIGkoKTtcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIHNob3dWYWx1ZUlucHV0KCkge1xuICAgIHJldHVybiB0aGlzLmlucHV0LnZhbHVlO1xuICB9XG4gIF9oYW5kbGVPa0J1dHRvbigpIHtcbiAgICByZS5vbihcbiAgICAgIHRoaXMuX21vZGFsLFxuICAgICAgXCJjbGlja1wiLFxuICAgICAgYFske3FufV1gLFxuICAgICAgKCkgPT4ge1xuICAgICAgICBsZXQgeyBtYXhUaW1lOiB0LCBtaW5UaW1lOiBlIH0gPSB0aGlzLl9vcHRpb25zO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgZm9ybWF0MTI6IGksXG4gICAgICAgICAgZm9ybWF0MjQ6IG4sXG4gICAgICAgICAgcmVhZE9ubHk6IG8sXG4gICAgICAgICAgZm9jdXNJbnB1dEFmdGVyQXBwcm92ZTogcixcbiAgICAgICAgICBkaXNhYmxlUGFzdDogYSxcbiAgICAgICAgICBkaXNhYmxlRnV0dXJlOiBsXG4gICAgICAgIH0gPSB0aGlzLl9vcHRpb25zLCBwID0gdGhpcy5fZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcbiAgICAgICAgICBgJHttc31bJHtIfV1gXG4gICAgICAgICksIHUgPSBgJHt0aGlzLl9ob3VyLnRleHRDb250ZW50fToke3RoaXMuX21pbnV0ZXMudGV4dENvbnRlbnR9YCwgXyA9IE51bWJlcih0aGlzLl9ob3VyLnRleHRDb250ZW50KSwgZiA9IF8gPT09IDEyICYmIGkgPyAwIDogXywgZyA9IE51bWJlcih0aGlzLl9taW51dGVzLnRleHRDb250ZW50KTtcbiAgICAgICAgZSA9IFh0KGUsIGEsIGkpLCB0ID0gR3QodCwgbCwgaSk7XG4gICAgICAgIGxldCBbbSwgYiwgdl0gPSBSKFxuICAgICAgICAgIHQsXG4gICAgICAgICAgITFcbiAgICAgICAgKSwgW0MsIHcsIEVdID0gUihcbiAgICAgICAgICBlLFxuICAgICAgICAgICExXG4gICAgICAgICk7XG4gICAgICAgIEMgPSBDID09PSBcIjEyXCIgJiYgaSA/IFwiMDBcIiA6IEMsIG0gPSBtID09PSBcIjEyXCIgJiYgaSA/IFwiMDBcIiA6IG07XG4gICAgICAgIGNvbnN0IFQgPSBmIDwgTnVtYmVyKEMpLCBBID0gZiA+IE51bWJlcihtKTtcbiAgICAgICAgbGV0IGsgPSAhMDtcbiAgICAgICAgcCAmJiAoayA9IHYgPT09IHAudGV4dENvbnRlbnQpO1xuICAgICAgICBsZXQgSSA9ICEwO1xuICAgICAgICBwICYmIChJID0gRSA9PT0gcC50ZXh0Q29udGVudCk7XG4gICAgICAgIGNvbnN0IE8gPSBnID4gYiAmJiBmID09PSBOdW1iZXIobSksIHggPSBnIDwgdyAmJiBmID09PSBOdW1iZXIoQyk7XG4gICAgICAgIGlmICh0aGlzLmlucHV0LnNldEF0dHJpYnV0ZShILCBcIlwiKSwgaC5hZGRTdHlsZSh0aGlzLmVsZW1lbnRUb2dnbGUsIHtcbiAgICAgICAgICBwb2ludGVyRXZlbnRzOiBcImF1dG9cIlxuICAgICAgICB9KSwgdCAhPT0gXCJcIikge1xuICAgICAgICAgIGlmIChrICYmIChBIHx8IE8pKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGlmICh2ID09PSBcIkFNXCIgJiYgcC50ZXh0Q29udGVudCA9PT0gXCJQTVwiKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGUgIT09IFwiXCIgJiYgKEkgJiYgKFQgfHwgeCkgfHwgRSA9PT0gXCJQTVwiICYmIHAudGV4dENvbnRlbnQgPT09IFwiQU1cIikgfHwgQm0oXG4gICAgICAgICAgdGhpcy5fb3B0aW9ucyxcbiAgICAgICAgICB0aGlzLmlucHV0LFxuICAgICAgICAgIHRoaXMuX2hvdXIudGV4dENvbnRlbnRcbiAgICAgICAgKSAhPT0gdm9pZCAwICYmICh0aGlzLl9pc0ludmFsaWRUaW1lRm9ybWF0ICYmIHRoaXMuaW5wdXQucmVtb3ZlQXR0cmlidXRlKEpuKSwgIW8gJiYgciAmJiB0aGlzLmlucHV0LmZvY3VzKCksIGguYWRkU3R5bGUodGhpcy5lbGVtZW50VG9nZ2xlLCB7XG4gICAgICAgICAgcG9pbnRlckV2ZW50czogXCJhdXRvXCJcbiAgICAgICAgfSksIG4gPyB0aGlzLmlucHV0LnZhbHVlID0gdSA6IHAgPT09IG51bGwgPyB0aGlzLmlucHV0LnZhbHVlID0gYCR7dX0gUE1gIDogdGhpcy5pbnB1dC52YWx1ZSA9IGAke3V9ICR7cC50ZXh0Q29udGVudH1gLCB0aGlzLl9hbmltYXRpb25zICYmIHRoaXMuX3RvZ2dsZUJhY2tkcm9wQW5pbWF0aW9uKCEwKSwgdGhpcy5fcmVtb3ZlTW9kYWwoKSwgYy50cmlnZ2VyKHRoaXMuaW5wdXQsIFwiaW5wdXQudGUudGltZXBpY2tlclwiKSwgYy50cmlnZ2VyKHRoaXMuaW5wdXQsIFwiaW5wdXRcIikpO1xuICAgICAgfVxuICAgICk7XG4gIH1cbiAgX2hhbmRsZUhvdmVySW5saW5lQnRuKCkge1xuICAgIHJlLm9uKFxuICAgICAgdGhpcy5fbW9kYWwsXG4gICAgICBcIm1vdXNlb3ZlciBtb3VzZWxlYXZlXCIsXG4gICAgICBgWyR7R219XWAsXG4gICAgICAoeyB0eXBlOiB0LCB0YXJnZXQ6IGUgfSkgPT4ge1xuICAgICAgICBjb25zdCBpID0gZC5maW5kKFxuICAgICAgICAgIGBbJHtVbX1dYCxcbiAgICAgICAgICB0aGlzLl9tb2RhbFxuICAgICAgICApLCBuID0gZC5maW5kKFxuICAgICAgICAgIGBbJHtYbX1dYCxcbiAgICAgICAgICB0aGlzLl9tb2RhbFxuICAgICAgICApLCBvID0gKGwsIHApID0+IGwuZm9yRWFjaCgodSkgPT4ge1xuICAgICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgICBoLmFkZENsYXNzKHUsIHRoaXMuX2NsYXNzZXMub3BhY2l0eSksIHUuc2V0QXR0cmlidXRlKEgsIFwiXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBoLnJlbW92ZUNsYXNzKHUsIHRoaXMuX2NsYXNzZXMub3BhY2l0eSksIHUucmVtb3ZlQXR0cmlidXRlKEgpO1xuICAgICAgICB9KSwgYSA9IGUuaGFzQXR0cmlidXRlKGdzKSA/IGkgOiBuO1xuICAgICAgICBvKGEsIHQgPT09IFwibW91c2VvdmVyXCIpO1xuICAgICAgfVxuICAgICk7XG4gIH1cbiAgX2hhbmRsZURvY3VtZW50Q2xpY2tJbmxpbmUoKSB7XG4gICAgYy5vbihkb2N1bWVudCwgQmEsICh7IHRhcmdldDogdCB9KSA9PiB7XG4gICAgICBpZiAodGhpcy5fbW9kYWwgJiYgIXRoaXMuX21vZGFsLmNvbnRhaW5zKHQpICYmICF0Lmhhc0F0dHJpYnV0ZSh6bSkpIHtcbiAgICAgICAgaWYgKGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWwpLCBoLmFkZFN0eWxlKHRoaXMuZWxlbWVudFRvZ2dsZSwge1xuICAgICAgICAgIHBvaW50ZXJFdmVudHM6IFwiYXV0b1wiXG4gICAgICAgIH0pLCB0aGlzLl9yZW1vdmVNb2RhbCgpLCAhdGhpcy5fYW5pbWF0aW9ucylcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuX3RvZ2dsZUJhY2tkcm9wQW5pbWF0aW9uKCEwKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBfaGFuZGxlU3dpdGNoSG91ck1pbnV0ZSgpIHtcbiAgICBQbShcbiAgICAgIFwiY2xpY2tcIixcbiAgICAgIGZzLFxuICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICksIGMub24oXG4gICAgICB0aGlzLl9tb2RhbCxcbiAgICAgIFwiY2xpY2tcIixcbiAgICAgIGZzLFxuICAgICAgKCkgPT4ge1xuICAgICAgICBjb25zdCB7IGZvcm1hdDI0OiB0IH0gPSB0aGlzLl9vcHRpb25zLCBlID0gZC5maW5kKFxuICAgICAgICAgIGZzLFxuICAgICAgICAgIHRoaXMuX21vZGFsXG4gICAgICAgICksIGkgPSBkLmZpbmQoXG4gICAgICAgICAgYFske1h9XWAsXG4gICAgICAgICAgdGhpcy5fbW9kYWxcbiAgICAgICAgKSwgbiA9IGQuZmluZChcbiAgICAgICAgICBgWyR7S31dYCxcbiAgICAgICAgICB0aGlzLl9tb2RhbFxuICAgICAgICApLCBvID0gZC5maW5kKFxuICAgICAgICAgIGBbJHtsdH1dYCxcbiAgICAgICAgICB0aGlzLl9tb2RhbFxuICAgICAgICApLCByID0gTnVtYmVyKHRoaXMuX2hvdXIudGV4dENvbnRlbnQpLCBhID0gTnVtYmVyKHRoaXMuX21pbnV0ZXMudGV4dENvbnRlbnQpLCBsID0gKHAsIHUpID0+IHtcbiAgICAgICAgICBuLmZvckVhY2goKGYpID0+IGYucmVtb3ZlKCkpLCBpLmZvckVhY2goKGYpID0+IGYucmVtb3ZlKCkpLCBoLmFkZENsYXNzKHRoaXMuX2hhbmQsIHRoaXMuX2NsYXNzZXMudHJhbnNmb3JtKSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBoLnJlbW92ZUNsYXNzKHRoaXMuX2hhbmQsIHRoaXMuX2NsYXNzZXMudHJhbnNmb3JtKTtcbiAgICAgICAgICB9LCA0MDEpLCB0aGlzLl9nZXRBcHBlbmRDbG9jayhwLCBgWyR7cGV9XWAsIHUpO1xuICAgICAgICAgIGNvbnN0IF8gPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmID0gZC5maW5kKFxuICAgICAgICAgICAgICBgWyR7S31dYCxcbiAgICAgICAgICAgICAgdGhpcy5fbW9kYWxcbiAgICAgICAgICAgICksIGcgPSBkLmZpbmQoXG4gICAgICAgICAgICAgIGBbJHtYfV1gLFxuICAgICAgICAgICAgICB0aGlzLl9tb2RhbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMuX2FkZEFjdGl2ZUNsYXNzVG9UaXAoZiwgciksIHRoaXMuX2FkZEFjdGl2ZUNsYXNzVG9UaXAoZywgYSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAoIXQpXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgXygpO1xuICAgICAgICAgICAgfSwgNDAxKTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSBkLmZpbmQoXG4gICAgICAgICAgICAgIGBbJHtsdH1dYCxcbiAgICAgICAgICAgICAgdGhpcy5fbW9kYWxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5fYWRkQWN0aXZlQ2xhc3NUb1RpcChmLCByKSwgXygpO1xuICAgICAgICAgICAgfSwgNDAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGUuZm9yRWFjaCgocCkgPT4ge1xuICAgICAgICAgIHAuaGFzQXR0cmlidXRlKEgpICYmIChwLmhhc0F0dHJpYnV0ZShlbykgPyAoaC5hZGRDbGFzcyh0aGlzLl9oYW5kLCB0aGlzLl9jbGFzc2VzLnRyYW5zZm9ybSksIGguYWRkU3R5bGUodGhpcy5faGFuZCwge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBgcm90YXRlWigke3RoaXMuX21pbnV0ZXMudGV4dENvbnRlbnQgKiA2fWRlZylgLFxuICAgICAgICAgICAgaGVpZ2h0OiBcImNhbGMoNDAlICsgMXB4KVwiXG4gICAgICAgICAgfSksIHQgJiYgby5sZW5ndGggPiAwICYmIG8uZm9yRWFjaCgodSkgPT4gdS5yZW1vdmUoKSksIGwoXG4gICAgICAgICAgICB0aGlzLm1pbnV0ZXNBcnJheSxcbiAgICAgICAgICAgIFhcbiAgICAgICAgICApLCB0aGlzLl9ob3VyLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcIlwiLCB0aGlzLl9taW51dGVzLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcIm5vbmVcIikgOiBwLmhhc0F0dHJpYnV0ZShncykgJiYgKGguYWRkU3R5bGUodGhpcy5faGFuZCwge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBgcm90YXRlWigke3RoaXMuX2hvdXIudGV4dENvbnRlbnQgKiAzMH1kZWcpYFxuICAgICAgICAgIH0pLCBOdW1iZXIodGhpcy5faG91ci50ZXh0Q29udGVudCkgPiAxMiA/IChoLmFkZFN0eWxlKHRoaXMuX2hhbmQsIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogYHJvdGF0ZVooJHt0aGlzLl9ob3VyLnRleHRDb250ZW50ICogMzAgLSAzNjB9ZGVnKWAsXG4gICAgICAgICAgICBoZWlnaHQ6IFwiMjEuNSVcIlxuICAgICAgICAgIH0pLCBOdW1iZXIodGhpcy5faG91ci50ZXh0Q29udGVudCkgPiAxMiAmJiBoLmFkZFN0eWxlKHRoaXMuX2hhbmQsIHtcbiAgICAgICAgICAgIGhlaWdodDogXCIyMS41JVwiXG4gICAgICAgICAgfSkpIDogaC5hZGRTdHlsZSh0aGlzLl9oYW5kLCB7XG4gICAgICAgICAgICBoZWlnaHQ6IFwiY2FsYyg0MCUgKyAxcHgpXCJcbiAgICAgICAgICB9KSwgdCAmJiB0aGlzLl9nZXRBcHBlbmRDbG9jayhcbiAgICAgICAgICAgIHRoaXMuaW5uZXJIb3VycyxcbiAgICAgICAgICAgIGBbJHtkaX1dYCxcbiAgICAgICAgICAgIGx0XG4gICAgICAgICAgKSwgby5sZW5ndGggPiAwICYmIG8uZm9yRWFjaCgodSkgPT4gdS5yZW1vdmUoKSksIGwoXG4gICAgICAgICAgICB0aGlzLmhvdXJzQXJyYXksXG4gICAgICAgICAgICBLXG4gICAgICAgICAgKSwgaC5hZGRTdHlsZSh0aGlzLl9ob3VyLCB7XG4gICAgICAgICAgICBwb2ludGVyRXZlbnRzOiBcIm5vbmVcIlxuICAgICAgICAgIH0pLCBoLmFkZFN0eWxlKHRoaXMuX21pbnV0ZXMsIHtcbiAgICAgICAgICAgIHBvaW50ZXJFdmVudHM6IFwiXCJcbiAgICAgICAgICB9KSkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIF9oYW5kbGVEaXNhYmxpbmdUaXBzTWF4VGltZSh0LCBlLCBpLCBuKSB7XG4gICAgaWYgKCF0aGlzLl9vcHRpb25zLm1heFRpbWUgJiYgIXRoaXMuX29wdGlvbnMuZGlzYWJsZUZ1dHVyZSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBvID0gZC5maW5kKFxuICAgICAgYFske0t9XWBcbiAgICApLCByID0gZC5maW5kKFxuICAgICAgYFske2x0fV1gXG4gICAgKSwgYSA9IGQuZmluZChcbiAgICAgIGBbJHtYfV1gXG4gICAgKTtcbiAgICBpZiAoIWUgfHwgZSA9PT0gdCkge1xuICAgICAgTWEoXG4gICAgICAgIHIsXG4gICAgICAgIG4sXG4gICAgICAgIHRoaXMuX2NsYXNzZXMsXG4gICAgICAgIHRoaXMuX29wdGlvbnMuZm9ybWF0MTJcbiAgICAgICksIE1hKFxuICAgICAgICBvLFxuICAgICAgICBuLFxuICAgICAgICB0aGlzLl9jbGFzc2VzLFxuICAgICAgICB0aGlzLl9vcHRpb25zLmZvcm1hdDEyXG4gICAgICApLCBIbShcbiAgICAgICAgYSxcbiAgICAgICAgaSxcbiAgICAgICAgbixcbiAgICAgICAgdGhpcy5faG91ci50ZXh0Q29udGVudCxcbiAgICAgICAgdGhpcy5fY2xhc3NlcyxcbiAgICAgICAgdGhpcy5fb3B0aW9ucy5mb3JtYXQxMlxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZSA9PT0gXCJBTVwiICYmIHQgPT09IFwiUE1cIiAmJiAoby5mb3JFYWNoKChsKSA9PiB7XG4gICAgICBoLmFkZENsYXNzKGwsIHRoaXMuX2NsYXNzZXMudGlwc0Rpc2FibGVkKSwgbC5zZXRBdHRyaWJ1dGUoWXQsIFwiXCIpO1xuICAgIH0pLCBhLmZvckVhY2goKGwpID0+IHtcbiAgICAgIGguYWRkQ2xhc3MobCwgdGhpcy5fY2xhc3Nlcy50aXBzRGlzYWJsZWQpLCBsLnNldEF0dHJpYnV0ZShZdCwgXCJcIik7XG4gICAgfSkpO1xuICB9XG4gIF9oYW5kbGVEaXNhYmxpbmdUaXBzTWluVGltZSh0LCBlLCBpLCBuKSB7XG4gICAgaWYgKCF0aGlzLl9vcHRpb25zLm1pblRpbWUgJiYgIXRoaXMuX29wdGlvbnMuZGlzYWJsZVBhc3QpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgbyA9IGQuZmluZChcbiAgICAgIGBbJHtLfV1gXG4gICAgKSwgciA9IGQuZmluZChcbiAgICAgIGBbJHtsdH1dYFxuICAgICksIGEgPSBkLmZpbmQoXG4gICAgICBgWyR7WH1dYFxuICAgICk7XG4gICAgIWUgfHwgZSA9PT0gdCA/IChSYShcbiAgICAgIG8sXG4gICAgICBuLFxuICAgICAgdGhpcy5fY2xhc3NlcyxcbiAgICAgIHRoaXMuX29wdGlvbnMuZm9ybWF0MTJcbiAgICApLCBSYShcbiAgICAgIHIsXG4gICAgICBuLFxuICAgICAgdGhpcy5fY2xhc3NlcyxcbiAgICAgIHRoaXMuX29wdGlvbnMuZm9ybWF0MTJcbiAgICApLCBWbShcbiAgICAgIGEsXG4gICAgICBpLFxuICAgICAgbixcbiAgICAgIHRoaXMuX2hvdXIudGV4dENvbnRlbnQsXG4gICAgICB0aGlzLl9jbGFzc2VzLFxuICAgICAgdGhpcy5fb3B0aW9ucy5mb3JtYXQxMlxuICAgICkpIDogZSA9PT0gXCJQTVwiICYmIHQgPT09IFwiQU1cIiAmJiAoby5mb3JFYWNoKChsKSA9PiB7XG4gICAgICBoLmFkZENsYXNzKGwsIHRoaXMuX2NsYXNzZXMudGlwc0Rpc2FibGVkKSwgbC5zZXRBdHRyaWJ1dGUoWXQsIFwiXCIpO1xuICAgIH0pLCBhLmZvckVhY2goKGwpID0+IHtcbiAgICAgIGguYWRkQ2xhc3MobCwgdGhpcy5fY2xhc3Nlcy50aXBzRGlzYWJsZWQpLCBsLnNldEF0dHJpYnV0ZShZdCwgXCJcIik7XG4gICAgfSkpO1xuICB9XG4gIF9oYW5kbGVTd2l0Y2hUaW1lTW9kZSgpIHtcbiAgICBjLm9uKFxuICAgICAgZG9jdW1lbnQsXG4gICAgICBcImNsaWNrXCIsXG4gICAgICBtcyxcbiAgICAgICh7IHRhcmdldDogdCB9KSA9PiB7XG4gICAgICAgIGxldCB7IG1heFRpbWU6IGUsIG1pblRpbWU6IGkgfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgICAgIGNvbnN0IHsgZGlzYWJsZVBhc3Q6IG4sIGRpc2FibGVGdXR1cmU6IG8sIGZvcm1hdDEyOiByIH0gPSB0aGlzLl9vcHRpb25zO1xuICAgICAgICBpID0gWHQoaSwgbiwgciksIGUgPSBHdChlLCBvLCByKTtcbiAgICAgICAgY29uc3QgW2EsIGwsIHBdID0gUihcbiAgICAgICAgICBlLFxuICAgICAgICAgICExXG4gICAgICAgICksIFt1LCBfLCBmXSA9IFIoXG4gICAgICAgICAgaSxcbiAgICAgICAgICAhMVxuICAgICAgICApLCBnID0gZC5maW5kKFxuICAgICAgICAgIGBbJHtLfV1gXG4gICAgICAgICksIG0gPSBkLmZpbmQoXG4gICAgICAgICAgYFske1h9XWBcbiAgICAgICAgKTtcbiAgICAgICAgKCgpID0+IHtcbiAgICAgICAgICBnLmZvckVhY2goKHYpID0+IHtcbiAgICAgICAgICAgIGgucmVtb3ZlQ2xhc3ModiwgdGhpcy5fY2xhc3Nlcy50aXBzRGlzYWJsZWQpLCB2LnJlbW92ZUF0dHJpYnV0ZShZdCk7XG4gICAgICAgICAgfSksIG0uZm9yRWFjaCgodikgPT4ge1xuICAgICAgICAgICAgaC5yZW1vdmVDbGFzcyh2LCB0aGlzLl9jbGFzc2VzLnRpcHNEaXNhYmxlZCksIHYucmVtb3ZlQXR0cmlidXRlKFl0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSkoKSwgdGhpcy5faGFuZGxlRGlzYWJsaW5nVGlwc01pblRpbWUoXG4gICAgICAgICAgdC50ZXh0Q29udGVudCxcbiAgICAgICAgICBmLFxuICAgICAgICAgIF8sXG4gICAgICAgICAgdVxuICAgICAgICApLCB0aGlzLl9oYW5kbGVEaXNhYmxpbmdUaXBzTWF4VGltZShcbiAgICAgICAgICB0LnRleHRDb250ZW50LFxuICAgICAgICAgIHAsXG4gICAgICAgICAgbCxcbiAgICAgICAgICBhXG4gICAgICAgICksIHRoaXMuX3RvZ2dsZUFtUG0odC50ZXh0Q29udGVudCksIHQuaGFzQXR0cmlidXRlKEgpIHx8IChkLmZpbmQoXG4gICAgICAgICAgbXNcbiAgICAgICAgKS5mb3JFYWNoKChDKSA9PiB7XG4gICAgICAgICAgQy5oYXNBdHRyaWJ1dGUoSCkgJiYgKGgucmVtb3ZlQ2xhc3MoQywgdGhpcy5fY2xhc3Nlcy5vcGFjaXR5KSwgQy5yZW1vdmVBdHRyaWJ1dGUoSCkpO1xuICAgICAgICB9KSwgaC5hZGRDbGFzcyh0LCB0aGlzLl9jbGFzc2VzLm9wYWNpdHkpLCB0LnNldEF0dHJpYnV0ZShILCBcIlwiKSk7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBfaGFuZGxlQ2xvY2tDbGljaygpIHtcbiAgICBsZXQgeyBtYXhUaW1lOiB0LCBtaW5UaW1lOiBlIH0gPSB0aGlzLl9vcHRpb25zO1xuICAgIGNvbnN0IHsgZGlzYWJsZVBhc3Q6IGksIGRpc2FibGVGdXR1cmU6IG4sIGZvcm1hdDEyOiBvIH0gPSB0aGlzLl9vcHRpb25zO1xuICAgIGUgPSBYdChlLCBpLCBvKSwgdCA9IEd0KHQsIG4sIG8pO1xuICAgIGNvbnN0IHIgPSBSKHQsICExKVsyXSwgYSA9IFIoZSwgITEpWzJdLCBsID0gUih0LCAhMSlbMF0sIHAgPSBSKGUsICExKVswXSwgdSA9IGQuZmluZE9uZShcbiAgICAgIGBbJHtHYX1dYFxuICAgICk7XG4gICAgcmUub24oXG4gICAgICBkb2N1bWVudCxcbiAgICAgIGAke0hhfSAke1ZhfSAke1dhfSAke0ZhfSAke1lhfSAke3phfSAke2phfSAke0thfWAsXG4gICAgICBcIlwiLFxuICAgICAgKF8pID0+IHtcbiAgICAgICAgcHMoKSB8fCBfLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGNvbnN0IHsgdHlwZTogZiwgdGFyZ2V0OiBnIH0gPSBfLCB7IGNsb3NlTW9kYWxPbk1pbnV0ZXNDbGljazogbSwgc3dpdGNoSG91cnNUb01pbnV0ZXNPbkNsaWNrOiBiIH0gPSB0aGlzLl9vcHRpb25zLCB2ID0gZC5maW5kT25lKFxuICAgICAgICAgIGBbJHtYfV1gLFxuICAgICAgICAgIHRoaXMuX21vZGFsXG4gICAgICAgICkgIT09IG51bGwsIEMgPSBkLmZpbmRPbmUoXG4gICAgICAgICAgYFske0t9XWAsXG4gICAgICAgICAgdGhpcy5fbW9kYWxcbiAgICAgICAgKSAhPT0gbnVsbCwgdyA9IGQuZmluZE9uZShcbiAgICAgICAgICBgWyR7bHR9XWAsXG4gICAgICAgICAgdGhpcy5fbW9kYWxcbiAgICAgICAgKSAhPT0gbnVsbCwgRSA9IGQuZmluZChcbiAgICAgICAgICBgWyR7WH1dYCxcbiAgICAgICAgICB0aGlzLl9tb2RhbFxuICAgICAgICApLCBUID0gTmEoXywgdSksIEEgPSB1Lm9mZnNldFdpZHRoIC8gMjtcbiAgICAgICAgbGV0IGsgPSBNYXRoLmF0YW4yKFQueSAtIEEsIFQueCAtIEEpO1xuICAgICAgICBpZiAocHMoKSkge1xuICAgICAgICAgIGNvbnN0IEwgPSBOYShfLCB1LCAhMCk7XG4gICAgICAgICAgayA9IE1hdGguYXRhbjIoTC55IC0gQSwgTC54IC0gQSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IEkgPSBudWxsLCBPID0gbnVsbCwgeCA9IG51bGw7XG4gICAgICAgIGlmIChmID09PSBcIm1vdXNlZG93blwiIHx8IGYgPT09IFwibW91c2Vtb3ZlXCIgfHwgZiA9PT0gXCJ0b3VjaG1vdmVcIiB8fCBmID09PSBcInRvdWNoc3RhcnRcIilcbiAgICAgICAgICAoZiA9PT0gXCJtb3VzZWRvd25cIiB8fCBmID09PSBcInRvdWNoc3RhcnRcIiB8fCBmID09PSBcInRvdWNobW92ZVwiKSAmJiAodGhpcy5faGFzVGFyZ2V0SW5uZXJDbGFzcyhnKSB8fCBnLmhhc0F0dHJpYnV0ZShHYSkgfHwgZy5oYXNBdHRyaWJ1dGUocGUpIHx8IGcuaGFzQXR0cmlidXRlKFgpIHx8IGcuaGFzQXR0cmlidXRlKEspIHx8IGcuaGFzQXR0cmlidXRlKHNvKSB8fCBnLmhhc0F0dHJpYnV0ZShpbykgfHwgZy5oYXNBdHRyaWJ1dGUocWEpIHx8IGcuaGFzQXR0cmlidXRlKGJzKSkgJiYgKHRoaXMuX2lzTW91c2VNb3ZlID0gITAsIHBzKCkgJiYgXy50b3VjaGVzICYmIChJID0gXy50b3VjaGVzWzBdLmNsaWVudFgsIE8gPSBfLnRvdWNoZXNbMF0uY2xpZW50WSwgeCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoSSwgTykpKTtcbiAgICAgICAgZWxzZSBpZiAoZiA9PT0gXCJtb3VzZXVwXCIgfHwgZiA9PT0gXCJ0b3VjaGVuZFwiKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2lzTW91c2VNb3ZlID0gITEsIHRoaXMuX2hhc1RhcmdldElubmVyQ2xhc3MoZykgfHwgZy5oYXNBdHRyaWJ1dGUocGUpIHx8IGcuaGFzQXR0cmlidXRlKEspIHx8IGcuaGFzQXR0cmlidXRlKHNvKSB8fCBnLmhhc0F0dHJpYnV0ZShpbykgfHwgZy5oYXNBdHRyaWJ1dGUocWEpIHx8IGcuaGFzQXR0cmlidXRlKGJzKSkge1xuICAgICAgICAgICAgaWYgKChDIHx8IHcpICYmIGIpIHtcbiAgICAgICAgICAgICAgY29uc3QgTCA9IE51bWJlcih0aGlzLl9ob3VyLnRleHRDb250ZW50KSA+IGwgfHwgTnVtYmVyKHRoaXMuX2hvdXIudGV4dENvbnRlbnQpIDwgcDtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMuZm9ybWF0MjQgJiYgbCAhPT0gXCJcIiAmJiBwICE9PSBcIlwiICYmIEwpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5mb3JtYXQyNCAmJiBwICE9PSBcIlwiICYmIE51bWJlcih0aGlzLl9ob3VyLnRleHRDb250ZW50KSA8IHApXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYy50cmlnZ2VyKHRoaXMuX21pbnV0ZXMsIFwiY2xpY2tcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2ICYmIG0pIHtcbiAgICAgICAgICAgIGNvbnN0IEwgPSBkLmZpbmRPbmUoXG4gICAgICAgICAgICAgIGBbJHtxbn1dYCxcbiAgICAgICAgICAgICAgdGhpcy5fbW9kYWxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjLnRyaWdnZXIoTCwgXCJjbGlja1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICBsZXQgTDtcbiAgICAgICAgICBjb25zdCBTID0gTWF0aC50cnVuYyhrICogMTgwIC8gTWF0aC5QSSkgKyA5MCwgeyBkZWdyZWVzOiBOLCBtaW51dGU6IFAgfSA9IHRoaXMuX21ha2VNaW51dGVzRGVncmVlcyhTLCBMKTtcbiAgICAgICAgICBpZiAodGhpcy5faGFuZGxlck1heE1pbk1pbnV0ZXNPcHRpb25zKE4sIFApID09PSB2b2lkIDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgY29uc3QgeyBkZWdyZWVzOiB0dCwgbWludXRlOiBldCB9ID0gdGhpcy5faGFuZGxlck1heE1pbk1pbnV0ZXNPcHRpb25zKE4sIFApO1xuICAgICAgICAgIGlmICh0aGlzLl9pc01vdXNlTW92ZSkge1xuICAgICAgICAgICAgaWYgKGguYWRkU3R5bGUodGhpcy5faGFuZCwge1xuICAgICAgICAgICAgICB0cmFuc2Zvcm06IGByb3RhdGVaKCR7dHR9ZGVnKWBcbiAgICAgICAgICAgIH0pLCBldCA9PT0gdm9pZCAwKVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBVID0gKCkgPT4gZXQgPj0gMTAgfHwgZXQgPT09IFwiMDBcIiA/IGV0IDogYDAke2V0fWA7XG4gICAgICAgICAgICB0aGlzLl9taW51dGVzLnRleHRDb250ZW50ID0gVSgpLCB0aGlzLl90b2dnbGVDbGFzc0FjdGl2ZShcbiAgICAgICAgICAgICAgdGhpcy5taW51dGVzQXJyYXksXG4gICAgICAgICAgICAgIHRoaXMuX21pbnV0ZXMsXG4gICAgICAgICAgICAgIEVcbiAgICAgICAgICAgICksIHRoaXMuX3RvZ2dsZUJhY2tncm91bmRDb2xvckNpcmNsZShcbiAgICAgICAgICAgICAgYFske1h9XWBcbiAgICAgICAgICAgICksIHRoaXMuX29ialdpdGhEYXRhT25DaGFuZ2UuZGVncmVlc01pbnV0ZXMgPSB0dCwgdGhpcy5fb2JqV2l0aERhdGFPbkNoYW5nZS5taW51dGVzID0gZXQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChDIHx8IHcpIHtcbiAgICAgICAgICBsZXQgTCwgUyA9IE1hdGgudHJ1bmMoayAqIDE4MCAvIE1hdGguUEkpICsgOTA7XG4gICAgICAgICAgaWYgKFMgPSBNYXRoLnJvdW5kKFMgLyAzMCkgKiAzMCwgaC5hZGRTdHlsZSh0aGlzLl9jaXJjbGUsIHtcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjMTk3NmQyXCJcbiAgICAgICAgICB9KSwgdGhpcy5fbWFrZUhvdXJEZWdyZWVzKGcsIFMsIEwpID09PSB2b2lkIDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgY29uc3QgTiA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChwcygpICYmIFMgJiYgeCkge1xuICAgICAgICAgICAgICBjb25zdCB7IGRlZ3JlZXM6IFAsIGhvdXI6IHR0IH0gPSB0aGlzLl9tYWtlSG91ckRlZ3JlZXMoeCwgUywgTCk7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVNb3ZlSGFuZChcbiAgICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICAgIHR0LFxuICAgICAgICAgICAgICAgIFBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnN0IHsgZGVncmVlczogUCwgaG91cjogdHQgfSA9IHRoaXMuX21ha2VIb3VyRGVncmVlcyhnLCBTLCBMKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZU1vdmVIYW5kKGcsIHR0LCBQKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIHRoaXMuX29ialdpdGhEYXRhT25DaGFuZ2UuZGVncmVlc0hvdXJzID0gUywgdGhpcy5faGFuZGxlck1heE1pbkhvdXJzT3B0aW9ucyhcbiAgICAgICAgICAgIFMsXG4gICAgICAgICAgICBsLFxuICAgICAgICAgICAgcCxcbiAgICAgICAgICAgIHIsXG4gICAgICAgICAgICBhLFxuICAgICAgICAgICAgX1xuICAgICAgICAgICkgJiYgTigpO1xuICAgICAgICB9XG4gICAgICAgIF8uc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBfaGFzVGFyZ2V0SW5uZXJDbGFzcyh0KSB7XG4gICAgcmV0dXJuIHQuaGFzQXR0cmlidXRlKGRpKSB8fCB0Lmhhc0F0dHJpYnV0ZShsdCkgfHwgdC5oYXNBdHRyaWJ1dGUodnMpO1xuICB9XG4gIF9oYW5kbGVNb3ZlSGFuZCh0LCBlLCBpKSB7XG4gICAgY29uc3QgbiA9IGQuZmluZChcbiAgICAgIGBbJHtLfV1gLFxuICAgICAgdGhpcy5fbW9kYWxcbiAgICApLCBvID0gZC5maW5kKFxuICAgICAgYFske2x0fV1gLFxuICAgICAgdGhpcy5fbW9kYWxcbiAgICApO1xuICAgIHRoaXMuX2lzTW91c2VNb3ZlICYmICh0aGlzLl9oYXNUYXJnZXRJbm5lckNsYXNzKHQpID8gaC5hZGRTdHlsZSh0aGlzLl9oYW5kLCB7XG4gICAgICBoZWlnaHQ6IFwiMjEuNSVcIlxuICAgIH0pIDogaC5hZGRTdHlsZSh0aGlzLl9oYW5kLCB7XG4gICAgICBoZWlnaHQ6IFwiY2FsYyg0MCUgKyAxcHgpXCJcbiAgICB9KSwgaC5hZGRTdHlsZSh0aGlzLl9oYW5kLCB7XG4gICAgICB0cmFuc2Zvcm06IGByb3RhdGVaKCR7aX1kZWcpYFxuICAgIH0pLCB0aGlzLl9ob3VyLnRleHRDb250ZW50ID0gZSA+PSAxMCB8fCBlID09PSBcIjAwXCIgPyBlIDogYDAke2V9YCwgdGhpcy5fdG9nZ2xlQ2xhc3NBY3RpdmUodGhpcy5ob3Vyc0FycmF5LCB0aGlzLl9ob3VyLCBuKSwgdGhpcy5fdG9nZ2xlQ2xhc3NBY3RpdmUodGhpcy5pbm5lckhvdXJzLCB0aGlzLl9ob3VyLCBvKSwgdGhpcy5fb2JqV2l0aERhdGFPbkNoYW5nZS5ob3VyID0gZSA+PSAxMCB8fCBlID09PSBcIjAwXCIgPyBlIDogYDAke2V9YCk7XG4gIH1cbiAgX2hhbmRsZXJNYXhNaW5NaW51dGVzT3B0aW9ucyh0LCBlKSB7XG4gICAgbGV0IHsgbWF4VGltZTogaSwgbWluVGltZTogbiB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICBjb25zdCB7IGZvcm1hdDEyOiBvLCBpbmNyZW1lbnQ6IHIsIGRpc2FibGVQYXN0OiBhLCBkaXNhYmxlRnV0dXJlOiBsIH0gPSB0aGlzLl9vcHRpb25zO1xuICAgIG4gPSBYdChuLCBhLCBvKSwgaSA9IEd0KGksIGwsIG8pO1xuICAgIGNvbnN0IHAgPSBSKGksICExKVsxXSwgdSA9IFIobiwgITEpWzFdLCBfID0gUihpLCAhMSlbMF0sIGYgPSBSKG4sICExKVswXSwgZyA9IGYgPT09IFwiMTJcIiAmJiBvID8gXCIwXCIgOiBmLCBtID0gXyA9PT0gXCIxMlwiICYmIG8gPyBcIjBcIiA6IF8sIGIgPSBSKGksICExKVsyXSwgdiA9IFIobiwgITEpWzJdLCBDID0gcCAhPT0gXCJcIiA/IHAgKiA2IDogXCJcIiwgdyA9IHUgIT09IFwiXCIgPyB1ICogNiA6IFwiXCIsIEUgPSBOdW1iZXIodGhpcy5faG91ci50ZXh0Q29udGVudCksIFQgPSBFID09PSAxMiAmJiBvID8gMCA6IEU7XG4gICAgaWYgKCFiICYmICF2KSB7XG4gICAgICBpZiAoaSAhPT0gXCJcIiAmJiBuICE9PSBcIlwiKSB7XG4gICAgICAgIGlmIChOdW1iZXIobSkgPT09IFQgJiYgdCA+IEMgfHwgTnVtYmVyKGcpID09PSBUICYmIHQgPCB3KVxuICAgICAgICAgIHJldHVybiB0O1xuICAgICAgfSBlbHNlIGlmIChuICE9PSBcIlwiICYmIFQgPD0gTnVtYmVyKGcpKSB7XG4gICAgICAgIGlmICh0IDw9IHcgLSA2KVxuICAgICAgICAgIHJldHVybiB0O1xuICAgICAgfSBlbHNlIGlmIChpICE9PSBcIlwiICYmIFQgPj0gTnVtYmVyKG0pICYmIHQgPj0gQyArIDYpXG4gICAgICAgIHJldHVybiB0O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobiAhPT0gXCJcIikge1xuICAgICAgICBpZiAodiA9PT0gXCJQTVwiICYmIHRoaXMuX2lzQW1FbmFibGVkKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHYgPT09IFwiUE1cIiAmJiB0aGlzLl9pc1BtRW5hYmxlZCkge1xuICAgICAgICAgIGlmIChUIDwgTnVtYmVyKGcpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGlmIChUIDw9IE51bWJlcihnKSAmJiB0IDw9IHcgLSA2KVxuICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgIH0gZWxzZSBpZiAodiA9PT0gXCJBTVwiICYmIHRoaXMuX2lzQW1FbmFibGVkKSB7XG4gICAgICAgICAgaWYgKFQgPCBOdW1iZXIoZykpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgaWYgKFQgPD0gTnVtYmVyKGcpICYmIHQgPD0gdyAtIDYpXG4gICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGkgIT09IFwiXCIpIHtcbiAgICAgICAgaWYgKGIgPT09IFwiQU1cIiAmJiB0aGlzLl9pc1BtRW5hYmxlZClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChiID09PSBcIlBNXCIgJiYgdGhpcy5faXNQbUVuYWJsZWQpIHtcbiAgICAgICAgICBpZiAoVCA+PSBOdW1iZXIobSkgJiYgdCA+PSBDICsgNilcbiAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICB9IGVsc2UgaWYgKGIgPT09IFwiQU1cIiAmJiB0aGlzLl9pc0FtRW5hYmxlZCAmJiBUID49IE51bWJlcihtKSAmJiB0ID49IEMgKyA2KVxuICAgICAgICAgIHJldHVybiB0O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gciAmJiAodCA9IE1hdGgucm91bmQodCAvIDMwKSAqIDMwKSwgdCA8IDAgPyB0ID0gMzYwICsgdCA6IHQgPj0gMzYwICYmICh0ID0gMCksIHtcbiAgICAgIGRlZ3JlZXM6IHQsXG4gICAgICBtaW51dGU6IGVcbiAgICB9O1xuICB9XG4gIF9yZW1vdmVNb2RhbCgpIHtcbiAgICB0aGlzLl9hbmltYXRpb25zID8gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLl9yZW1vdmVNb2RhbEVsZW1lbnRzKCksIHRoaXMuX3Njcm9sbEJhci5yZXNldCgpO1xuICAgIH0sIDMwMCkgOiAodGhpcy5fcmVtb3ZlTW9kYWxFbGVtZW50cygpLCB0aGlzLl9zY3JvbGxCYXIucmVzZXQoKSksIHJlLm9mZihcbiAgICAgIHRoaXMuX2RvY3VtZW50LFxuICAgICAgYCR7QmF9ICR7X3N9ICR7SGF9ICR7VmF9ICR7V2F9ICR7RmF9ICR7WWF9ICR7emF9ICR7amF9ICR7S2F9YFxuICAgICksIGMub2ZmKHdpbmRvdywgX3MpO1xuICB9XG4gIF9yZW1vdmVNb2RhbEVsZW1lbnRzKCkge1xuICAgIHRoaXMuX21vZGFsICYmIHRoaXMuX21vZGFsLnJlbW92ZSgpO1xuICB9XG4gIF90b2dnbGVCYWNrZHJvcEFuaW1hdGlvbih0ID0gITEpIHtcbiAgICB0ID8gdGhpcy5fd3JhcHBlci5jbGFzc0xpc3QuYWRkKFwiYW5pbWF0ZS1bZmFkZS1vdXRfMzUwbXNfZWFzZS1pbi1vdXRdXCIpIDogKHRoaXMuX3dyYXBwZXIuY2xhc3NMaXN0LmFkZChcImFuaW1hdGUtW2ZhZGUtaW5fMzUwbXNfZWFzZS1pbi1vdXRdXCIpLCB0aGlzLl9vcHRpb25zLmlubGluZSB8fCBoLmFkZENsYXNzKHRoaXMuX2Nsb2NrLCB0aGlzLl9jbGFzc2VzLmNsb2NrQW5pbWF0aW9uKSksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5fd3JhcHBlci5jbGFzc0xpc3QucmVtb3ZlKFxuICAgICAgICBcImFuaW1hdGUtW2ZhZGUtb3V0XzM1MG1zX2Vhc2UtaW4tb3V0XVwiLFxuICAgICAgICBcImFuaW1hdGUtW2ZhZGUtaW5fMzUwbXNfZWFzZS1pbi1vdXRdXCJcbiAgICAgICk7XG4gICAgfSwgMzUxKTtcbiAgfVxuICBfYWRkQWN0aXZlQ2xhc3NUb1RpcCh0LCBlKSB7XG4gICAgdC5mb3JFYWNoKChpKSA9PiB7XG4gICAgICBOdW1iZXIoaS50ZXh0Q29udGVudCkgPT09IE51bWJlcihlKSAmJiAoaC5hZGRDbGFzcyhpLCB0aGlzLl9jbGFzc2VzLnRpcHNBY3RpdmUpLCBpLnNldEF0dHJpYnV0ZShILCBcIlwiKSk7XG4gICAgfSk7XG4gIH1cbiAgX3NldEhvdXJPck1pbnV0ZSh0KSB7XG4gICAgcmV0dXJuIHQgPCAxMCA/IGAwJHt0fWAgOiB0O1xuICB9XG4gIF9hcHBlbmRUaW1lcygpIHtcbiAgICBjb25zdCB7IGZvcm1hdDI0OiB0IH0gPSB0aGlzLl9vcHRpb25zO1xuICAgIGlmICh0KSB7XG4gICAgICB0aGlzLl9nZXRBcHBlbmRDbG9jayhcbiAgICAgICAgdGhpcy5ob3Vyc0FycmF5LFxuICAgICAgICBgWyR7cGV9XWAsXG4gICAgICAgIEtcbiAgICAgICksIHRoaXMuX2dldEFwcGVuZENsb2NrKFxuICAgICAgICB0aGlzLmlubmVySG91cnMsXG4gICAgICAgIGBbJHtkaX1dYCxcbiAgICAgICAgbHRcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2dldEFwcGVuZENsb2NrKFxuICAgICAgdGhpcy5ob3Vyc0FycmF5LFxuICAgICAgYFske3BlfV1gLFxuICAgICAgS1xuICAgICk7XG4gIH1cbiAgX2dldENvbmZpZyh0KSB7XG4gICAgY29uc3QgZSA9IGguZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi50ZyxcbiAgICAgIC4uLmUsXG4gICAgICAuLi50XG4gICAgfSwgRCgkaSwgdCwgZWcpLCB0O1xuICB9XG4gIF9nZXRDbGFzc2VzKHQpIHtcbiAgICBjb25zdCBlID0gaC5nZXREYXRhQ2xhc3NBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uaWcsXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIEQoJGksIHQsIHNnKSwgdDtcbiAgfVxuICBfZ2V0Q29udGFpbmVyKCkge1xuICAgIHJldHVybiBkLmZpbmRPbmUodGhpcy5fb3B0aW9ucy5jb250YWluZXIpO1xuICB9XG4gIF9nZXRWYWxpZGF0ZSh0KSB7XG4gICAgY29uc3QgeyBmb3JtYXQyNDogZSwgZm9ybWF0MTI6IGksIGFwcGVuZFZhbGlkYXRpb25JbmZvOiBuIH0gPSB0aGlzLl9vcHRpb25zO1xuICAgIHJlLm9uKHRoaXMuaW5wdXQsIHQsICh7IHRhcmdldDogbyB9KSA9PiB7XG4gICAgICBpZiAodGhpcy5fb3B0aW9ucyA9PT0gbnVsbCB8fCB0aGlzLmlucHV0LnZhbHVlID09PSBcIlwiKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCByID0gL14oMD9bMS05XXwxWzAxMl0pKDpbMC01XVxcZCkgW0FQYXBdW21NXSQvLCBhID0gL14oWzAxXVxcZHwyWzAtM10pKDpbMC01XVxcZCkkLywgbCA9IHIudGVzdChvLnZhbHVlKTtcbiAgICAgIGlmIChhLnRlc3Qoby52YWx1ZSkgIT09ICEwICYmIGUgfHwgbCAhPT0gITAgJiYgaSkge1xuICAgICAgICBuICYmIHRoaXMuaW5wdXQuc2V0QXR0cmlidXRlKEpuLCBcIlwiKSwgaC5hZGRTdHlsZShvLCB7IG1hcmdpbkJvdHRvbTogMCB9KSwgdGhpcy5faXNJbnZhbGlkVGltZUZvcm1hdCA9ICEwO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmlucHV0LnJlbW92ZUF0dHJpYnV0ZShKbiksIHRoaXMuX2lzSW52YWxpZFRpbWVGb3JtYXQgPSAhMTtcbiAgICAgIGNvbnN0IHUgPSBkLmZpbmRPbmUoXG4gICAgICAgIGBbJHtabX1dYFxuICAgICAgKTtcbiAgICAgIHUgIT09IG51bGwgJiYgdS5yZW1vdmUoKTtcbiAgICB9KTtcbiAgfVxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGdldEluc3RhbmNlKHQpIHtcbiAgICByZXR1cm4geS5nZXREYXRhKHQsIFVzKTtcbiAgfVxuICBzdGF0aWMgZ2V0T3JDcmVhdGVJbnN0YW5jZSh0LCBlID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSh0KSB8fCBuZXcgdGhpcyh0LCB0eXBlb2YgZSA9PSBcIm9iamVjdFwiID8gZSA6IG51bGwpO1xuICB9XG59XG5jb25zdCBvZyA9IHtcbiAgdGhyZXNob2xkOiAxMCxcbiAgZGlyZWN0aW9uOiBcImFsbFwiXG59O1xubGV0IHJnID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih0LCBlKSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX3N0YXJ0UG9zaXRpb24gPSBudWxsLCB0aGlzLl9vcHRpb25zID0ge1xuICAgICAgLi4ub2csXG4gICAgICAuLi5lXG4gICAgfTtcbiAgfVxuICBoYW5kbGVUb3VjaFN0YXJ0KHQpIHtcbiAgICB0aGlzLl9zdGFydFBvc2l0aW9uID0gdGhpcy5fZ2V0Q29vcmRpbmF0ZXModCk7XG4gIH1cbiAgaGFuZGxlVG91Y2hNb3ZlKHQpIHtcbiAgICBpZiAoIXRoaXMuX3N0YXJ0UG9zaXRpb24pXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZSA9IHRoaXMuX2dldENvb3JkaW5hdGVzKHQpLCBpID0ge1xuICAgICAgeDogZS54IC0gdGhpcy5fc3RhcnRQb3NpdGlvbi54LFxuICAgICAgeTogZS55IC0gdGhpcy5fc3RhcnRQb3NpdGlvbi55XG4gICAgfSwgbiA9IHRoaXMuX2dldERpcmVjdGlvbihpKTtcbiAgICBpZiAodGhpcy5fb3B0aW9ucy5kaXJlY3Rpb24gPT09IFwiYWxsXCIpIHtcbiAgICAgIGlmIChuLnkudmFsdWUgPCB0aGlzLl9vcHRpb25zLnRocmVzaG9sZCAmJiBuLngudmFsdWUgPCB0aGlzLl9vcHRpb25zLnRocmVzaG9sZClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgciA9IG4ueS52YWx1ZSA+IG4ueC52YWx1ZSA/IG4ueS5kaXJlY3Rpb24gOiBuLnguZGlyZWN0aW9uO1xuICAgICAgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGBzd2lwZSR7cn1gKSwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIFwic3dpcGVcIiwgeyBkaXJlY3Rpb246IHIgfSksIHRoaXMuX3N0YXJ0UG9zaXRpb24gPSBudWxsO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBvID0gdGhpcy5fb3B0aW9ucy5kaXJlY3Rpb24gPT09IFwibGVmdFwiIHx8IHRoaXMuX29wdGlvbnMgPT09IFwicmlnaHRcIiA/IFwieFwiIDogXCJ5XCI7XG4gICAgbltvXS5kaXJlY3Rpb24gPT09IHRoaXMuX29wdGlvbnMuZGlyZWN0aW9uICYmIG5bb10udmFsdWUgPiB0aGlzLl9vcHRpb25zLnRocmVzaG9sZCAmJiAoYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGBzd2lwZSR7bltvXS5kaXJlY3Rpb259YCksIHRoaXMuX3N0YXJ0UG9zaXRpb24gPSBudWxsKTtcbiAgfVxuICBoYW5kbGVUb3VjaEVuZCgpIHtcbiAgICB0aGlzLl9zdGFydFBvc2l0aW9uID0gbnVsbDtcbiAgfVxuICBfZ2V0Q29vcmRpbmF0ZXModCkge1xuICAgIGNvbnN0IFtlXSA9IHQudG91Y2hlcztcbiAgICByZXR1cm4ge1xuICAgICAgeDogZS5jbGllbnRYLFxuICAgICAgeTogZS5jbGllbnRZXG4gICAgfTtcbiAgfVxuICBfZ2V0RGlyZWN0aW9uKHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDoge1xuICAgICAgICBkaXJlY3Rpb246IHQueCA8IDAgPyBcImxlZnRcIiA6IFwicmlnaHRcIixcbiAgICAgICAgdmFsdWU6IE1hdGguYWJzKHQueClcbiAgICAgIH0sXG4gICAgICB5OiB7XG4gICAgICAgIGRpcmVjdGlvbjogdC55IDwgMCA/IFwidXBcIiA6IFwiZG93blwiLFxuICAgICAgICB2YWx1ZTogTWF0aC5hYnModC55KVxuICAgICAgfVxuICAgIH07XG4gIH1cbn0sIGFnID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih0LCBlID0gXCJzd2lwZVwiLCBpID0ge30pIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gdCwgdGhpcy5fZXZlbnQgPSBlLCB0aGlzLnN3aXBlID0gbmV3IHJnKHQsIGkpLCB0aGlzLl90b3VjaFN0YXJ0SGFuZGxlciA9IHRoaXMuX2hhbmRsZVRvdWNoU3RhcnQuYmluZCh0aGlzKSwgdGhpcy5fdG91Y2hNb3ZlSGFuZGxlciA9IHRoaXMuX2hhbmRsZVRvdWNoTW92ZS5iaW5kKHRoaXMpLCB0aGlzLl90b3VjaEVuZEhhbmRsZXIgPSB0aGlzLl9oYW5kbGVUb3VjaEVuZC5iaW5kKHRoaXMpO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5fZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCB0aGlzLl90b3VjaFN0YXJ0SGFuZGxlciksIHRoaXMuX2VsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCB0aGlzLl90b3VjaE1vdmVIYW5kbGVyKSwgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCB0aGlzLl90b3VjaEVuZEhhbmRsZXIpO1xuICB9XG4gIGluaXQoKSB7XG4gICAgdGhpcy5fZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgXCJ0b3VjaHN0YXJ0XCIsXG4gICAgICAodCkgPT4gdGhpcy5faGFuZGxlVG91Y2hTdGFydCh0KVxuICAgICksIHRoaXMuX2VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIFwidG91Y2htb3ZlXCIsXG4gICAgICAodCkgPT4gdGhpcy5faGFuZGxlVG91Y2hNb3ZlKHQpXG4gICAgKSwgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCAodCkgPT4gdGhpcy5faGFuZGxlVG91Y2hFbmQodCkpO1xuICB9XG4gIF9oYW5kbGVUb3VjaFN0YXJ0KHQpIHtcbiAgICB0aGlzW3RoaXMuX2V2ZW50XS5oYW5kbGVUb3VjaFN0YXJ0KHQpO1xuICB9XG4gIF9oYW5kbGVUb3VjaE1vdmUodCkge1xuICAgIHRoaXNbdGhpcy5fZXZlbnRdLmhhbmRsZVRvdWNoTW92ZSh0KTtcbiAgfVxuICBfaGFuZGxlVG91Y2hFbmQodCkge1xuICAgIHRoaXNbdGhpcy5fZXZlbnRdLmhhbmRsZVRvdWNoRW5kKHQpO1xuICB9XG59O1xuY29uc3QgUWEgPSBcInNpZGVuYXZcIiwgVHMgPSBcInRlLnNpZGVuYXZcIiwgbGcgPSBcImRhdGEtdGUtc2lkZW5hdi1yb3RhdGUtaWNvbi1yZWZcIiwgbm8gPSBcIltkYXRhLXRlLXNpZGVuYXYtdG9nZ2xlLXJlZl1cIiwgY2cgPSBcIltkYXRhLXRlLWNvbGxhcHNlLWluaXRdXCIsIGhnID0gJ1tkYXRhLXRlLXNpZGVuYXYtc2xpbT1cInRydWVcIl0nLCBkZyA9ICdbZGF0YS10ZS1zaWRlbmF2LXNsaW09XCJmYWxzZVwiXScsIHVnID0gXCJbZGF0YS10ZS1zaWRlbmF2LW1lbnUtcmVmXVwiLCBPZSA9IFwiW2RhdGEtdGUtc2lkZW5hdi1jb2xsYXBzZS1yZWZdXCIsIHVpID0gXCJbZGF0YS10ZS1zaWRlbmF2LWxpbmstcmVmXVwiLCBwZyA9IEYoKSA/IDEwMCA6IC0xMDAsIF9nID0gRigpID8gLTEwMCA6IDEwMCwgZmcgPSB7XG4gIHNpZGVuYXZBY2NvcmRpb246IFwiKGJvb2xlYW4pXCIsXG4gIHNpZGVuYXZCYWNrZHJvcDogXCIoYm9vbGVhbilcIixcbiAgc2lkZW5hdkJhY2tkcm9wQ2xhc3M6IFwiKG51bGx8c3RyaW5nKVwiLFxuICBzaWRlbmF2Q2xvc2VPbkVzYzogXCIoYm9vbGVhbilcIixcbiAgc2lkZW5hdkNvbG9yOiBcIihzdHJpbmcpXCIsXG4gIHNpZGVuYXZDb250ZW50OiBcIihudWxsfHN0cmluZylcIixcbiAgc2lkZW5hdkV4cGFuZGFibGU6IFwiKGJvb2xlYW4pXCIsXG4gIHNpZGVuYXZFeHBhbmRPbkhvdmVyOiBcIihib29sZWFuKVwiLFxuICBzaWRlbmF2Rm9jdXNUcmFwOiBcIihib29sZWFuKVwiLFxuICBzaWRlbmF2SGlkZGVuOiBcIihib29sZWFuKVwiLFxuICBzaWRlbmF2TW9kZTogXCIoc3RyaW5nKVwiLFxuICBzaWRlbmF2TW9kZUJyZWFrcG9pbnRPdmVyOiBcIihudWxsfHN0cmluZ3xudW1iZXIpXCIsXG4gIHNpZGVuYXZNb2RlQnJlYWtwb2ludFNpZGU6IFwiKG51bGx8c3RyaW5nfG51bWJlcilcIixcbiAgc2lkZW5hdk1vZGVCcmVha3BvaW50UHVzaDogXCIobnVsbHxzdHJpbmd8bnVtYmVyKVwiLFxuICBzaWRlbmF2QnJlYWtwb2ludFNtOiBcIihudW1iZXIpXCIsXG4gIHNpZGVuYXZCcmVha3BvaW50TWQ6IFwiKG51bWJlcilcIixcbiAgc2lkZW5hdkJyZWFrcG9pbnRMZzogXCIobnVtYmVyKVwiLFxuICBzaWRlbmF2QnJlYWtwb2ludFhsOiBcIihudW1iZXIpXCIsXG4gIHNpZGVuYXZCcmVha3BvaW50MnhsOiBcIihudW1iZXIpXCIsXG4gIHNpZGVuYXZTY3JvbGxDb250YWluZXI6IFwiKG51bGx8c3RyaW5nKVwiLFxuICBzaWRlbmF2U2xpbTogXCIoYm9vbGVhbilcIixcbiAgc2lkZW5hdlNsaW1Db2xsYXBzZWQ6IFwiKGJvb2xlYW4pXCIsXG4gIHNpZGVuYXZTbGltV2lkdGg6IFwiKG51bWJlcilcIixcbiAgc2lkZW5hdlBvc2l0aW9uOiBcIihzdHJpbmcpXCIsXG4gIHNpZGVuYXZSaWdodDogXCIoYm9vbGVhbilcIixcbiAgc2lkZW5hdlRyYW5zaXRpb25EdXJhdGlvbjogXCIobnVtYmVyKVwiLFxuICBzaWRlbmF2V2lkdGg6IFwiKG51bWJlcilcIlxufSwgbWcgPSB7XG4gIHNpZGVuYXZBY2NvcmRpb246ICExLFxuICBzaWRlbmF2QmFja2Ryb3A6ICEwLFxuICBzaWRlbmF2QmFja2Ryb3BDbGFzczogbnVsbCxcbiAgc2lkZW5hdkNsb3NlT25Fc2M6ICEwLFxuICBzaWRlbmF2Q29sb3I6IFwicHJpbWFyeVwiLFxuICBzaWRlbmF2Q29udGVudDogbnVsbCxcbiAgc2lkZW5hdkV4cGFuZGFibGU6ICEwLFxuICBzaWRlbmF2RXhwYW5kT25Ib3ZlcjogITEsXG4gIHNpZGVuYXZGb2N1c1RyYXA6ICEwLFxuICBzaWRlbmF2SGlkZGVuOiAhMCxcbiAgc2lkZW5hdk1vZGU6IFwib3ZlclwiLFxuICBzaWRlbmF2TW9kZUJyZWFrcG9pbnRPdmVyOiBudWxsLFxuICBzaWRlbmF2TW9kZUJyZWFrcG9pbnRTaWRlOiBudWxsLFxuICBzaWRlbmF2TW9kZUJyZWFrcG9pbnRQdXNoOiBudWxsLFxuICBzaWRlbmF2QnJlYWtwb2ludFNtOiA2NDAsXG4gIHNpZGVuYXZCcmVha3BvaW50TWQ6IDc2OCxcbiAgc2lkZW5hdkJyZWFrcG9pbnRMZzogMTAyNCxcbiAgc2lkZW5hdkJyZWFrcG9pbnRYbDogMTI4MCxcbiAgc2lkZW5hdkJyZWFrcG9pbnQyeGw6IDE1MzYsXG4gIHNpZGVuYXZTY3JvbGxDb250YWluZXI6IG51bGwsXG4gIHNpZGVuYXZTbGltOiAhMSxcbiAgc2lkZW5hdlNsaW1Db2xsYXBzZWQ6ICExLFxuICBzaWRlbmF2U2xpbVdpZHRoOiA3NyxcbiAgc2lkZW5hdlBvc2l0aW9uOiBcImZpeGVkXCIsXG4gIHNpZGVuYXZSaWdodDogITEsXG4gIHNpZGVuYXZUcmFuc2l0aW9uRHVyYXRpb246IDMwMCxcbiAgc2lkZW5hdldpZHRoOiAyNDBcbn07XG5jbGFzcyBnaSB7XG4gIGNvbnN0cnVjdG9yKHQsIGUgPSB7fSkge1xuICAgIHl0KHRoaXMsIFwiX2FkZEJhY2tkcm9wT25Jbml0XCIsICgpID0+IHtcbiAgICAgIHRoaXMuX29wdGlvbnMuc2lkZW5hdkhpZGRlbiB8fCAodGhpcy5fYmFja2Ryb3Auc2hvdygpLCBjLm9mZih0aGlzLl9lbGVtZW50LCBcInRyYW5zaXRpb25lbmRcIiwgdGhpcy5fYWRkQmFja2Ryb3BPbkluaXQpKTtcbiAgICB9KTtcbiAgICB0aGlzLl9lbGVtZW50ID0gdCwgdGhpcy5fb3B0aW9ucyA9IGUsIHRoaXMuX0lEID0gcnQoXCJcIiksIHRoaXMuX2NvbnRlbnQgPSBudWxsLCB0aGlzLl9pbml0aWFsQ29udGVudFN0eWxlID0gbnVsbCwgdGhpcy5fc2xpbUNvbGxhcHNlZCA9ICExLCB0aGlzLl9hY3RpdmVOb2RlID0gbnVsbCwgdGhpcy5fdGVtcFNsaW0gPSAhMSwgdGhpcy5fYmFja2Ryb3AgPSB0aGlzLl9pbml0aWFsaXplQmFja0Ryb3AoKSwgdGhpcy5fZm9jdXNUcmFwID0gbnVsbCwgdGhpcy5fcGVyZmVjdFNjcm9sbGJhciA9IG51bGwsIHRoaXMuX3RvdWNoID0gbnVsbCwgdGhpcy5fc2V0TW9kZUZyb21CcmVha3BvaW50cygpLCB0aGlzLmVzY0hhbmRsZXIgPSAoaSkgPT4ge1xuICAgICAgaS5rZXlDb2RlID09PSBGaSAmJiB0aGlzLnRvZ2dsZXIgJiYgTnQodGhpcy50b2dnbGVyKSAmJiAodGhpcy5fdXBkYXRlKCExKSwgYy5vZmYod2luZG93LCBcImtleWRvd25cIiwgdGhpcy5lc2NIYW5kbGVyKSk7XG4gICAgfSwgdGhpcy5oYXNoSGFuZGxlciA9ICgpID0+IHtcbiAgICAgIHRoaXMuX3NldEFjdGl2ZUVsZW1lbnRzKCk7XG4gICAgfSwgdCAmJiAoeS5zZXREYXRhKHQsIFRzLCB0aGlzKSwgdGhpcy5fc2V0dXAoKSksIHRoaXMub3B0aW9ucy5zaWRlbmF2QmFja2Ryb3AgJiYgIXRoaXMub3B0aW9ucy5zaWRlbmF2SGlkZGVuICYmIHRoaXMub3B0aW9ucy5zaWRlbmF2TW9kZSA9PT0gXCJvdmVyXCIgJiYgYy5vbih0aGlzLl9lbGVtZW50LCBcInRyYW5zaXRpb25lbmRcIiwgdGhpcy5fYWRkQmFja2Ryb3BPbkluaXQpLCB0aGlzLl9kaWRJbml0ID0gITEsIHRoaXMuX2luaXQoKTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gUWE7XG4gIH1cbiAgZ2V0IGNvbnRhaW5lcigpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnNpZGVuYXZQb3NpdGlvbiA9PT0gXCJmaXhlZFwiKVxuICAgICAgcmV0dXJuIGQuZmluZE9uZShcImJvZHlcIik7XG4gICAgY29uc3QgdCA9IChlKSA9PiAhZS5wYXJlbnROb2RlIHx8IGUucGFyZW50Tm9kZSA9PT0gZG9jdW1lbnQgPyBlIDogZS5wYXJlbnROb2RlLnN0eWxlLnBvc2l0aW9uID09PSBcInJlbGF0aXZlXCIgfHwgZS5wYXJlbnROb2RlLmNsYXNzTGlzdC5jb250YWlucyhcInJlbGF0aXZlXCIpID8gZS5wYXJlbnROb2RlIDogdChlLnBhcmVudE5vZGUpO1xuICAgIHJldHVybiB0KHRoaXMuX2VsZW1lbnQpO1xuICB9XG4gIGdldCBpc1Zpc2libGUoKSB7XG4gICAgbGV0IHQgPSAwLCBlID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5zaWRlbmF2UG9zaXRpb24gIT09IFwiZml4ZWRcIikge1xuICAgICAgY29uc3QgbiA9IHRoaXMuY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdCA9IG4ueCwgZSA9IG4ueCArIG4ud2lkdGg7XG4gICAgfVxuICAgIGNvbnN0IHsgeDogaSB9ID0gdGhpcy5fZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnNpZGVuYXZSaWdodCA/IE1hdGguYWJzKGkgLSBlKSA+IDEwIDogTWF0aC5hYnMoaSAtIHQpIDwgMTA7XG4gIH1cbiAgZ2V0IGxpbmtzKCkge1xuICAgIHJldHVybiBkLmZpbmQodWksIHRoaXMuX2VsZW1lbnQpO1xuICB9XG4gIGdldCBuYXZpZ2F0aW9uKCkge1xuICAgIHJldHVybiBkLmZpbmQodWcsIHRoaXMuX2VsZW1lbnQpO1xuICB9XG4gIGdldCBvcHRpb25zKCkge1xuICAgIGNvbnN0IHQgPSB7XG4gICAgICAuLi5tZyxcbiAgICAgIC4uLmguZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCksXG4gICAgICAuLi50aGlzLl9vcHRpb25zXG4gICAgfTtcbiAgICByZXR1cm4gRChRYSwgdCwgZmcpLCB0O1xuICB9XG4gIGdldCBzaWRlbmF2U3R5bGUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiBgJHt0aGlzLndpZHRofXB4YCxcbiAgICAgIGhlaWdodDogdGhpcy5vcHRpb25zLnNpZGVuYXZQb3NpdGlvbiA9PT0gXCJmaXhlZFwiID8gXCIxMDB2aFwiIDogXCIxMDAlXCIsXG4gICAgICBwb3NpdGlvbjogdGhpcy5vcHRpb25zLnNpZGVuYXZQb3NpdGlvbixcbiAgICAgIHRyYW5zaXRpb246IGBhbGwgJHt0aGlzLnRyYW5zaXRpb25EdXJhdGlvbn0gbGluZWFyYFxuICAgIH07XG4gIH1cbiAgZ2V0IHRvZ2dsZXIoKSB7XG4gICAgcmV0dXJuIGQuZmluZChubykuZmluZChcbiAgICAgIChlKSA9PiB7XG4gICAgICAgIGNvbnN0IGkgPSBoLmdldERhdGFBdHRyaWJ1dGUoZSwgXCJ0YXJnZXRcIik7XG4gICAgICAgIHJldHVybiBkLmZpbmRPbmUoaSkgPT09IHRoaXMuX2VsZW1lbnQ7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBnZXQgdHJhbnNpdGlvbkR1cmF0aW9uKCkge1xuICAgIHJldHVybiBgJHt0aGlzLm9wdGlvbnMuc2lkZW5hdlRyYW5zaXRpb25EdXJhdGlvbiAvIDFlM31zYDtcbiAgfVxuICBnZXQgdHJhbnNsYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5zaWRlbmF2UmlnaHQgPyBfZyA6IHBnO1xuICB9XG4gIGdldCB3aWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2xpbUNvbGxhcHNlZCA/IHRoaXMub3B0aW9ucy5zaWRlbmF2U2xpbVdpZHRoIDogdGhpcy5vcHRpb25zLnNpZGVuYXZXaWR0aDtcbiAgfVxuICBnZXQgaXNCYWNrZHJvcFZpc2libGUoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fYmFja2Ryb3AuX2VsZW1lbnQ7XG4gIH1cbiAgLy8gUHVibGljXG4gIGNoYW5nZU1vZGUodCkge1xuICAgIHRoaXMuX3NldE1vZGUodCk7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICBjLm9mZih3aW5kb3csIFwia2V5ZG93blwiLCB0aGlzLmVzY0hhbmRsZXIpLCB0aGlzLm9wdGlvbnMuc2lkZW5hdkJhY2tkcm9wICYmIHRoaXMuX2JhY2tkcm9wLmRpc3Bvc2UoKSwgYy5vZmYod2luZG93LCBcImhhc2hjaGFuZ2VcIiwgdGhpcy5oYXNoSGFuZGxlciksIHRoaXMuX3RvdWNoLmRpc3Bvc2UoKSwgeS5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIFRzKSwgdGhpcy5fZWxlbWVudCA9IG51bGw7XG4gIH1cbiAgaGlkZSgpIHtcbiAgICB0aGlzLl9lbWl0RXZlbnRzKCExKSwgdGhpcy5fdXBkYXRlKCExKSwgdGhpcy5fb3B0aW9ucy5zaWRlbmF2QmFja2Ryb3AgJiYgdGhpcy5pc0JhY2tkcm9wVmlzaWJsZSAmJiB0aGlzLl9iYWNrZHJvcC5oaWRlKCk7XG4gIH1cbiAgc2hvdygpIHtcbiAgICB0aGlzLl9lbWl0RXZlbnRzKCEwKSwgdGhpcy5fdXBkYXRlKCEwKSwgdGhpcy5fb3B0aW9ucy5zaWRlbmF2QmFja2Ryb3AgJiYgdGhpcy5fb3B0aW9ucy5zaWRlbmF2TW9kZSA9PT0gXCJvdmVyXCIgJiYgdGhpcy5fYmFja2Ryb3Auc2hvdygpO1xuICB9XG4gIHRvZ2dsZSgpIHtcbiAgICB0aGlzLl9lbWl0RXZlbnRzKCF0aGlzLmlzVmlzaWJsZSksIHRoaXMuX3VwZGF0ZSghdGhpcy5pc1Zpc2libGUpO1xuICB9XG4gIHRvZ2dsZVNsaW0oKSB7XG4gICAgdGhpcy5fc2V0U2xpbSghdGhpcy5fc2xpbUNvbGxhcHNlZCk7XG4gIH1cbiAgdXBkYXRlKHQpIHtcbiAgICB0aGlzLl9vcHRpb25zID0gdCwgdGhpcy5fc2V0dXAoKTtcbiAgfVxuICBnZXRCcmVha3BvaW50KHQpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNmb3JtQnJlYWtwb2ludFZhbHVlc1RvT2JqZWN0KClbdF07XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfaW5pdCgpIHtcbiAgICB0aGlzLl9kaWRJbml0IHx8IChjLm9uKFxuICAgICAgZG9jdW1lbnQsXG4gICAgICBcImNsaWNrXCIsXG4gICAgICBubyxcbiAgICAgIGdpLnRvZ2dsZVNpZGVuYXYoKVxuICAgICksIHRoaXMuX2RpZEluaXQgPSAhMCk7XG4gIH1cbiAgX3RyYW5zZm9ybUJyZWFrcG9pbnRWYWx1ZXNUb09iamVjdCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc206IHRoaXMub3B0aW9ucy5zaWRlbmF2QnJlYWtwb2ludFNtLFxuICAgICAgbWQ6IHRoaXMub3B0aW9ucy5zaWRlbmF2QnJlYWtwb2ludE1kLFxuICAgICAgbGc6IHRoaXMub3B0aW9ucy5zaWRlbmF2QnJlYWtwb2ludExnLFxuICAgICAgeGw6IHRoaXMub3B0aW9ucy5zaWRlbmF2QnJlYWtwb2ludFhsLFxuICAgICAgXCIyeGxcIjogdGhpcy5vcHRpb25zLnNpZGVuYXZCcmVha3BvaW50MnhsXG4gICAgfTtcbiAgfVxuICBfc2V0TW9kZUZyb21CcmVha3BvaW50cygpIHtcbiAgICBjb25zdCB0ID0gd2luZG93LmlubmVyV2lkdGgsIGUgPSB0aGlzLl90cmFuc2Zvcm1CcmVha3BvaW50VmFsdWVzVG9PYmplY3QoKTtcbiAgICBpZiAodCA9PT0gdm9pZCAwIHx8ICFlKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGkgPSB0eXBlb2YgdGhpcy5vcHRpb25zLnNpZGVuYXZNb2RlQnJlYWtwb2ludE92ZXIgPT0gXCJudW1iZXJcIiA/IHQgLSB0aGlzLm9wdGlvbnMuc2lkZW5hdk1vZGVCcmVha3BvaW50T3ZlciA6IHQgLSBlW3RoaXMub3B0aW9ucy5zaWRlbmF2TW9kZUJyZWFrcG9pbnRPdmVyXSwgbiA9IHR5cGVvZiB0aGlzLm9wdGlvbnMuc2lkZW5hdk1vZGVCcmVha3BvaW50U2lkZSA9PSBcIm51bWJlclwiID8gdCAtIHRoaXMub3B0aW9ucy5zaWRlbmF2TW9kZUJyZWFrcG9pbnRTaWRlIDogdCAtIGVbdGhpcy5vcHRpb25zLnNpZGVuYXZNb2RlQnJlYWtwb2ludFNpZGVdLCBvID0gdHlwZW9mIHRoaXMub3B0aW9ucy5zaWRlbmF2TW9kZUJyZWFrcG9pbnRQdXNoID09IFwibnVtYmVyXCIgPyB0IC0gdGhpcy5vcHRpb25zLnNpZGVuYXZNb2RlQnJlYWtwb2ludFB1c2ggOiB0IC0gZVt0aGlzLm9wdGlvbnMuc2lkZW5hdk1vZGVCcmVha3BvaW50UHVzaF0sIHIgPSAobCwgcCkgPT4gbCAtIHAgPCAwID8gLTEgOiBwIC0gbCA8IDAgPyAxIDogMCwgYSA9IFtpLCBuLCBvXS5maWx0ZXIoKGwpID0+IGwgIT0gbnVsbCAmJiBsID49IDApLnNvcnQocilbMF07XG4gICAgaSA+IDAgJiYgaSA9PT0gYSA/ICh0aGlzLl9vcHRpb25zLnNpZGVuYXZNb2RlID0gXCJvdmVyXCIsIHRoaXMuX29wdGlvbnMuc2lkZW5hdkhpZGRlbiA9ICEwKSA6IG4gPiAwICYmIG4gPT09IGEgPyB0aGlzLl9vcHRpb25zLnNpZGVuYXZNb2RlID0gXCJzaWRlXCIgOiBvID4gMCAmJiBvID09PSBhICYmICh0aGlzLl9vcHRpb25zLnNpZGVuYXZNb2RlID0gXCJwdXNoXCIpO1xuICB9XG4gIF9jb2xsYXBzZUl0ZW1zKCkge1xuICAgIHRoaXMubmF2aWdhdGlvbi5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICBkLmZpbmQoT2UsIHQpLmZvckVhY2goKGkpID0+IHtcbiAgICAgICAgWnQuZ2V0SW5zdGFuY2UoaSkuaGlkZSgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgX2dldE9mZnNldFZhbHVlKHQsIHsgaW5kZXg6IGUsIHByb3BlcnR5OiBpLCBvZmZzZXRzOiBuIH0pIHtcbiAgICBjb25zdCBvID0gdGhpcy5fZ2V0UHhWYWx1ZShcbiAgICAgIHRoaXMuX2luaXRpYWxDb250ZW50U3R5bGVbZV1bbltpXS5wcm9wZXJ0eV1cbiAgICApLCByID0gdCA/IG5baV0udmFsdWUgOiAwO1xuICAgIHJldHVybiBvICsgcjtcbiAgfVxuICBfZ2V0UHJvcGVydHkoLi4udCkge1xuICAgIHJldHVybiB0Lm1hcCgoZSwgaSkgPT4gaSA9PT0gMCA/IGUgOiBlWzBdLnRvVXBwZXJDYXNlKCkuY29uY2F0KGUuc2xpY2UoMSkpKS5qb2luKFwiXCIpO1xuICB9XG4gIF9nZXRQeFZhbHVlKHQpIHtcbiAgICByZXR1cm4gdCA/IHBhcnNlRmxvYXQodCkgOiAwO1xuICB9XG4gIF9oYW5kbGVTd2lwZSh0LCBlKSB7XG4gICAgZSAmJiB0aGlzLl9zbGltQ29sbGFwc2VkICYmIHRoaXMub3B0aW9ucy5zaWRlbmF2U2xpbSAmJiB0aGlzLm9wdGlvbnMuc2lkZW5hdkV4cGFuZGFibGUgPyB0aGlzLnRvZ2dsZVNsaW0oKSA6IGUgfHwgKHRoaXMuX3NsaW1Db2xsYXBzZWQgfHwgIXRoaXMub3B0aW9ucy5zaWRlbmF2U2xpbSB8fCAhdGhpcy5vcHRpb25zLnNpZGVuYXZFeHBhbmRhYmxlID8gdGhpcy50b2dnbGVyICYmIE50KHRoaXMudG9nZ2xlcikgJiYgdGhpcy50b2dnbGUoKSA6IHRoaXMudG9nZ2xlU2xpbSgpKTtcbiAgfVxuICBfaXNBY3RpdmUodCwgZSkge1xuICAgIHJldHVybiBlID8gZSA9PT0gdCA6IHQuYXR0cmlidXRlcy5ocmVmID8gbmV3IFVSTCh0LCB3aW5kb3cubG9jYXRpb24uaHJlZikuaHJlZiA9PT0gd2luZG93LmxvY2F0aW9uLmhyZWYgOiAhMTtcbiAgfVxuICBfaXNBbGxUb0JlQ29sbGFwc2VkKCkge1xuICAgIHJldHVybiBkLmZpbmQoXG4gICAgICBjZyxcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApLmZpbHRlcihcbiAgICAgIChpKSA9PiBpLmdldEF0dHJpYnV0ZShcImFyaWEtZXhwYW5kZWRcIikgPT09IFwidHJ1ZVwiXG4gICAgKS5sZW5ndGggPT09IDA7XG4gIH1cbiAgX2lzQWxsQ29sbGFwc2VkKCkge1xuICAgIHJldHVybiBkLmZpbmQoT2UsIHRoaXMuX2VsZW1lbnQpLmZpbHRlcihcbiAgICAgICh0KSA9PiBOdCh0KVxuICAgICkubGVuZ3RoID09PSAwO1xuICB9XG4gIF9pbml0aWFsaXplQmFja0Ryb3AoKSB7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuc2lkZW5hdkJhY2tkcm9wKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHQgPSB0aGlzLm9wdGlvbnMuc2lkZW5hdkJhY2tkcm9wQ2xhc3MgPyB0aGlzLm9wdGlvbnMuc2lkZW5hdkJhY2tkcm9wQ2xhc3Muc3BsaXQoXCIgXCIpIDogdGhpcy5vcHRpb25zLnNpZGVuYXZQb3NpdGlvbiA/IFtcbiAgICAgIFwib3BhY2l0eS01MFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uLWFsbFwiLFxuICAgICAgXCJkdXJhdGlvbi0zMDBcIixcbiAgICAgIFwiZWFzZS1pbi1vdXRcIixcbiAgICAgIHRoaXMub3B0aW9ucy5zaWRlbmF2UG9zaXRpb24sXG4gICAgICBcInRvcC0wXCIsXG4gICAgICBcImxlZnQtMFwiLFxuICAgICAgXCJ6LTUwXCIsXG4gICAgICBcImJnLWJsYWNrLzEwXCIsXG4gICAgICBcImRhcms6YmctYmxhY2stNjBcIixcbiAgICAgIFwidy1mdWxsXCIsXG4gICAgICBcImgtZnVsbFwiLFxuICAgICAgdGhpcy5fZWxlbWVudC5pZFxuICAgIF0gOiBudWxsO1xuICAgIHJldHVybiBuZXcgaHIoe1xuICAgICAgaXNWaXNpYmxlOiB0aGlzLm9wdGlvbnMuc2lkZW5hdkJhY2tkcm9wLFxuICAgICAgaXNBbmltYXRlZDogITAsXG4gICAgICByb290RWxlbWVudDogdGhpcy5fZWxlbWVudC5wYXJlbnROb2RlLFxuICAgICAgYmFja2Ryb3BDbGFzc2VzOiB0LFxuICAgICAgY2xpY2tDYWxsYmFjazogKCkgPT4gdGhpcy5oaWRlKClcbiAgICB9KTtcbiAgfVxuICBfdXBkYXRlQmFja2Ryb3AodCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuc2lkZW5hdk1vZGUgPT09IFwib3ZlclwiKSB7XG4gICAgICB0ID8gdGhpcy5fYmFja2Ryb3Auc2hvdygpIDogdGhpcy5pc0JhY2tkcm9wVmlzaWJsZSAmJiB0aGlzLl9iYWNrZHJvcC5oaWRlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuaXNCYWNrZHJvcFZpc2libGUgJiYgdGhpcy5fYmFja2Ryb3AuaGlkZSgpO1xuICB9XG4gIF9zZXR1cCgpIHtcbiAgICB0aGlzLl9zZXR1cFRvdWNoKCksIHRoaXMub3B0aW9ucy5zaWRlbmF2Rm9jdXNUcmFwICYmIHRoaXMuX3NldHVwRm9jdXNUcmFwKCksIHRoaXMuX3NldHVwQ29sbGFwc2UoKSwgdGhpcy5vcHRpb25zLnNpZGVuYXZTbGltICYmIHRoaXMuX3NldHVwU2xpbSgpLCB0aGlzLl9zZXR1cEluaXRpYWxTdHlsaW5nKCksIHRoaXMuX3NldHVwU2Nyb2xsaW5nKCksIHRoaXMub3B0aW9ucy5zaWRlbmF2Q29udGVudCAmJiB0aGlzLl9zZXR1cENvbnRlbnQoKSwgdGhpcy5fc2V0dXBBY3RpdmVTdGF0ZSgpLCB0aGlzLl9zZXR1cFJpcHBsZUVmZmVjdCgpLCB0aGlzLm9wdGlvbnMuc2lkZW5hdkhpZGRlbiB8fCB0aGlzLl91cGRhdGVPZmZzZXRzKCEwLCAhMCksIHRoaXMub3B0aW9ucy5zaWRlbmF2TW9kZSA9PT0gXCJvdmVyXCIgJiYgdGhpcy5fc2V0VGFiaW5kZXgoITApO1xuICB9XG4gIF9zZXR1cEFjdGl2ZVN0YXRlKCkge1xuICAgIHRoaXMuX3NldEFjdGl2ZUVsZW1lbnRzKCksIHRoaXMubGlua3MuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgYy5vbih0LCBcImNsaWNrXCIsICgpID0+IHRoaXMuX3NldEFjdGl2ZUVsZW1lbnRzKHQpKSwgYy5vbih0LCBcImtleWRvd25cIiwgKGUpID0+IHtcbiAgICAgICAgZS5rZXlDb2RlID09PSBjdCAmJiB0aGlzLl9zZXRBY3RpdmVFbGVtZW50cyh0KTtcbiAgICAgIH0pO1xuICAgIH0pLCBjLm9uKHdpbmRvdywgXCJoYXNoY2hhbmdlXCIsIHRoaXMuaGFzaEhhbmRsZXIpO1xuICB9XG4gIF9zZXR1cENvbGxhcHNlKCkge1xuICAgIHRoaXMubmF2aWdhdGlvbi5mb3JFYWNoKCh0LCBlKSA9PiB7XG4gICAgICBkLmZpbmQoT2UsIHQpLmZvckVhY2goXG4gICAgICAgIChuLCBvKSA9PiB0aGlzLl9zZXR1cENvbGxhcHNlTGlzdCh7IGxpc3Q6IG4sIGluZGV4OiBvLCBtZW51OiB0LCBtZW51SW5kZXg6IGUgfSlcbiAgICAgICk7XG4gICAgfSk7XG4gIH1cbiAgX2dlbmVyYXRlQ29sbHBhc2VJRCh0LCBlKSB7XG4gICAgcmV0dXJuIGBzaWRlbmF2LWNvbGxhcHNlLSR7dGhpcy5fSUR9LSR7ZX0tJHt0fWA7XG4gIH1cbiAgX3NldHVwQ29sbGFwc2VMaXN0KHsgbGlzdDogdCwgaW5kZXg6IGUsIG1lbnU6IGksIG1lbnVJbmRleDogbiB9KSB7XG4gICAgY29uc3QgbyA9IHRoaXMuX2dlbmVyYXRlQ29sbHBhc2VJRChlLCBuKTtcbiAgICB0LnNldEF0dHJpYnV0ZShcImlkXCIsIG8pLCB0LnNldEF0dHJpYnV0ZShcImRhdGEtdGUtY29sbGFwc2UtaXRlbVwiLCBcIlwiKTtcbiAgICBjb25zdCBbcl0gPSBkLnByZXYodCwgdWkpO1xuICAgIGguc2V0RGF0YUF0dHJpYnV0ZShyLCBcImNvbGxhcHNlLWluaXRcIiwgXCJcIiksIHIuc2V0QXR0cmlidXRlKFwiaHJlZlwiLCBgIyR7b31gKSwgci5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwiYnV0dG9uXCIpO1xuICAgIGNvbnN0IGEgPSBadC5nZXRJbnN0YW5jZSh0KSB8fCBuZXcgWnQodCwge1xuICAgICAgdG9nZ2xlOiAhMSxcbiAgICAgIHBhcmVudDogdGhpcy5vcHRpb25zLnNpZGVuYXZBY2NvcmRpb24gPyBpIDogdFxuICAgIH0pO1xuICAgICh0LmRhdGFzZXQudGVTaWRlbmF2U3RhdGVTaG93ID09PSBcIlwiIHx8IHQuZGF0YXNldC50ZUNvbGxhcHNlU2hvdyA9PT0gXCJcIikgJiYgdGhpcy5fcm90YXRlQXJyb3cociwgITEpLCBjLm9uKHIsIFwiY2xpY2tcIiwgKGwpID0+IHtcbiAgICAgIHRoaXMuX3RvZ2dsZUNhdGVnb3J5KGwsIGEsIHQpLCB0aGlzLl90ZW1wU2xpbSAmJiB0aGlzLl9pc0FsbFRvQmVDb2xsYXBzZWQoKSAmJiAodGhpcy5fc2V0U2xpbSghMCksIHRoaXMuX3RlbXBTbGltID0gITEpLCB0aGlzLm9wdGlvbnMuc2lkZW5hdk1vZGUgPT09IFwib3ZlclwiICYmIHRoaXMuX2ZvY3VzVHJhcCAmJiB0aGlzLl9mb2N1c1RyYXAudXBkYXRlKCk7XG4gICAgfSksIGMub24oXG4gICAgICB0LFxuICAgICAgXCJzaG93LnRlLmNvbGxhcHNlXCIsXG4gICAgICAoKSA9PiB0aGlzLl9yb3RhdGVBcnJvdyhyLCAhMSlcbiAgICApLCBjLm9uKFxuICAgICAgdCxcbiAgICAgIFwiaGlkZS50ZS5jb2xsYXBzZVwiLFxuICAgICAgKCkgPT4gdGhpcy5fcm90YXRlQXJyb3cociwgITApXG4gICAgKSwgYy5vbih0LCBcInNob3duLnRlLmNvbGxhcHNlXCIsICgpID0+IHtcbiAgICAgIHRoaXMub3B0aW9ucy5zaWRlbmF2TW9kZSA9PT0gXCJvdmVyXCIgJiYgdGhpcy5fZm9jdXNUcmFwICYmIHRoaXMuX2ZvY3VzVHJhcC51cGRhdGUoKTtcbiAgICB9KSwgYy5vbih0LCBcImhpZGRlbi50ZS5jb2xsYXBzZVwiLCAoKSA9PiB7XG4gICAgICB0aGlzLl90ZW1wU2xpbSAmJiB0aGlzLl9pc0FsbENvbGxhcHNlZCgpICYmICh0aGlzLl9zZXRTbGltKCEwKSwgdGhpcy5fdGVtcFNsaW0gPSAhMSksIHRoaXMub3B0aW9ucy5zaWRlbmF2TW9kZSA9PT0gXCJvdmVyXCIgJiYgdGhpcy5fZm9jdXNUcmFwICYmIHRoaXMuX2ZvY3VzVHJhcC51cGRhdGUoKTtcbiAgICB9KTtcbiAgfVxuICBfc2V0dXBDb250ZW50KCkge1xuICAgIHRoaXMuX2NvbnRlbnQgPSBkLmZpbmQodGhpcy5vcHRpb25zLnNpZGVuYXZDb250ZW50KSwgdGhpcy5fY29udGVudC5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICBjb25zdCBlID0gW1xuICAgICAgICBcIiFwXCIsXG4gICAgICAgIFwiIW1cIixcbiAgICAgICAgXCIhcHhcIixcbiAgICAgICAgXCIhcGxcIixcbiAgICAgICAgXCIhcHJcIixcbiAgICAgICAgXCIhbXhcIixcbiAgICAgICAgXCIhbWxcIixcbiAgICAgICAgXCIhbXJcIixcbiAgICAgICAgXCIhLXBcIixcbiAgICAgICAgXCIhLW1cIixcbiAgICAgICAgXCIhLXB4XCIsXG4gICAgICAgIFwiIS1wbFwiLFxuICAgICAgICBcIiEtcHJcIixcbiAgICAgICAgXCIhLW14XCIsXG4gICAgICAgIFwiIS1tbFwiLFxuICAgICAgICBcIiEtbXJcIlxuICAgICAgXTtcbiAgICAgIFsuLi50LmNsYXNzTGlzdF0uZmlsdGVyKFxuICAgICAgICAobikgPT4gZS5maW5kSW5kZXgoKG8pID0+IG4uaW5jbHVkZXMobykpID49IDBcbiAgICAgICkuZm9yRWFjaCgobikgPT4gdC5jbGFzc0xpc3QucmVtb3ZlKG4pKTtcbiAgICB9KSwgdGhpcy5faW5pdGlhbENvbnRlbnRTdHlsZSA9IHRoaXMuX2NvbnRlbnQubWFwKCh0KSA9PiB7XG4gICAgICBjb25zdCB7IHBhZGRpbmdMZWZ0OiBlLCBwYWRkaW5nUmlnaHQ6IGksIG1hcmdpbkxlZnQ6IG4sIG1hcmdpblJpZ2h0OiBvLCB0cmFuc2l0aW9uOiByIH0gPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0KTtcbiAgICAgIHJldHVybiB7IHBhZGRpbmdMZWZ0OiBlLCBwYWRkaW5nUmlnaHQ6IGksIG1hcmdpbkxlZnQ6IG4sIG1hcmdpblJpZ2h0OiBvLCB0cmFuc2l0aW9uOiByIH07XG4gICAgfSk7XG4gIH1cbiAgX3NldHVwRm9jdXNUcmFwKCkge1xuICAgIHRoaXMuX2ZvY3VzVHJhcCA9IG5ldyBXaShcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICB7XG4gICAgICAgIGV2ZW50OiBcImtleWRvd25cIixcbiAgICAgICAgY29uZGl0aW9uOiAodCkgPT4gdC5rZXlDb2RlID09PSBQaSxcbiAgICAgICAgb25seVZpc2libGU6ICEwXG4gICAgICB9LFxuICAgICAgdGhpcy50b2dnbGVyXG4gICAgKTtcbiAgfVxuICBfc2V0dXBJbml0aWFsU3R5bGluZygpIHtcbiAgICB0aGlzLl9zZXRDb2xvcigpLCBoLnN0eWxlKHRoaXMuX2VsZW1lbnQsIHRoaXMuc2lkZW5hdlN0eWxlKTtcbiAgfVxuICBfc2V0dXBTY3JvbGxpbmcoKSB7XG4gICAgbGV0IHQgPSB0aGlzLl9lbGVtZW50O1xuICAgIGlmICh0aGlzLm9wdGlvbnMuc2lkZW5hdlNjcm9sbENvbnRhaW5lcikge1xuICAgICAgdCA9IGQuZmluZE9uZShcbiAgICAgICAgdGhpcy5vcHRpb25zLnNpZGVuYXZTY3JvbGxDb250YWluZXIsXG4gICAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICAgICk7XG4gICAgICBjb25zdCBpID0gS2godC5wYXJlbnROb2RlLmNoaWxkcmVuKS5maWx0ZXIoXG4gICAgICAgIChuKSA9PiBuICE9PSB0XG4gICAgICApLnJlZHVjZSgobiwgbykgPT4gbiArIG8uY2xpZW50SGVpZ2h0LCAwKTtcbiAgICAgIGguc3R5bGUodCwge1xuICAgICAgICBtYXhIZWlnaHQ6IGBjYWxjKDEwMCUgLSAke2l9cHgpYCxcbiAgICAgICAgcG9zaXRpb246IFwicmVsYXRpdmVcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX3BlcmZlY3RTY3JvbGxiYXIgPSBuZXcgbWgodCwge1xuICAgICAgc3VwcHJlc3NTY3JvbGxYOiAhMCxcbiAgICAgIGhhbmRsZXJzOiBbXCJjbGljay1yYWlsXCIsIFwiZHJhZy10aHVtYlwiLCBcIndoZWVsXCIsIFwidG91Y2hcIl1cbiAgICB9KTtcbiAgfVxuICBfc2V0dXBTbGltKCkge1xuICAgIHRoaXMuX3NsaW1Db2xsYXBzZWQgPSB0aGlzLm9wdGlvbnMuc2lkZW5hdlNsaW1Db2xsYXBzZWQsIHRoaXMuX3RvZ2dsZVNsaW1EaXNwbGF5KHRoaXMuX3NsaW1Db2xsYXBzZWQpLCB0aGlzLm9wdGlvbnMuc2lkZW5hdkV4cGFuZE9uSG92ZXIgJiYgKHRoaXMuX2VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZW50ZXJcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fc2xpbUNvbGxhcHNlZCAmJiB0aGlzLl9zZXRTbGltKCExKTtcbiAgICB9KSwgdGhpcy5fZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCAoKSA9PiB7XG4gICAgICB0aGlzLl9zbGltQ29sbGFwc2VkIHx8IHRoaXMuX3NldFNsaW0oITApO1xuICAgIH0pKTtcbiAgfVxuICBfc2V0dXBSaXBwbGVFZmZlY3QoKSB7XG4gICAgdGhpcy5saW5rcy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICBsZXQgZSA9IFplLmdldEluc3RhbmNlKHQpLCBpID0gdGhpcy5vcHRpb25zLnNpZGVuYXZDb2xvcjtcbiAgICAgIGlmIChlICYmIGUuX29wdGlvbnMuc2lkZW5hdkNvbG9yICE9PSB0aGlzLm9wdGlvbnMuc2lkZW5hdkNvbG9yKVxuICAgICAgICBlLmRpc3Bvc2UoKTtcbiAgICAgIGVsc2UgaWYgKGUpXG4gICAgICAgIHJldHVybjtcbiAgICAgIChsb2NhbFN0b3JhZ2UudGhlbWUgPT09IFwiZGFya1wiIHx8ICEoXCJ0aGVtZVwiIGluIGxvY2FsU3RvcmFnZSkgJiYgd2luZG93Lm1hdGNoTWVkaWEoXCIocHJlZmVycy1jb2xvci1zY2hlbWU6IGRhcmspXCIpLm1hdGNoZXMpICYmIChpID0gXCJ3aGl0ZVwiKSwgZSA9IG5ldyBaZSh0LCB7IHJpcHBsZUNvbG9yOiBpIH0pO1xuICAgIH0pO1xuICB9XG4gIF9zZXR1cFRvdWNoKCkge1xuICAgIHRoaXMuX3RvdWNoID0gbmV3IGFnKHRoaXMuX2VsZW1lbnQsIFwic3dpcGVcIiwgeyB0aHJlc2hvbGQ6IDIwIH0pLCB0aGlzLl90b3VjaC5pbml0KCksIGMub24oXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgXCJzd2lwZWxlZnRcIixcbiAgICAgICh0KSA9PiB0aGlzLl9oYW5kbGVTd2lwZSh0LCB0aGlzLm9wdGlvbnMuc2lkZW5hdlJpZ2h0KVxuICAgICksIGMub24oXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgXCJzd2lwZXJpZ2h0XCIsXG4gICAgICAodCkgPT4gdGhpcy5faGFuZGxlU3dpcGUodCwgIXRoaXMub3B0aW9ucy5zaWRlbmF2UmlnaHQpXG4gICAgKTtcbiAgfVxuICBfc2V0QWN0aXZlKHQsIGUpIHtcbiAgICB0LnNldEF0dHJpYnV0ZShcImRhdGEtdGUtc2lkZWJhci1zdGF0ZS1hY3RpdmVcIiwgXCJcIiksIHRoaXMuX2FjdGl2ZU5vZGUgJiYgdC5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLXRlLXNpZGViYXItc3RhdGUtYWN0aXZlXCIpLCB0aGlzLl9hY3RpdmVOb2RlID0gdDtcbiAgICBjb25zdCBbaV0gPSBkLnBhcmVudHMoXG4gICAgICB0aGlzLl9hY3RpdmVOb2RlLFxuICAgICAgT2VcbiAgICApO1xuICAgIGlmICghaSkge1xuICAgICAgdGhpcy5fc2V0QWN0aXZlQ2F0ZWdvcnkoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgW25dID0gZC5wcmV2KGksIHVpKTtcbiAgICB0aGlzLl9zZXRBY3RpdmVDYXRlZ29yeShuKSwgIWUgJiYgIXRoaXMuX3NsaW1Db2xsYXBzZWQgJiYgWnQuZ2V0SW5zdGFuY2UoaSkuc2hvdygpO1xuICB9XG4gIF9zZXRBY3RpdmVDYXRlZ29yeSh0KSB7XG4gICAgdGhpcy5uYXZpZ2F0aW9uLmZvckVhY2goKGUpID0+IHtcbiAgICAgIGQuZmluZChPZSwgZSkuZm9yRWFjaCgobikgPT4ge1xuICAgICAgICBjb25zdCBbb10gPSBkLnByZXYobiwgdWkpO1xuICAgICAgICBvICE9PSB0ID8gby5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLXRlLXNpZGVuYXYtc3RhdGUtYWN0aXZlXCIpIDogby5zZXRBdHRyaWJ1dGUoXCJkYXRhLXRlLXNpZGVuYXYtc3RhdGUtYWN0aXZlXCIsIFwiXCIpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgX3NldEFjdGl2ZUVsZW1lbnRzKHQpIHtcbiAgICB0aGlzLm5hdmlnYXRpb24uZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgZC5maW5kKHVpLCBlKS5maWx0ZXIoKG4pID0+IGQubmV4dChuLCBPZSkubGVuZ3RoID09PSAwKS5mb3JFYWNoKChuKSA9PiB7XG4gICAgICAgIHRoaXMuX2lzQWN0aXZlKG4sIHQpICYmIG4gIT09IHRoaXMuX2FjdGl2ZU5vZGUgJiYgdGhpcy5fc2V0QWN0aXZlKG4sIHQpO1xuICAgICAgfSk7XG4gICAgfSksIHQgJiYgdGhpcy5fdXBkYXRlRm9jdXModGhpcy5pc1Zpc2libGUpO1xuICB9XG4gIF9zZXRDb2xvcigpIHtcbiAgICBjb25zdCB0ID0gW1xuICAgICAgXCJwcmltYXJ5XCIsXG4gICAgICBcInNlY29uZGFyeVwiLFxuICAgICAgXCJzdWNjZXNzXCIsXG4gICAgICBcImluZm9cIixcbiAgICAgIFwid2FybmluZ1wiLFxuICAgICAgXCJkYW5nZXJcIixcbiAgICAgIFwibGlnaHRcIixcbiAgICAgIFwiZGFya1wiXG4gICAgXSwgeyBzaWRlbmF2Q29sb3I6IGUgfSA9IHRoaXMub3B0aW9ucywgaSA9IHQuaW5jbHVkZXMoZSkgPyBlIDogXCJwcmltYXJ5XCI7XG4gICAgdC5mb3JFYWNoKChuKSA9PiB7XG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoYHNpZGVuYXYtJHtufWApO1xuICAgIH0pLCBoLmFkZENsYXNzKHRoaXMuX2VsZW1lbnQsIGBzaWRlbmF2LSR7aX1gKTtcbiAgfVxuICBfc2V0Q29udGVudE9mZnNldHModCwgZSwgaSkge1xuICAgIHRoaXMuX2NvbnRlbnQuZm9yRWFjaCgobiwgbykgPT4ge1xuICAgICAgY29uc3QgciA9IHRoaXMuX2dldE9mZnNldFZhbHVlKHQsIHtcbiAgICAgICAgaW5kZXg6IG8sXG4gICAgICAgIHByb3BlcnR5OiBcInBhZGRpbmdcIixcbiAgICAgICAgb2Zmc2V0czogZVxuICAgICAgfSksIGEgPSB0aGlzLl9nZXRPZmZzZXRWYWx1ZSh0LCB7XG4gICAgICAgIGluZGV4OiBvLFxuICAgICAgICBwcm9wZXJ0eTogXCJtYXJnaW5cIixcbiAgICAgICAgb2Zmc2V0czogZVxuICAgICAgfSksIGwgPSB7fTtcbiAgICAgIGlmIChpIHx8IChsLnRyYW5zaXRpb24gPSBgYWxsICR7dGhpcy50cmFuc2l0aW9uRHVyYXRpb259IGxpbmVhcmApLCBsW2UucGFkZGluZy5wcm9wZXJ0eV0gPSBgJHtyfXB4YCwgbFtlLm1hcmdpbi5wcm9wZXJ0eV0gPSBgJHthfXB4YCwgaC5zdHlsZShuLCBsKSwgISF0KSB7XG4gICAgICAgIGlmIChpKSB7XG4gICAgICAgICAgaC5zdHlsZShuLCB7XG4gICAgICAgICAgICB0cmFuc2l0aW9uOiB0aGlzLl9pbml0aWFsQ29udGVudFN0eWxlW29dLnRyYW5zaXRpb25cbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYy5vbihuLCBcInRyYW5zaXRpb25lbmRcIiwgKCkgPT4ge1xuICAgICAgICAgIGguc3R5bGUobiwge1xuICAgICAgICAgICAgdHJhbnNpdGlvbjogdGhpcy5faW5pdGlhbENvbnRlbnRTdHlsZVtvXS50cmFuc2l0aW9uXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIF9zZXRNb2RlKHQpIHtcbiAgICB0aGlzLm9wdGlvbnMuc2lkZW5hdk1vZGUgIT09IHQgJiYgKHRoaXMuX29wdGlvbnMuc2lkZW5hdk1vZGUgPSB0LCB0aGlzLl91cGRhdGUodGhpcy5pc1Zpc2libGUpKTtcbiAgfVxuICBfc2V0U2xpbSh0KSB7XG4gICAgY29uc3QgZSA9IHQgPyBbXCJjb2xsYXBzZVwiLCBcImNvbGxhcHNlZFwiXSA6IFtcImV4cGFuZFwiLCBcImV4cGFuZGVkXCJdO1xuICAgIHRoaXMuX3RyaWdnZXJFdmVudHMoLi4uZSksIHQgJiYgdGhpcy5fY29sbGFwc2VJdGVtcygpLCB0aGlzLl9zbGltQ29sbGFwc2VkID0gdCwgdGhpcy5fdG9nZ2xlU2xpbURpc3BsYXkodCksIGguc3R5bGUodGhpcy5fZWxlbWVudCwgeyB3aWR0aDogYCR7dGhpcy53aWR0aH1weGAgfSksIHRoaXMuX3VwZGF0ZU9mZnNldHModGhpcy5pc1Zpc2libGUpO1xuICB9XG4gIF9zZXRUYWJpbmRleCh0KSB7XG4gICAgdGhpcy5saW5rcy5mb3JFYWNoKChlKSA9PiB7XG4gICAgICBlLnRhYkluZGV4ID0gdCA/IDAgOiAtMTtcbiAgICB9KTtcbiAgfVxuICBfZW1pdEV2ZW50cyh0KSB7XG4gICAgY29uc3QgZSA9IHQgPyBbXCJzaG93XCIsIFwic2hvd25cIl0gOiBbXCJoaWRlXCIsIFwiaGlkZGVuXCJdO1xuICAgIHRoaXMuX3RyaWdnZXJFdmVudHMoLi4uZSk7XG4gIH1cbiAgX3JvdGF0ZUFycm93KHQsIGUpIHtcbiAgICBjb25zdCBbaV0gPSBkLmNoaWxkcmVuKHQsIGBbJHtsZ31dYCk7XG4gICAgaSAmJiAoZSA/IGgucmVtb3ZlQ2xhc3MoaSwgXCJyb3RhdGUtMTgwXCIpIDogaC5hZGRDbGFzcyhpLCBcInJvdGF0ZS0xODBcIikpO1xuICB9XG4gIF90b2dnbGVDYXRlZ29yeSh0LCBlKSB7XG4gICAgdC5wcmV2ZW50RGVmYXVsdCgpLCBlLnRvZ2dsZSgpLCB0aGlzLl9zbGltQ29sbGFwc2VkICYmIHRoaXMub3B0aW9ucy5zaWRlbmF2RXhwYW5kYWJsZSAmJiAodGhpcy5fdGVtcFNsaW0gPSAhMCwgdGhpcy5fc2V0U2xpbSghMSkpO1xuICB9XG4gIF90b2dnbGVTbGltRGlzcGxheSh0KSB7XG4gICAgY29uc3QgZSA9IGQuZmluZChcbiAgICAgIGhnLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICksIGkgPSBkLmZpbmQoXG4gICAgICBkZyxcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApLCBuID0gKCkgPT4ge1xuICAgICAgZS5mb3JFYWNoKChvKSA9PiB7XG4gICAgICAgIGguc3R5bGUobywge1xuICAgICAgICAgIGRpc3BsYXk6IHRoaXMuX3NsaW1Db2xsYXBzZWQgPyBcInVuc2V0XCIgOiBcIm5vbmVcIlxuICAgICAgICB9KTtcbiAgICAgIH0pLCBpLmZvckVhY2goKG8pID0+IHtcbiAgICAgICAgaC5zdHlsZShvLCB7XG4gICAgICAgICAgZGlzcGxheTogdGhpcy5fc2xpbUNvbGxhcHNlZCA/IFwibm9uZVwiIDogXCJ1bnNldFwiXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICB0ID8gc2V0VGltZW91dChcbiAgICAgICgpID0+IG4oKSxcbiAgICAgIHRoaXMub3B0aW9ucy5zaWRlbmF2VHJhbnNpdGlvbkR1cmF0aW9uXG4gICAgKSA6IG4oKTtcbiAgfVxuICBhc3luYyBfdHJpZ2dlckV2ZW50cyh0LCBlKSB7XG4gICAgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGAke3R9LnRlLnNpZGVuYXZgKSwgZSAmJiBhd2FpdCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBgJHtlfS50ZS5zaWRlbmF2YCk7XG4gICAgfSwgdGhpcy5vcHRpb25zLnNpZGVuYXZUcmFuc2l0aW9uRHVyYXRpb24gKyA1KTtcbiAgfVxuICBfaXNpUGhvbmUoKSB7XG4gICAgcmV0dXJuIC9pUGhvbmV8aVBvZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIH1cbiAgX3VwZGF0ZSh0KSB7XG4gICAgdCAmJiB0aGlzLl9pc2lQaG9uZSgpICYmIGguYWRkQ2xhc3ModGhpcy5fZWxlbWVudCwgXCJwcy0tc2Nyb2xsaW5nLXlcIiksIHRoaXMudG9nZ2xlciAmJiB0aGlzLl91cGRhdGVUb2dnbGVyQXJpYSh0KSwgdGhpcy5fdXBkYXRlRGlzcGxheSh0KSwgdGhpcy5vcHRpb25zLnNpZGVuYXZCYWNrZHJvcCAmJiB0aGlzLl91cGRhdGVCYWNrZHJvcCh0KSwgdGhpcy5fdXBkYXRlT2Zmc2V0cyh0KSwgdCAmJiB0aGlzLm9wdGlvbnMuc2lkZW5hdkNsb3NlT25Fc2MgJiYgdGhpcy5vcHRpb25zLnNpZGVuYXZNb2RlICE9PSBcInNpZGVcIiAmJiBjLm9uKHdpbmRvdywgXCJrZXlkb3duXCIsIHRoaXMuZXNjSGFuZGxlciksIHRoaXMub3B0aW9ucy5zaWRlbmF2Rm9jdXNUcmFwICYmIHRoaXMuX3VwZGF0ZUZvY3VzKHQpO1xuICB9XG4gIF91cGRhdGVEaXNwbGF5KHQpIHtcbiAgICBjb25zdCBlID0gdCA/IDAgOiB0aGlzLnRyYW5zbGF0aW9uO1xuICAgIGguc3R5bGUodGhpcy5fZWxlbWVudCwge1xuICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlWCgke2V9JSlgXG4gICAgfSk7XG4gIH1cbiAgX3VwZGF0ZUZvY3VzKHQpIHtcbiAgICBpZiAodGhpcy5fc2V0VGFiaW5kZXgodCksIHRoaXMub3B0aW9ucy5zaWRlbmF2TW9kZSA9PT0gXCJvdmVyXCIgJiYgdGhpcy5vcHRpb25zLnNpZGVuYXZGb2N1c1RyYXApIHtcbiAgICAgIGlmICh0KSB7XG4gICAgICAgIHRoaXMuX2ZvY3VzVHJhcC50cmFwKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2ZvY3VzVHJhcC5kaXNhYmxlKCk7XG4gICAgfVxuICAgIHRoaXMuX2ZvY3VzVHJhcC5kaXNhYmxlKCk7XG4gIH1cbiAgX3VwZGF0ZU9mZnNldHModCwgZSA9ICExKSB7XG4gICAgY29uc3QgW2ksIG5dID0gdGhpcy5vcHRpb25zLnNpZGVuYXZSaWdodCA/IFtcInJpZ2h0XCIsIFwibGVmdFwiXSA6IFtcImxlZnRcIiwgXCJyaWdodFwiXSwgbyA9IHtcbiAgICAgIHByb3BlcnR5OiB0aGlzLl9nZXRQcm9wZXJ0eShcInBhZGRpbmdcIiwgaSksXG4gICAgICB2YWx1ZTogdGhpcy5vcHRpb25zLnNpZGVuYXZNb2RlID09PSBcIm92ZXJcIiA/IDAgOiB0aGlzLndpZHRoXG4gICAgfSwgciA9IHtcbiAgICAgIHByb3BlcnR5OiB0aGlzLl9nZXRQcm9wZXJ0eShcIm1hcmdpblwiLCBuKSxcbiAgICAgIHZhbHVlOiB0aGlzLm9wdGlvbnMuc2lkZW5hdk1vZGUgPT09IFwicHVzaFwiID8gLTEgKiB0aGlzLndpZHRoIDogMFxuICAgIH07XG4gICAgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIFwidXBkYXRlLnRlLnNpZGVuYXZcIiwge1xuICAgICAgbWFyZ2luOiByLFxuICAgICAgcGFkZGluZzogb1xuICAgIH0pLCB0aGlzLl9jb250ZW50ICYmICh0aGlzLl9jb250ZW50LmNsYXNzTmFtZSA9IFwiXCIsIHRoaXMuX3NldENvbnRlbnRPZmZzZXRzKHQsIHsgcGFkZGluZzogbywgbWFyZ2luOiByIH0sIGUpKTtcbiAgfVxuICBfdXBkYXRlVG9nZ2xlckFyaWEodCkge1xuICAgIHRoaXMudG9nZ2xlci5zZXRBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIsIHQpO1xuICB9XG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgdG9nZ2xlU2lkZW5hdigpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgY29uc3QgZSA9IGQuY2xvc2VzdCh0LnRhcmdldCwgbm8pLCBpID0gaC5nZXREYXRhQXR0cmlidXRlcyhlKS50YXJnZXQ7XG4gICAgICBkLmZpbmQoaSkuZm9yRWFjaCgobikgPT4ge1xuICAgICAgICAoZ2kuZ2V0SW5zdGFuY2UobikgfHwgbmV3IGdpKG4pKS50b2dnbGUoKTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH1cbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0LCBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGxldCBpID0geS5nZXREYXRhKHRoaXMsIFRzKTtcbiAgICAgIGNvbnN0IG4gPSB0eXBlb2YgdCA9PSBcIm9iamVjdFwiICYmIHQ7XG4gICAgICBpZiAoISghaSAmJiAvZGlzcG9zZS8udGVzdCh0KSkgJiYgKGkgfHwgKGkgPSBuZXcgZ2kodGhpcywgbikpLCB0eXBlb2YgdCA9PSBcInN0cmluZ1wiKSkge1xuICAgICAgICBpZiAodHlwZW9mIGlbdF0gPiBcInVcIilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke3R9XCJgKTtcbiAgICAgICAgaVt0XShlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZ2V0SW5zdGFuY2UodCkge1xuICAgIHJldHVybiB5LmdldERhdGEodCwgVHMpO1xuICB9XG4gIHN0YXRpYyBnZXRPckNyZWF0ZUluc3RhbmNlKHQsIGUgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKHQpIHx8IG5ldyB0aGlzKHQsIHR5cGVvZiBlID09IFwib2JqZWN0XCIgPyBlIDogbnVsbCk7XG4gIH1cbn1cbmNvbnN0IEhvID0gXCJzdGVwcGVyXCIsIFhzID0gXCJ0ZS5zdGVwcGVyXCIsIHBuID0gYC4ke1hzfWAsIFlpID0gYGRhdGEtdGUtJHtIb31gLCBiaSA9IFwiaG9yaXpvbnRhbFwiLCB4dCA9IFwidmVydGljYWxcIiwgZ2cgPSB7XG4gIHN0ZXBwZXJUeXBlOiBcInN0cmluZ1wiLFxuICBzdGVwcGVyTGluZWFyOiBcImJvb2xlYW5cIixcbiAgc3RlcHBlck5vRWRpdGFibGU6IFwiYm9vbGVhblwiLFxuICBzdGVwcGVyQWN0aXZlOiBcInN0cmluZ1wiLFxuICBzdGVwcGVyQ29tcGxldGVkOiBcInN0cmluZ1wiLFxuICBzdGVwcGVySW52YWxpZDogXCJzdHJpbmdcIixcbiAgc3RlcHBlckRpc2FibGVkOiBcInN0cmluZ1wiLFxuICBzdGVwcGVyVmVydGljYWxCcmVha3BvaW50OiBcIm51bWJlclwiLFxuICBzdGVwcGVyTW9iaWxlQnJlYWtwb2ludDogXCJudW1iZXJcIixcbiAgc3RlcHBlck1vYmlsZUJhckJyZWFrcG9pbnQ6IFwibnVtYmVyXCJcbn0sIGJnID0ge1xuICBzdGVwcGVyVHlwZTogYmksXG4gIHN0ZXBwZXJMaW5lYXI6ICExLFxuICBzdGVwcGVyTm9FZGl0YWJsZTogITEsXG4gIHN0ZXBwZXJBY3RpdmU6IFwiXCIsXG4gIHN0ZXBwZXJDb21wbGV0ZWQ6IFwiXCIsXG4gIHN0ZXBwZXJJbnZhbGlkOiBcIlwiLFxuICBzdGVwcGVyRGlzYWJsZWQ6IFwiXCIsXG4gIHN0ZXBwZXJWZXJ0aWNhbEJyZWFrcG9pbnQ6IDAsXG4gIHN0ZXBwZXJNb2JpbGVCcmVha3BvaW50OiAwLFxuICBzdGVwcGVyTW9iaWxlQmFyQnJlYWtwb2ludDogNFxufSwgSmEgPSBgbW91c2Vkb3duJHtwbn1gLCB0bCA9IGBrZXlkb3duJHtwbn1gLCB2ZyA9IGBrZXl1cCR7cG59YCwgZWwgPSBgcmVzaXplJHtwbn1gLCBqdCA9IGBbJHtZaX0tc3RlcC1yZWZdYCwgRyA9IGBbJHtZaX0taGVhZC1yZWZdYCwgaWwgPSBgWyR7WWl9LWhlYWQtdGV4dC1yZWZdYCwgRXMgPSBgWyR7WWl9LWhlYWQtaWNvbi1yZWZdYCwgc3QgPSBgWyR7WWl9LWNvbnRlbnQtcmVmXWA7XG5jbGFzcyBYQyB7XG4gIGNvbnN0cnVjdG9yKHQsIGUpIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gdCwgdGhpcy5fb3B0aW9ucyA9IHRoaXMuX2dldENvbmZpZyhlKSwgdGhpcy5fZWxlbWVudEhlaWdodCA9IDAsIHRoaXMuX3N0ZXBzID0gZC5maW5kKGAke2p0fWAsIHRoaXMuX2VsZW1lbnQpLCB0aGlzLl9jdXJyZW50VmlldyA9IFwiXCIsIHRoaXMuX2FjdGl2ZVN0ZXBJbmRleCA9IDAsIHRoaXMuX3ZlcnRpY2FsU3RlcHBlclN0eWxlcyA9IFtdLCB0aGlzLl9lbGVtZW50ICYmICh5LnNldERhdGEodCwgWHMsIHRoaXMpLCB0aGlzLl9pbml0KCkpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBIbztcbiAgfVxuICBnZXQgYWN0aXZlU3RlcCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RlcHNbdGhpcy5fYWN0aXZlU3RlcEluZGV4XTtcbiAgfVxuICBnZXQgYWN0aXZlU3RlcEluZGV4KCkge1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmVTdGVwSW5kZXg7XG4gIH1cbiAgLy8gUHVibGljXG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5fc3RlcHMuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgYy5vZmYodCwgSmEpLCBjLm9mZih0LCB0bCk7XG4gICAgfSksIGMub2ZmKHdpbmRvdywgZWwpLCB5LnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgWHMpLCB0aGlzLl9lbGVtZW50ID0gbnVsbDtcbiAgfVxuICBjaGFuZ2VTdGVwKHQpIHtcbiAgICB0aGlzLl90b2dnbGVTdGVwKHQpO1xuICB9XG4gIG5leHRTdGVwKCkge1xuICAgIHRoaXMuX3RvZ2dsZVN0ZXAodGhpcy5fYWN0aXZlU3RlcEluZGV4ICsgMSk7XG4gIH1cbiAgcHJldmlvdXNTdGVwKCkge1xuICAgIHRoaXMuX3RvZ2dsZVN0ZXAodGhpcy5fYWN0aXZlU3RlcEluZGV4IC0gMSk7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfaW5pdCgpIHtcbiAgICBjb25zdCB0ID0gZC5maW5kKGAke2p0fWAsIHRoaXMuX2VsZW1lbnQpW3RoaXMuX2FjdGl2ZVN0ZXBJbmRleF0uc2V0QXR0cmlidXRlKFwiZGF0YS10ZVwiLCBcImFjdGl2ZS1zdGVwXCIpLCBlID0gZC5maW5kKFxuICAgICAgYCR7aWx9YCxcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApLCBpID0gZC5maW5kKFxuICAgICAgYCR7RXN9YCxcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApO1xuICAgIHN3aXRjaCAodCA/ICh0aGlzLl9hY3RpdmVTdGVwSW5kZXggPSB0aGlzLl9zdGVwcy5pbmRleE9mKHQpLCB0aGlzLl90b2dnbGVTdGVwQ2xhc3MoXG4gICAgICB0aGlzLl9hY3RpdmVTdGVwSW5kZXgsXG4gICAgICBcImFkZFwiLFxuICAgICAgdGhpcy5fb3B0aW9ucy5zdGVwcGVyQWN0aXZlXG4gICAgKSwgZVt0aGlzLl9hY3RpdmVTdGVwSW5kZXhdLmNsYXNzTGlzdC5hZGQoXCJmb250LW1lZGl1bVwiKSwgaVt0aGlzLl9hY3RpdmVTdGVwSW5kZXhdLmNsYXNzTGlzdC5hZGQoXCIhYmctcHJpbWFyeS0xMDBcIiksIGlbdGhpcy5fYWN0aXZlU3RlcEluZGV4XS5jbGFzc0xpc3QuYWRkKFwiIXRleHQtcHJpbWFyeS03MDBcIikpIDogKGVbdGhpcy5fYWN0aXZlU3RlcEluZGV4XS5jbGFzc0xpc3QuYWRkKFwiZm9udC1tZWRpdW1cIiksIGlbdGhpcy5fYWN0aXZlU3RlcEluZGV4XS5jbGFzc0xpc3QuYWRkKFwiIWJnLXByaW1hcnktMTAwXCIpLCBpW3RoaXMuX2FjdGl2ZVN0ZXBJbmRleF0uY2xhc3NMaXN0LmFkZChcIiF0ZXh0LXByaW1hcnktNzAwXCIpLCB0aGlzLl90b2dnbGVTdGVwQ2xhc3MoXG4gICAgICB0aGlzLl9hY3RpdmVTdGVwSW5kZXgsXG4gICAgICBcImFkZFwiLFxuICAgICAgdGhpcy5fb3B0aW9ucy5zdGVwcGVyQWN0aXZlXG4gICAgKSksIHRoaXMuX2JpbmRNb3VzZURvd24oKSwgdGhpcy5fYmluZEtleXNOYXZpZ2F0aW9uKCksIHRoaXMuX29wdGlvbnMuc3RlcHBlclR5cGUpIHtcbiAgICAgIGNhc2UgeHQ6XG4gICAgICAgIHRoaXMuX3RvZ2dsZVZlcnRpY2FsKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy5fdG9nZ2xlSG9yaXpvbnRhbCgpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgKHRoaXMuX29wdGlvbnMuc3RlcHBlclZlcnRpY2FsQnJlYWtwb2ludCB8fCB0aGlzLl9vcHRpb25zLnN0ZXBwZXJNb2JpbGVCcmVha3BvaW50KSAmJiB0aGlzLl90b2dnbGVTdGVwcGVyVmlldygpLCB0aGlzLl9iaW5kUmVzaXplKCk7XG4gIH1cbiAgX2dldENvbmZpZyh0KSB7XG4gICAgY29uc3QgZSA9IGguZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5iZyxcbiAgICAgIC4uLmUsXG4gICAgICAuLi50XG4gICAgfSwgRChIbywgdCwgZ2cpLCB0O1xuICB9XG4gIF9iaW5kTW91c2VEb3duKCkge1xuICAgIHRoaXMuX3N0ZXBzLmZvckVhY2goKHQpID0+IHtcbiAgICAgIGNvbnN0IGUgPSBkLmZpbmRPbmUoYCR7R31gLCB0KTtcbiAgICAgIGMub24oZSwgSmEsIChpKSA9PiB7XG4gICAgICAgIGNvbnN0IG4gPSBkLnBhcmVudHMoaS50YXJnZXQsIGAke2p0fWApWzBdLCBvID0gdGhpcy5fc3RlcHMuaW5kZXhPZihuKTtcbiAgICAgICAgaS5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLl90b2dnbGVTdGVwKG8pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgX2JpbmRSZXNpemUoKSB7XG4gICAgYy5vbih3aW5kb3csIGVsLCAoKSA9PiB7XG4gICAgICB0aGlzLl9jdXJyZW50VmlldyA9PT0geHQgJiYgdGhpcy5fc2V0U2luZ2xlU3RlcEhlaWdodCh0aGlzLmFjdGl2ZVN0ZXApLCB0aGlzLl9jdXJyZW50VmlldyA9PT0gYmkgJiYgdGhpcy5fc2V0SGVpZ2h0KHRoaXMuYWN0aXZlU3RlcCksICh0aGlzLl9vcHRpb25zLnN0ZXBwZXJWZXJ0aWNhbEJyZWFrcG9pbnQgfHwgdGhpcy5fb3B0aW9ucy5zdGVwcGVyTW9iaWxlQnJlYWtwb2ludCkgJiYgdGhpcy5fdG9nZ2xlU3RlcHBlclZpZXcoKTtcbiAgICB9KTtcbiAgfVxuICBfdG9nZ2xlU3RlcHBlclZpZXcoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX29wdGlvbnMuc3RlcHBlclZlcnRpY2FsQnJlYWtwb2ludCA8IHdpbmRvdy5pbm5lcldpZHRoLCBlID0gdGhpcy5fb3B0aW9ucy5zdGVwcGVyVmVydGljYWxCcmVha3BvaW50ID4gd2luZG93LmlubmVyV2lkdGgsIGkgPSB0aGlzLl9vcHRpb25zLnN0ZXBwZXJNb2JpbGVCcmVha3BvaW50ID4gd2luZG93LmlubmVyV2lkdGg7XG4gICAgdCAmJiB0aGlzLl9jdXJyZW50VmlldyAhPT0gYmkgJiYgdGhpcy5fdG9nZ2xlSG9yaXpvbnRhbCgpLCBlICYmICFpICYmIHRoaXMuX2N1cnJlbnRWaWV3ICE9PSB4dCAmJiAodGhpcy5fc3RlcHMuZm9yRWFjaCgobikgPT4ge1xuICAgICAgY29uc3QgbyA9IGQuZmluZE9uZShgJHtzdH1gLCBuKTtcbiAgICAgIHRoaXMuX3Jlc2V0U3RlcHBlckhlaWdodCgpLCB0aGlzLl9zaG93RWxlbWVudChvKTtcbiAgICB9KSwgdGhpcy5fdG9nZ2xlVmVydGljYWwoKSk7XG4gIH1cbiAgX3RvZ2dsZVN0ZXAodCkge1xuICAgIHRoaXMuX2FjdGl2ZVN0ZXBJbmRleCAhPT0gdCAmJiAodGhpcy5fb3B0aW9ucy5zdGVwcGVyTm9FZGl0YWJsZSAmJiB0aGlzLl90b2dnbGVEaXNhYmxlZCgpLCB0aGlzLl9zaG93RWxlbWVudChcbiAgICAgIGQuZmluZE9uZShgJHtzdH1gLCB0aGlzLl9zdGVwc1t0XSlcbiAgICApLCB0aGlzLl90b2dnbGVBY3RpdmUodCksIHQgPiB0aGlzLl9hY3RpdmVTdGVwSW5kZXggJiYgdGhpcy5fdG9nZ2xlQ29tcGxldGVkKHRoaXMuX2FjdGl2ZVN0ZXBJbmRleCksIHRoaXMuX2N1cnJlbnRWaWV3ID09PSBiaSA/IHRoaXMuX2FuaW1hdGVIb3Jpem9udGFsU3RlcCh0KSA6ICh0aGlzLl9hbmltYXRlVmVydGljYWxTdGVwKHQpLCB0aGlzLl9zZXRTaW5nbGVTdGVwSGVpZ2h0KHRoaXMuX3N0ZXBzW3RdKSksIHRoaXMuX3RvZ2dsZVN0ZXBUYWJJbmRleChcbiAgICAgIGQuZmluZE9uZShgJHtHfWAsIHRoaXMuYWN0aXZlU3RlcCksXG4gICAgICBkLmZpbmRPbmUoYCR7R31gLCB0aGlzLl9zdGVwc1t0XSlcbiAgICApLCB0aGlzLl9hY3RpdmVTdGVwSW5kZXggPSB0LCB0aGlzLl9zdGVwc1t0aGlzLl9hY3RpdmVTdGVwSW5kZXhdLnNldEF0dHJpYnV0ZShcImRhdGEtdGVcIiwgXCJhY3RpdmUtc3RlcFwiKSwgdGhpcy5fc3RlcHMuZm9yRWFjaCgoZSwgaSkgPT4ge1xuICAgICAgZVt0aGlzLl9hY3RpdmVTdGVwSW5kZXhdICE9PSBpICYmIGUucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS10ZVwiKTtcbiAgICB9KSk7XG4gIH1cbiAgX3Jlc2V0U3RlcHBlckhlaWdodCgpIHtcbiAgICB0aGlzLl9lbGVtZW50LnN0eWxlLmhlaWdodCA9IFwiXCI7XG4gIH1cbiAgX3NldFN0ZXBzSGVpZ2h0KCkge1xuICAgIHRoaXMuX3N0ZXBzLmZvckVhY2goKHQpID0+IHtcbiAgICAgIGNvbnN0IGUgPSBkLmZpbmRPbmUoYCR7c3R9YCwgdCksIGkgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlKTtcbiAgICAgIHRoaXMuX3ZlcnRpY2FsU3RlcHBlclN0eWxlcy5wdXNoKHtcbiAgICAgICAgcGFkZGluZ1RvcDogcGFyc2VGbG9hdChpLnBhZGRpbmdUb3ApLFxuICAgICAgICBwYWRkaW5nQm90dG9tOiBwYXJzZUZsb2F0KGkucGFkZGluZ0JvdHRvbSlcbiAgICAgIH0pO1xuICAgICAgY29uc3QgbiA9IGUuc2Nyb2xsSGVpZ2h0O1xuICAgICAgZS5zdHlsZS5oZWlnaHQgPSBgJHtufXB4YDtcbiAgICB9KTtcbiAgfVxuICBfc2V0U2luZ2xlU3RlcEhlaWdodCh0KSB7XG4gICAgY29uc3QgZSA9IGQuZmluZE9uZShgJHtzdH1gLCB0KSwgaSA9IHRoaXMuYWN0aXZlU3RlcCA9PT0gdCwgbiA9IHRoaXMuX3N0ZXBzLmluZGV4T2YodCk7XG4gICAgbGV0IG87XG4gICAgaSA/IChlLnN0eWxlLmhlaWdodCA9IFwiXCIsIG8gPSBlLnNjcm9sbEhlaWdodCkgOiBvID0gZS5zY3JvbGxIZWlnaHQgKyB0aGlzLl92ZXJ0aWNhbFN0ZXBwZXJTdHlsZXNbbl0ucGFkZGluZ1RvcCArIHRoaXMuX3ZlcnRpY2FsU3RlcHBlclN0eWxlc1tuXS5wYWRkaW5nQm90dG9tLCBlLnN0eWxlLmhlaWdodCA9IGAke299cHhgO1xuICB9XG4gIF90b2dnbGVWZXJ0aWNhbCgpIHtcbiAgICB0aGlzLl9jdXJyZW50VmlldyA9IHh0LCB0aGlzLl9zZXRTdGVwc0hlaWdodCgpLCB0aGlzLl9oaWRlSW5hY3RpdmVTdGVwcygpO1xuICB9XG4gIF90b2dnbGVIb3Jpem9udGFsKCkge1xuICAgIHRoaXMuX2N1cnJlbnRWaWV3ID0gYmksIHRoaXMuX3NldEhlaWdodCh0aGlzLmFjdGl2ZVN0ZXApLCB0aGlzLl9oaWRlSW5hY3RpdmVTdGVwcygpO1xuICB9XG4gIF90b2dnbGVTdGVwcGVyQ2xhc3MoKSB7XG4gICAgZC5maW5kT25lKFxuICAgICAgXCJbZGF0YS10ZS1zdGVwcGVyLXR5cGVdXCIsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKSAhPT0gbnVsbCAmJiB0aGlzLl9zdGVwcy5mb3JFYWNoKChlKSA9PiB7XG4gICAgICBkLmZpbmRPbmUoYCR7c3R9YCwgZSkuY2xhc3NMaXN0LnJlbW92ZShcIiFteS0wXCIpLCBkLmZpbmRPbmUoYCR7c3R9YCwgZSkuY2xhc3NMaXN0LnJlbW92ZShcIiFweS0wXCIpLCBkLmZpbmRPbmUoYCR7c3R9YCwgZSkuY2xhc3NMaXN0LnJlbW92ZShcIiFoLTBcIik7XG4gICAgfSk7XG4gIH1cbiAgX3RvZ2dsZVN0ZXBDbGFzcyh0LCBlLCBpKSB7XG4gICAgaSAmJiB0aGlzLl9zdGVwc1t0XS5jbGFzc0xpc3RbZV0oaSk7XG4gIH1cbiAgX2JpbmRLZXlzTmF2aWdhdGlvbigpIHtcbiAgICB0aGlzLl90b2dnbGVTdGVwVGFiSW5kZXgoXG4gICAgICAhMSxcbiAgICAgIGQuZmluZE9uZShgJHtHfWAsIHRoaXMuYWN0aXZlU3RlcClcbiAgICApLCB0aGlzLl9zdGVwcy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICBjb25zdCBlID0gZC5maW5kT25lKGAke0d9YCwgdCk7XG4gICAgICBjLm9uKGUsIHRsLCAoaSkgPT4ge1xuICAgICAgICBjb25zdCBuID0gZC5wYXJlbnRzKFxuICAgICAgICAgIGkuY3VycmVudFRhcmdldCxcbiAgICAgICAgICBgJHtqdH1gXG4gICAgICAgIClbMF0sIG8gPSBkLm5leHQobiwgYCR7anR9YClbMF0sIHIgPSBkLnByZXYobiwgYCR7anR9YClbMF0sIGEgPSBkLmZpbmRPbmUoXG4gICAgICAgICAgYCR7R31gLFxuICAgICAgICAgIG5cbiAgICAgICAgKSwgbCA9IGQuZmluZE9uZShcbiAgICAgICAgICBgJHtHfWAsXG4gICAgICAgICAgdGhpcy5hY3RpdmVTdGVwXG4gICAgICAgICk7XG4gICAgICAgIGxldCBwID0gbnVsbCwgdSA9IG51bGw7XG4gICAgICAgIGlmIChvICYmIChwID0gZC5maW5kT25lKGAke0d9YCwgbykpLCByICYmICh1ID0gZC5maW5kT25lKGAke0d9YCwgcikpLCBpLmtleUNvZGUgPT09IEhlICYmIHRoaXMuX2N1cnJlbnRWaWV3ICE9PSB4dCAmJiAodSA/ICh0aGlzLl90b2dnbGVTdGVwVGFiSW5kZXgoYSwgdSksIHRoaXMuX3RvZ2dsZU91dGxpbmVTdHlsZXMoYSwgdSksIHUuZm9jdXMoKSkgOiBwICYmICh0aGlzLl90b2dnbGVTdGVwVGFiSW5kZXgoYSwgcCksIHRoaXMuX3RvZ2dsZU91dGxpbmVTdHlsZXMoYSwgcCksIHAuZm9jdXMoKSkpLCBpLmtleUNvZGUgPT09IFZlICYmIHRoaXMuX2N1cnJlbnRWaWV3ICE9PSB4dCAmJiAocCA/ICh0aGlzLl90b2dnbGVTdGVwVGFiSW5kZXgoYSwgcCksIHRoaXMuX3RvZ2dsZU91dGxpbmVTdHlsZXMoYSwgcCksIHAuZm9jdXMoKSkgOiB1ICYmICh0aGlzLl90b2dnbGVTdGVwVGFiSW5kZXgoYSwgdSksIHRoaXMuX3RvZ2dsZU91dGxpbmVTdHlsZXMoYSwgdSksIHUuZm9jdXMoKSkpLCBpLmtleUNvZGUgPT09IHogJiYgdGhpcy5fY3VycmVudFZpZXcgPT09IHh0ICYmIChpLnByZXZlbnREZWZhdWx0KCksIHAgJiYgKHRoaXMuX3RvZ2dsZVN0ZXBUYWJJbmRleChhLCBwKSwgdGhpcy5fdG9nZ2xlT3V0bGluZVN0eWxlcyhhLCBwKSwgcC5mb2N1cygpKSksIGkua2V5Q29kZSA9PT0gYXQgJiYgdGhpcy5fY3VycmVudFZpZXcgPT09IHh0ICYmIChpLnByZXZlbnREZWZhdWx0KCksIHUgJiYgKHRoaXMuX3RvZ2dsZVN0ZXBUYWJJbmRleChhLCB1KSwgdGhpcy5fdG9nZ2xlT3V0bGluZVN0eWxlcyhhLCB1KSwgdS5mb2N1cygpKSksIGkua2V5Q29kZSA9PT0gV2UpIHtcbiAgICAgICAgICBjb25zdCBfID0gZC5maW5kT25lKFxuICAgICAgICAgICAgYCR7R31gLFxuICAgICAgICAgICAgdGhpcy5fc3RlcHNbMF1cbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMuX3RvZ2dsZVN0ZXBUYWJJbmRleChhLCBfKSwgdGhpcy5fdG9nZ2xlT3V0bGluZVN0eWxlcyhhLCBfKSwgXy5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpLmtleUNvZGUgPT09IEZlKSB7XG4gICAgICAgICAgY29uc3QgXyA9IHRoaXMuX3N0ZXBzW3RoaXMuX3N0ZXBzLmxlbmd0aCAtIDFdLCBmID0gZC5maW5kT25lKGAke0d9YCwgXyk7XG4gICAgICAgICAgdGhpcy5fdG9nZ2xlU3RlcFRhYkluZGV4KGEsIGYpLCB0aGlzLl90b2dnbGVPdXRsaW5lU3R5bGVzKGEsIGYpLCBmLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgICAgKGkua2V5Q29kZSA9PT0gY3QgfHwgaS5rZXlDb2RlID09PSBLcykgJiYgKGkucHJldmVudERlZmF1bHQoKSwgdGhpcy5jaGFuZ2VTdGVwKHRoaXMuX3N0ZXBzLmluZGV4T2YobikpKSwgaS5rZXlDb2RlID09PSBQaSAmJiAodGhpcy5fdG9nZ2xlU3RlcFRhYkluZGV4KGEsIGwpLCB0aGlzLl90b2dnbGVPdXRsaW5lU3R5bGVzKGEsICExKSwgbC5mb2N1cygpKTtcbiAgICAgIH0pLCBjLm9uKGUsIHZnLCAoaSkgPT4ge1xuICAgICAgICBjb25zdCBuID0gZC5wYXJlbnRzKFxuICAgICAgICAgIGkuY3VycmVudFRhcmdldCxcbiAgICAgICAgICBgJHtqdH1gXG4gICAgICAgIClbMF0sIG8gPSBkLmZpbmRPbmUoXG4gICAgICAgICAgYCR7R31gLFxuICAgICAgICAgIG5cbiAgICAgICAgKSwgciA9IGQuZmluZE9uZShcbiAgICAgICAgICBgJHtHfWAsXG4gICAgICAgICAgdGhpcy5hY3RpdmVTdGVwXG4gICAgICAgICk7XG4gICAgICAgIGkua2V5Q29kZSA9PT0gUGkgJiYgKHRoaXMuX3RvZ2dsZVN0ZXBUYWJJbmRleChvLCByKSwgdGhpcy5fdG9nZ2xlT3V0bGluZVN0eWxlcyghMSwgciksIHIuZm9jdXMoKSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBfdG9nZ2xlU3RlcFRhYkluZGV4KHQsIGUpIHtcbiAgICB0ICYmIHQuc2V0QXR0cmlidXRlKFwidGFiSW5kZXhcIiwgLTEpLCBlICYmIGUuc2V0QXR0cmlidXRlKFwidGFiSW5kZXhcIiwgMCk7XG4gIH1cbiAgX3RvZ2dsZU91dGxpbmVTdHlsZXModCwgZSkge1xuICAgIHQgJiYgKHQuc3R5bGUub3V0bGluZSA9IFwiXCIpLCBlICYmIChlLnN0eWxlLm91dGxpbmUgPSBcInJldmVydFwiKTtcbiAgfVxuICBfdG9nZ2xlRGlzYWJsZWQoKSB7XG4gICAgY29uc3QgdCA9IGQuZmluZChgJHtHfWAsIHRoaXMuX2VsZW1lbnQpLCBlID0gZC5maW5kKFxuICAgICAgYCR7RXN9YCxcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApO1xuICAgIHRbdGhpcy5fYWN0aXZlU3RlcEluZGV4XS5jbGFzc0xpc3QuYWRkKFwiY29sb3ItWyM4NTg1ODVdXCIpLCB0W3RoaXMuX2FjdGl2ZVN0ZXBJbmRleF0uY2xhc3NMaXN0LmFkZChcImN1cnNvci1kZWZhdWx0XCIpLCBlW3RoaXMuX2FjdGl2ZVN0ZXBJbmRleF0uY2xhc3NMaXN0LmFkZChcIiFiZy1bIzg1ODU4NV1cIiksIHRoaXMuX3RvZ2dsZVN0ZXBDbGFzcyhcbiAgICAgIHRoaXMuX2FjdGl2ZVN0ZXBJbmRleCxcbiAgICAgIFwiYWRkXCIsXG4gICAgICB0aGlzLl9vcHRpb25zLnN0ZXBwZXJEaXNhYmxlZFxuICAgICk7XG4gIH1cbiAgX3RvZ2dsZUFjdGl2ZSh0KSB7XG4gICAgY29uc3QgZSA9IGQuZmluZChcbiAgICAgIGAke2lsfWAsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKSwgaSA9IGQuZmluZChcbiAgICAgIGAke0VzfWAsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKTtcbiAgICBlW3RdLmNsYXNzTGlzdC5hZGQoXCJmb250LW1lZGl1bVwiKSwgaVt0XS5jbGFzc0xpc3QuYWRkKFwiIWJnLXByaW1hcnktMTAwXCIpLCBpW3RdLmNsYXNzTGlzdC5hZGQoXCIhdGV4dC1wcmltYXJ5LTcwMFwiKSwgaVt0XS5jbGFzc0xpc3QucmVtb3ZlKFwiIWJnLXN1Y2Nlc3MtMTAwXCIpLCBpW3RdLmNsYXNzTGlzdC5yZW1vdmUoXCIhdGV4dC1zdWNjZXNzLTcwMFwiKSwgZVt0aGlzLl9hY3RpdmVTdGVwSW5kZXhdLmNsYXNzTGlzdC5yZW1vdmUoXCJmb250LW1lZGl1bVwiKSwgaVt0aGlzLl9hY3RpdmVTdGVwSW5kZXhdLmNsYXNzTGlzdC5yZW1vdmUoXCIhYmctcHJpbWFyeS0xMDBcIiksIGlbdGhpcy5fYWN0aXZlU3RlcEluZGV4XS5jbGFzc0xpc3QucmVtb3ZlKFxuICAgICAgXCIhdGV4dC1wcmltYXJ5LTcwMFwiXG4gICAgKSwgdGhpcy5fdG9nZ2xlU3RlcENsYXNzKHQsIFwiYWRkXCIsIHRoaXMuX29wdGlvbnMuc3RlcHBlckFjdGl2ZSksIHRoaXMuX3RvZ2dsZVN0ZXBDbGFzcyhcbiAgICAgIHRoaXMuX2FjdGl2ZVN0ZXBJbmRleCxcbiAgICAgIFwicmVtb3ZlXCIsXG4gICAgICB0aGlzLl9vcHRpb25zLnN0ZXBwZXJBY3RpdmVcbiAgICApO1xuICB9XG4gIF90b2dnbGVDb21wbGV0ZWQodCkge1xuICAgIGNvbnN0IGUgPSBkLmZpbmQoXG4gICAgICBgJHtFc31gLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICk7XG4gICAgZVt0XS5jbGFzc0xpc3QuYWRkKFwiIWJnLXN1Y2Nlc3MtMTAwXCIpLCBlW3RdLmNsYXNzTGlzdC5hZGQoXCIhdGV4dC1zdWNjZXNzLTcwMFwiKSwgZVt0XS5jbGFzc0xpc3QucmVtb3ZlKFwiIWJnLWRhbmdlci0xMDBcIiksIGVbdF0uY2xhc3NMaXN0LnJlbW92ZShcIiF0ZXh0LWRhbmdlci03MDBcIiksIHRoaXMuX3RvZ2dsZVN0ZXBDbGFzcyh0LCBcImFkZFwiLCB0aGlzLl9vcHRpb25zLnN0ZXBwZXJDb21wbGV0ZWQpLCB0aGlzLl90b2dnbGVTdGVwQ2xhc3ModCwgXCJyZW1vdmVcIiwgdGhpcy5fb3B0aW9ucy5zdGVwcGVySW52YWxpZCk7XG4gIH1cbiAgX2hpZGVJbmFjdGl2ZVN0ZXBzKCkge1xuICAgIHRoaXMuX3N0ZXBzLmZvckVhY2goKHQpID0+IHtcbiAgICAgIHQuZ2V0QXR0cmlidXRlKFwiZGF0YS10ZVwiKSB8fCB0aGlzLl9oaWRlRWxlbWVudChkLmZpbmRPbmUoYCR7c3R9YCwgdCkpO1xuICAgIH0pO1xuICB9XG4gIF9zZXRIZWlnaHQodCkge1xuICAgIGNvbnN0IGUgPSBkLmZpbmRPbmUoYCR7c3R9YCwgdCksIGkgPSBnZXRDb21wdXRlZFN0eWxlKGUpLCBuID0gZC5maW5kT25lKGAke0d9YCwgdCksIG8gPSBnZXRDb21wdXRlZFN0eWxlKG4pLCByID0gZS5vZmZzZXRIZWlnaHQgKyBwYXJzZUZsb2F0KGkubWFyZ2luVG9wKSArIHBhcnNlRmxvYXQoaS5tYXJnaW5Cb3R0b20pLCBhID0gbi5vZmZzZXRIZWlnaHQgKyBwYXJzZUZsb2F0KG8ubWFyZ2luVG9wKSArIHBhcnNlRmxvYXQoby5tYXJnaW5Cb3R0b20pO1xuICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gYCR7YSArIHJ9cHhgO1xuICB9XG4gIF9oaWRlRWxlbWVudCh0KSB7XG4gICAgIWQucGFyZW50cyhcbiAgICAgIHQsXG4gICAgICBgJHtqdH1gXG4gICAgKVswXS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXRlXCIpICYmIHRoaXMuX2N1cnJlbnRWaWV3ICE9PSB4dCB8fCAodC5jbGFzc0xpc3QuYWRkKFwiIW15LTBcIiksIHQuY2xhc3NMaXN0LmFkZChcIiFweS0wXCIpLCB0LmNsYXNzTGlzdC5hZGQoXCIhaC0wXCIpKTtcbiAgfVxuICBfc2hvd0VsZW1lbnQodCkge1xuICAgIHRoaXMuX2N1cnJlbnRWaWV3ID09PSB4dCA/ICh0LmNsYXNzTGlzdC5yZW1vdmUoXCIhbXktMFwiKSwgdC5jbGFzc0xpc3QucmVtb3ZlKFwiIXB5LTBcIiksIHQuY2xhc3NMaXN0LnJlbW92ZShcIiFoLTBcIikpIDogdC5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICB9XG4gIF9hbmltYXRlSG9yaXpvbnRhbFN0ZXAodCkge1xuICAgIGNvbnN0IGUgPSB0ID4gdGhpcy5fYWN0aXZlU3RlcEluZGV4LCBpID0gZC5maW5kT25lKFxuICAgICAgYCR7c3R9YCxcbiAgICAgIHRoaXMuX3N0ZXBzW3RdXG4gICAgKSwgbiA9IGQuZmluZE9uZShcbiAgICAgIGAke3N0fWAsXG4gICAgICB0aGlzLmFjdGl2ZVN0ZXBcbiAgICApO1xuICAgIGxldCBvLCByO1xuICAgIHRoaXMuX3N0ZXBzLmZvckVhY2goKHUsIF8pID0+IHtcbiAgICAgIGNvbnN0IGYgPSBkLmZpbmRPbmUoYCR7c3R9YCwgdSk7XG4gICAgICBfICE9PSB0ICYmIF8gIT09IHRoaXMuX2FjdGl2ZVN0ZXBJbmRleCAmJiB0aGlzLl9oaWRlRWxlbWVudChmKTtcbiAgICB9KTtcbiAgICBjb25zdCBhID0gXCJ0cmFuc2xhdGUteC1bMTUwJV1cIiwgbCA9IFwiLXRyYW5zbGF0ZS14LVsxNTAlXVwiLCBwID0gXCJ0cmFuc2xhdGUtMFwiO1xuICAgIGUgPyAociA9IGwsIG8gPSBwLCBpLmNsYXNzTGlzdC5yZW1vdmUoXCJ0cmFuc2xhdGUteC1bMTUwJV1cIiksIGkuY2xhc3NMaXN0LnJlbW92ZShcIi10cmFuc2xhdGUteC1bMTUwJV1cIikpIDogKHIgPSBhLCBvID0gcCwgaS5jbGFzc0xpc3QucmVtb3ZlKFwiLXRyYW5zbGF0ZS14LVsxNTAlXVwiKSwgaS5jbGFzc0xpc3QucmVtb3ZlKFwidHJhbnNsYXRlLXgtWzE1MCVdXCIpKSwgbi5jbGFzc0xpc3QuYWRkKHIpLCBpLmNsYXNzTGlzdC5hZGQobyksIHRoaXMuX3NldEhlaWdodCh0aGlzLl9zdGVwc1t0XSk7XG4gIH1cbiAgX2FuaW1hdGVWZXJ0aWNhbFN0ZXAodCkge1xuICAgIGNvbnN0IGUgPSBkLmZpbmRPbmUoXG4gICAgICBgJHtzdH1gLFxuICAgICAgdGhpcy5fc3RlcHNbdF1cbiAgICApLCBpID0gZC5maW5kT25lKFxuICAgICAgYCR7c3R9YCxcbiAgICAgIHRoaXMuYWN0aXZlU3RlcFxuICAgICk7XG4gICAgdGhpcy5faGlkZUVsZW1lbnQoaSksIHRoaXMuX3Nob3dFbGVtZW50KGUpO1xuICB9XG4gIHN0YXRpYyBnZXRJbnN0YW5jZSh0KSB7XG4gICAgcmV0dXJuIHkuZ2V0RGF0YSh0LCBYcyk7XG4gIH1cbiAgc3RhdGljIGdldE9yQ3JlYXRlSW5zdGFuY2UodCwgZSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UodCkgfHwgbmV3IHRoaXModCwgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiA/IGUgOiBudWxsKTtcbiAgfVxufVxuY29uc3Qgc2wgPSBcImRhdGEtdGUtaW5wdXQtc3RhdGUtYWN0aXZlXCIsIENzID0gXCJkYXRhLXRlLWlucHV0LXNlbGVjdGVkXCIsIG5sID0gXCJkYXRhLXRlLWlucHV0LW11bHRpcGxlLWFjdGl2ZVwiLCBvbCA9IFwiW2RhdGEtdGUtZm9ybS1jaGVjay1pbnB1dF1cIjtcbmNsYXNzIHJsIHtcbiAgY29uc3RydWN0b3IodCwgZSwgaSwgbiwgbywgciwgYSwgbCwgcCwgdSwgXykge1xuICAgIHRoaXMuaWQgPSB0LCB0aGlzLm5hdGl2ZU9wdGlvbiA9IGUsIHRoaXMubXVsdGlwbGUgPSBpLCB0aGlzLnZhbHVlID0gbiwgdGhpcy5sYWJlbCA9IG8sIHRoaXMuc2VsZWN0ZWQgPSByLCB0aGlzLmRpc2FibGVkID0gYSwgdGhpcy5oaWRkZW4gPSBsLCB0aGlzLnNlY29uZGFyeVRleHQgPSBwLCB0aGlzLmdyb3VwSWQgPSB1LCB0aGlzLmljb24gPSBfLCB0aGlzLm5vZGUgPSBudWxsLCB0aGlzLmFjdGl2ZSA9ICExO1xuICB9XG4gIHNlbGVjdCgpIHtcbiAgICB0aGlzLm11bHRpcGxlID8gdGhpcy5fc2VsZWN0TXVsdGlwbGUoKSA6IHRoaXMuX3NlbGVjdFNpbmdsZSgpO1xuICB9XG4gIF9zZWxlY3RTaW5nbGUoKSB7XG4gICAgdGhpcy5zZWxlY3RlZCB8fCAodGhpcy5ub2RlLnNldEF0dHJpYnV0ZShDcywgXCJcIiksIHRoaXMubm9kZS5zZXRBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIsICEwKSwgdGhpcy5zZWxlY3RlZCA9ICEwLCB0aGlzLm5hdGl2ZU9wdGlvbiAmJiAodGhpcy5uYXRpdmVPcHRpb24uc2VsZWN0ZWQgPSAhMCkpO1xuICB9XG4gIF9zZWxlY3RNdWx0aXBsZSgpIHtcbiAgICBpZiAoIXRoaXMuc2VsZWN0ZWQpIHtcbiAgICAgIGNvbnN0IHQgPSBkLmZpbmRPbmUoXG4gICAgICAgIG9sLFxuICAgICAgICB0aGlzLm5vZGVcbiAgICAgICk7XG4gICAgICB0LmNoZWNrZWQgPSAhMCwgdGhpcy5ub2RlLnNldEF0dHJpYnV0ZShDcywgXCJcIiksIHRoaXMubm9kZS5zZXRBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIsICEwKSwgdGhpcy5zZWxlY3RlZCA9ICEwLCB0aGlzLm5hdGl2ZU9wdGlvbiAmJiAodGhpcy5uYXRpdmVPcHRpb24uc2VsZWN0ZWQgPSAhMCk7XG4gICAgfVxuICB9XG4gIGRlc2VsZWN0KCkge1xuICAgIHRoaXMubXVsdGlwbGUgPyB0aGlzLl9kZXNlbGVjdE11bHRpcGxlKCkgOiB0aGlzLl9kZXNlbGVjdFNpbmdsZSgpO1xuICB9XG4gIF9kZXNlbGVjdFNpbmdsZSgpIHtcbiAgICB0aGlzLnNlbGVjdGVkICYmICh0aGlzLm5vZGUucmVtb3ZlQXR0cmlidXRlKENzKSwgdGhpcy5ub2RlLnNldEF0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIiwgITEpLCB0aGlzLnNlbGVjdGVkID0gITEsIHRoaXMubmF0aXZlT3B0aW9uICYmICh0aGlzLm5hdGl2ZU9wdGlvbi5zZWxlY3RlZCA9ICExKSk7XG4gIH1cbiAgX2Rlc2VsZWN0TXVsdGlwbGUoKSB7XG4gICAgaWYgKHRoaXMuc2VsZWN0ZWQpIHtcbiAgICAgIGNvbnN0IHQgPSBkLmZpbmRPbmUoXG4gICAgICAgIG9sLFxuICAgICAgICB0aGlzLm5vZGVcbiAgICAgICk7XG4gICAgICB0LmNoZWNrZWQgPSAhMSwgdGhpcy5ub2RlLnJlbW92ZUF0dHJpYnV0ZShDcyksIHRoaXMubm9kZS5zZXRBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIsICExKSwgdGhpcy5zZWxlY3RlZCA9ICExLCB0aGlzLm5hdGl2ZU9wdGlvbiAmJiAodGhpcy5uYXRpdmVPcHRpb24uc2VsZWN0ZWQgPSAhMSk7XG4gICAgfVxuICB9XG4gIHNldE5vZGUodCkge1xuICAgIHRoaXMubm9kZSA9IHQ7XG4gIH1cbiAgc2V0QWN0aXZlU3R5bGVzKCkge1xuICAgIGlmICghdGhpcy5hY3RpdmUpIHtcbiAgICAgIGlmICh0aGlzLm11bHRpcGxlKSB7XG4gICAgICAgIHRoaXMubm9kZS5zZXRBdHRyaWJ1dGUobmwsIFwiXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmFjdGl2ZSA9ICEwLCB0aGlzLm5vZGUuc2V0QXR0cmlidXRlKHNsLCBcIlwiKTtcbiAgICB9XG4gIH1cbiAgcmVtb3ZlQWN0aXZlU3R5bGVzKCkge1xuICAgIHRoaXMuYWN0aXZlICYmICh0aGlzLmFjdGl2ZSA9ICExLCB0aGlzLm5vZGUucmVtb3ZlQXR0cmlidXRlKHNsKSksIHRoaXMubXVsdGlwbGUgJiYgdGhpcy5ub2RlLnJlbW92ZUF0dHJpYnV0ZShubCk7XG4gIH1cbn1cbmNsYXNzIFRnIHtcbiAgY29uc3RydWN0b3IodCA9ICExKSB7XG4gICAgdGhpcy5fbXVsdGlwbGUgPSB0LCB0aGlzLl9zZWxlY3Rpb25zID0gW107XG4gIH1cbiAgc2VsZWN0KHQpIHtcbiAgICB0aGlzLl9tdWx0aXBsZSA/IHRoaXMuX3NlbGVjdGlvbnMucHVzaCh0KSA6IHRoaXMuX3NlbGVjdGlvbnMgPSBbdF07XG4gIH1cbiAgZGVzZWxlY3QodCkge1xuICAgIGlmICh0aGlzLl9tdWx0aXBsZSkge1xuICAgICAgY29uc3QgZSA9IHRoaXMuX3NlbGVjdGlvbnMuZmluZEluZGV4KFxuICAgICAgICAoaSkgPT4gdCA9PT0gaVxuICAgICAgKTtcbiAgICAgIHRoaXMuX3NlbGVjdGlvbnMuc3BsaWNlKGUsIDEpO1xuICAgIH0gZWxzZVxuICAgICAgdGhpcy5fc2VsZWN0aW9ucyA9IFtdO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIHRoaXMuX3NlbGVjdGlvbnMgPSBbXTtcbiAgfVxuICBnZXQgc2VsZWN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9zZWxlY3Rpb25zWzBdO1xuICB9XG4gIGdldCBzZWxlY3Rpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl9zZWxlY3Rpb25zO1xuICB9XG4gIGdldCBsYWJlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VsZWN0aW9uc1swXSAmJiB0aGlzLnNlbGVjdGlvbi5sYWJlbDtcbiAgfVxuICBnZXQgbGFiZWxzKCkge1xuICAgIHJldHVybiB0aGlzLl9zZWxlY3Rpb25zLm1hcCgodCkgPT4gdC5sYWJlbCkuam9pbihcIiwgXCIpO1xuICB9XG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25zWzBdICYmIHRoaXMuc2VsZWN0aW9uLnZhbHVlO1xuICB9XG4gIGdldCB2YWx1ZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NlbGVjdGlvbnMubWFwKCh0KSA9PiB0LnZhbHVlKTtcbiAgfVxufVxuZnVuY3Rpb24gVm8ocykge1xuICByZXR1cm4gcy5maWx0ZXIoKHQpID0+ICF0LmRpc2FibGVkKS5ldmVyeSgodCkgPT4gdC5zZWxlY3RlZCk7XG59XG5jb25zdCBFZyA9IFwiZGF0YS10ZS1zZWxlY3QtZm9ybS1vdXRsaW5lLXJlZlwiLCBDZyA9IFwiZGF0YS10ZS1zZWxlY3Qtd3JhcHBlci1yZWZcIiwgQWcgPSBcImRhdGEtdGUtc2VsZWN0LWlucHV0LXJlZlwiLCB5ZyA9IFwiZGF0YS10ZS1zZWxlY3QtY2xlYXItYnRuLXJlZlwiLCB3ZyA9IFwiZGF0YS10ZS1zZWxlY3QtZHJvcGRvd24tY29udGFpbmVyLXJlZlwiLCBrZyA9IFwiZGF0YS10ZS1zZWxlY3QtZHJvcGRvd24tcmVmXCIsIHhnID0gXCJkYXRhLXRlLXNlbGVjdC1vcHRpb25zLXdyYXBwZXItcmVmXCIsIE9nID0gXCJkYXRhLXRlLXNlbGVjdC1vcHRpb25zLWxpc3QtcmVmXCIsIFNnID0gXCJkYXRhLXRlLXNlbGVjdC1pbnB1dC1maWx0ZXItcmVmXCIsIEpjID0gXCJkYXRhLXRlLXNlbGVjdC1vcHRpb24tcmVmXCIsIElnID0gXCJkYXRhLXRlLXNlbGVjdC1vcHRpb24tYWxsLXJlZlwiLCBEZyA9IFwiZGF0YS10ZS1zZWxlY3Qtb3B0aW9uLXRleHQtcmVmXCIsICRnID0gXCJkYXRhLXRlLWZvcm0tY2hlY2staW5wdXRcIiwgTGcgPSBcImRhdGEtdGUtc2VsZWN0LW9wdGlvbi1ncm91cC1yZWZcIiwgTmcgPSBcImRhdGEtdGUtc2VsZWN0LW9wdGlvbi1ncm91cC1sYWJlbC1yZWZcIiwgdGggPSBcImRhdGEtdGUtc2VsZWN0LXNlbGVjdGVkXCIsIE1nID0gYFxuPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMS41XCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCI+XG4gIDxwYXRoIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIGQ9XCJNMTkuNSA4LjI1bC03LjUgNy41LTcuNS03LjVcIiAvPlxuPC9zdmc+XG5gLCBSZyA9IChzKSA9PiB7XG4gIHMuY29kZSA9PT0gXCJUYWJcIiB8fCBzLmNvZGUgPT09IFwiRXNjXCIgfHwgcy5wcmV2ZW50RGVmYXVsdCgpO1xufTtcbmZ1bmN0aW9uIEFzKHMsIHQsIGUsIGksIG4pIHtcbiAgdC5zZWxlY3RTaXplID09PSBcImRlZmF1bHRcIiAmJiBoLmFkZENsYXNzKHMsIGUpLCB0LnNlbGVjdFNpemUgPT09IFwic21cIiAmJiBoLmFkZENsYXNzKHMsIGkpLCB0LnNlbGVjdFNpemUgPT09IFwibGdcIiAmJiBoLmFkZENsYXNzKHMsIG4pO1xufVxuZnVuY3Rpb24gUGcocywgdCwgZSwgaSwgbikge1xuICBjb25zdCBvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgby5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBzKSwgby5zZXRBdHRyaWJ1dGUoQ2csIFwiXCIpO1xuICBjb25zdCByID0gJChcImRpdlwiKTtcbiAgci5zZXRBdHRyaWJ1dGUoRWcsIFwiXCIpLCBoLmFkZENsYXNzKHIsIGkuZm9ybU91dGxpbmUpO1xuICBjb25zdCBhID0gJChcImlucHV0XCIpLCBsID0gdC5zZWxlY3RGaWx0ZXIgPyBcImNvbWJvYm94XCIgOiBcImxpc3Rib3hcIiwgcCA9IHQubXVsdGlwbGUgPyBcInRydWVcIiA6IFwiZmFsc2VcIiwgdSA9IHQuZGlzYWJsZWQgPyBcInRydWVcIiA6IFwiZmFsc2VcIjtcbiAgYS5zZXRBdHRyaWJ1dGUoQWcsIFwiXCIpLCBoLmFkZENsYXNzKGEsIGkuc2VsZWN0SW5wdXQpLCBBcyhcbiAgICBhLFxuICAgIHQsXG4gICAgaS5zZWxlY3RJbnB1dFNpemVEZWZhdWx0LFxuICAgIGkuc2VsZWN0SW5wdXRTaXplU20sXG4gICAgaS5zZWxlY3RJbnB1dFNpemVMZ1xuICApLCB0LnNlbGVjdEZvcm1XaGl0ZSAmJiBoLmFkZENsYXNzKGEsIGkuc2VsZWN0SW5wdXRXaGl0ZSksIGEuc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcInRleHRcIiksIGEuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBsKSwgYS5zZXRBdHRyaWJ1dGUoXCJhcmlhLW11bHRpc2VsZWN0YWJsZVwiLCBwKSwgYS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWRpc2FibGVkXCIsIHUpLCBhLnNldEF0dHJpYnV0ZShcImFyaWEtaGFzcG9wdXBcIiwgXCJ0cnVlXCIpLCBhLnNldEF0dHJpYnV0ZShcImFyaWEtZXhwYW5kZWRcIiwgITEpLCBhLm5hbWUgPSBuLCB0LnRhYkluZGV4ICYmIGEuc2V0QXR0cmlidXRlKFwidGFiSW5kZXhcIiwgdC50YWJJbmRleCksIHQuZGlzYWJsZWQgJiYgYS5zZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiLCBcIlwiKSwgdC5zZWxlY3RQbGFjZWhvbGRlciAhPT0gXCJcIiAmJiBhLnNldEF0dHJpYnV0ZShcInBsYWNlaG9sZGVyXCIsIHQuc2VsZWN0UGxhY2Vob2xkZXIpLCB0LnNlbGVjdFZhbGlkYXRpb24gPyAoaC5hZGRTdHlsZShhLCB7XG4gICAgXCJwb2ludGVyLWV2ZW50c1wiOiBcIm5vbmVcIixcbiAgICBcImNhcmV0LWNvbG9yXCI6IFwidHJhbnNwYXJlbnRcIlxuICB9KSwgaC5hZGRTdHlsZShyLCB7IGN1cnNvcjogXCJwb2ludGVyXCIgfSkpIDogYS5zZXRBdHRyaWJ1dGUoXCJyZWFkb25seVwiLCBcInRydWVcIiksIHQuc2VsZWN0VmFsaWRhdGlvbiAmJiAoYS5zZXRBdHRyaWJ1dGUoXCJyZXF1aXJlZFwiLCBcInRydWVcIiksIGEuc2V0QXR0cmlidXRlKFwiYXJpYS1yZXF1aXJlZFwiLCBcInRydWVcIiksIGEuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgUmcpKTtcbiAgY29uc3QgXyA9ICQoXCJkaXZcIik7XG4gIGguYWRkQ2xhc3MoXywgaS5zZWxlY3RWYWxpZGF0aW9uVmFsaWQpO1xuICBjb25zdCBmID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXG4gICAgYCR7dC5zZWxlY3RWYWxpZEZlZWRiYWNrfWBcbiAgKTtcbiAgXy5hcHBlbmRDaGlsZChmKTtcbiAgY29uc3QgZyA9ICQoXCJkaXZcIik7XG4gIGguYWRkQ2xhc3MoZywgaS5zZWxlY3RWYWxpZGF0aW9uSW52YWxpZCk7XG4gIGNvbnN0IG0gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcbiAgICBgJHt0LnNlbGVjdEludmFsaWRGZWVkYmFja31gXG4gICk7XG4gIGcuYXBwZW5kQ2hpbGQobSk7XG4gIGNvbnN0IGIgPSAkKFwic3BhblwiKTtcbiAgYi5zZXRBdHRyaWJ1dGUoeWcsIFwiXCIpLCBoLmFkZENsYXNzKGIsIGkuc2VsZWN0Q2xlYXJCdG4pLCBBcyhcbiAgICBiLFxuICAgIHQsXG4gICAgaS5zZWxlY3RDbGVhckJ0bkRlZmF1bHQsXG4gICAgaS5zZWxlY3RDbGVhckJ0blNtLFxuICAgIGkuc2VsZWN0Q2xlYXJCdG5MZ1xuICApLCB0LnNlbGVjdEZvcm1XaGl0ZSAmJiBoLmFkZENsYXNzKGIsIGkuc2VsZWN0Q2xlYXJCdG5XaGl0ZSk7XG4gIGNvbnN0IHYgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIuKclVwiKTtcbiAgYi5hcHBlbmRDaGlsZCh2KSwgYi5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLCBcIjBcIik7XG4gIGNvbnN0IEMgPSAkKFwic3BhblwiKTtcbiAgcmV0dXJuIGguYWRkQ2xhc3MoQywgaS5zZWxlY3RBcnJvdyksIEFzKFxuICAgIEMsXG4gICAgdCxcbiAgICBpLnNlbGVjdEFycm93RGVmYXVsdCxcbiAgICBpLnNlbGVjdEFycm93U20sXG4gICAgaS5zZWxlY3RBcnJvd0xnXG4gICksIHQuc2VsZWN0Rm9ybVdoaXRlICYmIGguYWRkQ2xhc3MoQywgaS5zZWxlY3RBcnJvd1doaXRlKSwgQy5pbm5lckhUTUwgPSBNZywgci5hcHBlbmRDaGlsZChhKSwgZSAmJiAoaC5hZGRDbGFzcyhlLCBpLnNlbGVjdExhYmVsKSwgQXMoXG4gICAgZSxcbiAgICB0LFxuICAgIGkuc2VsZWN0TGFiZWxTaXplRGVmYXVsdCxcbiAgICBpLnNlbGVjdExhYmVsU2l6ZVNtLFxuICAgIGkuc2VsZWN0TGFiZWxTaXplTGdcbiAgKSwgdC5zZWxlY3RGb3JtV2hpdGUgJiYgaC5hZGRDbGFzcyhlLCBpLnNlbGVjdExhYmVsV2hpdGUpLCByLmFwcGVuZENoaWxkKGUpKSwgdC5zZWxlY3RWYWxpZGF0aW9uICYmIChyLmFwcGVuZENoaWxkKF8pLCByLmFwcGVuZENoaWxkKGcpKSwgdC5zZWxlY3RDbGVhckJ1dHRvbiAmJiByLmFwcGVuZENoaWxkKGIpLCByLmFwcGVuZENoaWxkKEMpLCBvLmFwcGVuZENoaWxkKHIpLCBvO1xufVxuZnVuY3Rpb24gYWwocywgdCwgZSwgaSwgbiwgbywgciwgYSkge1xuICBjb25zdCBsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgbC5zZXRBdHRyaWJ1dGUod2csIFwiXCIpLCBoLmFkZENsYXNzKGwsIGEuc2VsZWN0RHJvcGRvd25Db250YWluZXIpLCBsLnNldEF0dHJpYnV0ZShcImlkXCIsIGAke3N9YCksIGwuc3R5bGUud2lkdGggPSBgJHtlfXB4YDtcbiAgY29uc3QgcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIHAuc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIiwgMCksIHAuc2V0QXR0cmlidXRlKGtnLCBcIlwiKSwgaC5hZGRDbGFzcyhwLCBhLmRyb3Bkb3duKTtcbiAgY29uc3QgdSA9ICQoXCJkaXZcIik7XG4gIHUuc2V0QXR0cmlidXRlKHhnLCBcIlwiKSwgaC5hZGRDbGFzcyh1LCBhLm9wdGlvbnNXcmFwcGVyKSwgaC5hZGRDbGFzcyh1LCBhLm9wdGlvbnNXcmFwcGVyU2Nyb2xsYmFyKSwgdS5zdHlsZS5tYXhIZWlnaHQgPSBgJHtpfXB4YDtcbiAgY29uc3QgXyA9IGVoKFxuICAgIG8sXG4gICAgbixcbiAgICB0LFxuICAgIGFcbiAgKTtcbiAgcmV0dXJuIHUuYXBwZW5kQ2hpbGQoXyksIHQuc2VsZWN0RmlsdGVyICYmIHAuYXBwZW5kQ2hpbGQoXG4gICAgQmcodC5zZWxlY3RTZWFyY2hQbGFjZWhvbGRlciwgYSlcbiAgKSwgcC5hcHBlbmRDaGlsZCh1KSwgciAmJiBwLmFwcGVuZENoaWxkKHIpLCBsLmFwcGVuZENoaWxkKHApLCBsO1xufVxuZnVuY3Rpb24gZWgocywgdCwgZSwgaSkge1xuICBjb25zdCBuID0gJChcImRpdlwiKTtcbiAgbi5zZXRBdHRyaWJ1dGUoT2csIFwiXCIpLCBoLmFkZENsYXNzKG4sIGkub3B0aW9uc0xpc3QpO1xuICBsZXQgbztcbiAgcmV0dXJuIGUubXVsdGlwbGUgPyBvID0gVmcoXG4gICAgcyxcbiAgICB0LFxuICAgIGUsXG4gICAgaVxuICApIDogbyA9IEhnKHMsIGUsIGkpLCBvLmZvckVhY2goKHIpID0+IHtcbiAgICBuLmFwcGVuZENoaWxkKHIpO1xuICB9KSwgbjtcbn1cbmZ1bmN0aW9uIEJnKHMsIHQpIHtcbiAgY29uc3QgZSA9ICQoXCJkaXZcIik7XG4gIGguYWRkQ2xhc3MoZSwgdC5pbnB1dEdyb3VwKTtcbiAgY29uc3QgaSA9ICQoXCJpbnB1dFwiKTtcbiAgcmV0dXJuIGkuc2V0QXR0cmlidXRlKFNnLCBcIlwiKSwgaC5hZGRDbGFzcyhpLCB0LnNlbGVjdEZpbHRlcklucHV0KSwgaS5wbGFjZWhvbGRlciA9IHMsIGkuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInNlYXJjaGJveFwiKSwgaS5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIFwidGV4dFwiKSwgZS5hcHBlbmRDaGlsZChpKSwgZTtcbn1cbmZ1bmN0aW9uIEhnKHMsIHQsIGUpIHtcbiAgcmV0dXJuIGloKHMsIHQsIGUpO1xufVxuZnVuY3Rpb24gVmcocywgdCwgZSwgaSkge1xuICBsZXQgbiA9IG51bGw7XG4gIGUuc2VsZWN0QWxsICYmIChuID0gV2coXG4gICAgdCxcbiAgICBzLFxuICAgIGUsXG4gICAgaVxuICApKTtcbiAgY29uc3QgbyA9IGloKHMsIGUsIGkpO1xuICByZXR1cm4gbiA/IFtuLCAuLi5vXSA6IG87XG59XG5mdW5jdGlvbiBpaChzLCB0LCBlKSB7XG4gIGNvbnN0IGkgPSBbXTtcbiAgcmV0dXJuIHMuZm9yRWFjaCgobikgPT4ge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoXG4gICAgICBuLFxuICAgICAgXCJvcHRpb25zXCJcbiAgICApKSB7XG4gICAgICBjb25zdCByID0gS2cobiwgdCwgZSk7XG4gICAgICBpLnB1c2gocik7XG4gICAgfSBlbHNlXG4gICAgICBpLnB1c2goc2gobiwgdCwgZSkpO1xuICB9KSwgaTtcbn1cbmZ1bmN0aW9uIFdnKHMsIHQsIGUsIGkpIHtcbiAgY29uc3QgbiA9IFZvKHQpLCBvID0gJChcImRpdlwiKTtcbiAgcmV0dXJuIG8uc2V0QXR0cmlidXRlKEpjLCBcIlwiKSwgaC5hZGRDbGFzcyhvLCBpLnNlbGVjdE9wdGlvbiksIG8uc2V0QXR0cmlidXRlKElnLCBcIlwiKSwgaC5hZGRTdHlsZShvLCB7XG4gICAgaGVpZ2h0OiBgJHtlLnNlbGVjdE9wdGlvbkhlaWdodH1weGBcbiAgfSksIG8uc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcIm9wdGlvblwiKSwgby5zZXRBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIsIG4pLCBuICYmIG8uc2V0QXR0cmlidXRlKHRoLCBcIlwiKSwgby5hcHBlbmRDaGlsZChuaChzLCBlLCBpKSksIHMuc2V0Tm9kZShvKSwgbztcbn1cbmZ1bmN0aW9uIHNoKHMsIHQsIGUpIHtcbiAgaWYgKHMubm9kZSlcbiAgICByZXR1cm4gcy5ub2RlO1xuICBjb25zdCBpID0gJChcImRpdlwiKTtcbiAgcmV0dXJuIGkuc2V0QXR0cmlidXRlKEpjLCBcIlwiKSwgaC5hZGRDbGFzcyhpLCBlLnNlbGVjdE9wdGlvbiksIGguYWRkU3R5bGUoaSwge1xuICAgIGhlaWdodDogYCR7dC5zZWxlY3RPcHRpb25IZWlnaHR9cHhgXG4gIH0pLCBoLnNldERhdGFBdHRyaWJ1dGUoaSwgXCJpZFwiLCBzLmlkKSwgaS5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwib3B0aW9uXCIpLCBpLnNldEF0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIiwgcy5zZWxlY3RlZCksIGkuc2V0QXR0cmlidXRlKFwiYXJpYS1kaXNhYmxlZFwiLCBzLmRpc2FibGVkKSwgcy5zZWxlY3RlZCAmJiBpLnNldEF0dHJpYnV0ZSh0aCwgXCJcIiksIHMuZGlzYWJsZWQgJiYgaS5zZXRBdHRyaWJ1dGUoXCJkYXRhLXRlLXNlbGVjdC1vcHRpb24tZGlzYWJsZWRcIiwgITApLCBzLmhpZGRlbiAmJiBoLmFkZENsYXNzKGksIFwiaGlkZGVuXCIpLCBpLmFwcGVuZENoaWxkKG5oKHMsIHQsIGUpKSwgcy5pY29uICYmIGkuYXBwZW5kQ2hpbGQoamcocywgZSkpLCBzLnNldE5vZGUoaSksIGk7XG59XG5mdW5jdGlvbiBuaChzLCB0LCBlKSB7XG4gIGNvbnN0IGkgPSAkKFwic3BhblwiKTtcbiAgaS5zZXRBdHRyaWJ1dGUoRGcsIFwiXCIpLCBoLmFkZENsYXNzKGksIGUuc2VsZWN0T3B0aW9uVGV4dCk7XG4gIGNvbnN0IG4gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShzLmxhYmVsKTtcbiAgcmV0dXJuIHQubXVsdGlwbGUgJiYgaS5hcHBlbmRDaGlsZChZZyhzLCBlKSksIGkuYXBwZW5kQ2hpbGQobiksIChzLnNlY29uZGFyeVRleHQgfHwgdHlwZW9mIHMuc2Vjb25kYXJ5VGV4dCA9PSBcIm51bWJlclwiKSAmJiBpLmFwcGVuZENoaWxkKFxuICAgIEZnKHMuc2Vjb25kYXJ5VGV4dCwgZSlcbiAgKSwgaTtcbn1cbmZ1bmN0aW9uIEZnKHMsIHQpIHtcbiAgY29uc3QgZSA9ICQoXCJzcGFuXCIpO1xuICBoLmFkZENsYXNzKGUsIHQuc2VsZWN0T3B0aW9uU2Vjb25kYXJ5VGV4dCk7XG4gIGNvbnN0IGkgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShzKTtcbiAgcmV0dXJuIGUuYXBwZW5kQ2hpbGQoaSksIGU7XG59XG5mdW5jdGlvbiBZZyhzLCB0KSB7XG4gIGNvbnN0IGUgPSAkKFwiaW5wdXRcIik7XG4gIGUuc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcImNoZWNrYm94XCIpLCBoLmFkZENsYXNzKGUsIHQuZm9ybUNoZWNrSW5wdXQpLCBlLnNldEF0dHJpYnV0ZSgkZywgXCJcIik7XG4gIGNvbnN0IGkgPSAkKFwibGFiZWxcIik7XG4gIHJldHVybiBzLnNlbGVjdGVkICYmIGUuc2V0QXR0cmlidXRlKFwiY2hlY2tlZFwiLCAhMCksIHMuZGlzYWJsZWQgJiYgZS5zZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiLCAhMCksIGUuYXBwZW5kQ2hpbGQoaSksIGU7XG59XG5mdW5jdGlvbiBqZyhzLCB0KSB7XG4gIGNvbnN0IGUgPSAkKFwic3BhblwiKSwgaSA9ICQoXCJpbWdcIik7XG4gIHJldHVybiBoLmFkZENsYXNzKGksIHQuc2VsZWN0T3B0aW9uSWNvbiksIGkuc3JjID0gcy5pY29uLCBlLmFwcGVuZENoaWxkKGkpLCBlO1xufVxuZnVuY3Rpb24gS2cocywgdCwgZSkge1xuICBjb25zdCBpID0gJChcImRpdlwiKTtcbiAgaS5zZXRBdHRyaWJ1dGUoTGcsIFwiXCIpLCBoLmFkZENsYXNzKGksIGUuc2VsZWN0T3B0aW9uR3JvdXApLCBpLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJncm91cFwiKSwgaS5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBzLmlkKSwgcy5oaWRkZW4gJiYgaC5hZGRDbGFzcyhpLCBcImhpZGRlblwiKTtcbiAgY29uc3QgbiA9ICQoXCJsYWJlbFwiKTtcbiAgcmV0dXJuIG4uc2V0QXR0cmlidXRlKE5nLCBcIlwiKSwgaC5hZGRDbGFzcyhuLCBlLnNlbGVjdE9wdGlvbkdyb3VwTGFiZWwpLCBoLmFkZFN0eWxlKG4sIHsgaGVpZ2h0OiBgJHt0LnNlbGVjdE9wdGlvbkhlaWdodH1weGAgfSksIG4uc2V0QXR0cmlidXRlKFwiZm9yXCIsIHMuaWQpLCBuLnRleHRDb250ZW50ID0gcy5sYWJlbCwgaS5hcHBlbmRDaGlsZChuKSwgcy5vcHRpb25zLmZvckVhY2goKG8pID0+IHtcbiAgICBpLmFwcGVuZENoaWxkKHNoKG8sIHQsIGUpKTtcbiAgfSksIGk7XG59XG5mdW5jdGlvbiB6ZyhzLCB0KSB7XG4gIGNvbnN0IGUgPSAkKFwiZGl2XCIpO1xuICByZXR1cm4gZS5pbm5lckhUTUwgPSBzLCBoLmFkZENsYXNzKGUsIHQuc2VsZWN0TGFiZWwpLCBoLmFkZENsYXNzKGUsIHQuc2VsZWN0RmFrZVZhbHVlKSwgZTtcbn1cbmNvbnN0IG9vID0gXCJzZWxlY3RcIiwgdmkgPSBcInRlLnNlbGVjdFwiLCBqaSA9IGAuJHt2aX1gLCBVZyA9IGBjbG9zZSR7aml9YCwgWGcgPSBgb3BlbiR7aml9YCwgbGwgPSBgb3B0aW9uU2VsZWN0JHtqaX1gLCBjbCA9IGBvcHRpb25EZXNlbGVjdCR7aml9YCwgR2cgPSBgdmFsdWVDaGFuZ2Uke2ppfWAsIHFnID0gXCJjaGFuZ2VcIiwgaGwgPSBcImRhdGEtdGUtc2VsZWN0LWluaXRcIiwgb2ggPSBcImRhdGEtdGUtc2VsZWN0LW5vLXJlc3VsdHMtcmVmXCIsIGRsID0gXCJkYXRhLXRlLXNlbGVjdC1vcGVuXCIsIHEgPSBcImRhdGEtdGUtaW5wdXQtc3RhdGUtYWN0aXZlXCIsIEt0ID0gXCJkYXRhLXRlLWlucHV0LWZvY3VzZWRcIiwgcm8gPSBcImRhdGEtdGUtaW5wdXQtZGlzYWJsZWRcIiwgWmcgPSBcImRhdGEtdGUtc2VsZWN0LW9wdGlvbi1ncm91cC1sYWJlbC1yZWZcIiwgUWcgPSBcImRhdGEtdGUtc2VsZWN0LW9wdGlvbi1hbGwtcmVmXCIsIHBpID0gXCJkYXRhLXRlLXNlbGVjdC1zZWxlY3RlZFwiLCBKZyA9IFwiW2RhdGEtdGUtc2VsZWN0LWxhYmVsLXJlZl1cIiwgdWwgPSBcIltkYXRhLXRlLXNlbGVjdC1pbnB1dC1yZWZdXCIsIHRiID0gXCJbZGF0YS10ZS1zZWxlY3QtaW5wdXQtZmlsdGVyLXJlZl1cIiwgZWIgPSBcIltkYXRhLXRlLXNlbGVjdC1kcm9wZG93bi1yZWZdXCIsIGliID0gXCJbZGF0YS10ZS1zZWxlY3Qtb3B0aW9ucy13cmFwcGVyLXJlZl1cIiwgcGwgPSBcIltkYXRhLXRlLXNlbGVjdC1vcHRpb25zLWxpc3QtcmVmXVwiLCBzYiA9IFwiW2RhdGEtdGUtc2VsZWN0LW9wdGlvbi1yZWZdXCIsIG5iID0gXCJbZGF0YS10ZS1zZWxlY3QtY2xlYXItYnRuLXJlZl1cIiwgb2IgPSBcIltkYXRhLXRlLXNlbGVjdC1jdXN0b20tY29udGVudC1yZWZdXCIsIHJiID0gYFske29ofV1gLCBfbCA9IFwiW2RhdGEtdGUtc2VsZWN0LWZvcm0tb3V0bGluZS1yZWZdXCIsIGFiID0gXCJbZGF0YS10ZS1zZWxlY3QtdG9nZ2xlXVwiLCBhbyA9IFwiW2RhdGEtdGUtaW5wdXQtbm90Y2gtcmVmXVwiLCBsYiA9IDIwMCwgY2IgPSB7XG4gIHNlbGVjdEF1dG9TZWxlY3Q6ICExLFxuICBzZWxlY3RDb250YWluZXI6IFwiYm9keVwiLFxuICBzZWxlY3RDbGVhckJ1dHRvbjogITEsXG4gIGRpc2FibGVkOiAhMSxcbiAgc2VsZWN0RGlzcGxheWVkTGFiZWxzOiA1LFxuICBzZWxlY3RGb3JtV2hpdGU6ICExLFxuICBtdWx0aXBsZTogITEsXG4gIHNlbGVjdE9wdGlvbnNTZWxlY3RlZExhYmVsOiBcIm9wdGlvbnMgc2VsZWN0ZWRcIixcbiAgc2VsZWN0T3B0aW9uSGVpZ2h0OiAzOCxcbiAgc2VsZWN0QWxsOiAhMCxcbiAgc2VsZWN0QWxsTGFiZWw6IFwiU2VsZWN0IGFsbFwiLFxuICBzZWxlY3RTZWFyY2hQbGFjZWhvbGRlcjogXCJTZWFyY2guLi5cIixcbiAgc2VsZWN0U2l6ZTogXCJkZWZhdWx0XCIsXG4gIHNlbGVjdFZpc2libGVPcHRpb25zOiA1LFxuICBzZWxlY3RGaWx0ZXI6ICExLFxuICBzZWxlY3RGaWx0ZXJEZWJvdW5jZTogMzAwLFxuICBzZWxlY3ROb1Jlc3VsdFRleHQ6IFwiTm8gcmVzdWx0c1wiLFxuICBzZWxlY3RWYWxpZGF0aW9uOiAhMSxcbiAgc2VsZWN0VmFsaWRGZWVkYmFjazogXCJWYWxpZFwiLFxuICBzZWxlY3RJbnZhbGlkRmVlZGJhY2s6IFwiSW52YWxpZFwiLFxuICBzZWxlY3RQbGFjZWhvbGRlcjogXCJcIlxufSwgaGIgPSB7XG4gIHNlbGVjdEF1dG9TZWxlY3Q6IFwiYm9vbGVhblwiLFxuICBzZWxlY3RDb250YWluZXI6IFwic3RyaW5nXCIsXG4gIHNlbGVjdENsZWFyQnV0dG9uOiBcImJvb2xlYW5cIixcbiAgZGlzYWJsZWQ6IFwiYm9vbGVhblwiLFxuICBzZWxlY3REaXNwbGF5ZWRMYWJlbHM6IFwibnVtYmVyXCIsXG4gIHNlbGVjdEZvcm1XaGl0ZTogXCJib29sZWFuXCIsXG4gIG11bHRpcGxlOiBcImJvb2xlYW5cIixcbiAgc2VsZWN0T3B0aW9uc1NlbGVjdGVkTGFiZWw6IFwic3RyaW5nXCIsXG4gIHNlbGVjdE9wdGlvbkhlaWdodDogXCJudW1iZXJcIixcbiAgc2VsZWN0QWxsOiBcImJvb2xlYW5cIixcbiAgc2VsZWN0QWxsTGFiZWw6IFwic3RyaW5nXCIsXG4gIHNlbGVjdFNlYXJjaFBsYWNlaG9sZGVyOiBcInN0cmluZ1wiLFxuICBzZWxlY3RTaXplOiBcInN0cmluZ1wiLFxuICBzZWxlY3RWaXNpYmxlT3B0aW9uczogXCJudW1iZXJcIixcbiAgc2VsZWN0RmlsdGVyOiBcImJvb2xlYW5cIixcbiAgc2VsZWN0RmlsdGVyRGVib3VuY2U6IFwibnVtYmVyXCIsXG4gIHNlbGVjdE5vUmVzdWx0VGV4dDogXCJzdHJpbmdcIixcbiAgc2VsZWN0VmFsaWRhdGlvbjogXCJib29sZWFuXCIsXG4gIHNlbGVjdFZhbGlkRmVlZGJhY2s6IFwic3RyaW5nXCIsXG4gIHNlbGVjdEludmFsaWRGZWVkYmFjazogXCJzdHJpbmdcIixcbiAgc2VsZWN0UGxhY2Vob2xkZXI6IFwic3RyaW5nXCJcbn0sIGRiID0ge1xuICBkcm9wZG93bjogXCJyZWxhdGl2ZSBvdXRsaW5lLW5vbmUgbWluLXctWzEwMHB4XSBtLTAgc2NhbGUtWzAuOF0gb3BhY2l0eS0wIGJnLXdoaXRlIHNoYWRvdy1bMF8ycHhfNXB4XzBfcmdiYSgwLDAsMCwwLjE2KSxfMF8ycHhfMTBweF8wX3JnYmEoMCwwLDAsMC4xMildIHRyYW5zaXRpb24gZHVyYXRpb24tMjAwIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIGRhdGEtW3RlLXNlbGVjdC1vcGVuXTpzY2FsZS0xMDAgZGF0YS1bdGUtc2VsZWN0LW9wZW5dOm9wYWNpdHktMTAwIGRhcms6YmctemluYy03MDBcIixcbiAgZm9ybUNoZWNrSW5wdXQ6IFwicmVsYXRpdmUgZmxvYXQtbGVmdCBtdC1bMC4xNXJlbV0gbXItWzhweF0gaC1bMS4xMjVyZW1dIHctWzEuMTI1cmVtXSBhcHBlYXJhbmNlLW5vbmUgcm91bmRlZC1bMC4yNXJlbV0gYm9yZGVyLVswLjEyNXJlbV0gYm9yZGVyLXNvbGlkIGJvcmRlci1uZXV0cmFsLTMwMCBkYXJrOmJvcmRlci1uZXV0cmFsLTYwMCBvdXRsaW5lLW5vbmUgYmVmb3JlOnBvaW50ZXItZXZlbnRzLW5vbmUgYmVmb3JlOmFic29sdXRlIGJlZm9yZTpoLVswLjg3NXJlbV0gYmVmb3JlOnctWzAuODc1cmVtXSBiZWZvcmU6c2NhbGUtMCBiZWZvcmU6cm91bmRlZC1mdWxsIGJlZm9yZTpiZy10cmFuc3BhcmVudCBiZWZvcmU6b3BhY2l0eS0wIGJlZm9yZTpzaGFkb3ctWzBweF8wcHhfMHB4XzEzcHhfdHJhbnNwYXJlbnRdIGJlZm9yZTpjb250ZW50LVsnJ10gY2hlY2tlZDpib3JkZXItcHJpbWFyeSBkYXJrOmNoZWNrZWQ6Ym9yZGVyLXByaW1hcnkgY2hlY2tlZDpiZy1wcmltYXJ5IGRhcms6Y2hlY2tlZDpiZy1wcmltYXJ5IGNoZWNrZWQ6YmVmb3JlOm9wYWNpdHktWzAuMTZdIGNoZWNrZWQ6YWZ0ZXI6YWJzb2x1dGUgY2hlY2tlZDphZnRlcjptbC1bMC4yNXJlbV0gY2hlY2tlZDphZnRlcjotbXQtcHggY2hlY2tlZDphZnRlcjpibG9jayBjaGVja2VkOmFmdGVyOmgtWzAuODEyNXJlbV0gY2hlY2tlZDphZnRlcjp3LVswLjM3NXJlbV0gY2hlY2tlZDphZnRlcjpyb3RhdGUtNDUgY2hlY2tlZDphZnRlcjpib3JkZXItWzAuMTI1cmVtXSBjaGVja2VkOmFmdGVyOmJvcmRlci10LTAgY2hlY2tlZDphZnRlcjpib3JkZXItbC0wIGNoZWNrZWQ6YWZ0ZXI6Ym9yZGVyLXNvbGlkIGNoZWNrZWQ6YWZ0ZXI6Ym9yZGVyLXdoaXRlIGNoZWNrZWQ6YWZ0ZXI6YmctdHJhbnNwYXJlbnQgY2hlY2tlZDphZnRlcjpjb250ZW50LVsnJ10gaG92ZXI6Y3Vyc29yLXBvaW50ZXIgaG92ZXI6YmVmb3JlOm9wYWNpdHktWzAuMDRdIGhvdmVyOmJlZm9yZTpzaGFkb3ctWzBweF8wcHhfMHB4XzEzcHhfcmdiYSgwLDAsMCwwLjYpXSBmb2N1czpzaGFkb3ctbm9uZSBmb2N1czp0cmFuc2l0aW9uLVtib3JkZXItY29sb3JfMC4yc10gZm9jdXM6YmVmb3JlOnNjYWxlLTEwMCBmb2N1czpiZWZvcmU6b3BhY2l0eS1bMC4xMl0gZm9jdXM6YmVmb3JlOnNoYWRvdy1bMHB4XzBweF8wcHhfMTNweF9yZ2JhKDAsMCwwLDAuNildIGRhcms6Zm9jdXM6YmVmb3JlOnNoYWRvdy1bMHB4XzBweF8wcHhfMTNweF9yZ2JhKDI1NSwyNTUsMjU1LDAuNCldIGZvY3VzOmJlZm9yZTp0cmFuc2l0aW9uLVtib3gtc2hhZG93XzAuMnMsdHJhbnNmb3JtXzAuMnNdIGZvY3VzOmFmdGVyOmFic29sdXRlIGZvY3VzOmFmdGVyOnotWzFdIGZvY3VzOmFmdGVyOmJsb2NrIGZvY3VzOmFmdGVyOmgtWzAuODc1cmVtXSBmb2N1czphZnRlcjp3LVswLjg3NXJlbV0gZm9jdXM6YWZ0ZXI6cm91bmRlZC1bMC4xMjVyZW1dIGZvY3VzOmFmdGVyOmNvbnRlbnQtWycnXSBjaGVja2VkOmZvY3VzOmJlZm9yZTpzY2FsZS0xMDAgY2hlY2tlZDpmb2N1czpiZWZvcmU6c2hhZG93LVswcHhfMHB4XzBweF8xM3B4XyMzYjcxY2FdIGRhcms6Y2hlY2tlZDpmb2N1czpiZWZvcmU6c2hhZG93LVswcHhfMHB4XzBweF8xM3B4XyMzYjcxY2FdIGNoZWNrZWQ6Zm9jdXM6YmVmb3JlOnRyYW5zaXRpb24tW2JveC1zaGFkb3dfMC4ycyx0cmFuc2Zvcm1fMC4yc10gY2hlY2tlZDpmb2N1czphZnRlcjptbC1bMC4yNXJlbV0gY2hlY2tlZDpmb2N1czphZnRlcjotbXQtcHggY2hlY2tlZDpmb2N1czphZnRlcjpoLVswLjgxMjVyZW1dIGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6dy1bMC4zNzVyZW1dIGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6cm90YXRlLTQ1IGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6cm91bmRlZC1ub25lIGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6Ym9yZGVyLVswLjEyNXJlbV0gY2hlY2tlZDpmb2N1czphZnRlcjpib3JkZXItdC0wIGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6Ym9yZGVyLWwtMCBjaGVja2VkOmZvY3VzOmFmdGVyOmJvcmRlci1zb2xpZCBjaGVja2VkOmZvY3VzOmFmdGVyOmJvcmRlci13aGl0ZSBjaGVja2VkOmZvY3VzOmFmdGVyOmJnLXRyYW5zcGFyZW50XCIsXG4gIGZvcm1PdXRsaW5lOiBcInJlbGF0aXZlXCIsXG4gIGluaXRpYWxpemVkOiBcImhpZGRlblwiLFxuICBpbnB1dEdyb3VwOiBcImZsZXggaXRlbXMtY2VudGVyIHdoaXRlc3BhY2Utbm93cmFwIHAtMi41IHRleHQtY2VudGVyIHRleHQtYmFzZSBmb250LW5vcm1hbCBsZWFkaW5nLVsxLjZdIHRleHQtZ3JheS03MDAgZGFyazpiZy16aW5jLTgwMCBkYXJrOnRleHQtZ3JheS0yMDAgZGFyazpwbGFjZWhvbGRlcjp0ZXh0LWdyYXktMjAwXCIsXG4gIG5vUmVzdWx0OiBcImZsZXggaXRlbXMtY2VudGVyIHB4LTRcIixcbiAgb3B0aW9uc0xpc3Q6IFwibGlzdC1ub25lIG0tMCBwLTBcIixcbiAgb3B0aW9uc1dyYXBwZXI6IFwib3ZlcmZsb3cteS1hdXRvXCIsXG4gIG9wdGlvbnNXcmFwcGVyU2Nyb2xsYmFyOiBcIlsmOjotd2Via2l0LXNjcm9sbGJhcl06dy0xIFsmOjotd2Via2l0LXNjcm9sbGJhcl06aC0xIFsmOjotd2Via2l0LXNjcm9sbGJhci1idXR0b25dOmJsb2NrIFsmOjotd2Via2l0LXNjcm9sbGJhci1idXR0b25dOmgtMCBbJjo6LXdlYmtpdC1zY3JvbGxiYXItYnV0dG9uXTpiZy10cmFuc3BhcmVudCBbJjo6LXdlYmtpdC1zY3JvbGxiYXItdHJhY2stcGllY2VdOmJnLXRyYW5zcGFyZW50IFsmOjotd2Via2l0LXNjcm9sbGJhci10cmFjay1waWVjZV06cm91bmRlZC1ub25lIFsmOjotd2Via2l0LXNjcm9sbGJhci10cmFjay1waWVjZV06IFsmOjotd2Via2l0LXNjcm9sbGJhci10cmFjay1waWVjZV06cm91bmRlZC1sIFsmOjotd2Via2l0LXNjcm9sbGJhci10aHVtYl06aC1bNTBweF0gWyY6Oi13ZWJraXQtc2Nyb2xsYmFyLXRodW1iXTpiZy1bIzk5OV0gWyY6Oi13ZWJraXQtc2Nyb2xsYmFyLXRodW1iXTpyb3VuZGVkXCIsXG4gIHNlbGVjdEFycm93OiBcImFic29sdXRlIHJpZ2h0LTMgdGV4dC1bMC44cmVtXSBjdXJzb3ItcG9pbnRlciBwZWVyLWZvY3VzOnRleHQtcHJpbWFyeSBwZWVyLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOnRleHQtcHJpbWFyeSBncm91cC1kYXRhLVt0ZS13YXMtdmFsaWRhdGVkXS92YWxpZGF0aW9uOnBlZXItdmFsaWQ6dGV4dC1ncmVlbi02MDAgZ3JvdXAtZGF0YS1bdGUtd2FzLXZhbGlkYXRlZF0vdmFsaWRhdGlvbjpwZWVyLWludmFsaWQ6dGV4dC1bcmdiKDIyMCw3NiwxMDApXSB3LTUgaC01XCIsXG4gIHNlbGVjdEFycm93V2hpdGU6IFwidGV4dC1ncmF5LTUwIHBlZXItZm9jdXM6IXRleHQtd2hpdGUgcGVlci1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTohdGV4dC13aGl0ZVwiLFxuICBzZWxlY3RBcnJvd0RlZmF1bHQ6IFwidG9wLTJcIixcbiAgc2VsZWN0QXJyb3dMZzogXCJ0b3AtWzEzcHhdXCIsXG4gIHNlbGVjdEFycm93U206IFwidG9wLTFcIixcbiAgc2VsZWN0Q2xlYXJCdG46IFwiYWJzb2x1dGUgdG9wLTIgcmlnaHQtOSB0ZXh0LWJsYWNrIGN1cnNvci1wb2ludGVyIGZvY3VzOnRleHQtcHJpbWFyeSBvdXRsaW5lLW5vbmUgZGFyazp0ZXh0LWdyYXktMjAwXCIsXG4gIHNlbGVjdENsZWFyQnRuV2hpdGU6IFwiIXRleHQtZ3JheS01MFwiLFxuICBzZWxlY3RDbGVhckJ0bkRlZmF1bHQ6IFwidG9wLTIgdGV4dC1iYXNlXCIsXG4gIHNlbGVjdENsZWFyQnRuTGc6IFwidG9wLVsxMXB4XSB0ZXh0LWJhc2VcIixcbiAgc2VsZWN0Q2xlYXJCdG5TbTogXCJ0b3AtMSB0ZXh0LVswLjhyZW1dXCIsXG4gIHNlbGVjdERyb3Bkb3duQ29udGFpbmVyOiBcInotWzEwNzBdXCIsXG4gIHNlbGVjdEZha2VWYWx1ZTogXCJ0cmFuc2Zvcm0tbm9uZSBoaWRkZW4gZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTpibG9ja1wiLFxuICBzZWxlY3RGaWx0ZXJJbnB1dDogXCJyZWxhdGl2ZSBtLTAgYmxvY2sgdy1mdWxsIG1pbi13LTAgZmxleC1hdXRvIHJvdW5kZWQgYm9yZGVyIGJvcmRlci1zb2xpZCBib3JkZXItZ3JheS0zMDAgYmctdHJhbnNwYXJlbnQgYmctY2xpcC1wYWRkaW5nIHB4LTMgcHktMS41IHRleHQtYmFzZSBmb250LW5vcm1hbCB0ZXh0LWdyYXktNzAwIHRyYW5zaXRpb24gZHVyYXRpb24tMzAwIGVhc2UtaW4tb3V0IG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIGZvY3VzOmJvcmRlci1wcmltYXJ5IGZvY3VzOnRleHQtZ3JheS03MDAgZm9jdXM6c2hhZG93LXRlLXByaW1hcnkgZm9jdXM6b3V0bGluZS1ub25lIGRhcms6dGV4dC1ncmF5LTIwMCBkYXJrOnBsYWNlaG9sZGVyOnRleHQtZ3JheS0yMDBcIixcbiAgc2VsZWN0SW5wdXQ6IFwicGVlciBibG9jayBtaW4taC1bYXV0b10gdy1mdWxsIHJvdW5kZWQgYm9yZGVyLTAgYmctdHJhbnNwYXJlbnQgb3V0bGluZS1ub25lIHRyYW5zaXRpb24tYWxsIGR1cmF0aW9uLTIwMCBlYXNlLWxpbmVhciBmb2N1czpwbGFjZWhvbGRlcjpvcGFjaXR5LTEwMCBkYXRhLVt0ZS1pbnB1dC1zdGF0ZS1hY3RpdmVdOnBsYWNlaG9sZGVyOm9wYWNpdHktMTAwIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIGRhcms6dGV4dC1ncmF5LTIwMCBkYXJrOnBsYWNlaG9sZGVyOnRleHQtZ3JheS0yMDAgWyY6bm90KFtkYXRhLXRlLWlucHV0LXBsYWNlaG9sZGVyLWFjdGl2ZV0pXTpwbGFjZWhvbGRlcjpvcGFjaXR5LTAgY3Vyc29yLXBvaW50ZXIgZGF0YS1bdGUtaW5wdXQtZGlzYWJsZWRdOmJnLVsjZTllY2VmXSBkYXRhLVt0ZS1pbnB1dC1kaXNhYmxlZF06Y3Vyc29yLWRlZmF1bHQgZ3JvdXAtZGF0YS1bdGUtd2FzLXZhbGlkYXRlZF0vdmFsaWRhdGlvbjptYi00IGRhcms6ZGF0YS1bdGUtaW5wdXQtZGlzYWJsZWRdOmJnLXppbmMtNjAwXCIsXG4gIHNlbGVjdElucHV0V2hpdGU6IFwiIXRleHQtZ3JheS01MFwiLFxuICBzZWxlY3RJbnB1dFNpemVEZWZhdWx0OiBcInB5LVswLjMycmVtXSBweC0zIGxlYWRpbmctWzEuNl1cIixcbiAgc2VsZWN0SW5wdXRTaXplTGc6IFwicHktWzAuMzJyZW1dIHB4LTMgbGVhZGluZy1bMi4xNV1cIixcbiAgc2VsZWN0SW5wdXRTaXplU206IFwicHktWzAuMzNyZW1dIHB4LTMgdGV4dC14cyBsZWFkaW5nLVsxLjVdXCIsXG4gIHNlbGVjdExhYmVsOiBcInBvaW50ZXItZXZlbnRzLW5vbmUgYWJzb2x1dGUgdG9wLTAgbGVmdC0zIG1iLTAgbWF4LXctWzkwJV0gb3JpZ2luLVswXzBdIHRydW5jYXRlIHRleHQtZ3JheS01MDAgdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tMjAwIGVhc2Utb3V0IHBlZXItZm9jdXM6c2NhbGUtWzAuOF0gcGVlci1mb2N1czp0ZXh0LXByaW1hcnkgcGVlci1kYXRhLVt0ZS1pbnB1dC1zdGF0ZS1hY3RpdmVdOnNjYWxlLVswLjhdIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIGRhcms6dGV4dC1ncmF5LTIwMCBkYXJrOnBlZXItZm9jdXM6dGV4dC1ncmF5LTIwMCBkYXRhLVt0ZS1pbnB1dC1zdGF0ZS1hY3RpdmVdOnNjYWxlLVswLjhdIGRhcms6cGVlci1mb2N1czp0ZXh0LXByaW1hcnlcIixcbiAgc2VsZWN0TGFiZWxXaGl0ZTogXCIhdGV4dC1ncmF5LTUwXCIsXG4gIHNlbGVjdExhYmVsU2l6ZURlZmF1bHQ6IFwicHQtWzAuMzdyZW1dIGxlYWRpbmctWzEuNl0gcGVlci1mb2N1czotdHJhbnNsYXRlLXktWzAuOXJlbV0gcGVlci1kYXRhLVt0ZS1pbnB1dC1zdGF0ZS1hY3RpdmVdOi10cmFuc2xhdGUteS1bMC45cmVtXSBkYXRhLVt0ZS1pbnB1dC1zdGF0ZS1hY3RpdmVdOi10cmFuc2xhdGUteS1bMC45cmVtXVwiLFxuICBzZWxlY3RMYWJlbFNpemVMZzogXCJwdC1bMC4zN3JlbV0gbGVhZGluZy1bMi4xNV0gcGVlci1mb2N1czotdHJhbnNsYXRlLXktWzEuMTVyZW1dIHBlZXItZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTotdHJhbnNsYXRlLXktWzEuMTVyZW1dIGRhdGEtW3RlLWlucHV0LXN0YXRlLWFjdGl2ZV06LXRyYW5zbGF0ZS15LVsxLjE1cmVtXVwiLFxuICBzZWxlY3RMYWJlbFNpemVTbTogXCJwdC1bMC4zN3JlbV0gdGV4dC14cyBsZWFkaW5nLVsxLjVdIHBlZXItZm9jdXM6LXRyYW5zbGF0ZS15LVswLjc1cmVtXSBwZWVyLWRhdGEtW3RlLWlucHV0LXN0YXRlLWFjdGl2ZV06LXRyYW5zbGF0ZS15LVswLjc1cmVtXSBkYXRhLVt0ZS1pbnB1dC1zdGF0ZS1hY3RpdmVdOi10cmFuc2xhdGUteS1bMC43NXJlbV1cIixcbiAgc2VsZWN0T3B0aW9uOiBcImZsZXggZmxleC1yb3cgaXRlbXMtY2VudGVyIGp1c3RpZnktYmV0d2VlbiB3LWZ1bGwgcHgtNCB0cnVuY2F0ZSB0ZXh0LWdyYXktNzAwIGJnLXRyYW5zcGFyZW50IHNlbGVjdC1ub25lIGN1cnNvci1wb2ludGVyIGRhdGEtW3RlLWlucHV0LW11bHRpcGxlLWFjdGl2ZV06YmctYmxhY2svNSBob3ZlcjpbJjpub3QoW2RhdGEtdGUtc2VsZWN0LW9wdGlvbi1kaXNhYmxlZF0pXTpiZy1ibGFjay81IGRhdGEtW3RlLWlucHV0LXN0YXRlLWFjdGl2ZV06YmctYmxhY2svNSBkYXRhLVt0ZS1zZWxlY3Qtb3B0aW9uLXNlbGVjdGVkXTpkYXRhLVt0ZS1pbnB1dC1zdGF0ZS1hY3RpdmVdOmJnLWJsYWNrLzUgZGF0YS1bdGUtc2VsZWN0LXNlbGVjdGVkXTpkYXRhLVt0ZS1zZWxlY3Qtb3B0aW9uLWRpc2FibGVkXTpjdXJzb3ItZGVmYXVsdCBkYXRhLVt0ZS1zZWxlY3Qtc2VsZWN0ZWRdOmRhdGEtW3RlLXNlbGVjdC1vcHRpb24tZGlzYWJsZWRdOnRleHQtZ3JheS00MDAgZGF0YS1bdGUtc2VsZWN0LXNlbGVjdGVkXTpkYXRhLVt0ZS1zZWxlY3Qtb3B0aW9uLWRpc2FibGVkXTpiZy10cmFuc3BhcmVudCBkYXRhLVt0ZS1zZWxlY3Qtb3B0aW9uLXNlbGVjdGVkXTpiZy1ibGFjay9bMC4wMl0gZGF0YS1bdGUtc2VsZWN0LW9wdGlvbi1kaXNhYmxlZF06dGV4dC1ncmF5LTQwMCBkYXRhLVt0ZS1zZWxlY3Qtb3B0aW9uLWRpc2FibGVkXTpjdXJzb3ItZGVmYXVsdCBncm91cC1kYXRhLVt0ZS1zZWxlY3Qtb3B0aW9uLWdyb3VwLXJlZl0vb3B0OnBsLTcgZGFyazp0ZXh0LWdyYXktMjAwIGRhcms6aG92ZXI6WyY6bm90KFtkYXRhLXRlLXNlbGVjdC1vcHRpb24tZGlzYWJsZWRdKV06Ymctd2hpdGUvMzAgZGFyazpkYXRhLVt0ZS1pbnB1dC1zdGF0ZS1hY3RpdmVdOmJnLXdoaXRlLzMwIGRhcms6ZGF0YS1bdGUtc2VsZWN0LW9wdGlvbi1zZWxlY3RlZF06ZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTpiZy13aGl0ZS8zMCBkYXJrOmRhdGEtW3RlLXNlbGVjdC1vcHRpb24tZGlzYWJsZWRdOnRleHQtZ3JheS00MDAgZGFyazpkYXRhLVt0ZS1pbnB1dC1tdWx0aXBsZS1hY3RpdmVdOmJnLXdoaXRlLzMwXCIsXG4gIHNlbGVjdE9wdGlvbkdyb3VwOiBcImdyb3VwL29wdFwiLFxuICBzZWxlY3RPcHRpb25Hcm91cExhYmVsOiBcImZsZXggZmxleC1yb3cgaXRlbXMtY2VudGVyIHctZnVsbCBweC00IHRydW5jYXRlIGJnLXRyYW5zcGFyZW50IHRleHQtYmxhY2svNTAgc2VsZWN0LW5vbmUgZGFyazp0ZXh0LWdyYXktMzAwXCIsXG4gIHNlbGVjdE9wdGlvbkljb246IFwidy03IGgtNyByb3VuZGVkLWZ1bGxcIixcbiAgc2VsZWN0T3B0aW9uU2Vjb25kYXJ5VGV4dDogXCJibG9jayB0ZXh0LVswLjhyZW1dIHRleHQtZ3JheS01MDAgZGFyazp0ZXh0LWdyYXktMzAwXCIsXG4gIHNlbGVjdE9wdGlvblRleHQ6IFwiZ3JvdXBcIixcbiAgc2VsZWN0VmFsaWRhdGlvblZhbGlkOiBcImhpZGRlbiBhYnNvbHV0ZSAtbXQtMyB3LWF1dG8gdGV4dC1zbSB0ZXh0LWdyZWVuLTYwMCBjdXJzb3ItcG9pbnRlciBncm91cC1kYXRhLVt0ZS13YXMtdmFsaWRhdGVkXS92YWxpZGF0aW9uOnBlZXItdmFsaWQ6YmxvY2tcIixcbiAgc2VsZWN0VmFsaWRhdGlvbkludmFsaWQ6IFwiaGlkZGVuIGFic29sdXRlIC1tdC0zIHctYXV0byB0ZXh0LXNtIHRleHQtW3JnYigyMjAsNzYsMTAwKV0gY3Vyc29yLXBvaW50ZXIgZ3JvdXAtZGF0YS1bdGUtd2FzLXZhbGlkYXRlZF0vdmFsaWRhdGlvbjpwZWVyLWludmFsaWQ6YmxvY2tcIlxufSwgdWIgPSB7XG4gIGRyb3Bkb3duOiBcInN0cmluZ1wiLFxuICBmb3JtQ2hlY2tJbnB1dDogXCJzdHJpbmdcIixcbiAgZm9ybU91dGxpbmU6IFwic3RyaW5nXCIsXG4gIGluaXRpYWxpemVkOiBcInN0cmluZ1wiLFxuICBpbnB1dEdyb3VwOiBcInN0cmluZ1wiLFxuICBub1Jlc3VsdDogXCJzdHJpbmdcIixcbiAgb3B0aW9uc0xpc3Q6IFwic3RyaW5nXCIsXG4gIG9wdGlvbnNXcmFwcGVyOiBcInN0cmluZ1wiLFxuICBvcHRpb25zV3JhcHBlclNjcm9sbGJhcjogXCJzdHJpbmdcIixcbiAgc2VsZWN0QXJyb3c6IFwic3RyaW5nXCIsXG4gIHNlbGVjdEFycm93RGVmYXVsdDogXCJzdHJpbmdcIixcbiAgc2VsZWN0QXJyb3dMZzogXCJzdHJpbmdcIixcbiAgc2VsZWN0QXJyb3dTbTogXCJzdHJpbmdcIixcbiAgc2VsZWN0Q2xlYXJCdG46IFwic3RyaW5nXCIsXG4gIHNlbGVjdENsZWFyQnRuRGVmYXVsdDogXCJzdHJpbmdcIixcbiAgc2VsZWN0Q2xlYXJCdG5MZzogXCJzdHJpbmdcIixcbiAgc2VsZWN0Q2xlYXJCdG5TbTogXCJzdHJpbmdcIixcbiAgc2VsZWN0RHJvcGRvd25Db250YWluZXI6IFwic3RyaW5nXCIsXG4gIHNlbGVjdEZha2VWYWx1ZTogXCJzdHJpbmdcIixcbiAgc2VsZWN0RmlsdGVySW5wdXQ6IFwic3RyaW5nXCIsXG4gIHNlbGVjdElucHV0OiBcInN0cmluZ1wiLFxuICBzZWxlY3RJbnB1dFNpemVEZWZhdWx0OiBcInN0cmluZ1wiLFxuICBzZWxlY3RJbnB1dFNpemVMZzogXCJzdHJpbmdcIixcbiAgc2VsZWN0SW5wdXRTaXplU206IFwic3RyaW5nXCIsXG4gIHNlbGVjdExhYmVsOiBcInN0cmluZ1wiLFxuICBzZWxlY3RMYWJlbFNpemVEZWZhdWx0OiBcInN0cmluZ1wiLFxuICBzZWxlY3RMYWJlbFNpemVMZzogXCJzdHJpbmdcIixcbiAgc2VsZWN0TGFiZWxTaXplU206IFwic3RyaW5nXCIsXG4gIHNlbGVjdE9wdGlvbjogXCJzdHJpbmdcIixcbiAgc2VsZWN0T3B0aW9uR3JvdXA6IFwic3RyaW5nXCIsXG4gIHNlbGVjdE9wdGlvbkdyb3VwTGFiZWw6IFwic3RyaW5nXCIsXG4gIHNlbGVjdE9wdGlvbkljb246IFwic3RyaW5nXCIsXG4gIHNlbGVjdE9wdGlvblNlY29uZGFyeVRleHQ6IFwic3RyaW5nXCIsXG4gIHNlbGVjdE9wdGlvblRleHQ6IFwic3RyaW5nXCJcbn07XG5jbGFzcyBfciB7XG4gIGNvbnN0cnVjdG9yKHQsIGUsIGkpIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gdCwgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLl9jbGFzc2VzID0gdGhpcy5fZ2V0Q2xhc3NlcyhpKSwgdGhpcy5fY29uZmlnLnNlbGVjdFBsYWNlaG9sZGVyICYmICF0aGlzLl9jb25maWcubXVsdGlwbGUgJiYgdGhpcy5fYWRkUGxhY2Vob2xkZXJPcHRpb24oKSwgdGhpcy5fb3B0aW9uc1RvUmVuZGVyID0gdGhpcy5fZ2V0T3B0aW9uc1RvUmVuZGVyKHQpLCB0aGlzLl9wbGFpbk9wdGlvbnMgPSB0aGlzLl9nZXRQbGFpbk9wdGlvbnModGhpcy5fb3B0aW9uc1RvUmVuZGVyKSwgdGhpcy5fZmlsdGVyZWRPcHRpb25zTGlzdCA9IG51bGwsIHRoaXMuX3NlbGVjdGlvbk1vZGVsID0gbmV3IFRnKHRoaXMubXVsdGlwbGUpLCB0aGlzLl9hY3RpdmVPcHRpb25JbmRleCA9IC0xLCB0aGlzLl9hY3RpdmVPcHRpb24gPSBudWxsLCB0aGlzLl93cmFwcGVySWQgPSBydChcInNlbGVjdC13cmFwcGVyLVwiKSwgdGhpcy5fZHJvcGRvd25Db250YWluZXJJZCA9IHJ0KFwic2VsZWN0LWRyb3Bkb3duLWNvbnRhaW5lci1cIiksIHRoaXMuX3NlbGVjdEFsbElkID0gcnQoXCJzZWxlY3QtYWxsLVwiKSwgdGhpcy5fZGVib3VuY2VUaW1lb3V0SWQgPSBudWxsLCB0aGlzLl9kcm9wZG93bkhlaWdodCA9IHRoaXMuX2NvbmZpZy5zZWxlY3RPcHRpb25IZWlnaHQgKiB0aGlzLl9jb25maWcuc2VsZWN0VmlzaWJsZU9wdGlvbnMsIHRoaXMuX3BvcHBlciA9IG51bGwsIHRoaXMuX2lucHV0ID0gbnVsbCwgdGhpcy5fbGFiZWwgPSBkLm5leHQodGhpcy5fZWxlbWVudCwgSmcpWzBdLCB0aGlzLl9ub3RjaCA9IG51bGwsIHRoaXMuX2Zha2VWYWx1ZSA9IG51bGwsIHRoaXMuX2lzRmFrZVZhbHVlQWN0aXZlID0gITEsIHRoaXMuX2N1c3RvbUNvbnRlbnQgPSBkLm5leHQoXG4gICAgICB0LFxuICAgICAgb2JcbiAgICApWzBdLCB0aGlzLl90b2dnbGVCdXR0b24gPSBudWxsLCB0aGlzLl9lbGVtZW50VG9nZ2xlID0gbnVsbCwgdGhpcy5fd3JhcHBlciA9IG51bGwsIHRoaXMuX2lucHV0RWwgPSBudWxsLCB0aGlzLl9kcm9wZG93bkNvbnRhaW5lciA9IG51bGwsIHRoaXMuX2NvbnRhaW5lciA9IG51bGwsIHRoaXMuX3NlbGVjdEFsbE9wdGlvbiA9IG51bGwsIHRoaXMuX2luaXQoKSwgdGhpcy5fbXV0YXRpb25PYnNlcnZlciA9IG51bGwsIHRoaXMuX2lzT3BlbiA9ICExLCB0aGlzLl9hZGRNdXRhdGlvbk9ic2VydmVyKCksIHRoaXMuX2VsZW1lbnQgJiYgeS5zZXREYXRhKHQsIHZpLCB0aGlzKTtcbiAgfVxuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIG9vO1xuICB9XG4gIGdldCBmaWx0ZXJJbnB1dCgpIHtcbiAgICByZXR1cm4gZC5maW5kT25lKFxuICAgICAgdGIsXG4gICAgICB0aGlzLl9kcm9wZG93bkNvbnRhaW5lclxuICAgICk7XG4gIH1cbiAgZ2V0IGRyb3Bkb3duKCkge1xuICAgIHJldHVybiBkLmZpbmRPbmUoZWIsIHRoaXMuX2Ryb3Bkb3duQ29udGFpbmVyKTtcbiAgfVxuICBnZXQgb3B0aW9uc0xpc3QoKSB7XG4gICAgcmV0dXJuIGQuZmluZE9uZShcbiAgICAgIHBsLFxuICAgICAgdGhpcy5fZHJvcGRvd25Db250YWluZXJcbiAgICApO1xuICB9XG4gIGdldCBvcHRpb25zV3JhcHBlcigpIHtcbiAgICByZXR1cm4gZC5maW5kT25lKFxuICAgICAgaWIsXG4gICAgICB0aGlzLl9kcm9wZG93bkNvbnRhaW5lclxuICAgICk7XG4gIH1cbiAgZ2V0IGNsZWFyQnV0dG9uKCkge1xuICAgIHJldHVybiBkLmZpbmRPbmUobmIsIHRoaXMuX3dyYXBwZXIpO1xuICB9XG4gIGdldCBvcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl9maWx0ZXJlZE9wdGlvbnNMaXN0ID8gdGhpcy5fZmlsdGVyZWRPcHRpb25zTGlzdCA6IHRoaXMuX3BsYWluT3B0aW9ucztcbiAgfVxuICBnZXQgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMubXVsdGlwbGUgPyB0aGlzLl9zZWxlY3Rpb25Nb2RlbC52YWx1ZXMgOiB0aGlzLl9zZWxlY3Rpb25Nb2RlbC52YWx1ZTtcbiAgfVxuICBnZXQgbXVsdGlwbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5tdWx0aXBsZTtcbiAgfVxuICBnZXQgaGFzU2VsZWN0QWxsKCkge1xuICAgIHJldHVybiB0aGlzLm11bHRpcGxlICYmIHRoaXMuX2NvbmZpZy5zZWxlY3RBbGw7XG4gIH1cbiAgZ2V0IGhhc1NlbGVjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0aW9uIHx8IHRoaXMuX3NlbGVjdGlvbk1vZGVsLnNlbGVjdGlvbnMubGVuZ3RoID4gMDtcbiAgfVxuICBfZ2V0Q29uZmlnKHQpIHtcbiAgICBjb25zdCBlID0gaC5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLmNiLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCB0aGlzLl9lbGVtZW50Lmhhc0F0dHJpYnV0ZShcIm11bHRpcGxlXCIpICYmICh0Lm11bHRpcGxlID0gITApLCB0aGlzLl9lbGVtZW50Lmhhc0F0dHJpYnV0ZShcImRpc2FibGVkXCIpICYmICh0LmRpc2FibGVkID0gITApLCB0aGlzLl9lbGVtZW50LnRhYkluZGV4ICYmICh0LnRhYkluZGV4ID0gdGhpcy5fZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ0YWJJbmRleFwiKSksIEQob28sIHQsIGhiKSwgdDtcbiAgfVxuICBfZ2V0Q2xhc3Nlcyh0KSB7XG4gICAgY29uc3QgZSA9IGguZ2V0RGF0YUNsYXNzQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLmRiLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBEKG9vLCB0LCB1YiksIHQ7XG4gIH1cbiAgX2FkZFBsYWNlaG9sZGVyT3B0aW9uKCkge1xuICAgIGNvbnN0IHQgPSBuZXcgT3B0aW9uKFwiXCIsIFwiXCIsICEwLCAhMCk7XG4gICAgdC5oaWRkZW4gPSAhMCwgdC5zZWxlY3RlZCA9ICEwLCB0aGlzLl9lbGVtZW50LnByZXBlbmQodCk7XG4gIH1cbiAgX2dldE9wdGlvbnNUb1JlbmRlcih0KSB7XG4gICAgY29uc3QgZSA9IFtdO1xuICAgIHJldHVybiB0LmNoaWxkTm9kZXMuZm9yRWFjaCgobikgPT4ge1xuICAgICAgaWYgKG4ubm9kZU5hbWUgPT09IFwiT1BUR1JPVVBcIikge1xuICAgICAgICBjb25zdCBvID0ge1xuICAgICAgICAgIGlkOiBydChcImdyb3VwLVwiKSxcbiAgICAgICAgICBsYWJlbDogbi5sYWJlbCxcbiAgICAgICAgICBkaXNhYmxlZDogbi5oYXNBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSxcbiAgICAgICAgICBoaWRkZW46IG4uaGFzQXR0cmlidXRlKFwiaGlkZGVuXCIpLFxuICAgICAgICAgIG9wdGlvbnM6IFtdXG4gICAgICAgIH07XG4gICAgICAgIG4uY2hpbGROb2Rlcy5mb3JFYWNoKChhKSA9PiB7XG4gICAgICAgICAgYS5ub2RlTmFtZSA9PT0gXCJPUFRJT05cIiAmJiBvLm9wdGlvbnMucHVzaChcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZU9wdGlvbk9iamVjdChhLCBvKVxuICAgICAgICAgICk7XG4gICAgICAgIH0pLCBlLnB1c2gobyk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgbi5ub2RlTmFtZSA9PT0gXCJPUFRJT05cIiAmJiBlLnB1c2godGhpcy5fY3JlYXRlT3B0aW9uT2JqZWN0KG4pKTtcbiAgICB9KSwgZTtcbiAgfVxuICBfZ2V0UGxhaW5PcHRpb25zKHQpIHtcbiAgICBpZiAoIWQuZmluZE9uZShcIm9wdGdyb3VwXCIsIHRoaXMuX2VsZW1lbnQpKVxuICAgICAgcmV0dXJuIHQ7XG4gICAgY29uc3QgaSA9IFtdO1xuICAgIHJldHVybiB0LmZvckVhY2goKG4pID0+IHtcbiAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChcbiAgICAgICAgbixcbiAgICAgICAgXCJvcHRpb25zXCJcbiAgICAgICkgPyBuLm9wdGlvbnMuZm9yRWFjaCgocikgPT4ge1xuICAgICAgICBpLnB1c2gocik7XG4gICAgICB9KSA6IGkucHVzaChuKTtcbiAgICB9KSwgaTtcbiAgfVxuICBfY3JlYXRlT3B0aW9uT2JqZWN0KHQsIGUgPSB7fSkge1xuICAgIGNvbnN0IGkgPSBydChcIm9wdGlvbi1cIiksIG4gPSBlLmlkID8gZS5pZCA6IG51bGwsIG8gPSBlLmRpc2FibGVkID8gZS5kaXNhYmxlZCA6ICExLCByID0gdC5zZWxlY3RlZCB8fCB0Lmhhc0F0dHJpYnV0ZShwaSksIGEgPSB0Lmhhc0F0dHJpYnV0ZShcImRpc2FibGVkXCIpIHx8IG8sIGwgPSB0Lmhhc0F0dHJpYnV0ZShcImhpZGRlblwiKSB8fCBlICYmIGUuaGlkZGVuLCBwID0gdGhpcy5tdWx0aXBsZSwgdSA9IHQudmFsdWUsIF8gPSB0LmxhYmVsLCBmID0gaC5nZXREYXRhQXR0cmlidXRlKFxuICAgICAgdCxcbiAgICAgIFwic2VsZWN0U2Vjb25kYXJ5VGV4dFwiXG4gICAgKSwgZyA9IGguZ2V0RGF0YUF0dHJpYnV0ZSh0LCBcInNlbGVjdC1pY29uXCIpO1xuICAgIHJldHVybiBuZXcgcmwoXG4gICAgICBpLFxuICAgICAgdCxcbiAgICAgIHAsXG4gICAgICB1LFxuICAgICAgXyxcbiAgICAgIHIsXG4gICAgICBhLFxuICAgICAgbCxcbiAgICAgIGYsXG4gICAgICBuLFxuICAgICAgZ1xuICAgICk7XG4gIH1cbiAgX2dldE5hdmlnYXRpb25PcHRpb25zKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLm9wdGlvbnMuZmlsdGVyKChlKSA9PiAhZS5oaWRkZW4pO1xuICAgIHJldHVybiB0aGlzLmhhc1NlbGVjdEFsbCA/IFt0aGlzLl9zZWxlY3RBbGxPcHRpb24sIC4uLnRdIDogdDtcbiAgfVxuICBfaW5pdCgpIHtcbiAgICB0aGlzLl9yZW5kZXJNYXRlcmlhbFdyYXBwZXIoKSwgdGhpcy5fd3JhcHBlciA9IGQuZmluZE9uZShgIyR7dGhpcy5fd3JhcHBlcklkfWApLCB0aGlzLl9pbnB1dCA9IGQuZmluZE9uZSh1bCwgdGhpcy5fd3JhcHBlciksIHRoaXMuX2NvbmZpZy5kaXNhYmxlZCAmJiB0aGlzLl9pbnB1dC5zZXRBdHRyaWJ1dGUocm8sIFwiXCIpO1xuICAgIGNvbnN0IHQgPSB0aGlzLl9jb25maWcuc2VsZWN0Q29udGFpbmVyO1xuICAgIHQgPT09IFwiYm9keVwiID8gdGhpcy5fY29udGFpbmVyID0gZG9jdW1lbnQuYm9keSA6IHRoaXMuX2NvbnRhaW5lciA9IGQuZmluZE9uZSh0KSwgdGhpcy5faW5pdE91dGxpbmVJbnB1dCgpLCB0aGlzLl9zZXREZWZhdWx0U2VsZWN0aW9ucygpLCB0aGlzLl91cGRhdGVJbnB1dFZhbHVlKCksIHRoaXMuX2FwcGVuZEZha2VWYWx1ZSgpLCB0aGlzLl91cGRhdGVGYWtlTGFiZWxQb3NpdGlvbigpLCB0aGlzLl91cGRhdGVMYWJlbFBvc2l0aW9uKCksIHRoaXMuX3VwZGF0ZUNsZWFyQnV0dG9uVmlzaWJpbGl0eSgpLCB0aGlzLl9iaW5kQ29tcG9uZW50RXZlbnRzKCksIHRoaXMuaGFzU2VsZWN0QWxsICYmICh0aGlzLl9zZWxlY3RBbGxPcHRpb24gPSB0aGlzLl9jcmVhdGVTZWxlY3RBbGxPcHRpb24oKSksIHRoaXMuX2Ryb3Bkb3duQ29udGFpbmVyID0gYWwoXG4gICAgICB0aGlzLl9kcm9wZG93bkNvbnRhaW5lcklkLFxuICAgICAgdGhpcy5fY29uZmlnLFxuICAgICAgdGhpcy5faW5wdXQub2Zmc2V0V2lkdGgsXG4gICAgICB0aGlzLl9kcm9wZG93bkhlaWdodCxcbiAgICAgIHRoaXMuX3NlbGVjdEFsbE9wdGlvbixcbiAgICAgIHRoaXMuX29wdGlvbnNUb1JlbmRlcixcbiAgICAgIHRoaXMuX2N1c3RvbUNvbnRlbnQsXG4gICAgICB0aGlzLl9jbGFzc2VzXG4gICAgKSwgdGhpcy5fc2V0Rmlyc3RBY3RpdmVPcHRpb24oKSwgdGhpcy5fbGlzdGVuVG9Gb2N1c0NoYW5nZSgpO1xuICB9XG4gIF9yZW5kZXJNYXRlcmlhbFdyYXBwZXIoKSB7XG4gICAgY29uc3QgdCA9IFBnKFxuICAgICAgdGhpcy5fd3JhcHBlcklkLFxuICAgICAgdGhpcy5fY29uZmlnLFxuICAgICAgdGhpcy5fbGFiZWwsXG4gICAgICB0aGlzLl9jbGFzc2VzLFxuICAgICAgdGhpcy5fZWxlbWVudC5uYW1lXG4gICAgKTtcbiAgICB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHQsIHRoaXMuX2VsZW1lbnQpLCBoLmFkZENsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NsYXNzZXMuaW5pdGlhbGl6ZWQpLCB0LmFwcGVuZENoaWxkKHRoaXMuX2VsZW1lbnQpO1xuICB9XG4gIF9pbml0T3V0bGluZUlucHV0KCkge1xuICAgIGNvbnN0IHQgPSBkLmZpbmRPbmUoXG4gICAgICBfbCxcbiAgICAgIHRoaXMuX3dyYXBwZXJcbiAgICApO1xuICAgIG5ldyBWKFxuICAgICAgdCxcbiAgICAgIHtcbiAgICAgICAgaW5wdXRGb3JtV2hpdGU6IHRoaXMuX2NvbmZpZy5zZWxlY3RGb3JtV2hpdGVcbiAgICAgIH0sXG4gICAgICB0aGlzLl9jbGFzc2VzXG4gICAgKS5pbml0KCksIHRoaXMuX25vdGNoID0gZC5maW5kT25lKGFvLCB0aGlzLl93cmFwcGVyKTtcbiAgfVxuICBfYmluZENvbXBvbmVudEV2ZW50cygpIHtcbiAgICB0aGlzLl9saXN0ZW5Ub0NvbXBvbmVudEtleWRvd24oKSwgdGhpcy5fbGlzdGVuVG9XcmFwcGVyQ2xpY2soKSwgdGhpcy5fbGlzdGVuVG9DbGVhckJ0bkNsaWNrKCksIHRoaXMuX2xpc3RlblRvQ2xlYXJCdG5LZXlkb3duKCk7XG4gIH1cbiAgX3NldERlZmF1bHRTZWxlY3Rpb25zKCkge1xuICAgIHRoaXMub3B0aW9ucy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICB0LnNlbGVjdGVkICYmIHRoaXMuX3NlbGVjdGlvbk1vZGVsLnNlbGVjdCh0KTtcbiAgICB9KTtcbiAgfVxuICBfbGlzdGVuVG9Db21wb25lbnRLZXlkb3duKCkge1xuICAgIGMub24odGhpcy5fd3JhcHBlciwgXCJrZXlkb3duXCIsIHRoaXMuX2hhbmRsZUtleWRvd24uYmluZCh0aGlzKSk7XG4gIH1cbiAgX2hhbmRsZUtleWRvd24odCkge1xuICAgIHRoaXMuX2lzT3BlbiAmJiAhdGhpcy5fY29uZmlnLnNlbGVjdEZpbHRlciA/IHRoaXMuX2hhbmRsZU9wZW5LZXlkb3duKHQpIDogdGhpcy5faGFuZGxlQ2xvc2VkS2V5ZG93bih0KTtcbiAgfVxuICBfaGFuZGxlT3BlbktleWRvd24odCkge1xuICAgIGNvbnN0IGUgPSB0LmtleUNvZGUsIGkgPSBlID09PSBGaSB8fCBlID09PSBhdCAmJiB0LmFsdEtleSB8fCBlID09PSBQaTtcbiAgICBpZiAoZSA9PT0gUGkgJiYgdGhpcy5fY29uZmlnLnNlbGVjdEF1dG9TZWxlY3QgJiYgIXRoaXMubXVsdGlwbGUgJiYgdGhpcy5faGFuZGxlQXV0b1NlbGVjdGlvbih0aGlzLl9hY3RpdmVPcHRpb24pLCBpKSB7XG4gICAgICB0aGlzLmNsb3NlKCksIHRoaXMuX2lucHV0LmZvY3VzKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN3aXRjaCAoZSkge1xuICAgICAgY2FzZSB6OlxuICAgICAgICB0aGlzLl9zZXROZXh0T3B0aW9uQWN0aXZlKCksIHRoaXMuX3Njcm9sbFRvT3B0aW9uKHRoaXMuX2FjdGl2ZU9wdGlvbik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBhdDpcbiAgICAgICAgdGhpcy5fc2V0UHJldmlvdXNPcHRpb25BY3RpdmUoKSwgdGhpcy5fc2Nyb2xsVG9PcHRpb24odGhpcy5fYWN0aXZlT3B0aW9uKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFdlOlxuICAgICAgICB0aGlzLl9zZXRGaXJzdE9wdGlvbkFjdGl2ZSgpLCB0aGlzLl9zY3JvbGxUb09wdGlvbih0aGlzLl9hY3RpdmVPcHRpb24pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRmU6XG4gICAgICAgIHRoaXMuX3NldExhc3RPcHRpb25BY3RpdmUoKSwgdGhpcy5fc2Nyb2xsVG9PcHRpb24odGhpcy5fYWN0aXZlT3B0aW9uKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGN0OlxuICAgICAgICB0LnByZXZlbnREZWZhdWx0KCksIHRoaXMuX2FjdGl2ZU9wdGlvbiAmJiAodGhpcy5oYXNTZWxlY3RBbGwgJiYgdGhpcy5fYWN0aXZlT3B0aW9uSW5kZXggPT09IDAgPyB0aGlzLl9oYW5kbGVTZWxlY3RBbGwoKSA6IHRoaXMuX2hhbmRsZVNlbGVjdGlvbih0aGlzLl9hY3RpdmVPcHRpb24pKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbiAgX2hhbmRsZUNsb3NlZEtleWRvd24odCkge1xuICAgIGNvbnN0IGUgPSB0LmtleUNvZGU7XG4gICAgaWYgKGUgPT09IGN0ICYmIHQucHJldmVudERlZmF1bHQoKSwgKGUgPT09IGN0IHx8IGUgPT09IHogJiYgdC5hbHRLZXkgfHwgZSA9PT0geiAmJiB0aGlzLm11bHRpcGxlKSAmJiB0aGlzLm9wZW4oKSwgdGhpcy5tdWx0aXBsZSlcbiAgICAgIHN3aXRjaCAoZSkge1xuICAgICAgICBjYXNlIHo6XG4gICAgICAgICAgdGhpcy5vcGVuKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgYXQ6XG4gICAgICAgICAgdGhpcy5vcGVuKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIGVsc2VcbiAgICAgIHN3aXRjaCAoZSkge1xuICAgICAgICBjYXNlIHo6XG4gICAgICAgICAgdGhpcy5fc2V0TmV4dE9wdGlvbkFjdGl2ZSgpLCB0aGlzLl9oYW5kbGVTZWxlY3Rpb24odGhpcy5fYWN0aXZlT3B0aW9uKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBhdDpcbiAgICAgICAgICB0aGlzLl9zZXRQcmV2aW91c09wdGlvbkFjdGl2ZSgpLCB0aGlzLl9oYW5kbGVTZWxlY3Rpb24odGhpcy5fYWN0aXZlT3B0aW9uKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBXZTpcbiAgICAgICAgICB0aGlzLl9zZXRGaXJzdE9wdGlvbkFjdGl2ZSgpLCB0aGlzLl9oYW5kbGVTZWxlY3Rpb24odGhpcy5fYWN0aXZlT3B0aW9uKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBGZTpcbiAgICAgICAgICB0aGlzLl9zZXRMYXN0T3B0aW9uQWN0aXZlKCksIHRoaXMuX2hhbmRsZVNlbGVjdGlvbih0aGlzLl9hY3RpdmVPcHRpb24pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB0LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbiAgX3Njcm9sbFRvT3B0aW9uKHQpIHtcbiAgICBpZiAoIXQpXG4gICAgICByZXR1cm47XG4gICAgbGV0IGU7XG4gICAgY29uc3QgaSA9IHRoaXMub3B0aW9ucy5maWx0ZXIoKHUpID0+ICF1LmhpZGRlbik7XG4gICAgdGhpcy5oYXNTZWxlY3RBbGwgPyBlID0gaS5pbmRleE9mKHQpICsgMSA6IGUgPSBpLmluZGV4T2YodCk7XG4gICAgY29uc3QgbiA9IHRoaXMuX2dldE51bWJlck9mR3JvdXBzQmVmb3JlT3B0aW9uKGUpLCBvID0gZSArIG4sIHIgPSB0aGlzLm9wdGlvbnNXcmFwcGVyLCBhID0gci5vZmZzZXRIZWlnaHQsIGwgPSB0aGlzLl9jb25maWcuc2VsZWN0T3B0aW9uSGVpZ2h0LCBwID0gci5zY3JvbGxUb3A7XG4gICAgaWYgKGUgPiAtMSkge1xuICAgICAgY29uc3QgdSA9IG8gKiBsLCBfID0gdSArIGwgPiBwICsgYTtcbiAgICAgIHUgPCBwID8gci5zY3JvbGxUb3AgPSB1IDogXyA/IHIuc2Nyb2xsVG9wID0gdSAtIGEgKyBsIDogci5zY3JvbGxUb3AgPSBwO1xuICAgIH1cbiAgfVxuICBfZ2V0TnVtYmVyT2ZHcm91cHNCZWZvcmVPcHRpb24odCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLm9wdGlvbnMuZmlsdGVyKChyKSA9PiAhci5oaWRkZW4pLCBpID0gdGhpcy5fb3B0aW9uc1RvUmVuZGVyLmZpbHRlcigocikgPT4gIXIuaGlkZGVuKSwgbiA9IHRoaXMuaGFzU2VsZWN0QWxsID8gdCAtIDEgOiB0O1xuICAgIGxldCBvID0gMDtcbiAgICBmb3IgKGxldCByID0gMDsgciA8PSBuOyByKyspXG4gICAgICBlW3JdLmdyb3VwSWQgJiYgaVtvXSAmJiBpW29dLmlkICYmIGVbcl0uZ3JvdXBJZCA9PT0gaVtvXS5pZCAmJiBvKys7XG4gICAgcmV0dXJuIG87XG4gIH1cbiAgX3NldE5leHRPcHRpb25BY3RpdmUoKSB7XG4gICAgbGV0IHQgPSB0aGlzLl9hY3RpdmVPcHRpb25JbmRleCArIDE7XG4gICAgY29uc3QgZSA9IHRoaXMuX2dldE5hdmlnYXRpb25PcHRpb25zKCk7XG4gICAgaWYgKGVbdF0pIHtcbiAgICAgIGZvciAoOyBlW3RdLmRpc2FibGVkOyApXG4gICAgICAgIGlmICh0ICs9IDEsICFlW3RdKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgIHRoaXMuX3VwZGF0ZUFjdGl2ZU9wdGlvbihlW3RdLCB0KTtcbiAgICB9XG4gIH1cbiAgX3NldFByZXZpb3VzT3B0aW9uQWN0aXZlKCkge1xuICAgIGxldCB0ID0gdGhpcy5fYWN0aXZlT3B0aW9uSW5kZXggLSAxO1xuICAgIGNvbnN0IGUgPSB0aGlzLl9nZXROYXZpZ2F0aW9uT3B0aW9ucygpO1xuICAgIGlmIChlW3RdKSB7XG4gICAgICBmb3IgKDsgZVt0XS5kaXNhYmxlZDsgKVxuICAgICAgICBpZiAodCAtPSAxLCAhZVt0XSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICB0aGlzLl91cGRhdGVBY3RpdmVPcHRpb24oZVt0XSwgdCk7XG4gICAgfVxuICB9XG4gIF9zZXRGaXJzdE9wdGlvbkFjdGl2ZSgpIHtcbiAgICBjb25zdCBlID0gdGhpcy5fZ2V0TmF2aWdhdGlvbk9wdGlvbnMoKTtcbiAgICB0aGlzLl91cGRhdGVBY3RpdmVPcHRpb24oZVswXSwgMCk7XG4gIH1cbiAgX3NldExhc3RPcHRpb25BY3RpdmUoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2dldE5hdmlnYXRpb25PcHRpb25zKCksIGUgPSB0Lmxlbmd0aCAtIDE7XG4gICAgdGhpcy5fdXBkYXRlQWN0aXZlT3B0aW9uKHRbZV0sIGUpO1xuICB9XG4gIF91cGRhdGVBY3RpdmVPcHRpb24odCwgZSkge1xuICAgIGNvbnN0IGkgPSB0aGlzLl9hY3RpdmVPcHRpb247XG4gICAgaSAmJiBpLnJlbW92ZUFjdGl2ZVN0eWxlcygpLCB0LnNldEFjdGl2ZVN0eWxlcygpLCB0aGlzLl9hY3RpdmVPcHRpb25JbmRleCA9IGUsIHRoaXMuX2FjdGl2ZU9wdGlvbiA9IHQ7XG4gIH1cbiAgX2xpc3RlblRvV3JhcHBlckNsaWNrKCkge1xuICAgIGMub24odGhpcy5fd3JhcHBlciwgXCJjbGlja1wiLCAoKSA9PiB7XG4gICAgICB0aGlzLnRvZ2dsZSgpO1xuICAgIH0pO1xuICB9XG4gIF9saXN0ZW5Ub0NsZWFyQnRuQ2xpY2soKSB7XG4gICAgYy5vbih0aGlzLmNsZWFyQnV0dG9uLCBcImNsaWNrXCIsICh0KSA9PiB7XG4gICAgICB0LnByZXZlbnREZWZhdWx0KCksIHQuc3RvcFByb3BhZ2F0aW9uKCksIHRoaXMuX2hhbmRsZUNsZWFyKCk7XG4gICAgfSk7XG4gIH1cbiAgX2xpc3RlblRvQ2xlYXJCdG5LZXlkb3duKCkge1xuICAgIGMub24odGhpcy5jbGVhckJ1dHRvbiwgXCJrZXlkb3duXCIsICh0KSA9PiB7XG4gICAgICB0LmtleUNvZGUgPT09IGN0ICYmICh0aGlzLl9oYW5kbGVDbGVhcigpLCB0LnByZXZlbnREZWZhdWx0KCksIHQuc3RvcFByb3BhZ2F0aW9uKCkpO1xuICAgIH0pO1xuICB9XG4gIF9oYW5kbGVDbGVhcigpIHtcbiAgICBpZiAodGhpcy5tdWx0aXBsZSlcbiAgICAgIHRoaXMuX3NlbGVjdGlvbk1vZGVsLmNsZWFyKCksIHRoaXMuX2Rlc2VsZWN0QWxsT3B0aW9ucyh0aGlzLm9wdGlvbnMpLCB0aGlzLmhhc1NlbGVjdEFsbCAmJiB0aGlzLl91cGRhdGVTZWxlY3RBbGxTdGF0ZSgpO1xuICAgIGVsc2Uge1xuICAgICAgY29uc3QgdCA9IHRoaXMuX3NlbGVjdGlvbk1vZGVsLnNlbGVjdGlvbjtcbiAgICAgIHRoaXMuX3NlbGVjdGlvbk1vZGVsLmNsZWFyKCksIHQuZGVzZWxlY3QoKTtcbiAgICB9XG4gICAgdGhpcy5fZmFrZVZhbHVlLmlubmVySFRNTCA9IFwiXCIsIHRoaXMuX3VwZGF0ZUlucHV0VmFsdWUoKSwgdGhpcy5fdXBkYXRlRmFrZUxhYmVsUG9zaXRpb24oKSwgdGhpcy5fdXBkYXRlTGFiZWxQb3NpdGlvbigpLCB0aGlzLl91cGRhdGVDbGVhckJ1dHRvblZpc2liaWxpdHkoKSwgdGhpcy5fZW1pdFZhbHVlQ2hhbmdlRXZlbnQobnVsbCksIHRoaXMuX2VtaXROYXRpdmVDaGFuZ2VFdmVudCgpO1xuICB9XG4gIF9saXN0ZW5Ub09wdGlvbnNDbGljaygpIHtcbiAgICBjLm9uKHRoaXMub3B0aW9uc1dyYXBwZXIsIFwiY2xpY2tcIiwgKHQpID0+IHtcbiAgICAgIGlmICh0LnRhcmdldC5oYXNBdHRyaWJ1dGUoXG4gICAgICAgIFpnXG4gICAgICApKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBpID0gdC50YXJnZXQubm9kZU5hbWUgPT09IFwiRElWXCIgPyB0LnRhcmdldCA6IGQuY2xvc2VzdCh0LnRhcmdldCwgc2IpO1xuICAgICAgaWYgKGkuaGFzQXR0cmlidXRlKFFnKSkge1xuICAgICAgICB0aGlzLl9oYW5kbGVTZWxlY3RBbGwoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbyA9IGkuZGF0YXNldC50ZUlkLCByID0gdGhpcy5vcHRpb25zLmZpbmQoKGEpID0+IGEuaWQgPT09IG8pO1xuICAgICAgciAmJiAhci5kaXNhYmxlZCAmJiB0aGlzLl9oYW5kbGVTZWxlY3Rpb24ocik7XG4gICAgfSk7XG4gIH1cbiAgX2hhbmRsZVNlbGVjdEFsbCgpIHtcbiAgICB0aGlzLl9zZWxlY3RBbGxPcHRpb24uc2VsZWN0ZWQgPyAodGhpcy5fZGVzZWxlY3RBbGxPcHRpb25zKHRoaXMub3B0aW9ucyksIHRoaXMuX3NlbGVjdEFsbE9wdGlvbi5kZXNlbGVjdCgpKSA6ICh0aGlzLl9zZWxlY3RBbGxPcHRpb25zKHRoaXMub3B0aW9ucyksIHRoaXMuX3NlbGVjdEFsbE9wdGlvbi5zZWxlY3QoKSksIHRoaXMuX3VwZGF0ZUlucHV0VmFsdWUoKSwgdGhpcy5fdXBkYXRlRmFrZUxhYmVsUG9zaXRpb24oKSwgdGhpcy5fdXBkYXRlTGFiZWxQb3NpdGlvbigpLCB0aGlzLl91cGRhdGVDbGVhckJ1dHRvblZpc2liaWxpdHkoKSwgdGhpcy5fZW1pdFZhbHVlQ2hhbmdlRXZlbnQodGhpcy52YWx1ZSksIHRoaXMuX2VtaXROYXRpdmVDaGFuZ2VFdmVudCgpO1xuICB9XG4gIF9zZWxlY3RBbGxPcHRpb25zKHQpIHtcbiAgICB0LmZvckVhY2goKGUpID0+IHtcbiAgICAgICFlLnNlbGVjdGVkICYmICFlLmRpc2FibGVkICYmICh0aGlzLl9zZWxlY3Rpb25Nb2RlbC5zZWxlY3QoZSksIGUuc2VsZWN0KCkpO1xuICAgIH0pO1xuICB9XG4gIF9kZXNlbGVjdEFsbE9wdGlvbnModCkge1xuICAgIHQuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgZS5zZWxlY3RlZCAmJiAhZS5kaXNhYmxlZCAmJiAodGhpcy5fc2VsZWN0aW9uTW9kZWwuZGVzZWxlY3QoZSksIGUuZGVzZWxlY3QoKSk7XG4gICAgfSk7XG4gIH1cbiAgX2hhbmRsZVNlbGVjdGlvbih0KSB7XG4gICAgdGhpcy5tdWx0aXBsZSA/ICh0aGlzLl9oYW5kbGVNdWx0aVNlbGVjdGlvbih0KSwgdGhpcy5oYXNTZWxlY3RBbGwgJiYgdGhpcy5fdXBkYXRlU2VsZWN0QWxsU3RhdGUoKSkgOiB0aGlzLl9oYW5kbGVTaW5nbGVTZWxlY3Rpb24odCksIHRoaXMuX3VwZGF0ZUlucHV0VmFsdWUoKSwgdGhpcy5fdXBkYXRlRmFrZUxhYmVsUG9zaXRpb24oKSwgdGhpcy5fdXBkYXRlTGFiZWxQb3NpdGlvbigpLCB0aGlzLl91cGRhdGVDbGVhckJ1dHRvblZpc2liaWxpdHkoKTtcbiAgfVxuICBfaGFuZGxlQXV0b1NlbGVjdGlvbih0KSB7XG4gICAgdGhpcy5fc2luZ2xlT3B0aW9uU2VsZWN0KHQpLCB0aGlzLl91cGRhdGVJbnB1dFZhbHVlKCksIHRoaXMuX3VwZGF0ZUZha2VMYWJlbFBvc2l0aW9uKCksIHRoaXMuX3VwZGF0ZUxhYmVsUG9zaXRpb24oKSwgdGhpcy5fdXBkYXRlQ2xlYXJCdXR0b25WaXNpYmlsaXR5KCk7XG4gIH1cbiAgX2hhbmRsZVNpbmdsZVNlbGVjdGlvbih0KSB7XG4gICAgdGhpcy5fc2luZ2xlT3B0aW9uU2VsZWN0KHQpLCB0aGlzLmNsb3NlKCksIHRoaXMuX2lucHV0LmZvY3VzKCk7XG4gIH1cbiAgX3NpbmdsZU9wdGlvblNlbGVjdCh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuX3NlbGVjdGlvbk1vZGVsLnNlbGVjdGlvbnNbMF07XG4gICAgZSAmJiBlICE9PSB0ICYmICh0aGlzLl9zZWxlY3Rpb25Nb2RlbC5kZXNlbGVjdChlKSwgZS5kZXNlbGVjdCgpLCBlLm5vZGUuc2V0QXR0cmlidXRlKHBpLCAhMSksIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBjbCwge1xuICAgICAgdmFsdWU6IGUudmFsdWVcbiAgICB9KSksICghZSB8fCBlICYmIHQgIT09IGUpICYmICh0aGlzLl9zZWxlY3Rpb25Nb2RlbC5zZWxlY3QodCksIHQuc2VsZWN0KCksIHQubm9kZS5zZXRBdHRyaWJ1dGUocGksICEwKSwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGxsLCB7XG4gICAgICB2YWx1ZTogdC52YWx1ZVxuICAgIH0pLCB0aGlzLl9lbWl0VmFsdWVDaGFuZ2VFdmVudCh0aGlzLnZhbHVlKSwgdGhpcy5fZW1pdE5hdGl2ZUNoYW5nZUV2ZW50KCkpO1xuICB9XG4gIF9oYW5kbGVNdWx0aVNlbGVjdGlvbih0KSB7XG4gICAgdC5zZWxlY3RlZCA/ICh0aGlzLl9zZWxlY3Rpb25Nb2RlbC5kZXNlbGVjdCh0KSwgdC5kZXNlbGVjdCgpLCB0Lm5vZGUuc2V0QXR0cmlidXRlKHBpLCAhMSksIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBjbCwge1xuICAgICAgdmFsdWU6IHQudmFsdWVcbiAgICB9KSkgOiAodGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0KHQpLCB0LnNlbGVjdCgpLCB0Lm5vZGUuc2V0QXR0cmlidXRlKHBpLCAhMCksIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBsbCwge1xuICAgICAgdmFsdWU6IHQudmFsdWVcbiAgICB9KSksIHRoaXMuX2VtaXRWYWx1ZUNoYW5nZUV2ZW50KHRoaXMudmFsdWUpLCB0aGlzLl9lbWl0TmF0aXZlQ2hhbmdlRXZlbnQoKTtcbiAgfVxuICBfZW1pdFZhbHVlQ2hhbmdlRXZlbnQodCkge1xuICAgIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBHZywgeyB2YWx1ZTogdCB9KTtcbiAgfVxuICBfZW1pdE5hdGl2ZUNoYW5nZUV2ZW50KCkge1xuICAgIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBxZyk7XG4gIH1cbiAgX3VwZGF0ZUlucHV0VmFsdWUoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMubXVsdGlwbGUgPyB0aGlzLl9zZWxlY3Rpb25Nb2RlbC5sYWJlbHMgOiB0aGlzLl9zZWxlY3Rpb25Nb2RlbC5sYWJlbDtcbiAgICBsZXQgZTtcbiAgICB0aGlzLm11bHRpcGxlICYmIHRoaXMuX2NvbmZpZy5zZWxlY3REaXNwbGF5ZWRMYWJlbHMgIT09IC0xICYmIHRoaXMuX3NlbGVjdGlvbk1vZGVsLnNlbGVjdGlvbnMubGVuZ3RoID4gdGhpcy5fY29uZmlnLnNlbGVjdERpc3BsYXllZExhYmVscyA/IGUgPSBgJHt0aGlzLl9zZWxlY3Rpb25Nb2RlbC5zZWxlY3Rpb25zLmxlbmd0aH0gJHt0aGlzLl9jb25maWcuc2VsZWN0T3B0aW9uc1NlbGVjdGVkTGFiZWx9YCA6IGUgPSB0LCAhdGhpcy5tdWx0aXBsZSAmJiAhdGhpcy5faXNTZWxlY3Rpb25WYWxpZCh0aGlzLl9zZWxlY3Rpb25Nb2RlbC5zZWxlY3Rpb24pID8gdGhpcy5faW5wdXQudmFsdWUgPSBcIlwiIDogdGhpcy5faXNMYWJlbEVtcHR5KHRoaXMuX3NlbGVjdGlvbk1vZGVsLnNlbGVjdGlvbikgPyB0aGlzLl9pbnB1dC52YWx1ZSA9IFwiIFwiIDogZSA/IHRoaXMuX2lucHV0LnZhbHVlID0gZSA6IHRoaXMubXVsdGlwbGUgfHwgIXRoaXMuX29wdGlvbnNUb1JlbmRlclswXSA/IHRoaXMuX2lucHV0LnZhbHVlID0gXCJcIiA6IHRoaXMuX2lucHV0LnZhbHVlID0gdGhpcy5fb3B0aW9uc1RvUmVuZGVyWzBdLmxhYmVsO1xuICB9XG4gIF9pc1NlbGVjdGlvblZhbGlkKHQpIHtcbiAgICByZXR1cm4gISh0ICYmICh0LmRpc2FibGVkIHx8IHQudmFsdWUgPT09IFwiXCIpKTtcbiAgfVxuICBfaXNMYWJlbEVtcHR5KHQpIHtcbiAgICByZXR1cm4gISEodCAmJiB0LmxhYmVsID09PSBcIlwiKTtcbiAgfVxuICBfYXBwZW5kRmFrZVZhbHVlKCkge1xuICAgIGlmICghdGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0aW9uIHx8IHRoaXMuX3NlbGVjdGlvbk1vZGVsLl9tdWx0aXBsZSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB0ID0gdGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0aW9uLmxhYmVsO1xuICAgIHRoaXMuX2Zha2VWYWx1ZSA9IHpnKHQsIHRoaXMuX2NsYXNzZXMpLCBkLmZpbmRPbmUoXG4gICAgICBfbCxcbiAgICAgIHRoaXMuX3dyYXBwZXJcbiAgICApLmFwcGVuZENoaWxkKHRoaXMuX2Zha2VWYWx1ZSk7XG4gIH1cbiAgX3VwZGF0ZUxhYmVsUG9zaXRpb24oKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2VsZW1lbnQuaGFzQXR0cmlidXRlKGhsKSwgZSA9IHRoaXMuX2lucHV0LnZhbHVlICE9PSBcIlwiO1xuICAgIHRoaXMuX2xhYmVsICYmICh0ICYmIChlIHx8IHRoaXMuX2lzT3BlbiB8fCB0aGlzLl9pc0Zha2VWYWx1ZUFjdGl2ZSkgPyAodGhpcy5fbGFiZWwuc2V0QXR0cmlidXRlKHEsIFwiXCIpLCB0aGlzLl9ub3RjaC5zZXRBdHRyaWJ1dGUocSwgXCJcIikpIDogKHRoaXMuX2xhYmVsLnJlbW92ZUF0dHJpYnV0ZShxKSwgdGhpcy5fbm90Y2gucmVtb3ZlQXR0cmlidXRlKHEsIFwiXCIpKSk7XG4gIH1cbiAgX3VwZGF0ZUxhYmVsUG9zaXRpb25XaGlsZUNsb3NpbmcoKSB7XG4gICAgdGhpcy5fbGFiZWwgJiYgKHRoaXMuX2lucHV0LnZhbHVlICE9PSBcIlwiIHx8IHRoaXMuX2lzRmFrZVZhbHVlQWN0aXZlID8gKHRoaXMuX2xhYmVsLnNldEF0dHJpYnV0ZShxLCBcIlwiKSwgdGhpcy5fbm90Y2guc2V0QXR0cmlidXRlKHEsIFwiXCIpKSA6ICh0aGlzLl9sYWJlbC5yZW1vdmVBdHRyaWJ1dGUocSksIHRoaXMuX25vdGNoLnJlbW92ZUF0dHJpYnV0ZShxKSkpO1xuICB9XG4gIF91cGRhdGVGYWtlTGFiZWxQb3NpdGlvbigpIHtcbiAgICB0aGlzLl9mYWtlVmFsdWUgJiYgKHRoaXMuX2lucHV0LnZhbHVlID09PSBcIlwiICYmIHRoaXMuX2Zha2VWYWx1ZS5pbm5lckhUTUwgIT09IFwiXCIgJiYgIXRoaXMuX2NvbmZpZy5zZWxlY3RQbGFjZWhvbGRlciA/ICh0aGlzLl9pc0Zha2VWYWx1ZUFjdGl2ZSA9ICEwLCB0aGlzLl9mYWtlVmFsdWUuc2V0QXR0cmlidXRlKHEsIFwiXCIpKSA6ICh0aGlzLl9pc0Zha2VWYWx1ZUFjdGl2ZSA9ICExLCB0aGlzLl9mYWtlVmFsdWUucmVtb3ZlQXR0cmlidXRlKHEpKSk7XG4gIH1cbiAgX3VwZGF0ZUNsZWFyQnV0dG9uVmlzaWJpbGl0eSgpIHtcbiAgICBpZiAoIXRoaXMuY2xlYXJCdXR0b24pXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0aW9uIHx8IHRoaXMuX3NlbGVjdGlvbk1vZGVsLnNlbGVjdGlvbnMubGVuZ3RoID4gMCA/IGguYWRkU3R5bGUodGhpcy5jbGVhckJ1dHRvbiwgeyBkaXNwbGF5OiBcImJsb2NrXCIgfSkgOiBoLmFkZFN0eWxlKHRoaXMuY2xlYXJCdXR0b24sIHsgZGlzcGxheTogXCJub25lXCIgfSk7XG4gIH1cbiAgX3VwZGF0ZVNlbGVjdEFsbFN0YXRlKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9zZWxlY3RBbGxPcHRpb24uc2VsZWN0ZWQsIGUgPSBWbyh0aGlzLm9wdGlvbnMpO1xuICAgICFlICYmIHQgPyB0aGlzLl9zZWxlY3RBbGxPcHRpb24uZGVzZWxlY3QoKSA6IGUgJiYgIXQgJiYgdGhpcy5fc2VsZWN0QWxsT3B0aW9uLnNlbGVjdCgpO1xuICB9XG4gIHRvZ2dsZSgpIHtcbiAgICB0aGlzLl9pc09wZW4gPyB0aGlzLmNsb3NlKCkgOiB0aGlzLm9wZW4oKTtcbiAgfVxuICBvcGVuKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9jb25maWcuZGlzYWJsZWQsIGUgPSBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgWGcpO1xuICAgIHRoaXMuX2lzT3BlbiB8fCB0IHx8IGUuZGVmYXVsdFByZXZlbnRlZCB8fCAodGhpcy5fb3BlbkRyb3Bkb3duKCksIHRoaXMuX3VwZGF0ZURyb3Bkb3duV2lkdGgoKSwgdGhpcy5fc2V0Rmlyc3RBY3RpdmVPcHRpb24oKSwgdGhpcy5fc2Nyb2xsVG9PcHRpb24odGhpcy5fYWN0aXZlT3B0aW9uKSwgdGhpcy5fY29uZmlnLnNlbGVjdEZpbHRlciAmJiAoc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmZpbHRlcklucHV0LmZvY3VzKCk7XG4gICAgfSwgMCksIHRoaXMuX2xpc3RlblRvU2VsZWN0U2VhcmNoKCksIHRoaXMuX2xpc3RlblRvRHJvcGRvd25LZXlkb3duKCkpLCB0aGlzLl9saXN0ZW5Ub09wdGlvbnNDbGljaygpLCB0aGlzLl9saXN0ZW5Ub091dHNpZGVDbGljaygpLCB0aGlzLl9saXN0ZW5Ub1dpbmRvd1Jlc2l6ZSgpLCB0aGlzLl9pc09wZW4gPSAhMCwgdGhpcy5fdXBkYXRlTGFiZWxQb3NpdGlvbigpLCB0aGlzLl9zZXRJbnB1dEFjdGl2ZVN0eWxlcygpKTtcbiAgfVxuICBfb3BlbkRyb3Bkb3duKCkge1xuICAgIHRoaXMuX3BvcHBlciA9IENlKHRoaXMuX2lucHV0LCB0aGlzLl9kcm9wZG93bkNvbnRhaW5lciwge1xuICAgICAgcGxhY2VtZW50OiBcImJvdHRvbS1zdGFydFwiLFxuICAgICAgbW9kaWZpZXJzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcIm9mZnNldFwiLFxuICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIG9mZnNldDogWzAsIDFdXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSksIHRoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9kcm9wZG93bkNvbnRhaW5lciksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5kcm9wZG93bi5zZXRBdHRyaWJ1dGUoZGwsIFwiXCIpO1xuICAgIH0sIDApO1xuICB9XG4gIF91cGRhdGVEcm9wZG93bldpZHRoKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9pbnB1dC5vZmZzZXRXaWR0aDtcbiAgICBoLmFkZFN0eWxlKHRoaXMuX2Ryb3Bkb3duQ29udGFpbmVyLCB7IHdpZHRoOiBgJHt0fXB4YCB9KTtcbiAgfVxuICBfc2V0Rmlyc3RBY3RpdmVPcHRpb24oKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2dldE5hdmlnYXRpb25PcHRpb25zKCksIGUgPSB0aGlzLl9hY3RpdmVPcHRpb247XG4gICAgZSAmJiBlLnJlbW92ZUFjdGl2ZVN0eWxlcygpO1xuICAgIGNvbnN0IGkgPSB0aGlzLm11bHRpcGxlID8gdGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0aW9uc1swXSA6IHRoaXMuX3NlbGVjdGlvbk1vZGVsLnNlbGVjdGlvbjtcbiAgICBpID8gKHRoaXMuX2FjdGl2ZU9wdGlvbiA9IGksIGkuc2V0QWN0aXZlU3R5bGVzKCksIHRoaXMuX2FjdGl2ZU9wdGlvbkluZGV4ID0gdC5maW5kSW5kZXgoXG4gICAgICAobikgPT4gbiA9PT0gaVxuICAgICkpIDogKHRoaXMuX2FjdGl2ZU9wdGlvbiA9IG51bGwsIHRoaXMuX2FjdGl2ZU9wdGlvbkluZGV4ID0gLTEpO1xuICB9XG4gIF9zZXRJbnB1dEFjdGl2ZVN0eWxlcygpIHtcbiAgICB0aGlzLl9pbnB1dC5zZXRBdHRyaWJ1dGUoS3QsIFwiXCIpLCBkLmZpbmRPbmUoYW8sIHRoaXMuX3dyYXBwZXIpLnNldEF0dHJpYnV0ZShcbiAgICAgIEt0LFxuICAgICAgXCJcIlxuICAgICk7XG4gIH1cbiAgX2xpc3RlblRvV2luZG93UmVzaXplKCkge1xuICAgIGMub24od2luZG93LCBcInJlc2l6ZVwiLCB0aGlzLl9oYW5kbGVXaW5kb3dSZXNpemUuYmluZCh0aGlzKSk7XG4gIH1cbiAgX2hhbmRsZVdpbmRvd1Jlc2l6ZSgpIHtcbiAgICB0aGlzLl9kcm9wZG93bkNvbnRhaW5lciAmJiB0aGlzLl91cGRhdGVEcm9wZG93bldpZHRoKCk7XG4gIH1cbiAgX2xpc3RlblRvU2VsZWN0U2VhcmNoKCkge1xuICAgIHRoaXMuZmlsdGVySW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsICh0KSA9PiB7XG4gICAgICBjb25zdCBlID0gdC50YXJnZXQudmFsdWUsIGkgPSB0aGlzLl9jb25maWcuc2VsZWN0RmlsdGVyRGVib3VuY2U7XG4gICAgICB0aGlzLl9kZWJvdW5jZUZpbHRlcihlLCBpKTtcbiAgICB9KTtcbiAgfVxuICBfZGVib3VuY2VGaWx0ZXIodCwgZSkge1xuICAgIHRoaXMuX2RlYm91bmNlVGltZW91dElkICYmIGNsZWFyVGltZW91dCh0aGlzLl9kZWJvdW5jZVRpbWVvdXRJZCksIHRoaXMuX2RlYm91bmNlVGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLl9maWx0ZXJPcHRpb25zKHQpO1xuICAgIH0sIGUpO1xuICB9XG4gIF9maWx0ZXJPcHRpb25zKHQpIHtcbiAgICBjb25zdCBlID0gW107XG4gICAgdGhpcy5fb3B0aW9uc1RvUmVuZGVyLmZvckVhY2goKG8pID0+IHtcbiAgICAgIGNvbnN0IHIgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoXG4gICAgICAgIG8sXG4gICAgICAgIFwib3B0aW9uc1wiXG4gICAgICApLCBhID0gIXIgJiYgby5sYWJlbC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHQudG9Mb3dlckNhc2UoKSksIGwgPSB7fTtcbiAgICAgIHIgJiYgKGwubGFiZWwgPSBvLmxhYmVsLCBsLm9wdGlvbnMgPSB0aGlzLl9maWx0ZXIodCwgby5vcHRpb25zKSwgbC5vcHRpb25zLmxlbmd0aCA+IDAgJiYgZS5wdXNoKGwpKSwgYSAmJiBlLnB1c2gobyk7XG4gICAgfSk7XG4gICAgY29uc3QgaSA9IHRoaXMuX2NvbmZpZy5zZWxlY3ROb1Jlc3VsdFRleHQgIT09IFwiXCIsIG4gPSBlLmxlbmd0aCAhPT0gMDtcbiAgICBpZiAobilcbiAgICAgIHRoaXMuX3VwZGF0ZU9wdGlvbnNMaXN0VGVtcGxhdGUoZSksIHRoaXMuX3BvcHBlci5mb3JjZVVwZGF0ZSgpLCB0aGlzLl9maWx0ZXJlZE9wdGlvbnNMaXN0ID0gdGhpcy5fZ2V0UGxhaW5PcHRpb25zKGUpLCB0aGlzLmhhc1NlbGVjdEFsbCAmJiB0aGlzLl91cGRhdGVTZWxlY3RBbGxTdGF0ZSgpLCB0aGlzLl9zZXRGaXJzdEFjdGl2ZU9wdGlvbigpO1xuICAgIGVsc2UgaWYgKCFuICYmIGkpIHtcbiAgICAgIGNvbnN0IG8gPSB0aGlzLl9nZXROb1Jlc3VsdFRlbXBsYXRlKCk7XG4gICAgICB0aGlzLm9wdGlvbnNXcmFwcGVyLmlubmVySFRNTCA9IG87XG4gICAgfVxuICB9XG4gIF91cGRhdGVPcHRpb25zTGlzdFRlbXBsYXRlKHQpIHtcbiAgICBjb25zdCBlID0gZC5maW5kT25lKHBsLCB0aGlzLl9kcm9wZG93bkNvbnRhaW5lcikgfHwgZC5maW5kT25lKHJiLCB0aGlzLl9kcm9wZG93bkNvbnRhaW5lciksIGkgPSBlaChcbiAgICAgIHQsXG4gICAgICB0aGlzLl9zZWxlY3RBbGxPcHRpb24sXG4gICAgICB0aGlzLl9jb25maWcsXG4gICAgICB0aGlzLl9jbGFzc2VzXG4gICAgKTtcbiAgICB0aGlzLm9wdGlvbnNXcmFwcGVyLnJlbW92ZUNoaWxkKGUpLCB0aGlzLm9wdGlvbnNXcmFwcGVyLmFwcGVuZENoaWxkKGkpO1xuICB9XG4gIF9nZXROb1Jlc3VsdFRlbXBsYXRlKCkge1xuICAgIHJldHVybiBgPGRpdiBjbGFzcz1cIiR7dGhpcy5fY2xhc3Nlcy5ub1Jlc3VsdH1cIiAke29ofSBzdHlsZT1cImhlaWdodDogJHt0aGlzLl9jb25maWcuc2VsZWN0T3B0aW9uSGVpZ2h0fXB4XCI+JHt0aGlzLl9jb25maWcuc2VsZWN0Tm9SZXN1bHRUZXh0fTwvZGl2PmA7XG4gIH1cbiAgX2ZpbHRlcih0LCBlKSB7XG4gICAgY29uc3QgaSA9IHQudG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gZS5maWx0ZXIoXG4gICAgICAobikgPT4gbi5sYWJlbC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKGkpXG4gICAgKTtcbiAgfVxuICBfbGlzdGVuVG9Ecm9wZG93bktleWRvd24oKSB7XG4gICAgYy5vbihcbiAgICAgIHRoaXMuZHJvcGRvd24sXG4gICAgICBcImtleWRvd25cIixcbiAgICAgIHRoaXMuX2hhbmRsZU9wZW5LZXlkb3duLmJpbmQodGhpcylcbiAgICApO1xuICB9XG4gIF9saXN0ZW5Ub091dHNpZGVDbGljaygpIHtcbiAgICB0aGlzLl9vdXRzaWRlQ2xpY2sgPSB0aGlzLl9oYW5kbGVPdXRTaWRlQ2xpY2suYmluZCh0aGlzKSwgYy5vbihkb2N1bWVudCwgXCJjbGlja1wiLCB0aGlzLl9vdXRzaWRlQ2xpY2spO1xuICB9XG4gIF9saXN0ZW5Ub0ZvY3VzQ2hhbmdlKHQgPSAhMCkge1xuICAgIGlmICh0ID09PSAhMSkge1xuICAgICAgYy5vZmYoXG4gICAgICAgIHRoaXMuX2lucHV0LFxuICAgICAgICBcImZvY3VzXCIsXG4gICAgICAgICgpID0+IHRoaXMuX25vdGNoLnNldEF0dHJpYnV0ZShLdCwgXCJcIilcbiAgICAgICksIGMub2ZmKFxuICAgICAgICB0aGlzLl9pbnB1dCxcbiAgICAgICAgXCJibHVyXCIsXG4gICAgICAgICgpID0+IHRoaXMuX25vdGNoLnJlbW92ZUF0dHJpYnV0ZShLdClcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGMub24oXG4gICAgICB0aGlzLl9pbnB1dCxcbiAgICAgIFwiZm9jdXNcIixcbiAgICAgICgpID0+IHRoaXMuX25vdGNoLnNldEF0dHJpYnV0ZShLdCwgXCJcIilcbiAgICApLCBjLm9uKFxuICAgICAgdGhpcy5faW5wdXQsXG4gICAgICBcImJsdXJcIixcbiAgICAgICgpID0+IHRoaXMuX25vdGNoLnJlbW92ZUF0dHJpYnV0ZShLdClcbiAgICApO1xuICB9XG4gIF9oYW5kbGVPdXRTaWRlQ2xpY2sodCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLl93cmFwcGVyICYmIHRoaXMuX3dyYXBwZXIuY29udGFpbnModC50YXJnZXQpLCBpID0gdC50YXJnZXQgPT09IHRoaXMuX2Ryb3Bkb3duQ29udGFpbmVyLCBuID0gdGhpcy5fZHJvcGRvd25Db250YWluZXIgJiYgdGhpcy5fZHJvcGRvd25Db250YWluZXIuY29udGFpbnModC50YXJnZXQpO1xuICAgIGxldCBvO1xuICAgIHRoaXMuX3RvZ2dsZUJ1dHRvbiB8fCAodGhpcy5fZWxlbWVudFRvZ2dsZSA9IGQuZmluZChhYikpLCB0aGlzLl9lbGVtZW50VG9nZ2xlICYmIHRoaXMuX2VsZW1lbnRUb2dnbGUuZm9yRWFjaCgocikgPT4ge1xuICAgICAgY29uc3QgYSA9IGguZ2V0RGF0YUF0dHJpYnV0ZShcbiAgICAgICAgcixcbiAgICAgICAgXCJzZWxlY3QtdG9nZ2xlXCJcbiAgICAgICk7XG4gICAgICAoYSA9PT0gdGhpcy5fZWxlbWVudC5pZCB8fCB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhhKSkgJiYgKHRoaXMuX3RvZ2dsZUJ1dHRvbiA9IHIsIG8gPSB0aGlzLl90b2dnbGVCdXR0b24uY29udGFpbnModC50YXJnZXQpKTtcbiAgICB9KSwgIWUgJiYgIWkgJiYgIW4gJiYgIW8gJiYgdGhpcy5jbG9zZSgpO1xuICB9XG4gIGNsb3NlKCkge1xuICAgIGNvbnN0IHQgPSBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgVWcpO1xuICAgICF0aGlzLl9pc09wZW4gfHwgdC5kZWZhdWx0UHJldmVudGVkIHx8ICh0aGlzLl9jb25maWcuc2VsZWN0RmlsdGVyICYmIHRoaXMuaGFzU2VsZWN0QWxsICYmICh0aGlzLl9yZXNldEZpbHRlclN0YXRlKCksIHRoaXMuX3VwZGF0ZU9wdGlvbnNMaXN0VGVtcGxhdGUodGhpcy5fb3B0aW9uc1RvUmVuZGVyKSwgdGhpcy5fY29uZmlnLm11bHRpcGxlICYmIHRoaXMuX3VwZGF0ZVNlbGVjdEFsbFN0YXRlKCkpLCB0aGlzLl9yZW1vdmVEcm9wZG93bkV2ZW50cygpLCB0aGlzLmRyb3Bkb3duLnJlbW92ZUF0dHJpYnV0ZShkbCksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5faW5wdXQucmVtb3ZlQXR0cmlidXRlKEt0KSwgdGhpcy5faW5wdXQuYmx1cigpLCBkLmZpbmRPbmUoYW8sIHRoaXMuX3dyYXBwZXIpLnJlbW92ZUF0dHJpYnV0ZShcbiAgICAgICAgS3RcbiAgICAgICksIHRoaXMuX2xhYmVsICYmICF0aGlzLmhhc1NlbGVjdGlvbiAmJiAodGhpcy5fbGFiZWwucmVtb3ZlQXR0cmlidXRlKHEpLCB0aGlzLl9ub3RjaC5zZXRBdHRyaWJ1dGUocSwgXCJcIiksIHRoaXMuX2lucHV0LnJlbW92ZUF0dHJpYnV0ZShxKSwgdGhpcy5fbm90Y2gucmVtb3ZlQXR0cmlidXRlKHEpKSwgdGhpcy5fdXBkYXRlTGFiZWxQb3NpdGlvbldoaWxlQ2xvc2luZygpO1xuICAgIH0sIDApLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuX2NvbnRhaW5lciAmJiB0aGlzLl9kcm9wZG93bkNvbnRhaW5lci5wYXJlbnROb2RlID09PSB0aGlzLl9jb250YWluZXIgJiYgdGhpcy5fY29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMuX2Ryb3Bkb3duQ29udGFpbmVyKSwgdGhpcy5fcG9wcGVyLmRlc3Ryb3koKSwgdGhpcy5faXNPcGVuID0gITEsIGMub2ZmKHRoaXMuZHJvcGRvd24sIFwidHJhbnNpdGlvbmVuZFwiKTtcbiAgICB9LCBsYikpO1xuICB9XG4gIF9yZXNldEZpbHRlclN0YXRlKCkge1xuICAgIHRoaXMuZmlsdGVySW5wdXQudmFsdWUgPSBcIlwiLCB0aGlzLl9maWx0ZXJlZE9wdGlvbnNMaXN0ID0gbnVsbDtcbiAgfVxuICBfcmVtb3ZlRHJvcGRvd25FdmVudHMoKSB7XG4gICAgYy5vZmYoZG9jdW1lbnQsIFwiY2xpY2tcIiwgdGhpcy5fb3V0c2lkZUNsaWNrKSwgdGhpcy5fY29uZmlnLnNlbGVjdEZpbHRlciAmJiBjLm9mZih0aGlzLmRyb3Bkb3duLCBcImtleWRvd25cIiksIGMub2ZmKHRoaXMub3B0aW9uc1dyYXBwZXIsIFwiY2xpY2tcIik7XG4gIH1cbiAgX2FkZE11dGF0aW9uT2JzZXJ2ZXIoKSB7XG4gICAgdGhpcy5fbXV0YXRpb25PYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKCgpID0+IHtcbiAgICAgIHRoaXMuX3dyYXBwZXIgJiYgKHRoaXMuX3VwZGF0ZVNlbGVjdGlvbnMoKSwgdGhpcy5fdXBkYXRlRGlzYWJsZWRTdGF0ZSgpKTtcbiAgICB9KSwgdGhpcy5fb2JzZXJ2ZU11dGF0aW9uT2JzZXJ2ZXIoKTtcbiAgfVxuICBfdXBkYXRlU2VsZWN0aW9ucygpIHtcbiAgICB0aGlzLl9vcHRpb25zVG9SZW5kZXIgPSB0aGlzLl9nZXRPcHRpb25zVG9SZW5kZXIodGhpcy5fZWxlbWVudCksIHRoaXMuX3BsYWluT3B0aW9ucyA9IHRoaXMuX2dldFBsYWluT3B0aW9ucyh0aGlzLl9vcHRpb25zVG9SZW5kZXIpLCB0aGlzLl9zZWxlY3Rpb25Nb2RlbC5jbGVhcigpLCB0aGlzLl9zZXREZWZhdWx0U2VsZWN0aW9ucygpLCB0aGlzLl91cGRhdGVJbnB1dFZhbHVlKCksIHRoaXMuX3VwZGF0ZUZha2VMYWJlbFBvc2l0aW9uKCksIHRoaXMuX3VwZGF0ZUxhYmVsUG9zaXRpb24oKSwgdGhpcy5fdXBkYXRlQ2xlYXJCdXR0b25WaXNpYmlsaXR5KCksIHRoaXMuaGFzU2VsZWN0QWxsICYmIHRoaXMuX3VwZGF0ZVNlbGVjdEFsbFN0YXRlKCk7XG4gICAgY29uc3QgdCA9IHRoaXMuX2NvbmZpZy5maWx0ZXIgJiYgdGhpcy5maWx0ZXJJbnB1dCAmJiB0aGlzLmZpbHRlcklucHV0LnZhbHVlO1xuICAgIHRoaXMuX2lzT3BlbiAmJiAhdCA/ICh0aGlzLl91cGRhdGVPcHRpb25zTGlzdFRlbXBsYXRlKHRoaXMuX29wdGlvbnNUb1JlbmRlciksIHRoaXMuX3NldEZpcnN0QWN0aXZlT3B0aW9uKCkpIDogdGhpcy5faXNPcGVuICYmIHQgPyAodGhpcy5fZmlsdGVyT3B0aW9ucyh0aGlzLmZpbHRlcklucHV0LnZhbHVlKSwgdGhpcy5fc2V0Rmlyc3RBY3RpdmVPcHRpb24oKSkgOiB0aGlzLl9kcm9wZG93bkNvbnRhaW5lciA9IGFsKFxuICAgICAgdGhpcy5fZHJvcGRvd25Db250YWluZXJJZCxcbiAgICAgIHRoaXMuX2NvbmZpZyxcbiAgICAgIHRoaXMuX2lucHV0Lm9mZnNldFdpZHRoLFxuICAgICAgdGhpcy5fZHJvcGRvd25IZWlnaHQsXG4gICAgICB0aGlzLl9zZWxlY3RBbGxPcHRpb24sXG4gICAgICB0aGlzLl9vcHRpb25zVG9SZW5kZXIsXG4gICAgICB0aGlzLl9jdXN0b21Db250ZW50LFxuICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICk7XG4gIH1cbiAgX3VwZGF0ZURpc2FibGVkU3RhdGUoKSB7XG4gICAgY29uc3QgdCA9IGQuZmluZE9uZSh1bCwgdGhpcy5fd3JhcHBlcik7XG4gICAgdGhpcy5fZWxlbWVudC5oYXNBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSA/ICh0aGlzLl9jb25maWcuZGlzYWJsZWQgPSAhMCwgdC5zZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiLCBcIlwiKSwgdC5zZXRBdHRyaWJ1dGUocm8sIFwiXCIpKSA6ICh0aGlzLl9jb25maWcuZGlzYWJsZWQgPSAhMSwgdC5yZW1vdmVBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSwgdC5yZW1vdmVBdHRyaWJ1dGUocm8pKTtcbiAgfVxuICBfb2JzZXJ2ZU11dGF0aW9uT2JzZXJ2ZXIoKSB7XG4gICAgdGhpcy5fbXV0YXRpb25PYnNlcnZlciAmJiB0aGlzLl9tdXRhdGlvbk9ic2VydmVyLm9ic2VydmUodGhpcy5fZWxlbWVudCwge1xuICAgICAgYXR0cmlidXRlczogITAsXG4gICAgICBjaGlsZExpc3Q6ICEwLFxuICAgICAgY2hhcmFjdGVyRGF0YTogITAsXG4gICAgICBzdWJ0cmVlOiAhMFxuICAgIH0pO1xuICB9XG4gIF9kaXNjb25uZWN0TXV0YXRpb25PYnNlcnZlcigpIHtcbiAgICB0aGlzLm11dGF0aW9uT2JzZXJ2ZXIgJiYgKHRoaXMuX211dGF0aW9uT2JzZXJ2ZXIuZGlzY29ubmVjdCgpLCB0aGlzLl9tdXRhdGlvbk9ic2VydmVyID0gbnVsbCk7XG4gIH1cbiAgX2NyZWF0ZVNlbGVjdEFsbE9wdGlvbigpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fc2VsZWN0QWxsSWQsIGUgPSBudWxsLCBpID0gITAsIG4gPSBcInNlbGVjdC1hbGxcIiwgbyA9IHRoaXMuX2NvbmZpZy5zZWxlY3RBbGxMYWJlbCwgciA9IFZvKHRoaXMub3B0aW9ucyksIGEgPSAhMSwgbCA9ICExLCBwID0gbnVsbCwgdSA9IG51bGwsIF8gPSBudWxsO1xuICAgIHJldHVybiBuZXcgcmwoXG4gICAgICB0LFxuICAgICAgZSxcbiAgICAgIGksXG4gICAgICBuLFxuICAgICAgbyxcbiAgICAgIHIsXG4gICAgICBhLFxuICAgICAgbCxcbiAgICAgIHAsXG4gICAgICB1LFxuICAgICAgX1xuICAgICk7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLl9yZW1vdmVDb21wb25lbnRFdmVudHMoKSwgdGhpcy5fZGVzdHJveU1hdGVyaWFsU2VsZWN0KCksIHRoaXMuX2xpc3RlblRvRm9jdXNDaGFuZ2UoITEpLCB5LnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgdmkpO1xuICB9XG4gIF9yZW1vdmVDb21wb25lbnRFdmVudHMoKSB7XG4gICAgYy5vZmYodGhpcy5pbnB1dCwgXCJjbGlja1wiKSwgYy5vZmYodGhpcy53cmFwcGVyLCB0aGlzLl9oYW5kbGVLZXlkb3duLmJpbmQodGhpcykpLCBjLm9mZih0aGlzLmNsZWFyQnV0dG9uLCBcImNsaWNrXCIpLCBjLm9mZih0aGlzLmNsZWFyQnV0dG9uLCBcImtleWRvd25cIiksIGMub2ZmKHdpbmRvdywgXCJyZXNpemVcIiwgdGhpcy5faGFuZGxlV2luZG93UmVzaXplLmJpbmQodGhpcykpO1xuICB9XG4gIF9kZXN0cm95TWF0ZXJpYWxTZWxlY3QoKSB7XG4gICAgdGhpcy5faXNPcGVuICYmIHRoaXMuY2xvc2UoKSwgdGhpcy5fZGVzdHJveU1hdGVyaWFsVGVtcGxhdGUoKTtcbiAgfVxuICBfZGVzdHJveU1hdGVyaWFsVGVtcGxhdGUoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX3dyYXBwZXIucGFyZW50Tm9kZSwgZSA9IGQuZmluZChcImxhYmVsXCIsIHRoaXMuX3dyYXBwZXIpO1xuICAgIHQuYXBwZW5kQ2hpbGQodGhpcy5fZWxlbWVudCksIGUuZm9yRWFjaCgoaSkgPT4ge1xuICAgICAgdC5hcHBlbmRDaGlsZChpKTtcbiAgICB9KSwgZS5mb3JFYWNoKChpKSA9PiB7XG4gICAgICBpLnJlbW92ZUF0dHJpYnV0ZShxKTtcbiAgICB9KSwgaC5yZW1vdmVDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl9jbGFzc2VzLmluaXRpYWxpemVkKSwgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoaGwpLCB0LnJlbW92ZUNoaWxkKHRoaXMuX3dyYXBwZXIpO1xuICB9XG4gIHNldFZhbHVlKHQpIHtcbiAgICB0aGlzLm9wdGlvbnMuZmlsdGVyKChpKSA9PiBpLnNlbGVjdGVkKS5mb3JFYWNoKChpKSA9PiBpLm5hdGl2ZU9wdGlvbi5zZWxlY3RlZCA9ICExKSwgQXJyYXkuaXNBcnJheSh0KSA/IHQuZm9yRWFjaCgoaSkgPT4ge1xuICAgICAgdGhpcy5fc2VsZWN0QnlWYWx1ZShpKTtcbiAgICB9KSA6IHRoaXMuX3NlbGVjdEJ5VmFsdWUodCksIHRoaXMuX3VwZGF0ZVNlbGVjdGlvbnMoKTtcbiAgfVxuICBfc2VsZWN0QnlWYWx1ZSh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMub3B0aW9ucy5maW5kKFxuICAgICAgKGkpID0+IGkudmFsdWUgPT09IHRcbiAgICApO1xuICAgIHJldHVybiBlID8gKGUubmF0aXZlT3B0aW9uLnNlbGVjdGVkID0gITAsICEwKSA6ICExO1xuICB9XG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCwgZSkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICBsZXQgaSA9IHkuZ2V0RGF0YSh0aGlzLCB2aSk7XG4gICAgICBjb25zdCBuID0gdHlwZW9mIHQgPT0gXCJvYmplY3RcIiAmJiB0O1xuICAgICAgaWYgKCEoIWkgJiYgL2Rpc3Bvc2UvLnRlc3QodCkpICYmIChpIHx8IChpID0gbmV3IF9yKHRoaXMsIG4pKSwgdHlwZW9mIHQgPT0gXCJzdHJpbmdcIikpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpW3RdID4gXCJ1XCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgIGlbdF0oZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGdldEluc3RhbmNlKHQpIHtcbiAgICByZXR1cm4geS5nZXREYXRhKHQsIHZpKTtcbiAgfVxuICBzdGF0aWMgZ2V0T3JDcmVhdGVJbnN0YW5jZSh0LCBlID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSh0KSB8fCBuZXcgdGhpcyh0LCB0eXBlb2YgZSA9PSBcIm9iamVjdFwiID8gZSA6IG51bGwpO1xuICB9XG59XG5jb25zdCBwYiA9ICh7IGlucHV0SUQ6IHMsIGxhYmVsVGV4dDogdCB9LCBlKSA9PiBgPGRpdiBkYXRhLXRlLWNoaXBzLWlucHV0LXdyYXBwZXIgZGF0YS10ZS1pbnB1dC13cmFwcGVyLWluaXQgY2xhc3M9XCIke2UuY2hpcHNJbnB1dFdyYXBwZXJ9XCI+XG4gICAgICA8aW5wdXRcbiAgICAgICAgICB0eXBlPVwidGV4dFwiXG4gICAgICAgICAgY2xhc3M9XCIke2UuY2hpcHNJbnB1dH1cIlxuICAgICAgICAgIGlkPVwiJHtzfVwiXG4gICAgICAgICAgcGxhY2Vob2xkZXI9XCJFeGFtcGxlIGxhYmVsXCIgLz5cbiAgICAgICAgPGxhYmVsXG4gICAgICAgICAgZm9yPVwiJHtzfVwiXG4gICAgICAgICAgY2xhc3M9XCIke2UuY2hpcHNMYWJlbH1cIlxuICAgICAgICAgID4ke3R9XG4gICAgICAgIDwvbGFiZWw+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5gLCBfYiA9ICh7IHRleHQ6IHMsIGljb25TVkc6IHQgfSwgZSkgPT4gYDxkaXYgZGF0YS10ZS1jaGlwLWluaXQgZGF0YS10ZS1yaXBwbGUtaW5pdCBjbGFzcz1cIiR7ZS5jaGlwRWxlbWVudH1cIj5cbiAgICA8c3BhbiBkYXRhLXRlLWNoaXAtdGV4dD4ke3N9PC9zcGFuPiBcbiAgICAgIDxzcGFuIGRhdGEtdGUtY2hpcC1jbG9zZSBjbGFzcz1cIiR7ZS5jaGlwQ2xvc2VJY29ufVwiPlxuICAgICAgICAke3R9XG4gICAgICA8L3NwYW4+XG4gIDwvZGl2PmAsIEdzID0gXCJjaGlwXCIsIGZiID0gYHRlLiR7R3N9YCwgcmggPSBcImRhdGEtdGUtY2hpcC1jbG9zZVwiLCBsbyA9IGBbJHtyaH1dYCwgbWIgPSBcImRlbGV0ZS50ZS5jaGlwc1wiLCBnYiA9IFwic2VsZWN0LnRlLmNoaXBcIiwgYmIgPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMS41XCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgY2xhc3M9XCJ3LTMgaC0zXCI+IDxwYXRoIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIGQ9XCJNNiAxOEwxOCA2TTYgNmwxMiAxMlwiIC8+PC9zdmc+JywgdmIgPSB7XG4gIHRleHQ6IFwic3RyaW5nXCIsXG4gIGNsb3NlSWNvbjogXCJib29sZWFuXCIsXG4gIGltZzogXCJvYmplY3RcIixcbiAgaWNvblNWRzogXCJzdHJpbmdcIlxufSwgVGIgPSB7XG4gIHRleHQ6IFwiXCIsXG4gIGNsb3NlSWNvbjogITEsXG4gIGltZzogeyBwYXRoOiBcIlwiLCBhbHQ6IFwiXCIgfSxcbiAgaWNvblNWRzogYmJcbn0sIEViID0ge1xuICBpY29uOiBcImZsb2F0LXJpZ2h0IHBsLVs4cHhdIHRleHQtWzE2cHhdIG9wYWNpdHktWy41M10gY3Vyc29yLXBvaW50ZXIgZmlsbC1bI2FmYWZhZl0gaG92ZXI6dGV4dC1bIzhiOGI4Yl0gdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tMjAwIGVhc2UtaW4tb3V0XCIsXG4gIGNoaXBFbGVtZW50OiBcImZsZXgganVzdGlmeS1iZXR3ZWVuIGl0ZW1zLWNlbnRlciBoLVszMnB4XSBsZWFkaW5nLWxvb3NlIHB5LVs1cHhdIHB4LVsxMnB4XSBtci00IG15LVs1cHhdIHRleHQtWzEzcHhdIGZvbnQtbm9ybWFsIHRleHQtWyM0ZjRmNGZdIGN1cnNvci1wb2ludGVyIGJnLVsjZWNlZmYxXSBkYXJrOnRleHQtd2hpdGUgZGFyazpiZy1uZXV0cmFsLTYwMCByb3VuZGVkLVsxNnB4XSB0cmFuc2l0aW9uLVtvcGFjaXR5XSBkdXJhdGlvbi0zMDAgZWFzZS1saW5lYXIgW3dvcmQtd3JhcDogYnJlYWstd29yZF0gc2hhZG93LW5vbmUgbm9ybWFsLWNhc2UgaG92ZXI6IXNoYWRvdy1ub25lIGFjdGl2ZTpiZy1bI2NhY2ZkMV0gaW5saW5lLWJsb2NrIGZvbnQtbWVkaXVtIGxlYWRpbmctbm9ybWFsIHRleHQtWyM0ZjRmNGZdIHRleHQtY2VudGVyIG5vLXVuZGVybGluZSBhbGlnbi1taWRkbGUgY3Vyc29yLXBvaW50ZXIgc2VsZWN0LW5vbmUgYm9yZGVyLVsuMTI1cmVtXSBib3JkZXItc29saWQgYm9yZGVyLXRyYW5zcGFyZW50IHB5LTEuNSBweC0zIHRleHQteHMgcm91bmRlZFwiLFxuICBjaGlwQ2xvc2VJY29uOiBcInctNCBmbG9hdC1yaWdodCBwbC1bOHB4XSB0ZXh0LVsxNnB4XSBvcGFjaXR5LVsuNTNdIGN1cnNvci1wb2ludGVyIGZpbGwtWyNhZmFmYWZdIGhvdmVyOmZpbGwtWyM4YjhiOGJdIGRhcms6ZmlsbC1ncmF5LTQwMCBkYXJrOmhvdmVyOmZpbGwtZ3JheS0xMDAgdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tMjAwIGVhc2UtaW4tb3V0XCJcbn0sIENiID0ge1xuICBpY29uOiBcInN0cmluZ1wiLFxuICBjaGlwRWxlbWVudDogXCJzdHJpbmdcIixcbiAgY2hpcENsb3NlSWNvbjogXCJzdHJpbmdcIlxufTtcbmNsYXNzIF9pIHtcbiAgY29uc3RydWN0b3IodCwgZSA9IHt9LCBpKSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX29wdGlvbnMgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX2NsYXNzZXMgPSB0aGlzLl9nZXRDbGFzc2VzKGkpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBHcztcbiAgfVxuICAvLyBQdWJsaWNcbiAgaW5pdCgpIHtcbiAgICB0aGlzLl9hcHBlbmRDbG9zZUljb24oKSwgdGhpcy5faGFuZGxlRGVsZXRlKCksIHRoaXMuX2hhbmRsZVRleHRDaGlwKCksIHRoaXMuX2hhbmRsZUNsaWNrT25DaGlwKCk7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gbnVsbCwgdGhpcy5fb3B0aW9ucyA9IG51bGwsIGMub2ZmKHRoaXMuX2VsZW1lbnQsIFwiY2xpY2tcIik7XG4gIH1cbiAgYXBwZW5kQ2hpcCgpIHtcbiAgICBjb25zdCB7IHRleHQ6IHQsIGNsb3NlSWNvbjogZSwgaWNvblNWRzogaSB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICByZXR1cm4gX2IoeyB0ZXh0OiB0LCBjbG9zZUljb246IGUsIGljb25TVkc6IGkgfSwgdGhpcy5fY2xhc3Nlcyk7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfYXBwZW5kQ2xvc2VJY29uKHQgPSB0aGlzLl9lbGVtZW50KSB7XG4gICAgaWYgKCEoZC5maW5kKGxvLCB0aGlzLl9lbGVtZW50KS5sZW5ndGggPiAwKSAmJiB0aGlzLl9vcHRpb25zLmNsb3NlSWNvbikge1xuICAgICAgY29uc3QgZSA9ICQoXCJzcGFuXCIpO1xuICAgICAgZS5jbGFzc0xpc3QgPSB0aGlzLl9jbGFzc2VzLmljb24sIGUuc2V0QXR0cmlidXRlKHJoKSwgZS5pbm5lckhUTUwgPSB0aGlzLl9vcHRpb25zLmljb25TVkcsIHQuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KFwiYmVmb3JlZW5kXCIsIGUpO1xuICAgIH1cbiAgfVxuICBfaGFuZGxlQ2xpY2tPbkNoaXAoKSB7XG4gICAgYy5vbih0aGlzLl9lbGVtZW50LCBcImNsaWNrXCIsICh0KSA9PiB7XG4gICAgICBjb25zdCB7IHRleHRDb250ZW50OiBlIH0gPSB0LnRhcmdldCwgaSA9IHt9O1xuICAgICAgaS50YWcgPSBlLnRyaW0oKSwgYy50cmlnZ2VyKGdiLCB7IGV2ZW50OiB0LCBvYmo6IGkgfSk7XG4gICAgfSk7XG4gIH1cbiAgX2hhbmRsZURlbGV0ZSgpIHtcbiAgICBkLmZpbmQoXG4gICAgICBsbyxcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApLmxlbmd0aCAhPT0gMCAmJiBjLm9uKHRoaXMuX2VsZW1lbnQsIFwiY2xpY2tcIiwgbG8sICgpID0+IHtcbiAgICAgIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBtYiksIHRoaXMuX2VsZW1lbnQucmVtb3ZlKCk7XG4gICAgfSk7XG4gIH1cbiAgX2hhbmRsZVRleHRDaGlwKCkge1xuICAgIHRoaXMuX2VsZW1lbnQuaW5uZXJUZXh0ID09PSBcIlwiICYmICh0aGlzLl9lbGVtZW50LmlubmVyVGV4dCA9IHRoaXMuX29wdGlvbnMudGV4dCk7XG4gIH1cbiAgX2dldENvbmZpZyh0KSB7XG4gICAgY29uc3QgZSA9IHtcbiAgICAgIC4uLlRiLFxuICAgICAgLi4uaC5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KSxcbiAgICAgIC4uLnRcbiAgICB9O1xuICAgIHJldHVybiBEKEdzLCBlLCB2YiksIGU7XG4gIH1cbiAgX2dldENsYXNzZXModCkge1xuICAgIGNvbnN0IGUgPSBoLmdldERhdGFDbGFzc0F0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5FYixcbiAgICAgIC4uLmUsXG4gICAgICAuLi50XG4gICAgfSwgRChHcywgdCwgQ2IpLCB0O1xuICB9XG4gIHN0YXRpYyBnZXRJbnN0YW5jZSh0KSB7XG4gICAgcmV0dXJuIHkuZ2V0RGF0YSh0LCBmYik7XG4gIH1cbiAgc3RhdGljIGdldE9yQ3JlYXRlSW5zdGFuY2UodCwgZSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UodCkgfHwgbmV3IHRoaXModCwgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiA/IGUgOiBudWxsKTtcbiAgfVxufVxuY29uc3QgTGkgPSBcImNoaXBzXCIsIEtpID0gYGRhdGEtdGUtJHtMaX1gLCBmbCA9IGB0ZS4ke0xpfWAsIEFiID0gYCR7S2l9LWlucHV0LWluaXRgLCBtdCA9IGAke0tpfS1hY3RpdmVgLCBtbCA9IGAke0tpfS1pbml0aWFsYCwgYWggPSBgJHtLaX0tcGxhY2Vob2xkZXJgLCB5YiA9IGAke0tpfS1pbnB1dC13cmFwcGVyYCwgV28gPSBcImRhdGEtdGUtY2hpcC1pbml0XCIsIGxoID0gXCJkYXRhLXRlLWNoaXAtY2xvc2VcIiwgY2ggPSBcImRhdGEtdGUtY2hpcC10ZXh0XCIsIHdiID0gYFske210fV1gLCBGbyA9IGBbJHtXb31dYCwga2IgPSBgJHtGb30ke3difWAsIGNvID0gYFske2xofV1gLCB4YiA9IGBbJHt5Yn1dYCwgT2IgPSBgWyR7Y2h9XWAsIFNiID0gYFske2FofV1gLCBJYiA9IFwiZGF0YS10ZS1pbnB1dC1ub3RjaC1sZWFkaW5nLXJlZlwiLCBEYiA9IFwiZGF0YS10ZS1pbnB1dC1ub3RjaC1taWRkbGUtcmVmXCIsICRiID0gYFske0lifV1gLCBMYiA9IGBbJHtEYn1dYCwgU2UgPSBcImRhdGEtdGUtaW5wdXQtc3RhdGUtYWN0aXZlXCIsIGhvID0gXCJbZGF0YS10ZS1pbnB1dC1ub3RjaC1yZWZdXCIsIE5iID0gXCJhZGQudGUuY2hpcHNcIiwgTWIgPSBcImFycm93RG93bi50ZS5jaGlwc1wiLCBSYiA9IFwiYXJyb3dMZWZ0LnRlLmNoaXBzXCIsIFBiID0gXCJhcnJvd1JpZ2h0LnRlLmNoaXBzXCIsIEJiID0gXCJhcnJvd1VwLnRlLmNoaXBzXCIsIGdsID0gXCJkZWxldGUudGUuY2hpcHNcIiwgYmwgPSBcInNlbGVjdC50ZS5jaGlwc1wiLCBIYiA9IHtcbiAgaW5wdXRJRDogXCJzdHJpbmdcIixcbiAgcGFyZW50U2VsZWN0b3I6IFwic3RyaW5nXCIsXG4gIGluaXRpYWxWYWx1ZXM6IFwiYXJyYXlcIixcbiAgZWRpdGFibGU6IFwiYm9vbGVhblwiLFxuICBsYWJlbFRleHQ6IFwic3RyaW5nXCIsXG4gIGlucHV0Q2xhc3NlczogXCJvYmplY3RcIixcbiAgaW5wdXRPcHRpb25zOiBcIm9iamVjdFwiXG59LCBWYiA9IHtcbiAgaW5wdXRJRDogcnQoXCJjaGlwcy1pbnB1dC1cIiksXG4gIHBhcmVudFNlbGVjdG9yOiBcIlwiLFxuICBpbml0aWFsVmFsdWVzOiBbeyB0YWc6IFwiaW5pdDFcIiB9LCB7IHRhZzogXCJpbml0MlwiIH1dLFxuICBlZGl0YWJsZTogITEsXG4gIGxhYmVsVGV4dDogXCJFeGFtcGxlIGxhYmVsXCIsXG4gIGlucHV0Q2xhc3Nlczoge30sXG4gIGlucHV0T3B0aW9uczoge31cbn0sIFdiID0ge1xuICBvcGFjaXR5OiBcIm9wYWNpdHktMFwiLFxuICBpbnB1dFdyYXBwZXJQYWRkaW5nOiBcInAtWzVweF1cIixcbiAgdHJhbnNpdGlvbjogXCJ0cmFuc2l0aW9uLWFsbCBkdXJhdGlvbi0zMDAgZWFzZS1bY3ViaWMtYmV6aWVyKDAuMjUsMC4xLDAuMjUsMSldXCIsXG4gIGNvbnRlbnRFZGl0YWJsZTogXCJvdXRsaW5lLW5vbmUgIWJvcmRlci1bM3B4XSAhYm9yZGVyLXNvbGlkICFib3JkZXItWyNiMmIzYjRdXCIsXG4gIGNoaXBzSW5wdXRXcmFwcGVyOiBcInJlbGF0aXZlIGZsZXggaXRlbXMtY2VudGVyIGZsZXgtd3JhcCB0cmFuc2l0aW9uLWFsbCBkdXJhdGlvbi0zMDAgZWFzZS1bY3ViaWMtYmV6aWVyKDAuMjUsMC4xLDAuMjUsMSldXCIsXG4gIGNoaXBzSW5wdXQ6IFwicGVlciBibG9jayBtaW4taC1bYXV0b10gdy1bMTUwcHhdIHJvdW5kZWQgYm9yZGVyLTAgYmctdHJhbnNwYXJlbnQgcHktWzAuMzJyZW1dIHB4LTMgbGVhZGluZy1bMS42XSBvdXRsaW5lLW5vbmUgdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tMjAwIGVhc2UtbGluZWFyIGZvY3VzOnBsYWNlaG9sZGVyOm9wYWNpdHktMTAwIGRhdGEtW3RlLWlucHV0LXN0YXRlLWFjdGl2ZV06cGxhY2Vob2xkZXI6b3BhY2l0eS0xMDAgbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmUgZGFyazp0ZXh0LWdyYXktMjAwIGRhcms6cGxhY2Vob2xkZXI6dGV4dC1ncmF5LTIwMCBbJjpub3QoW2RhdGEtdGUtaW5wdXQtcGxhY2Vob2xkZXItYWN0aXZlXSldOnBsYWNlaG9sZGVyOm9wYWNpdHktMFwiLFxuICBjaGlwc0xhYmVsOiBcInBvaW50ZXItZXZlbnRzLW5vbmUgYWJzb2x1dGUgdG9wLTAgbGVmdC0zIG1iLTAgbWF4LXctWzkwJV0gb3JpZ2luLVswXzBdIHRydW5jYXRlIHB0LVswLjM3cmVtXSBsZWFkaW5nLVsxLjZdIHRleHQtZ3JheS01MDAgdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tMjAwIGVhc2Utb3V0IHBlZXItZm9jdXM6LXRyYW5zbGF0ZS15LVswLjlyZW1dIHBlZXItZm9jdXM6c2NhbGUtWzAuOF0gcGVlci1mb2N1czp0ZXh0LXByaW1hcnkgcGVlci1kYXRhLVt0ZS1pbnB1dC1zdGF0ZS1hY3RpdmVdOi10cmFuc2xhdGUteS1bMC45cmVtXSBwZWVyLWRhdGEtW3RlLWlucHV0LXN0YXRlLWFjdGl2ZV06c2NhbGUtWzAuOF0gbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmUgZGFyazp0ZXh0LWdyYXktMjAwIGRhcms6cGVlci1mb2N1czp0ZXh0LWdyYXktMjAwXCJcbn0sIEZiID0ge1xuICBvcGFjaXR5OiBcInN0cmluZ1wiLFxuICBpbnB1dFdyYXBwZXJQYWRkaW5nOiBcInN0cmluZ1wiLFxuICB0cmFuc2l0aW9uOiBcInN0cmluZ1wiLFxuICBjb250ZW50RWRpdGFibGU6IFwic3RyaW5nXCIsXG4gIGNoaXBzSW5wdXRXcmFwcGVyOiBcInN0cmluZ1wiLFxuICBjaGlwc0lucHV0OiBcInN0cmluZ1wiLFxuICBjaGlwc0xhYmVsOiBcInN0cmluZ1wiXG59O1xuY2xhc3MgR0MgZXh0ZW5kcyBfaSB7XG4gIGNvbnN0cnVjdG9yKGUsIGkgPSB7fSwgbikge1xuICAgIHN1cGVyKGUsIGkpO1xuICAgIHl0KHRoaXMsIFwiX2hhbmRsZUJsdXJJbnB1dFwiLCAoeyB0YXJnZXQ6IGUgfSkgPT4ge1xuICAgICAgZS52YWx1ZS5sZW5ndGggPiAwICYmIHRoaXMuX2hhbmRsZUNyZWF0ZUNoaXAoZSwgZS52YWx1ZSksIHRoaXMuYWxsQ2hpcHMubGVuZ3RoID4gMCA/IChlLnNldEF0dHJpYnV0ZShtdCwgXCJcIiksIHRoaXMuaW5wdXQuc2V0QXR0cmlidXRlKFNlLCBcIlwiKSwgZC5maW5kT25lKFxuICAgICAgICBobyxcbiAgICAgICAgdGhpcy5pbnB1dC5wYXJlbnROb2RlXG4gICAgICApLnNldEF0dHJpYnV0ZShTZSwgXCJcIiksIHRoaXMuY2hpcHNJbnB1dFdyYXBwZXIuY2xhc3NMaXN0LmFkZChcbiAgICAgICAgLi4udGhpcy5fY2xhc3Nlcy5pbnB1dFdyYXBwZXJQYWRkaW5nLnNwbGl0KFwiIFwiKVxuICAgICAgKSkgOiAoZS5yZW1vdmVBdHRyaWJ1dGUobXQpLCB0aGlzLmlucHV0LnJlbW92ZUF0dHJpYnV0ZShTZSksIGQuZmluZE9uZShcbiAgICAgICAgaG8sXG4gICAgICAgIHRoaXMuaW5wdXQucGFyZW50Tm9kZVxuICAgICAgKS5yZW1vdmVBdHRyaWJ1dGUoU2UpLCB0aGlzLmNoaXBzSW5wdXRXcmFwcGVyLmNsYXNzTGlzdC5yZW1vdmUoXG4gICAgICAgIC4uLnRoaXMuX2NsYXNzZXMuaW5wdXRXcmFwcGVyUGFkZGluZy5zcGxpdChcIiBcIilcbiAgICAgICkpLCB0aGlzLmFsbENoaXBzLmZvckVhY2goKGkpID0+IGkucmVtb3ZlQXR0cmlidXRlKG10KSk7XG4gICAgfSk7XG4gICAgdGhpcy5fZWxlbWVudCA9IGUsIHRoaXMuX2lucHV0SW5zdGFuY2UgPSBudWxsLCB0aGlzLl9lbGVtZW50ICYmIHkuc2V0RGF0YShlLCBmbCwgdGhpcyksIHRoaXMuX29wdGlvbnMgPSB0aGlzLl9nZXRDb25maWcoaSksIHRoaXMuX2NsYXNzZXMgPSB0aGlzLl9nZXRDbGFzc2VzKG4pLCB0aGlzLm51bWJlckNsaWNrcyA9IDAsIHRoaXMuaW5pdCgpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBMaTtcbiAgfVxuICBnZXQgYWN0aXZlQ2hpcCgpIHtcbiAgICByZXR1cm4gZC5maW5kT25lKGtiLCB0aGlzLl9lbGVtZW50KTtcbiAgfVxuICBnZXQgaW5wdXQoKSB7XG4gICAgcmV0dXJuIGQuZmluZE9uZShcImlucHV0XCIsIHRoaXMuX2VsZW1lbnQpO1xuICB9XG4gIGdldCBhbGxDaGlwcygpIHtcbiAgICByZXR1cm4gZC5maW5kKEZvLCB0aGlzLl9lbGVtZW50KTtcbiAgfVxuICBnZXQgY2hpcHNJbnB1dFdyYXBwZXIoKSB7XG4gICAgcmV0dXJuIGQuZmluZE9uZSh4YiwgdGhpcy5fZWxlbWVudCk7XG4gIH1cbiAgLy8gUHVibGljXG4gIGluaXQoKSB7XG4gICAgdGhpcy5fc2V0Q2hpcHNDbGFzcygpLCB0aGlzLl9hcHBlbmRJbnB1dFRvRWxlbWVudChhaCksIHRoaXMuX2hhbmRsZUluaXRpYWxWYWx1ZSgpLCB0aGlzLl9oYW5kbGVJbnB1dFRleHQoKSwgdGhpcy5faGFuZGxlS2V5Ym9hcmQoKSwgdGhpcy5faGFuZGxlQ2hpcHNPblNlbGVjdCgpLCB0aGlzLl9oYW5kbGVFZGl0YWJsZSgpLCB0aGlzLl9oYW5kbGVDaGlwc0ZvY3VzKCksIHRoaXMuX2hhbmRsZUNsaWNrc09uQ2hpcHMoKSwgdGhpcy5faW5wdXRJbnN0YW5jZS5fZ2V0TGFiZWxXaWR0aCgpLCB0aGlzLl9pbnB1dEluc3RhbmNlLl9hcHBseU5vdGNoKCk7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gbnVsbCwgdGhpcy5fb3B0aW9ucyA9IG51bGw7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfZ2V0Tm90Y2hEYXRhKCkge1xuICAgIHRoaXMuX25vdGNoTWlkZGxlID0gZC5maW5kT25lKFxuICAgICAgTGIsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKSwgdGhpcy5fbm90Y2hMZWFkaW5nID0gZC5maW5kT25lKFxuICAgICAgJGIsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKTtcbiAgfVxuICBfc2V0Q2hpcHNDbGFzcygpIHtcbiAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShBYiwgXCJcIik7XG4gIH1cbiAgX2hhbmRsZURlbGV0ZUV2ZW50cyhlKSB7XG4gICAgY29uc3QgW2ldID0gdGhpcy5hbGxDaGlwcy5zbGljZSgtMSk7XG4gICAgaWYgKHRoaXMuYWN0aXZlQ2hpcCA9PT0gbnVsbClcbiAgICAgIGkucmVtb3ZlKCksIHRoaXMuX2hhbmRsZUV2ZW50cyhlLCBnbCk7XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBuID0gdGhpcy5hbGxDaGlwcy5maW5kSW5kZXgoKGEpID0+IGEgPT09IHRoaXMuYWN0aXZlQ2hpcCksIG8gPSB0aGlzLl9oYW5kbGVBY3RpdmVDaGlwQWZ0ZXJSZW1vdmUobiksIHIgPSBbXTtcbiAgICAgIGlmICh0aGlzLmFjdGl2ZUNoaXAgPT09IG51bGwpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHRoaXMuYWN0aXZlQ2hpcC5yZW1vdmUoKSwgdGhpcy5faGFuZGxlRXZlbnRzKGUsIGdsKSwgdGhpcy5udW1iZXJDbGlja3MgPSBuLCBvLnNldEF0dHJpYnV0ZShtdCwgXCJcIiksIHRoaXMuYWxsQ2hpcHMuZm9yRWFjaCgoYSkgPT4ge1xuICAgICAgICBhLmhhc0F0dHJpYnV0ZShtdCkgJiYgKHIucHVzaChhKSwgci5sZW5ndGggPiAxICYmIHRoaXMuYWxsQ2hpcHMuZm9yRWFjaCgobCkgPT4gbC5yZW1vdmUoKSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIF9oYW5kbGVVcEV2ZW50cyhlKSB7XG4gICAgdGhpcy5udW1iZXJDbGlja3MgKz0gMSwgdGhpcy5udW1iZXJDbGlja3MgPT09IHRoaXMuYWxsQ2hpcHMubGVuZ3RoICsgMSAmJiAodGhpcy5udW1iZXJDbGlja3MgPSAwKSwgdGhpcy5faGFuZGxlUmlnaHRLZXlib2FyZEFycm93KHRoaXMubnVtYmVyQ2xpY2tzKSwgdGhpcy5faGFuZGxlRXZlbnRzKGUsIFBiKSwgdGhpcy5faGFuZGxlRXZlbnRzKGUsIEJiKTtcbiAgfVxuICBfaGFuZGxlRG93bkV2ZW50cyhlKSB7XG4gICAgdGhpcy5udW1iZXJDbGlja3MgLT0gMSwgdGhpcy5udW1iZXJDbGlja3MgPD0gMCAmJiAodGhpcy5udW1iZXJDbGlja3MgPSB0aGlzLmFsbENoaXBzLmxlbmd0aCksIHRoaXMuX2hhbmRsZUxlZnRLZXlib2FyZEFycm93KHRoaXMubnVtYmVyQ2xpY2tzKSwgdGhpcy5faGFuZGxlRXZlbnRzKGUsIFJiKSwgdGhpcy5faGFuZGxlRXZlbnRzKGUsIE1iKTtcbiAgfVxuICBfa2V5Ym9hcmRFdmVudHMoZSkge1xuICAgIGNvbnN0IHsgdGFyZ2V0OiBpLCBrZXlDb2RlOiBuLCBjdHJsS2V5OiBvIH0gPSBlO1xuICAgIGkudmFsdWUubGVuZ3RoID4gMCB8fCB0aGlzLmFsbENoaXBzLmxlbmd0aCA9PT0gMCB8fCAobiA9PT0gTmYgfHwgbiA9PT0gTWYgPyB0aGlzLl9oYW5kbGVEZWxldGVFdmVudHMoZSkgOiBuID09PSBWZSB8fCBuID09PSBhdCA/IHRoaXMuX2hhbmRsZVVwRXZlbnRzKGUpIDogbiA9PT0gSGUgfHwgbiA9PT0geiA/IHRoaXMuX2hhbmRsZURvd25FdmVudHMoZSkgOiBuID09PSA2NSAmJiBvICYmIHRoaXMuX2hhbmRsZUFkZEFjdGl2ZUNsYXNzKCkpO1xuICB9XG4gIF9oYW5kbGVLZXlib2FyZCgpIHtcbiAgICBjLm9uKFxuICAgICAgdGhpcy5pbnB1dCxcbiAgICAgIFwia2V5ZG93blwiLFxuICAgICAgKGUpID0+IHRoaXMuX2tleWJvYXJkRXZlbnRzKGUpXG4gICAgKTtcbiAgfVxuICBfaGFuZGxlRWRpdGFibGUoKSB7XG4gICAgY29uc3QgeyBlZGl0YWJsZTogZSB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICBlICYmIHRoaXMuYWxsQ2hpcHMuZm9yRWFjaCgoaSkgPT4ge1xuICAgICAgYy5vbihpLCBcImRibGNsaWNrXCIsIChuKSA9PiB7XG4gICAgICAgIGNvbnN0IG8gPSBkLmZpbmRPbmUoY28sIGkpO1xuICAgICAgICBpLmNsYXNzTGlzdC5hZGQoLi4udGhpcy5fY2xhc3Nlcy5jb250ZW50RWRpdGFibGUuc3BsaXQoXCIgXCIpKSwgaS5jb250ZW50RWRpdGFibGUgPSAhMCwgaS5mb2N1cygpLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBoLmFkZFN0eWxlKG8sIHsgZGlzcGxheTogXCJub25lXCIgfSk7XG4gICAgICAgIH0sIDIwMCksIG8uY2xhc3NMaXN0LmFkZCguLi50aGlzLl9jbGFzc2VzLm9wYWNpdHkuc3BsaXQoXCIgXCIpKSwgbi50YXJnZXQudGV4dENvbnRlbnQsIGMudHJpZ2dlcihpLCBibCwge1xuICAgICAgICAgIGV2ZW50OiBuLFxuICAgICAgICAgIGFsbENoaXBzOiB0aGlzLmFsbENoaXBzXG4gICAgICAgIH0pO1xuICAgICAgfSksIGMub24oZG9jdW1lbnQsIFwiY2xpY2tcIiwgKHsgdGFyZ2V0OiBuIH0pID0+IHtcbiAgICAgICAgY29uc3QgbyA9IGQuZmluZE9uZShjbywgaSksIHIgPSBkLmZpbmRPbmUoT2IsIGkpLCBhID0gbiA9PT0gaSwgbCA9IGkgJiYgaS5jb250YWlucyhuKTtcbiAgICAgICAgIWEgJiYgIWwgJiYgKGkuY29udGVudEVkaXRhYmxlID0gITEsIGkuY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLl9jbGFzc2VzLmNvbnRlbnRFZGl0YWJsZS5zcGxpdChcIiBcIikpLCByLnRleHRDb250ZW50ICE9PSBcIlwiICYmIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGguYWRkU3R5bGUobywgeyBkaXNwbGF5OiBcImJsb2NrXCIgfSksIG8uY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLl9jbGFzc2VzLm9wYWNpdHkuc3BsaXQoXCIgXCIpKTtcbiAgICAgICAgfSwgMTYwKSksIHIudGV4dENvbnRlbnQgPT09IFwiXCIgJiYgKHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGkuY2xhc3NMaXN0LmFkZCguLi50aGlzLl9jbGFzc2VzLm9wYWNpdHkuc3BsaXQoXCIgXCIpKTtcbiAgICAgICAgfSwgMjAwKSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaS5yZW1vdmUoKTtcbiAgICAgICAgfSwgMzAwKSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBfaGFuZGxlUmVtb3ZlQWN0aXZlQ2xhc3MoKSB7XG4gICAgdGhpcy5hbGxDaGlwcy5mb3JFYWNoKChlKSA9PiBlLnJlbW92ZUF0dHJpYnV0ZShtdCkpO1xuICB9XG4gIF9oYW5kbGVBZGRBY3RpdmVDbGFzcygpIHtcbiAgICB0aGlzLmFsbENoaXBzLmZvckVhY2goKGUpID0+IGUuc2V0QXR0cmlidXRlKG10LCBcIlwiKSk7XG4gIH1cbiAgX2hhbmRsZVJpZ2h0S2V5Ym9hcmRBcnJvdyhlKSB7XG4gICAgdGhpcy5faGFuZGxlUmVtb3ZlQWN0aXZlQ2xhc3MoKSwgZSA9PT0gMCAmJiAoZSA9IDEpLCB0aGlzLl9oYW5kbGVBZGRBY3RpdmVDbGFzc1dpdGhLZWJ5Ym9hcmQoZSk7XG4gIH1cbiAgX2hhbmRsZUxlZnRLZXlib2FyZEFycm93KGUpIHtcbiAgICB0aGlzLl9oYW5kbGVSZW1vdmVBY3RpdmVDbGFzcygpLCB0aGlzLl9oYW5kbGVBZGRBY3RpdmVDbGFzc1dpdGhLZWJ5Ym9hcmQoZSk7XG4gIH1cbiAgX2hhbmRsZUFjdGl2ZUNoaXBBZnRlclJlbW92ZShlKSB7XG4gICAgY29uc3QgaSA9IGUgPT09IDAgPyAxIDogZSAtIDE7XG4gICAgcmV0dXJuIHRoaXMuYWxsQ2hpcHNbaV07XG4gIH1cbiAgX2hhbmRsZUNsaWNrc09uQ2hpcHMoKSB7XG4gICAgYy5vbih0aGlzLl9lbGVtZW50LCBcImNsaWNrXCIsICgpID0+IHtcbiAgICAgIHRoaXMuYWxsQ2hpcHMubGVuZ3RoID09PSAwICYmICh0aGlzLmNoaXBzSW5wdXRXcmFwcGVyLmNsYXNzTGlzdC5yZW1vdmUoXG4gICAgICAgIC4uLnRoaXMuX2NsYXNzZXMuaW5wdXRXcmFwcGVyUGFkZGluZy5zcGxpdChcIiBcIilcbiAgICAgICksIHRoaXMuaW5wdXQucmVtb3ZlQXR0cmlidXRlKG10KSk7XG4gICAgfSk7XG4gIH1cbiAgX2hhbmRsZVRleHRDb250ZW50KCkge1xuICAgIGNvbnN0IGUgPSBbXTtcbiAgICByZXR1cm4gdGhpcy5hbGxDaGlwcy5mb3JFYWNoKChpKSA9PiBlLnB1c2goeyB0YWc6IGkudGV4dENvbnRlbnQudHJpbSgpIH0pKSwgZTtcbiAgfVxuICBfaGFuZGxlRXZlbnRzKGUsIGkpIHtcbiAgICBjb25zdCBuID0gdGhpcy5faGFuZGxlVGV4dENvbnRlbnQoKSwgbyA9IHRoaXMuYWxsQ2hpcHMuZmlsdGVyKFxuICAgICAgKHIpID0+IHIuaGFzQXR0cmlidXRlKG10KSAmJiByXG4gICAgKTtcbiAgICBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgaSwge1xuICAgICAgZXZlbnQ6IGUsXG4gICAgICBhbGxDaGlwczogdGhpcy5hbGxDaGlwcyxcbiAgICAgIGFyck9mT2JqZWN0czogbixcbiAgICAgIGFjdGl2ZTogbyxcbiAgICAgIGFjdGl2ZU9iajoge1xuICAgICAgICB0YWc6IG8ubGVuZ3RoIDw9IDAgPyBcIlwiIDogb1swXS50ZXh0Q29udGVudC50cmltKClcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBfaGFuZGxlQ2hpcHNGb2N1cygpIHtcbiAgICBjLm9uKHRoaXMuX2VsZW1lbnQsIFwiY2xpY2tcIiwgKHsgdGFyZ2V0OiB7IGF0dHJpYnV0ZXM6IGUgfSB9KSA9PiB7XG4gICAgICBjb25zdCBpID0gWy4uLmVdO1xuICAgICAgaS5pbmNsdWRlcyhXbykgfHwgaS5pbmNsdWRlcyhsaCkgfHwgaS5pbmNsdWRlcyhjaCkgfHwgdGhpcy5pbnB1dC5mb2N1cygpO1xuICAgIH0pO1xuICB9XG4gIF9oYW5kbGVJbml0aWFsVmFsdWUoKSB7XG4gICAgaWYgKHRoaXMuX2FwcGVuZElucHV0VG9FbGVtZW50KG1sKSwgdGhpcy5fZWxlbWVudC5oYXNBdHRyaWJ1dGUobWwpKSB7XG4gICAgICBjb25zdCB7IGluaXRpYWxWYWx1ZXM6IGUgfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgICBlLmZvckVhY2goXG4gICAgICAgICh7IHRhZzogaSB9KSA9PiB0aGlzLl9oYW5kbGVDcmVhdGVDaGlwKHRoaXMuaW5wdXQsIGkpXG4gICAgICApLCBkLmZpbmRPbmUoXG4gICAgICAgIGhvLFxuICAgICAgICB0aGlzLmlucHV0LnBhcmVudE5vZGVcbiAgICAgICkuc2V0QXR0cmlidXRlKFNlLCBcIlwiKSwgdGhpcy5pbnB1dC5zZXRBdHRyaWJ1dGUobXQsIFwiXCIpLCB0aGlzLmlucHV0LnNldEF0dHJpYnV0ZShTZSwgXCJcIik7XG4gICAgfVxuICAgIHRoaXMuYWxsQ2hpcHMubGVuZ3RoID4gMCAmJiAodGhpcy5jaGlwc0lucHV0V3JhcHBlci5jbGFzc0xpc3QuYWRkKFxuICAgICAgLi4udGhpcy5fY2xhc3Nlcy5pbnB1dFdyYXBwZXJQYWRkaW5nLnNwbGl0KFwiIFwiKVxuICAgICksIHRoaXMuY2hpcHNJbnB1dFdyYXBwZXIuY2xhc3NMaXN0LmFkZChcbiAgICAgIC4uLnRoaXMuX2NsYXNzZXMudHJhbnNpdGlvbi5zcGxpdChcIiBcIilcbiAgICApKTtcbiAgfVxuICBfaGFuZGxlS2V5c0lucHV0VG9FbGVtZW50KGUpIHtcbiAgICBjb25zdCB7IGtleUNvZGU6IGksIHRhcmdldDogbiB9ID0gZTtcbiAgICBpZiAobi5oYXNBdHRyaWJ1dGUoV28pKSB7XG4gICAgICBjb25zdCBvID0gZC5maW5kT25lKGNvLCBuKTtcbiAgICAgIGkgPT09IGN0ICYmIChuLmNvbnRlbnRFZGl0YWJsZSA9ICExLCBuLmNsYXNzTGlzdC5yZW1vdmUoLi4udGhpcy5fY2xhc3Nlcy5jb250ZW50RWRpdGFibGUuc3BsaXQoXCIgXCIpKSwgbi50ZXh0Q29udGVudCAhPT0gXCJcIiA/IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBoLmFkZFN0eWxlKG8sIHsgZGlzcGxheTogXCJibG9ja1wiIH0pLCBvLmNsYXNzTGlzdC5yZW1vdmUoLi4udGhpcy5fY2xhc3Nlcy5vcGFjaXR5LnNwbGl0KFwiIFwiKSk7XG4gICAgICB9LCAxNjApIDogbi50ZXh0Q29udGVudCA9PT0gXCJcIiAmJiAoc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIG4uY2xhc3NMaXN0LmFkZCguLi50aGlzLl9jbGFzc2VzLm9wYWNpdHkuc3BsaXQoXCIgXCIpKTtcbiAgICAgIH0sIDIwMCksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBuLnJlbW92ZSgpO1xuICAgICAgfSwgMzAwKSkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaSA9PT0gY3QpIHtcbiAgICAgIGlmIChuLnZhbHVlID09PSBcIlwiKVxuICAgICAgICByZXR1cm47XG4gICAgICB0aGlzLl9oYW5kbGVDcmVhdGVDaGlwKG4sIG4udmFsdWUpLCB0aGlzLl9oYW5kbGVSZW1vdmVBY3RpdmVDbGFzcygpLCB0aGlzLm51bWJlckNsaWNrcyA9IHRoaXMuYWxsQ2hpcHMubGVuZ3RoICsgMSwgdGhpcy5faGFuZGxlRXZlbnRzKGUsIE5iKTtcbiAgICB9XG4gICAgdGhpcy5hbGxDaGlwcy5sZW5ndGggPiAwID8gKHRoaXMuY2hpcHNJbnB1dFdyYXBwZXIuY2xhc3NMaXN0LmFkZChcbiAgICAgIC4uLnRoaXMuX2NsYXNzZXMuaW5wdXRXcmFwcGVyUGFkZGluZy5zcGxpdChcIiBcIilcbiAgICApLCB0aGlzLmNoaXBzSW5wdXRXcmFwcGVyLmNsYXNzTGlzdC5hZGQoXG4gICAgICAuLi50aGlzLl9jbGFzc2VzLnRyYW5zaXRpb24uc3BsaXQoXCIgXCIpXG4gICAgKSkgOiB0aGlzLmNoaXBzSW5wdXRXcmFwcGVyLmNsYXNzTGlzdC5yZW1vdmUoXG4gICAgICAuLi50aGlzLl9jbGFzc2VzLmlucHV0V3JhcHBlclBhZGRpbmcuc3BsaXQoXCIgXCIpXG4gICAgKTtcbiAgfVxuICBfaGFuZGxlSW5wdXRUZXh0KCkge1xuICAgIGNvbnN0IGUgPSBkLmZpbmRPbmUoXG4gICAgICBTYixcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApO1xuICAgIGMub24oXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgXCJrZXl1cFwiLFxuICAgICAgZSxcbiAgICAgIChpKSA9PiB0aGlzLl9oYW5kbGVLZXlzSW5wdXRUb0VsZW1lbnQoaSlcbiAgICApLCBjLm9uKHRoaXMuaW5wdXQsIFwiYmx1clwiLCAoaSkgPT4gdGhpcy5faGFuZGxlQmx1cklucHV0KGkpKTtcbiAgfVxuICBfYXBwZW5kSW5wdXRUb0VsZW1lbnQoZSkge1xuICAgIGlmICghdGhpcy5fZWxlbWVudC5oYXNBdHRyaWJ1dGUoZSkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgaSA9IHBiKHRoaXMuX29wdGlvbnMsIHRoaXMuX2NsYXNzZXMpO1xuICAgIHRoaXMuX2VsZW1lbnQuaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYmVmb3JlZW5kXCIsIGkpO1xuICAgIGNvbnN0IG4gPSBkLmZpbmRPbmUoXG4gICAgICBcIltkYXRhLXRlLWNoaXBzLWlucHV0LXdyYXBwZXJdXCIsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKTtcbiAgICB0aGlzLl9pbnB1dEluc3RhbmNlID0gbmV3IFYoXG4gICAgICBuLFxuICAgICAgdGhpcy5fb3B0aW9ucy5pbnB1dE9wdGlvbnMsXG4gICAgICB0aGlzLl9vcHRpb25zLmlucHV0Q2xhc3Nlc1xuICAgICk7XG4gIH1cbiAgX2hhbmRsZUNyZWF0ZUNoaXAoZSwgaSkge1xuICAgIGNvbnN0IG4gPSAkKFwiZGl2XCIpLCBvID0gX2kuZ2V0SW5zdGFuY2UobiksIHIgPSBuZXcgX2kobywgeyB0ZXh0OiBpIH0sIHRoaXMuX2NsYXNzZXMpO1xuICAgIHRoaXMuX29wdGlvbnMucGFyZW50U2VsZWN0b3IgIT09IFwiXCIgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRoaXMuX29wdGlvbnMucGFyZW50U2VsZWN0b3IpLmluc2VydEFkamFjZW50SFRNTChcImJlZm9yZWVuZFwiLCByLmFwcGVuZENoaXAoKSkgOiBlLmluc2VydEFkamFjZW50SFRNTChcImJlZm9yZWJlZ2luXCIsIHIuYXBwZW5kQ2hpcCgpKSwgZS52YWx1ZSA9IFwiXCIsIGQuZmluZChGbykuZm9yRWFjaCgoYSkgPT4ge1xuICAgICAgbGV0IGwgPSBfaS5nZXRJbnN0YW5jZShhKTtcbiAgICAgIHJldHVybiBsIHx8IChsID0gbmV3IF9pKGEsIHt9LCB0aGlzLl9jbGFzc2VzKSksIGwuaW5pdCgpO1xuICAgIH0pLCB0aGlzLl9oYW5kbGVFZGl0YWJsZSgpO1xuICB9XG4gIF9oYW5kbGVDaGlwc09uU2VsZWN0KCkge1xuICAgIHRoaXMuYWxsQ2hpcHMuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgYy5vbih0aGlzLl9lbGVtZW50LCBcImNsaWNrXCIsIChpKSA9PiB7XG4gICAgICAgIGMudHJpZ2dlcihlLCBibCwge1xuICAgICAgICAgIGV2ZW50OiBpLFxuICAgICAgICAgIGFsbENoaXBzOiB0aGlzLmFsbENoaXBzXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgX2hhbmRsZUFkZEFjdGl2ZUNsYXNzV2l0aEtlYnlib2FyZChlKSB7XG4gICAgbGV0IGk7XG4gICAgdGhpcy5hbGxDaGlwc1tlIC0gMV0gPT09IHZvaWQgMCA/IGkgPSB0aGlzLmFsbENoaXBzW2UgLSAyXSA6IGkgPSB0aGlzLmFsbENoaXBzW2UgLSAxXSwgaS5zZXRBdHRyaWJ1dGUobXQpO1xuICB9XG4gIF9nZXRDb25maWcoZSkge1xuICAgIGNvbnN0IGkgPSB7XG4gICAgICAuLi5WYixcbiAgICAgIC4uLmguZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCksXG4gICAgICAuLi5lXG4gICAgfTtcbiAgICByZXR1cm4gRChMaSwgaSwgSGIpLCBpO1xuICB9XG4gIF9nZXRDbGFzc2VzKGUpIHtcbiAgICBjb25zdCBpID0gaC5nZXREYXRhQ2xhc3NBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiBlID0ge1xuICAgICAgLi4uV2IsXG4gICAgICAuLi5pLFxuICAgICAgLi4uZVxuICAgIH0sIEQoTGksIGUsIEZiKSwgZTtcbiAgfVxuICBzdGF0aWMgZ2V0SW5zdGFuY2UoZSkge1xuICAgIHJldHVybiB5LmdldERhdGEoZSwgZmwpO1xuICB9XG4gIHN0YXRpYyBnZXRPckNyZWF0ZUluc3RhbmNlKGUsIGkgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKGUpIHx8IG5ldyB0aGlzKGUsIHR5cGVvZiBpID09IFwib2JqZWN0XCIgPyBpIDogbnVsbCk7XG4gIH1cbn1cbmNvbnN0IHp0ID0ge1xuICBwbHVnaW5zOiB7XG4gICAgbGVnZW5kOiB7XG4gICAgICBsYWJlbHM6IHtcbiAgICAgICAgY29sb3I6IFwicmdiKDEwMiwxMDIsMTAyKVwiXG4gICAgICB9XG4gICAgfVxuICB9XG59LCBUaSA9IHtcbiAgbGluZToge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgIC4uLnp0LFxuICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgbGluZToge1xuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCJyZ2JhKDU5LCAxMTIsIDIwMiwgMC4wKVwiLFxuICAgICAgICAgIGJvcmRlckNvbG9yOiBcInJnYig1OSwgMTEyLCAyMDIpXCIsXG4gICAgICAgICAgYm9yZGVyV2lkdGg6IDIsXG4gICAgICAgICAgdGVuc2lvbjogMFxuICAgICAgICB9LFxuICAgICAgICBwb2ludDoge1xuICAgICAgICAgIGJvcmRlckNvbG9yOiBcInJnYig1OSwgMTEyLCAyMDIpXCIsXG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcInJnYig1OSwgMTEyLCAyMDIpXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJlc3BvbnNpdmU6ICEwLFxuICAgICAgbGVnZW5kOiB7XG4gICAgICAgIGRpc3BsYXk6ICEwXG4gICAgICB9LFxuICAgICAgdG9vbHRpcHM6IHtcbiAgICAgICAgaW50ZXJzZWN0OiAhMSxcbiAgICAgICAgbW9kZTogXCJpbmRleFwiXG4gICAgICB9LFxuICAgICAgZGF0YXNldHM6IHtcbiAgICAgICAgYm9yZGVyQ29sb3I6IFwicmVkXCJcbiAgICAgIH0sXG4gICAgICBzY2FsZXM6IHtcbiAgICAgICAgeDoge1xuICAgICAgICAgIHN0YWNrZWQ6ICEwLFxuICAgICAgICAgIGdyaWQ6IHtcbiAgICAgICAgICAgIGRpc3BsYXk6ICExXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0aWNrczoge1xuICAgICAgICAgICAgZm9udENvbG9yOiBcInJnYmEoMCwwLDAsIDAuNSlcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgeToge1xuICAgICAgICAgIHN0YWNrZWQ6ICExLFxuICAgICAgICAgIGdyaWQ6IHtcbiAgICAgICAgICAgIGJvcmRlckRhc2g6IFsyXSxcbiAgICAgICAgICAgIGRyYXdCb3JkZXI6ICExLFxuICAgICAgICAgICAgemVyb0xpbmVDb2xvcjogXCJyZ2JhKDAsMCwwLDApXCIsXG4gICAgICAgICAgICB6ZXJvTGluZUJvcmRlckRhc2g6IFsyXSxcbiAgICAgICAgICAgIHplcm9MaW5lQm9yZGVyRGFzaE9mZnNldDogWzJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0aWNrczoge1xuICAgICAgICAgICAgZm9udENvbG9yOiBcInJnYmEoMCwwLDAsIDAuNSlcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgYmFyOiB7XG4gICAgb3B0aW9uczoge1xuICAgICAgLi4uenQsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwicmdiKDU5LCAxMTIsIDIwMilcIixcbiAgICAgIGJvcmRlcldpZHRoOiAwLFxuICAgICAgcmVzcG9uc2l2ZTogITAsXG4gICAgICBsZWdlbmQ6IHtcbiAgICAgICAgZGlzcGxheTogITBcbiAgICAgIH0sXG4gICAgICB0b29sdGlwczoge1xuICAgICAgICBpbnRlcnNlY3Q6ICExLFxuICAgICAgICBtb2RlOiBcImluZGV4XCJcbiAgICAgIH0sXG4gICAgICBzY2FsZXM6IHtcbiAgICAgICAgeDoge1xuICAgICAgICAgIHN0YWNrZWQ6ICEwLFxuICAgICAgICAgIGdyaWQ6IHtcbiAgICAgICAgICAgIGRpc3BsYXk6ICExXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0aWNrczoge1xuICAgICAgICAgICAgZm9udENvbG9yOiBcInJnYmEoMCwwLDAsIDAuNSlcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgeToge1xuICAgICAgICAgIHN0YWNrZWQ6ICEwLFxuICAgICAgICAgIGdyaWQ6IHtcbiAgICAgICAgICAgIGJvcmRlckRhc2g6IFsyXSxcbiAgICAgICAgICAgIGRyYXdCb3JkZXI6ICExLFxuICAgICAgICAgICAgemVyb0xpbmVDb2xvcjogXCJyZ2JhKDAsMCwwLDApXCIsXG4gICAgICAgICAgICB6ZXJvTGluZUJvcmRlckRhc2g6IFsyXSxcbiAgICAgICAgICAgIHplcm9MaW5lQm9yZGVyRGFzaE9mZnNldDogWzJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0aWNrczoge1xuICAgICAgICAgICAgZm9udENvbG9yOiBcInJnYmEoMCwwLDAsIDAuNSlcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgcGllOiB7XG4gICAgb3B0aW9uczoge1xuICAgICAgLi4uenQsXG4gICAgICBlbGVtZW50czoge1xuICAgICAgICBhcmM6IHsgYmFja2dyb3VuZENvbG9yOiBcInJnYig1OSwgMTEyLCAyMDIpXCIgfVxuICAgICAgfSxcbiAgICAgIHJlc3BvbnNpdmU6ICEwLFxuICAgICAgbGVnZW5kOiB7XG4gICAgICAgIGRpc3BsYXk6ICEwXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBkb3VnaG51dDoge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgIC4uLnp0LFxuICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgYXJjOiB7IGJhY2tncm91bmRDb2xvcjogXCJyZ2IoNTksIDExMiwgMjAyKVwiIH1cbiAgICAgIH0sXG4gICAgICByZXNwb25zaXZlOiAhMCxcbiAgICAgIGxlZ2VuZDoge1xuICAgICAgICBkaXNwbGF5OiAhMFxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgcG9sYXJBcmVhOiB7XG4gICAgb3B0aW9uczoge1xuICAgICAgLi4uenQsXG4gICAgICBlbGVtZW50czoge1xuICAgICAgICBhcmM6IHsgYmFja2dyb3VuZENvbG9yOiBcInJnYmEoNTksIDExMiwgMjAyLCAwLjUpXCIgfVxuICAgICAgfSxcbiAgICAgIHJlc3BvbnNpdmU6ICEwLFxuICAgICAgbGVnZW5kOiB7XG4gICAgICAgIGRpc3BsYXk6ICEwXG4gICAgICB9XG4gICAgfVxuICB9LFxuICByYWRhcjoge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgIC4uLnp0LFxuICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgbGluZToge1xuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCJyZ2JhKDU5LCAxMTIsIDIwMiwgMC41KVwiLFxuICAgICAgICAgIGJvcmRlckNvbG9yOiBcInJnYig1OSwgMTEyLCAyMDIpXCIsXG4gICAgICAgICAgYm9yZGVyV2lkdGg6IDJcbiAgICAgICAgfSxcbiAgICAgICAgcG9pbnQ6IHtcbiAgICAgICAgICBib3JkZXJDb2xvcjogXCJyZ2IoNTksIDExMiwgMjAyKVwiLFxuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCJyZ2IoNTksIDExMiwgMjAyKVwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICByZXNwb25zaXZlOiAhMCxcbiAgICAgIGxlZ2VuZDoge1xuICAgICAgICBkaXNwbGF5OiAhMFxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgc2NhdHRlcjoge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgIC4uLnp0LFxuICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgbGluZToge1xuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCJyZ2JhKDU5LCAxMTIsIDIwMiwgMC41KVwiLFxuICAgICAgICAgIGJvcmRlckNvbG9yOiBcInJnYig1OSwgMTEyLCAyMDIpXCIsXG4gICAgICAgICAgYm9yZGVyV2lkdGg6IDIsXG4gICAgICAgICAgdGVuc2lvbjogMFxuICAgICAgICB9LFxuICAgICAgICBwb2ludDoge1xuICAgICAgICAgIGJvcmRlckNvbG9yOiBcInJnYig1OSwgMTEyLCAyMDIpXCIsXG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcInJnYmEoNTksIDExMiwgMjAyLCAwLjUpXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJlc3BvbnNpdmU6ICEwLFxuICAgICAgbGVnZW5kOiB7XG4gICAgICAgIGRpc3BsYXk6ICEwXG4gICAgICB9LFxuICAgICAgdG9vbHRpcHM6IHtcbiAgICAgICAgaW50ZXJzZWN0OiAhMSxcbiAgICAgICAgbW9kZTogXCJpbmRleFwiXG4gICAgICB9LFxuICAgICAgZGF0YXNldHM6IHtcbiAgICAgICAgYm9yZGVyQ29sb3I6IFwicmVkXCJcbiAgICAgIH0sXG4gICAgICBzY2FsZXM6IHtcbiAgICAgICAgeDoge1xuICAgICAgICAgIHN0YWNrZWQ6ICEwLFxuICAgICAgICAgIGdyaWQ6IHtcbiAgICAgICAgICAgIGRpc3BsYXk6ICExXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0aWNrczoge1xuICAgICAgICAgICAgZm9udENvbG9yOiBcInJnYmEoMCwwLDAsIDAuNSlcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgeToge1xuICAgICAgICAgIHN0YWNrZWQ6ICExLFxuICAgICAgICAgIGdyaWQ6IHtcbiAgICAgICAgICAgIGJvcmRlckRhc2g6IFsyXSxcbiAgICAgICAgICAgIGRyYXdCb3JkZXI6ICExLFxuICAgICAgICAgICAgemVyb0xpbmVDb2xvcjogXCJyZ2JhKDAsMCwwLDApXCIsXG4gICAgICAgICAgICB6ZXJvTGluZUJvcmRlckRhc2g6IFsyXSxcbiAgICAgICAgICAgIHplcm9MaW5lQm9yZGVyRGFzaE9mZnNldDogWzJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0aWNrczoge1xuICAgICAgICAgICAgZm9udENvbG9yOiBcInJnYmEoMCwwLDAsIDAuNSlcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgYnViYmxlOiB7XG4gICAgb3B0aW9uczoge1xuICAgICAgLi4uenQsXG4gICAgICBlbGVtZW50czoge1xuICAgICAgICBwb2ludDoge1xuICAgICAgICAgIGJvcmRlckNvbG9yOiBcInJnYig1OSwgMTEyLCAyMDIpXCIsXG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcInJnYmEoNTksIDExMiwgMjAyLCAwLjUpXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJlc3BvbnNpdmU6ICEwLFxuICAgICAgbGVnZW5kOiB7XG4gICAgICAgIGRpc3BsYXk6ICEwXG4gICAgICB9LFxuICAgICAgc2NhbGVzOiB7XG4gICAgICAgIHg6IHtcbiAgICAgICAgICBncmlkOiB7XG4gICAgICAgICAgICBkaXNwbGF5OiAhMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdGlja3M6IHtcbiAgICAgICAgICAgIGZvbnRDb2xvcjogXCJyZ2JhKDAsMCwwLCAwLjUpXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHk6IHtcbiAgICAgICAgICBncmlkOiB7XG4gICAgICAgICAgICBib3JkZXJEYXNoOiBbMl0sXG4gICAgICAgICAgICBkcmF3Qm9yZGVyOiAhMSxcbiAgICAgICAgICAgIHplcm9MaW5lQ29sb3I6IFwicmdiYSgwLDAsMCwwKVwiLFxuICAgICAgICAgICAgemVyb0xpbmVCb3JkZXJEYXNoOiBbMl0sXG4gICAgICAgICAgICB6ZXJvTGluZUJvcmRlckRhc2hPZmZzZXQ6IFsyXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdGlja3M6IHtcbiAgICAgICAgICAgIGZvbnRDb2xvcjogXCJyZ2JhKDAsMCwwLCAwLjUpXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG52YXIgWWIgPSBmdW5jdGlvbih0KSB7XG4gIHJldHVybiBqYih0KSAmJiAhS2IodCk7XG59O1xuZnVuY3Rpb24gamIocykge1xuICByZXR1cm4gISFzICYmIHR5cGVvZiBzID09IFwib2JqZWN0XCI7XG59XG5mdW5jdGlvbiBLYihzKSB7XG4gIHZhciB0ID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHMpO1xuICByZXR1cm4gdCA9PT0gXCJbb2JqZWN0IFJlZ0V4cF1cIiB8fCB0ID09PSBcIltvYmplY3QgRGF0ZV1cIiB8fCBYYihzKTtcbn1cbnZhciB6YiA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5mb3IsIFViID0gemIgPyBTeW1ib2wuZm9yKFwicmVhY3QuZWxlbWVudFwiKSA6IDYwMTAzO1xuZnVuY3Rpb24gWGIocykge1xuICByZXR1cm4gcy4kJHR5cGVvZiA9PT0gVWI7XG59XG5mdW5jdGlvbiBHYihzKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHMpID8gW10gOiB7fTtcbn1cbmZ1bmN0aW9uIEJpKHMsIHQpIHtcbiAgcmV0dXJuIHQuY2xvbmUgIT09ICExICYmIHQuaXNNZXJnZWFibGVPYmplY3QocykgPyBRZShHYihzKSwgcywgdCkgOiBzO1xufVxuZnVuY3Rpb24gcWIocywgdCwgZSkge1xuICByZXR1cm4gcy5jb25jYXQodCkubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICByZXR1cm4gQmkoaSwgZSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gWmIocywgdCkge1xuICBpZiAoIXQuY3VzdG9tTWVyZ2UpXG4gICAgcmV0dXJuIFFlO1xuICB2YXIgZSA9IHQuY3VzdG9tTWVyZ2Uocyk7XG4gIHJldHVybiB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIgPyBlIDogUWU7XG59XG5mdW5jdGlvbiBRYihzKSB7XG4gIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID8gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKS5maWx0ZXIoZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBPYmplY3QucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCB0KTtcbiAgfSkgOiBbXTtcbn1cbmZ1bmN0aW9uIHZsKHMpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHMpLmNvbmNhdChRYihzKSk7XG59XG5mdW5jdGlvbiBoaChzLCB0KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHQgaW4gcztcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuICExO1xuICB9XG59XG5mdW5jdGlvbiBKYihzLCB0KSB7XG4gIHJldHVybiBoaChzLCB0KSAmJiAhKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHQpICYmIE9iamVjdC5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHQpKTtcbn1cbmZ1bmN0aW9uIHR2KHMsIHQsIGUpIHtcbiAgdmFyIGkgPSB7fTtcbiAgcmV0dXJuIGUuaXNNZXJnZWFibGVPYmplY3QocykgJiYgdmwocykuZm9yRWFjaChmdW5jdGlvbihuKSB7XG4gICAgaVtuXSA9IEJpKHNbbl0sIGUpO1xuICB9KSwgdmwodCkuZm9yRWFjaChmdW5jdGlvbihuKSB7XG4gICAgSmIocywgbikgfHwgKGhoKHMsIG4pICYmIGUuaXNNZXJnZWFibGVPYmplY3QodFtuXSkgPyBpW25dID0gWmIobiwgZSkoc1tuXSwgdFtuXSwgZSkgOiBpW25dID0gQmkodFtuXSwgZSkpO1xuICB9KSwgaTtcbn1cbmZ1bmN0aW9uIFFlKHMsIHQsIGUpIHtcbiAgZSA9IGUgfHwge30sIGUuYXJyYXlNZXJnZSA9IGUuYXJyYXlNZXJnZSB8fCBxYiwgZS5pc01lcmdlYWJsZU9iamVjdCA9IGUuaXNNZXJnZWFibGVPYmplY3QgfHwgWWIsIGUuY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQgPSBCaTtcbiAgdmFyIGkgPSBBcnJheS5pc0FycmF5KHQpLCBuID0gQXJyYXkuaXNBcnJheShzKSwgbyA9IGkgPT09IG47XG4gIHJldHVybiBvID8gaSA/IGUuYXJyYXlNZXJnZShzLCB0LCBlKSA6IHR2KHMsIHQsIGUpIDogQmkodCwgZSk7XG59XG5RZS5hbGwgPSBmdW5jdGlvbih0LCBlKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheSh0KSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJmaXJzdCBhcmd1bWVudCBzaG91bGQgYmUgYW4gYXJyYXlcIik7XG4gIHJldHVybiB0LnJlZHVjZShmdW5jdGlvbihpLCBuKSB7XG4gICAgcmV0dXJuIFFlKGksIG4sIGUpO1xuICB9LCB7fSk7XG59O1xudmFyIGV2ID0gUWUsIFlvID0gZXY7XG5jb25zdCBUbCA9IFwiY2hhcnRcIiwgeXMgPSBcInRlLmNoYXJ0XCIsIGl2ID0gXCJjaGFydFwiLCB1byA9IChzLCB0LCBlKSA9PiB7XG4gIGNvbnN0IGkgPSAobiwgbywgcikgPT4ge1xuICAgIGNvbnN0IGEgPSBuLnNsaWNlKCk7XG4gICAgcmV0dXJuIG8uZm9yRWFjaCgobCwgcCkgPT4ge1xuICAgICAgdHlwZW9mIGFbcF0gPiBcInVcIiA/IGFbcF0gPSByLmNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkKFxuICAgICAgICBsLFxuICAgICAgICByXG4gICAgICApIDogci5pc01lcmdlYWJsZU9iamVjdChsKSA/IGFbcF0gPSBZbyhuW3BdLCBsLCByKSA6IG4uaW5kZXhPZihsKSA9PT0gLTEgJiYgYS5wdXNoKGwpO1xuICAgIH0pLCBhO1xuICB9O1xuICByZXR1cm4gWW8oZVt0XSwgcywge1xuICAgIGFycmF5TWVyZ2U6IGlcbiAgfSk7XG59LCBzdiA9IHtcbiAgZGFya1RpY2tzQ29sb3I6IFwiI2ZmZlwiLFxuICBkYXJrTGFiZWxDb2xvcjogXCIjZmZmXCIsXG4gIGRhcmtHcmlkTGluZXNDb2xvcjogXCIjNTU1XCIsXG4gIGRhcmttb2RlT2ZmOiBcInVuZGVmaW5lZFwiLFxuICBkYXJrTW9kZTogbnVsbCxcbiAgZGFya0JnQ29sb3I6IFwiIzI2MjYyNlwiLFxuICBkYXJrQmdDb2xvckxpZ2h0OiBcIiNmZmZcIixcbiAgb3B0aW9uczogbnVsbFxufSwgbnYgPSB7XG4gIGRhcmtUaWNrc0NvbG9yOiBcInN0cmluZ1wiLFxuICBkYXJrTGFiZWxDb2xvcjogXCJzdHJpbmdcIixcbiAgZGFya0dyaWRMaW5lc0NvbG9yOiBcInN0cmluZ1wiLFxuICBkYXJrbW9kZU9mZjogXCIoc3RyaW5nfG51bGwpXCIsXG4gIGRhcmtNb2RlOiBcIihzdHJpbmd8bnVsbClcIixcbiAgZGFya0JnQ29sb3I6IFwic3RyaW5nXCIsXG4gIGRhcmtCZ0NvbG9yTGlnaHQ6IFwic3RyaW5nXCIsXG4gIG9wdGlvbnM6IFwiKG9iamVjdHxudWxsKVwiXG59O1xuY2xhc3MgZGgge1xuICBjb25zdHJ1Y3Rvcih0LCBlLCBpID0ge30sIG4gPSB7fSkge1xuICAgIHRoaXMuX3dhaXRGb3JDaGFydHModCwgZSwgaSwgbik7XG4gIH1cbiAgYXN5bmMgX2dldENoYXJ0anMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgQ2hhcnQ6IHQsXG4gICAgICBBcmNFbGVtZW50OiBlLFxuICAgICAgTGluZUVsZW1lbnQ6IGksXG4gICAgICBCYXJFbGVtZW50OiBuLFxuICAgICAgUG9pbnRFbGVtZW50OiBvLFxuICAgICAgQmFyQ29udHJvbGxlcjogcixcbiAgICAgIEJ1YmJsZUNvbnRyb2xsZXI6IGEsXG4gICAgICBEb3VnaG51dENvbnRyb2xsZXI6IGwsXG4gICAgICBMaW5lQ29udHJvbGxlcjogcCxcbiAgICAgIFBpZUNvbnRyb2xsZXI6IHUsXG4gICAgICBQb2xhckFyZWFDb250cm9sbGVyOiBfLFxuICAgICAgUmFkYXJDb250cm9sbGVyOiBmLFxuICAgICAgU2NhdHRlckNvbnRyb2xsZXI6IGcsXG4gICAgICBDYXRlZ29yeVNjYWxlOiBtLFxuICAgICAgTGluZWFyU2NhbGU6IGIsXG4gICAgICBMb2dhcml0aG1pY1NjYWxlOiB2LFxuICAgICAgUmFkaWFsTGluZWFyU2NhbGU6IEMsXG4gICAgICBUaW1lU2NhbGU6IHcsXG4gICAgICBUaW1lU2VyaWVzU2NhbGU6IEUsXG4gICAgICBEZWNpbWF0aW9uOiBULFxuICAgICAgRmlsbGVyOiBBLFxuICAgICAgTGVnZW5kOiBrLFxuICAgICAgVGl0bGU6IEksXG4gICAgICBUb29sdGlwOiBPLFxuICAgICAgU3ViVGl0bGU6IHhcbiAgICB9ID0gYXdhaXQgaW1wb3J0KFwiLi9jaGFydC5lcy5qc1wiKS50aGVuKChMKSA9PiBMLmYpO1xuICAgIHJldHVybiB0LnJlZ2lzdGVyKFxuICAgICAgZSxcbiAgICAgIGksXG4gICAgICBuLFxuICAgICAgbyxcbiAgICAgIHIsXG4gICAgICBhLFxuICAgICAgbCxcbiAgICAgIHAsXG4gICAgICB1LFxuICAgICAgXyxcbiAgICAgIGYsXG4gICAgICBnLFxuICAgICAgbSxcbiAgICAgIGIsXG4gICAgICB2LFxuICAgICAgQyxcbiAgICAgIHcsXG4gICAgICBFLFxuICAgICAgVCxcbiAgICAgIEEsXG4gICAgICBrLFxuICAgICAgSSxcbiAgICAgIE8sXG4gICAgICB4XG4gICAgKSwgdDtcbiAgfVxuICBhc3luYyBfZ2V0Q2hhcnREYXRhTGFiZWxzKCkge1xuICAgIHJldHVybiBhd2FpdCBpbXBvcnQoXCIuL2NoYXJ0anMtcGx1Z2luLWRhdGFsYWJlbHMuZXMuanNcIik7XG4gIH1cbiAgYXN5bmMgX3dhaXRGb3JDaGFydHModCwgZSwgaSA9IHt9LCBuID0ge30pIHtcbiAgICBpZiAodGhpcy5fQ2hhcnRqcyA9IGF3YWl0IHRoaXMuX2dldENoYXJ0anMoKSwgdGhpcy5fQ2hhcnREYXRhTGFiZWxzID0gYXdhaXQgdGhpcy5fZ2V0Q2hhcnREYXRhTGFiZWxzKCksIHRoaXMuX2VsZW1lbnQgPSB0LCB0aGlzLl9kYXRhID0gZSwgdGhpcy5fb3B0aW9ucyA9IGksIHRoaXMuX3R5cGUgPSBlLnR5cGUsIHRoaXMuX2NhbnZhcyA9IG51bGwsIHRoaXMuX2NoYXJ0ID0gbnVsbCwgdGhpcy5fZGFya09wdGlvbnMgPSB0aGlzLl9nZXREYXJrQ29uZmlnKG4pLCB0aGlzLl9kYXJrTW9kZUNsYXNzQ29udGFpbmVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImh0bWxcIiksIHRoaXMuX3ByZXZDb25maWcgPSBudWxsLCB0aGlzLl9vYnNlcnZlciA9IG51bGwsIHRoaXMuX2VsZW1lbnQgJiYgKHkuc2V0RGF0YSh0LCB5cywgdGhpcyksIGguYWRkQ2xhc3ModGhpcy5fZWxlbWVudCwgaXYpLCB0aGlzLl9jaGFydENvbnN0cnVjdG9yKCkpLCB0aGlzLl9kYXJrT3B0aW9ucy5kYXJrbW9kZU9mZiAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgbyA9IHRoaXMuX2RhcmtPcHRpb25zLmRhcmtNb2RlID09PSBcImRhcmtcIiA/IFwiZGFya1wiIDogdGhpcy5fZGFya09wdGlvbnMuZGFya01vZGUgPT09IFwibGlnaHRcIiA/IFwibGlnaHRcIiA6IHRoaXMuc3lzdGVtQ29sb3JNb2RlO1xuICAgICAgdGhpcy5faGFuZGxlTW9kZShvKSwgdGhpcy5fb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcih0aGlzLl9vYnNlcnZlckNhbGxiYWNrLmJpbmQodGhpcykpLCB0aGlzLl9vYnNlcnZlci5vYnNlcnZlKHRoaXMuX2RhcmtNb2RlQ2xhc3NDb250YWluZXIsIHtcbiAgICAgICAgYXR0cmlidXRlczogITBcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gVGw7XG4gIH1cbiAgZ2V0IHN5c3RlbUNvbG9yTW9kZSgpIHtcbiAgICByZXR1cm4gbG9jYWxTdG9yYWdlLnRoZW1lIHx8ICh0aGlzLl9kYXJrTW9kZUNsYXNzQ29udGFpbmVyLmNsYXNzTGlzdC5jb250YWlucyhcImRhcmtcIikgPyBcImRhcmtcIiA6IFwibGlnaHRcIik7XG4gIH1cbiAgLy8gUHVibGljXG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5fb2JzZXJ2ZXIuZGlzY29ubmVjdCgpLCB5LnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgeXMpLCB0aGlzLl9lbGVtZW50ID0gbnVsbDtcbiAgfVxuICB1cGRhdGUodCwgZSkge1xuICAgIHQgJiYgKHRoaXMuX2RhdGEgPSB7IC4uLnRoaXMuX2RhdGEsIC4uLnQgfSwgdGhpcy5fY2hhcnQuZGF0YSA9IHRoaXMuX2RhdGEpO1xuICAgIGNvbnN0IGkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoXG4gICAgICBlLFxuICAgICAgXCJvcHRpb25zXCJcbiAgICApID8gZSA6IHsgb3B0aW9uczogeyAuLi5lIH0gfTtcbiAgICB0aGlzLl9vcHRpb25zID0gWW8odGhpcy5fb3B0aW9ucywgaSksIHRoaXMuX2NoYXJ0Lm9wdGlvbnMgPSB1byhcbiAgICAgIHRoaXMuX29wdGlvbnMsXG4gICAgICB0aGlzLl90eXBlLFxuICAgICAgVGlcbiAgICApLm9wdGlvbnMsIHRoaXMuX2NoYXJ0LnVwZGF0ZSgpO1xuICB9XG4gIHNldFRoZW1lKHQpIHtcbiAgICB0ICE9PSBcImRhcmtcIiAmJiB0ICE9PSBcImxpZ2h0XCIgfHwgIXRoaXMuX2RhdGEgfHwgdGhpcy5faGFuZGxlTW9kZSh0KTtcbiAgfVxuICAvLyBQcml2YXRlXG4gIF9nZXREYXJrQ29uZmlnKHQpIHtcbiAgICBsZXQgZSA9IHt9O1xuICAgIGNvbnN0IGkgPSBoLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIE9iamVjdC5rZXlzKGkpLmZvckVhY2goXG4gICAgICAocCkgPT4gcC5zdGFydHNXaXRoKFwiZGFya1wiKSAmJiAoZVtwXSA9IGlbcF0pXG4gICAgKSwgZSA9IHtcbiAgICAgIC4uLnN2LFxuICAgICAgLi4uZVxuICAgIH07XG4gICAgY29uc3QgbiA9IHtcbiAgICAgIHk6IHtcbiAgICAgICAgdGlja3M6IHtcbiAgICAgICAgICBjb2xvcjogZS5kYXJrVGlja3NDb2xvclxuICAgICAgICB9LFxuICAgICAgICBncmlkOiB7XG4gICAgICAgICAgY29sb3I6IGUuZGFya0dyaWRMaW5lc0NvbG9yXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB4OiB7XG4gICAgICAgIHRpY2tzOiB7XG4gICAgICAgICAgY29sb3I6IGUuZGFya1RpY2tzQ29sb3JcbiAgICAgICAgfSxcbiAgICAgICAgZ3JpZDoge1xuICAgICAgICAgIGNvbG9yOiBlLmRhcmtHcmlkTGluZXNDb2xvclxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgbyA9IHtcbiAgICAgIHI6IHtcbiAgICAgICAgdGlja3M6IHtcbiAgICAgICAgICBjb2xvcjogZS5kYXJrVGlja3NDb2xvcixcbiAgICAgICAgICBiYWNrZHJvcENvbG9yOiBlLmRhcmtCZ0NvbG9yXG4gICAgICAgIH0sXG4gICAgICAgIGdyaWQ6IHtcbiAgICAgICAgICBjb2xvcjogZS5kYXJrR3JpZExpbmVzQ29sb3JcbiAgICAgICAgfSxcbiAgICAgICAgcG9pbnRMYWJlbHM6IHtcbiAgICAgICAgICBjb2xvcjogZS5kYXJrVGlja3NDb2xvclxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgbCA9IHtcbiAgICAgIHNjYWxlczogW1wicGllXCIsIFwiZG91Z2hudXRcIiwgXCJwb2xhckFyZWFcIiwgXCJyYWRhclwiXS5pbmNsdWRlcyh0aGlzLl90eXBlKSA/IFtcInBvbGFyQXJlYVwiLCBcInJhZGFyXCJdLmluY2x1ZGVzKHRoaXMuX3R5cGUpID8gbyA6IHt9IDogbixcbiAgICAgIHBsdWdpbnM6IHtcbiAgICAgICAgbGVnZW5kOiB7XG4gICAgICAgICAgbGFiZWxzOiB7XG4gICAgICAgICAgICBjb2xvcjogZS5kYXJrTGFiZWxDb2xvclxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5lLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICAuLi5sXG4gICAgICB9LFxuICAgICAgLi4udFxuICAgIH0sIEQoVGwsIHQsIG52KSwgdDtcbiAgfVxuICBfY2hhcnRDb25zdHJ1Y3RvcigpIHtcbiAgICBpZiAodGhpcy5fZGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlQ2FudmFzKCk7XG4gICAgICBjb25zdCB0ID0gdW8odGhpcy5fb3B0aW9ucywgdGhpcy5fdHlwZSwgVGkpLCBlID0gW107XG4gICAgICB0LmRhdGFMYWJlbHNQbHVnaW4gJiYgZS5wdXNoKHRoaXMuX0NoYXJ0RGF0YUxhYmVscy5kZWZhdWx0KSwgdGhpcy5fcHJldkNvbmZpZyA9IHQsIHRoaXMuX2NoYXJ0ID0gbmV3IHRoaXMuX0NoYXJ0anModGhpcy5fY2FudmFzLCB7XG4gICAgICAgIC4uLnRoaXMuX2RhdGEsXG4gICAgICAgIC4uLnQsXG4gICAgICAgIHBsdWdpbnM6IGVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBfY3JlYXRlQ2FudmFzKCkge1xuICAgIHRoaXMuX2NhbnZhcyB8fCAodGhpcy5fZWxlbWVudC5ub2RlTmFtZSA9PT0gXCJDQU5WQVNcIiA/IHRoaXMuX2NhbnZhcyA9IHRoaXMuX2VsZW1lbnQgOiAodGhpcy5fY2FudmFzID0gJChcImNhbnZhc1wiKSwgdGhpcy5fZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9jYW52YXMpKSk7XG4gIH1cbiAgX2hhbmRsZU1vZGUodCkge1xuICAgIHQgPT09IFwiZGFya1wiID8gKHRoaXMuX2NoYW5nZURhdGFzZXRCb3JkZXJDb2xvcigpLCB0aGlzLnVwZGF0ZShudWxsLCB0aGlzLl9kYXJrT3B0aW9ucy5vcHRpb25zKSkgOiAodGhpcy5fY2hhbmdlRGF0YXNldEJvcmRlckNvbG9yKCExKSwgdGhpcy5fcHJldkNvbmZpZyAmJiB0aGlzLnVwZGF0ZShudWxsLCB0aGlzLl9wcmV2Q29uZmlnKSk7XG4gIH1cbiAgX29ic2VydmVyQ2FsbGJhY2sodCkge1xuICAgIGZvciAoY29uc3QgZSBvZiB0KVxuICAgICAgZS50eXBlID09PSBcImF0dHJpYnV0ZXNcIiAmJiB0aGlzLl9oYW5kbGVNb2RlKHRoaXMuc3lzdGVtQ29sb3JNb2RlKTtcbiAgfVxuICBfY2hhbmdlRGF0YXNldEJvcmRlckNvbG9yKHQgPSAhMCkge1xuICAgIFsuLi50aGlzLl9kYXRhLmRhdGEuZGF0YXNldHNdLmZvckVhY2goXG4gICAgICAoZSkgPT4gW1wicGllXCIsIFwiZG91Z2hudXRcIiwgXCJwb2xhckFyZWFcIl0uaW5jbHVkZXModGhpcy5fdHlwZSkgJiYgKGUuYm9yZGVyQ29sb3IgPSB0ID8gdGhpcy5fZGFya09wdGlvbnMuZGFya0JnQ29sb3IgOiB0aGlzLl9kYXJrT3B0aW9ucy5kYXJrQmdDb2xvckxpZ2h0KVxuICAgICk7XG4gIH1cbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0LCBlLCBpKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGxldCBuID0geS5nZXREYXRhKHRoaXMsIHlzKTtcbiAgICAgIGlmICghKCFuICYmIC9kaXNwb3NlLy50ZXN0KHQpKSkge1xuICAgICAgICBpZiAoIW4pIHtcbiAgICAgICAgICBjb25zdCBvID0gZSA/IHVvKGUsIGksIFRpKSA6IFRpW2ldO1xuICAgICAgICAgIG4gPSBuZXcgZGgodGhpcywge1xuICAgICAgICAgICAgLi4udCxcbiAgICAgICAgICAgIC4uLm9cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHQgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGlmICh0eXBlb2Ygblt0XSA+IFwidVwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgICAgblt0XShlLCBpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBnZXRJbnN0YW5jZSh0KSB7XG4gICAgcmV0dXJuIHkuZ2V0RGF0YSh0LCB5cyk7XG4gIH1cbiAgc3RhdGljIGdldE9yQ3JlYXRlSW5zdGFuY2UodCwgZSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UodCkgfHwgbmV3IHRoaXModCwgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiA/IGUgOiBudWxsKTtcbiAgfVxufVxuLyohXG4gKiBwZXJmZWN0LXNjcm9sbGJhciB2MS41LjNcbiAqIENvcHlyaWdodCAyMDIxIEh5dW5qZSBKdW4sIE1EQm9vdHN0cmFwIGFuZCBDb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVFxuICovXG5mdW5jdGlvbiBMdChzKSB7XG4gIHJldHVybiBnZXRDb21wdXRlZFN0eWxlKHMpO1xufVxuZnVuY3Rpb24gb3QocywgdCkge1xuICBmb3IgKHZhciBlIGluIHQpIHtcbiAgICB2YXIgaSA9IHRbZV07XG4gICAgdHlwZW9mIGkgPT0gXCJudW1iZXJcIiAmJiAoaSA9IGkgKyBcInB4XCIpLCBzLnN0eWxlW2VdID0gaTtcbiAgfVxuICByZXR1cm4gcztcbn1cbmZ1bmN0aW9uIHdzKHMpIHtcbiAgdmFyIHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICByZXR1cm4gdC5jbGFzc05hbWUgPSBzLCB0O1xufVxudmFyIEVsID0gdHlwZW9mIEVsZW1lbnQgPCBcInVcIiAmJiAoRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcyB8fCBFbGVtZW50LnByb3RvdHlwZS53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHwgRWxlbWVudC5wcm90b3R5cGUubW96TWF0Y2hlc1NlbGVjdG9yIHx8IEVsZW1lbnQucHJvdG90eXBlLm1zTWF0Y2hlc1NlbGVjdG9yKTtcbmZ1bmN0aW9uIFF0KHMsIHQpIHtcbiAgaWYgKCFFbClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBlbGVtZW50IG1hdGNoaW5nIG1ldGhvZCBzdXBwb3J0ZWRcIik7XG4gIHJldHVybiBFbC5jYWxsKHMsIHQpO1xufVxuZnVuY3Rpb24gUGUocykge1xuICBzLnJlbW92ZSA/IHMucmVtb3ZlKCkgOiBzLnBhcmVudE5vZGUgJiYgcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHMpO1xufVxuZnVuY3Rpb24gQ2wocywgdCkge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsKFxuICAgIHMuY2hpbGRyZW4sXG4gICAgZnVuY3Rpb24oZSkge1xuICAgICAgcmV0dXJuIFF0KGUsIHQpO1xuICAgIH1cbiAgKTtcbn1cbnZhciBqID0ge1xuICBtYWluOiBcInBzXCIsXG4gIHJ0bDogXCJwc19fcnRsXCIsXG4gIGVsZW1lbnQ6IHtcbiAgICB0aHVtYjogZnVuY3Rpb24ocykge1xuICAgICAgcmV0dXJuIFwicHNfX3RodW1iLVwiICsgcztcbiAgICB9LFxuICAgIHJhaWw6IGZ1bmN0aW9uKHMpIHtcbiAgICAgIHJldHVybiBcInBzX19yYWlsLVwiICsgcztcbiAgICB9LFxuICAgIGNvbnN1bWluZzogXCJwc19fY2hpbGQtLWNvbnN1bWVcIlxuICB9LFxuICBzdGF0ZToge1xuICAgIGZvY3VzOiBcInBzLS1mb2N1c1wiLFxuICAgIGNsaWNraW5nOiBcInBzLS1jbGlja2luZ1wiLFxuICAgIGFjdGl2ZTogZnVuY3Rpb24ocykge1xuICAgICAgcmV0dXJuIFwicHMtLWFjdGl2ZS1cIiArIHM7XG4gICAgfSxcbiAgICBzY3JvbGxpbmc6IGZ1bmN0aW9uKHMpIHtcbiAgICAgIHJldHVybiBcInBzLS1zY3JvbGxpbmctXCIgKyBzO1xuICAgIH1cbiAgfVxufSwgdWggPSB7IHg6IG51bGwsIHk6IG51bGwgfTtcbmZ1bmN0aW9uIHBoKHMsIHQpIHtcbiAgdmFyIGUgPSBzLmVsZW1lbnQuY2xhc3NMaXN0LCBpID0gai5zdGF0ZS5zY3JvbGxpbmcodCk7XG4gIGUuY29udGFpbnMoaSkgPyBjbGVhclRpbWVvdXQodWhbdF0pIDogZS5hZGQoaSk7XG59XG5mdW5jdGlvbiBfaChzLCB0KSB7XG4gIHVoW3RdID0gc2V0VGltZW91dChcbiAgICBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzLmlzQWxpdmUgJiYgcy5lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoai5zdGF0ZS5zY3JvbGxpbmcodCkpO1xuICAgIH0sXG4gICAgcy5zZXR0aW5ncy5zY3JvbGxpbmdUaHJlc2hvbGRcbiAgKTtcbn1cbmZ1bmN0aW9uIG92KHMsIHQpIHtcbiAgcGgocywgdCksIF9oKHMsIHQpO1xufVxudmFyIHppID0gZnVuY3Rpb24odCkge1xuICB0aGlzLmVsZW1lbnQgPSB0LCB0aGlzLmhhbmRsZXJzID0ge307XG59LCBmaCA9IHsgaXNFbXB0eTogeyBjb25maWd1cmFibGU6ICEwIH0gfTtcbnppLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24odCwgZSkge1xuICB0eXBlb2YgdGhpcy5oYW5kbGVyc1t0XSA+IFwidVwiICYmICh0aGlzLmhhbmRsZXJzW3RdID0gW10pLCB0aGlzLmhhbmRsZXJzW3RdLnB1c2goZSksIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHQsIGUsICExKTtcbn07XG56aS5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24odCwgZSkge1xuICB2YXIgaSA9IHRoaXM7XG4gIHRoaXMuaGFuZGxlcnNbdF0gPSB0aGlzLmhhbmRsZXJzW3RdLmZpbHRlcihmdW5jdGlvbihuKSB7XG4gICAgcmV0dXJuIGUgJiYgbiAhPT0gZSA/ICEwIDogKGkuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHQsIG4sICExKSwgITEpO1xuICB9KTtcbn07XG56aS5wcm90b3R5cGUudW5iaW5kQWxsID0gZnVuY3Rpb24oKSB7XG4gIGZvciAodmFyIHQgaW4gdGhpcy5oYW5kbGVycylcbiAgICB0aGlzLnVuYmluZCh0KTtcbn07XG5maC5pc0VtcHR5LmdldCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcyA9IHRoaXM7XG4gIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmhhbmRsZXJzKS5ldmVyeShcbiAgICBmdW5jdGlvbih0KSB7XG4gICAgICByZXR1cm4gcy5oYW5kbGVyc1t0XS5sZW5ndGggPT09IDA7XG4gICAgfVxuICApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHppLnByb3RvdHlwZSwgZmgpO1xudmFyIHNpID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZXZlbnRFbGVtZW50cyA9IFtdO1xufTtcbnNpLnByb3RvdHlwZS5ldmVudEVsZW1lbnQgPSBmdW5jdGlvbih0KSB7XG4gIHZhciBlID0gdGhpcy5ldmVudEVsZW1lbnRzLmZpbHRlcihmdW5jdGlvbihpKSB7XG4gICAgcmV0dXJuIGkuZWxlbWVudCA9PT0gdDtcbiAgfSlbMF07XG4gIHJldHVybiBlIHx8IChlID0gbmV3IHppKHQpLCB0aGlzLmV2ZW50RWxlbWVudHMucHVzaChlKSksIGU7XG59O1xuc2kucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbih0LCBlLCBpKSB7XG4gIHRoaXMuZXZlbnRFbGVtZW50KHQpLmJpbmQoZSwgaSk7XG59O1xuc2kucHJvdG90eXBlLnVuYmluZCA9IGZ1bmN0aW9uKHQsIGUsIGkpIHtcbiAgdmFyIG4gPSB0aGlzLmV2ZW50RWxlbWVudCh0KTtcbiAgbi51bmJpbmQoZSwgaSksIG4uaXNFbXB0eSAmJiB0aGlzLmV2ZW50RWxlbWVudHMuc3BsaWNlKHRoaXMuZXZlbnRFbGVtZW50cy5pbmRleE9mKG4pLCAxKTtcbn07XG5zaS5wcm90b3R5cGUudW5iaW5kQWxsID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZXZlbnRFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdC51bmJpbmRBbGwoKTtcbiAgfSksIHRoaXMuZXZlbnRFbGVtZW50cyA9IFtdO1xufTtcbnNpLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odCwgZSwgaSkge1xuICB2YXIgbiA9IHRoaXMuZXZlbnRFbGVtZW50KHQpLCBvID0gZnVuY3Rpb24ocikge1xuICAgIG4udW5iaW5kKGUsIG8pLCBpKHIpO1xuICB9O1xuICBuLmJpbmQoZSwgbyk7XG59O1xuZnVuY3Rpb24ga3Mocykge1xuICBpZiAodHlwZW9mIHdpbmRvdy5DdXN0b21FdmVudCA9PSBcImZ1bmN0aW9uXCIpXG4gICAgcmV0dXJuIG5ldyBDdXN0b21FdmVudChzKTtcbiAgdmFyIHQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkN1c3RvbUV2ZW50XCIpO1xuICByZXR1cm4gdC5pbml0Q3VzdG9tRXZlbnQocywgITEsICExLCB2b2lkIDApLCB0O1xufVxuZnVuY3Rpb24gb24ocywgdCwgZSwgaSwgbikge1xuICBpID09PSB2b2lkIDAgJiYgKGkgPSAhMCksIG4gPT09IHZvaWQgMCAmJiAobiA9ICExKTtcbiAgdmFyIG87XG4gIGlmICh0ID09PSBcInRvcFwiKVxuICAgIG8gPSBbXG4gICAgICBcImNvbnRlbnRIZWlnaHRcIixcbiAgICAgIFwiY29udGFpbmVySGVpZ2h0XCIsXG4gICAgICBcInNjcm9sbFRvcFwiLFxuICAgICAgXCJ5XCIsXG4gICAgICBcInVwXCIsXG4gICAgICBcImRvd25cIlxuICAgIF07XG4gIGVsc2UgaWYgKHQgPT09IFwibGVmdFwiKVxuICAgIG8gPSBbXG4gICAgICBcImNvbnRlbnRXaWR0aFwiLFxuICAgICAgXCJjb250YWluZXJXaWR0aFwiLFxuICAgICAgXCJzY3JvbGxMZWZ0XCIsXG4gICAgICBcInhcIixcbiAgICAgIFwibGVmdFwiLFxuICAgICAgXCJyaWdodFwiXG4gICAgXTtcbiAgZWxzZVxuICAgIHRocm93IG5ldyBFcnJvcihcIkEgcHJvcGVyIGF4aXMgc2hvdWxkIGJlIHByb3ZpZGVkXCIpO1xuICBydihzLCBlLCBvLCBpLCBuKTtcbn1cbmZ1bmN0aW9uIHJ2KHMsIHQsIGUsIGksIG4pIHtcbiAgdmFyIG8gPSBlWzBdLCByID0gZVsxXSwgYSA9IGVbMl0sIGwgPSBlWzNdLCBwID0gZVs0XSwgdSA9IGVbNV07XG4gIGkgPT09IHZvaWQgMCAmJiAoaSA9ICEwKSwgbiA9PT0gdm9pZCAwICYmIChuID0gITEpO1xuICB2YXIgXyA9IHMuZWxlbWVudDtcbiAgcy5yZWFjaFtsXSA9IG51bGwsIF9bYV0gPCAxICYmIChzLnJlYWNoW2xdID0gXCJzdGFydFwiKSwgX1thXSA+IHNbb10gLSBzW3JdIC0gMSAmJiAocy5yZWFjaFtsXSA9IFwiZW5kXCIpLCB0ICYmIChfLmRpc3BhdGNoRXZlbnQoa3MoXCJwcy1zY3JvbGwtXCIgKyBsKSksIHQgPCAwID8gXy5kaXNwYXRjaEV2ZW50KGtzKFwicHMtc2Nyb2xsLVwiICsgcCkpIDogdCA+IDAgJiYgXy5kaXNwYXRjaEV2ZW50KGtzKFwicHMtc2Nyb2xsLVwiICsgdSkpLCBpICYmIG92KHMsIGwpKSwgcy5yZWFjaFtsXSAmJiAodCB8fCBuKSAmJiBfLmRpc3BhdGNoRXZlbnQoa3MoXCJwcy1cIiArIGwgKyBcIi1yZWFjaC1cIiArIHMucmVhY2hbbF0pKTtcbn1cbmZ1bmN0aW9uIFcocykge1xuICByZXR1cm4gcGFyc2VJbnQocywgMTApIHx8IDA7XG59XG5mdW5jdGlvbiBhdihzKSB7XG4gIHJldHVybiBRdChzLCBcImlucHV0LFtjb250ZW50ZWRpdGFibGVdXCIpIHx8IFF0KHMsIFwic2VsZWN0LFtjb250ZW50ZWRpdGFibGVdXCIpIHx8IFF0KHMsIFwidGV4dGFyZWEsW2NvbnRlbnRlZGl0YWJsZV1cIikgfHwgUXQocywgXCJidXR0b24sW2NvbnRlbnRlZGl0YWJsZV1cIik7XG59XG5mdW5jdGlvbiBsdihzKSB7XG4gIHZhciB0ID0gTHQocyk7XG4gIHJldHVybiBXKHQud2lkdGgpICsgVyh0LnBhZGRpbmdMZWZ0KSArIFcodC5wYWRkaW5nUmlnaHQpICsgVyh0LmJvcmRlckxlZnRXaWR0aCkgKyBXKHQuYm9yZGVyUmlnaHRXaWR0aCk7XG59XG52YXIgTmUgPSB7XG4gIGlzV2ViS2l0OiB0eXBlb2YgZG9jdW1lbnQgPCBcInVcIiAmJiBcIldlYmtpdEFwcGVhcmFuY2VcIiBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUsXG4gIHN1cHBvcnRzVG91Y2g6IHR5cGVvZiB3aW5kb3cgPCBcInVcIiAmJiAoXCJvbnRvdWNoc3RhcnRcIiBpbiB3aW5kb3cgfHwgXCJtYXhUb3VjaFBvaW50c1wiIGluIHdpbmRvdy5uYXZpZ2F0b3IgJiYgd2luZG93Lm5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDAgfHwgd2luZG93LkRvY3VtZW50VG91Y2ggJiYgZG9jdW1lbnQgaW5zdGFuY2VvZiB3aW5kb3cuRG9jdW1lbnRUb3VjaCksXG4gIHN1cHBvcnRzSWVQb2ludGVyOiB0eXBlb2YgbmF2aWdhdG9yIDwgXCJ1XCIgJiYgbmF2aWdhdG9yLm1zTWF4VG91Y2hQb2ludHMsXG4gIGlzQ2hyb21lOiB0eXBlb2YgbmF2aWdhdG9yIDwgXCJ1XCIgJiYgL0Nocm9tZS9pLnRlc3QobmF2aWdhdG9yICYmIG5hdmlnYXRvci51c2VyQWdlbnQpXG59O1xuZnVuY3Rpb24gQnQocykge1xuICB2YXIgdCA9IHMuZWxlbWVudCwgZSA9IE1hdGguZmxvb3IodC5zY3JvbGxUb3ApLCBpID0gdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgcy5jb250YWluZXJXaWR0aCA9IE1hdGgucm91bmQoaS53aWR0aCksIHMuY29udGFpbmVySGVpZ2h0ID0gTWF0aC5yb3VuZChpLmhlaWdodCksIHMuY29udGVudFdpZHRoID0gdC5zY3JvbGxXaWR0aCwgcy5jb250ZW50SGVpZ2h0ID0gdC5zY3JvbGxIZWlnaHQsIHQuY29udGFpbnMocy5zY3JvbGxiYXJYUmFpbCkgfHwgKENsKHQsIGouZWxlbWVudC5yYWlsKFwieFwiKSkuZm9yRWFjaChcbiAgICBmdW5jdGlvbihuKSB7XG4gICAgICByZXR1cm4gUGUobik7XG4gICAgfVxuICApLCB0LmFwcGVuZENoaWxkKHMuc2Nyb2xsYmFyWFJhaWwpKSwgdC5jb250YWlucyhzLnNjcm9sbGJhcllSYWlsKSB8fCAoQ2wodCwgai5lbGVtZW50LnJhaWwoXCJ5XCIpKS5mb3JFYWNoKFxuICAgIGZ1bmN0aW9uKG4pIHtcbiAgICAgIHJldHVybiBQZShuKTtcbiAgICB9XG4gICksIHQuYXBwZW5kQ2hpbGQocy5zY3JvbGxiYXJZUmFpbCkpLCAhcy5zZXR0aW5ncy5zdXBwcmVzc1Njcm9sbFggJiYgcy5jb250YWluZXJXaWR0aCArIHMuc2V0dGluZ3Muc2Nyb2xsWE1hcmdpbk9mZnNldCA8IHMuY29udGVudFdpZHRoID8gKHMuc2Nyb2xsYmFyWEFjdGl2ZSA9ICEwLCBzLnJhaWxYV2lkdGggPSBzLmNvbnRhaW5lcldpZHRoIC0gcy5yYWlsWE1hcmdpbldpZHRoLCBzLnJhaWxYUmF0aW8gPSBzLmNvbnRhaW5lcldpZHRoIC8gcy5yYWlsWFdpZHRoLCBzLnNjcm9sbGJhclhXaWR0aCA9IEFsKFxuICAgIHMsXG4gICAgVyhzLnJhaWxYV2lkdGggKiBzLmNvbnRhaW5lcldpZHRoIC8gcy5jb250ZW50V2lkdGgpXG4gICksIHMuc2Nyb2xsYmFyWExlZnQgPSBXKFxuICAgIChzLm5lZ2F0aXZlU2Nyb2xsQWRqdXN0bWVudCArIHQuc2Nyb2xsTGVmdCkgKiAocy5yYWlsWFdpZHRoIC0gcy5zY3JvbGxiYXJYV2lkdGgpIC8gKHMuY29udGVudFdpZHRoIC0gcy5jb250YWluZXJXaWR0aClcbiAgKSkgOiBzLnNjcm9sbGJhclhBY3RpdmUgPSAhMSwgIXMuc2V0dGluZ3Muc3VwcHJlc3NTY3JvbGxZICYmIHMuY29udGFpbmVySGVpZ2h0ICsgcy5zZXR0aW5ncy5zY3JvbGxZTWFyZ2luT2Zmc2V0IDwgcy5jb250ZW50SGVpZ2h0ID8gKHMuc2Nyb2xsYmFyWUFjdGl2ZSA9ICEwLCBzLnJhaWxZSGVpZ2h0ID0gcy5jb250YWluZXJIZWlnaHQgLSBzLnJhaWxZTWFyZ2luSGVpZ2h0LCBzLnJhaWxZUmF0aW8gPSBzLmNvbnRhaW5lckhlaWdodCAvIHMucmFpbFlIZWlnaHQsIHMuc2Nyb2xsYmFyWUhlaWdodCA9IEFsKFxuICAgIHMsXG4gICAgVyhzLnJhaWxZSGVpZ2h0ICogcy5jb250YWluZXJIZWlnaHQgLyBzLmNvbnRlbnRIZWlnaHQpXG4gICksIHMuc2Nyb2xsYmFyWVRvcCA9IFcoXG4gICAgZSAqIChzLnJhaWxZSGVpZ2h0IC0gcy5zY3JvbGxiYXJZSGVpZ2h0KSAvIChzLmNvbnRlbnRIZWlnaHQgLSBzLmNvbnRhaW5lckhlaWdodClcbiAgKSkgOiBzLnNjcm9sbGJhcllBY3RpdmUgPSAhMSwgcy5zY3JvbGxiYXJYTGVmdCA+PSBzLnJhaWxYV2lkdGggLSBzLnNjcm9sbGJhclhXaWR0aCAmJiAocy5zY3JvbGxiYXJYTGVmdCA9IHMucmFpbFhXaWR0aCAtIHMuc2Nyb2xsYmFyWFdpZHRoKSwgcy5zY3JvbGxiYXJZVG9wID49IHMucmFpbFlIZWlnaHQgLSBzLnNjcm9sbGJhcllIZWlnaHQgJiYgKHMuc2Nyb2xsYmFyWVRvcCA9IHMucmFpbFlIZWlnaHQgLSBzLnNjcm9sbGJhcllIZWlnaHQpLCBjdih0LCBzKSwgcy5zY3JvbGxiYXJYQWN0aXZlID8gdC5jbGFzc0xpc3QuYWRkKGouc3RhdGUuYWN0aXZlKFwieFwiKSkgOiAodC5jbGFzc0xpc3QucmVtb3ZlKGouc3RhdGUuYWN0aXZlKFwieFwiKSksIHMuc2Nyb2xsYmFyWFdpZHRoID0gMCwgcy5zY3JvbGxiYXJYTGVmdCA9IDAsIHQuc2Nyb2xsTGVmdCA9IHMuaXNSdGwgPT09ICEwID8gcy5jb250ZW50V2lkdGggOiAwKSwgcy5zY3JvbGxiYXJZQWN0aXZlID8gdC5jbGFzc0xpc3QuYWRkKGouc3RhdGUuYWN0aXZlKFwieVwiKSkgOiAodC5jbGFzc0xpc3QucmVtb3ZlKGouc3RhdGUuYWN0aXZlKFwieVwiKSksIHMuc2Nyb2xsYmFyWUhlaWdodCA9IDAsIHMuc2Nyb2xsYmFyWVRvcCA9IDAsIHQuc2Nyb2xsVG9wID0gMCk7XG59XG5mdW5jdGlvbiBBbChzLCB0KSB7XG4gIHJldHVybiBzLnNldHRpbmdzLm1pblNjcm9sbGJhckxlbmd0aCAmJiAodCA9IE1hdGgubWF4KHQsIHMuc2V0dGluZ3MubWluU2Nyb2xsYmFyTGVuZ3RoKSksIHMuc2V0dGluZ3MubWF4U2Nyb2xsYmFyTGVuZ3RoICYmICh0ID0gTWF0aC5taW4odCwgcy5zZXR0aW5ncy5tYXhTY3JvbGxiYXJMZW5ndGgpKSwgdDtcbn1cbmZ1bmN0aW9uIGN2KHMsIHQpIHtcbiAgdmFyIGUgPSB7IHdpZHRoOiB0LnJhaWxYV2lkdGggfSwgaSA9IE1hdGguZmxvb3Iocy5zY3JvbGxUb3ApO1xuICB0LmlzUnRsID8gZS5sZWZ0ID0gdC5uZWdhdGl2ZVNjcm9sbEFkanVzdG1lbnQgKyBzLnNjcm9sbExlZnQgKyB0LmNvbnRhaW5lcldpZHRoIC0gdC5jb250ZW50V2lkdGggOiBlLmxlZnQgPSBzLnNjcm9sbExlZnQsIHQuaXNTY3JvbGxiYXJYVXNpbmdCb3R0b20gPyBlLmJvdHRvbSA9IHQuc2Nyb2xsYmFyWEJvdHRvbSAtIGkgOiBlLnRvcCA9IHQuc2Nyb2xsYmFyWFRvcCArIGksIG90KHQuc2Nyb2xsYmFyWFJhaWwsIGUpO1xuICB2YXIgbiA9IHsgdG9wOiBpLCBoZWlnaHQ6IHQucmFpbFlIZWlnaHQgfTtcbiAgdC5pc1Njcm9sbGJhcllVc2luZ1JpZ2h0ID8gdC5pc1J0bCA/IG4ucmlnaHQgPSB0LmNvbnRlbnRXaWR0aCAtICh0Lm5lZ2F0aXZlU2Nyb2xsQWRqdXN0bWVudCArIHMuc2Nyb2xsTGVmdCkgLSB0LnNjcm9sbGJhcllSaWdodCAtIHQuc2Nyb2xsYmFyWU91dGVyV2lkdGggLSA5IDogbi5yaWdodCA9IHQuc2Nyb2xsYmFyWVJpZ2h0IC0gcy5zY3JvbGxMZWZ0IDogdC5pc1J0bCA/IG4ubGVmdCA9IHQubmVnYXRpdmVTY3JvbGxBZGp1c3RtZW50ICsgcy5zY3JvbGxMZWZ0ICsgdC5jb250YWluZXJXaWR0aCAqIDIgLSB0LmNvbnRlbnRXaWR0aCAtIHQuc2Nyb2xsYmFyWUxlZnQgLSB0LnNjcm9sbGJhcllPdXRlcldpZHRoIDogbi5sZWZ0ID0gdC5zY3JvbGxiYXJZTGVmdCArIHMuc2Nyb2xsTGVmdCwgb3QodC5zY3JvbGxiYXJZUmFpbCwgbiksIG90KHQuc2Nyb2xsYmFyWCwge1xuICAgIGxlZnQ6IHQuc2Nyb2xsYmFyWExlZnQsXG4gICAgd2lkdGg6IHQuc2Nyb2xsYmFyWFdpZHRoIC0gdC5yYWlsQm9yZGVyWFdpZHRoXG4gIH0pLCBvdCh0LnNjcm9sbGJhclksIHtcbiAgICB0b3A6IHQuc2Nyb2xsYmFyWVRvcCxcbiAgICBoZWlnaHQ6IHQuc2Nyb2xsYmFyWUhlaWdodCAtIHQucmFpbEJvcmRlcllXaWR0aFxuICB9KTtcbn1cbmZ1bmN0aW9uIGh2KHMpIHtcbiAgcy5lbGVtZW50LCBzLmV2ZW50LmJpbmQocy5zY3JvbGxiYXJZLCBcIm1vdXNlZG93blwiLCBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIHQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH0pLCBzLmV2ZW50LmJpbmQocy5zY3JvbGxiYXJZUmFpbCwgXCJtb3VzZWRvd25cIiwgZnVuY3Rpb24odCkge1xuICAgIHZhciBlID0gdC5wYWdlWSAtIHdpbmRvdy5wYWdlWU9mZnNldCAtIHMuc2Nyb2xsYmFyWVJhaWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wLCBpID0gZSA+IHMuc2Nyb2xsYmFyWVRvcCA/IDEgOiAtMTtcbiAgICBzLmVsZW1lbnQuc2Nyb2xsVG9wICs9IGkgKiBzLmNvbnRhaW5lckhlaWdodCwgQnQocyksIHQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH0pLCBzLmV2ZW50LmJpbmQocy5zY3JvbGxiYXJYLCBcIm1vdXNlZG93blwiLCBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIHQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH0pLCBzLmV2ZW50LmJpbmQocy5zY3JvbGxiYXJYUmFpbCwgXCJtb3VzZWRvd25cIiwgZnVuY3Rpb24odCkge1xuICAgIHZhciBlID0gdC5wYWdlWCAtIHdpbmRvdy5wYWdlWE9mZnNldCAtIHMuc2Nyb2xsYmFyWFJhaWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCwgaSA9IGUgPiBzLnNjcm9sbGJhclhMZWZ0ID8gMSA6IC0xO1xuICAgIHMuZWxlbWVudC5zY3JvbGxMZWZ0ICs9IGkgKiBzLmNvbnRhaW5lcldpZHRoLCBCdChzKSwgdC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBkdihzKSB7XG4gIHlsKHMsIFtcbiAgICBcImNvbnRhaW5lcldpZHRoXCIsXG4gICAgXCJjb250ZW50V2lkdGhcIixcbiAgICBcInBhZ2VYXCIsXG4gICAgXCJyYWlsWFdpZHRoXCIsXG4gICAgXCJzY3JvbGxiYXJYXCIsXG4gICAgXCJzY3JvbGxiYXJYV2lkdGhcIixcbiAgICBcInNjcm9sbExlZnRcIixcbiAgICBcInhcIixcbiAgICBcInNjcm9sbGJhclhSYWlsXCJcbiAgXSksIHlsKHMsIFtcbiAgICBcImNvbnRhaW5lckhlaWdodFwiLFxuICAgIFwiY29udGVudEhlaWdodFwiLFxuICAgIFwicGFnZVlcIixcbiAgICBcInJhaWxZSGVpZ2h0XCIsXG4gICAgXCJzY3JvbGxiYXJZXCIsXG4gICAgXCJzY3JvbGxiYXJZSGVpZ2h0XCIsXG4gICAgXCJzY3JvbGxUb3BcIixcbiAgICBcInlcIixcbiAgICBcInNjcm9sbGJhcllSYWlsXCJcbiAgXSk7XG59XG5mdW5jdGlvbiB5bChzLCB0KSB7XG4gIHZhciBlID0gdFswXSwgaSA9IHRbMV0sIG4gPSB0WzJdLCBvID0gdFszXSwgciA9IHRbNF0sIGEgPSB0WzVdLCBsID0gdFs2XSwgcCA9IHRbN10sIHUgPSB0WzhdLCBfID0gcy5lbGVtZW50LCBmID0gbnVsbCwgZyA9IG51bGwsIG0gPSBudWxsO1xuICBmdW5jdGlvbiBiKHcpIHtcbiAgICB3LnRvdWNoZXMgJiYgdy50b3VjaGVzWzBdICYmICh3W25dID0gdy50b3VjaGVzWzBdLnBhZ2VZKSwgX1tsXSA9IGYgKyBtICogKHdbbl0gLSBnKSwgcGgocywgcCksIEJ0KHMpLCB3LnN0b3BQcm9wYWdhdGlvbigpLCB3LnR5cGUuc3RhcnRzV2l0aChcInRvdWNoXCIpICYmIHcuY2hhbmdlZFRvdWNoZXMubGVuZ3RoID4gMSAmJiB3LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbiAgZnVuY3Rpb24gdigpIHtcbiAgICBfaChzLCBwKSwgc1t1XS5jbGFzc0xpc3QucmVtb3ZlKGouc3RhdGUuY2xpY2tpbmcpLCBzLmV2ZW50LnVuYmluZChzLm93bmVyRG9jdW1lbnQsIFwibW91c2Vtb3ZlXCIsIGIpO1xuICB9XG4gIGZ1bmN0aW9uIEModywgRSkge1xuICAgIGYgPSBfW2xdLCBFICYmIHcudG91Y2hlcyAmJiAod1tuXSA9IHcudG91Y2hlc1swXS5wYWdlWSksIGcgPSB3W25dLCBtID0gKHNbaV0gLSBzW2VdKSAvIChzW29dIC0gc1thXSksIEUgPyBzLmV2ZW50LmJpbmQocy5vd25lckRvY3VtZW50LCBcInRvdWNobW92ZVwiLCBiKSA6IChzLmV2ZW50LmJpbmQocy5vd25lckRvY3VtZW50LCBcIm1vdXNlbW92ZVwiLCBiKSwgcy5ldmVudC5vbmNlKHMub3duZXJEb2N1bWVudCwgXCJtb3VzZXVwXCIsIHYpLCB3LnByZXZlbnREZWZhdWx0KCkpLCBzW3VdLmNsYXNzTGlzdC5hZGQoai5zdGF0ZS5jbGlja2luZyksIHcuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH1cbiAgcy5ldmVudC5iaW5kKHNbcl0sIFwibW91c2Vkb3duXCIsIGZ1bmN0aW9uKHcpIHtcbiAgICBDKHcpO1xuICB9KSwgcy5ldmVudC5iaW5kKHNbcl0sIFwidG91Y2hzdGFydFwiLCBmdW5jdGlvbih3KSB7XG4gICAgQyh3LCAhMCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gdXYocykge1xuICB2YXIgdCA9IHMuZWxlbWVudCwgZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBRdCh0LCBcIjpob3ZlclwiKTtcbiAgfSwgaSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBRdChzLnNjcm9sbGJhclgsIFwiOmZvY3VzXCIpIHx8IFF0KHMuc2Nyb2xsYmFyWSwgXCI6Zm9jdXNcIik7XG4gIH07XG4gIGZ1bmN0aW9uIG4obywgcikge1xuICAgIHZhciBhID0gTWF0aC5mbG9vcih0LnNjcm9sbFRvcCk7XG4gICAgaWYgKG8gPT09IDApIHtcbiAgICAgIGlmICghcy5zY3JvbGxiYXJZQWN0aXZlKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICBpZiAoYSA9PT0gMCAmJiByID4gMCB8fCBhID49IHMuY29udGVudEhlaWdodCAtIHMuY29udGFpbmVySGVpZ2h0ICYmIHIgPCAwKVxuICAgICAgICByZXR1cm4gIXMuc2V0dGluZ3Mud2hlZWxQcm9wYWdhdGlvbjtcbiAgICB9XG4gICAgdmFyIGwgPSB0LnNjcm9sbExlZnQ7XG4gICAgaWYgKHIgPT09IDApIHtcbiAgICAgIGlmICghcy5zY3JvbGxiYXJYQWN0aXZlKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICBpZiAobCA9PT0gMCAmJiBvIDwgMCB8fCBsID49IHMuY29udGVudFdpZHRoIC0gcy5jb250YWluZXJXaWR0aCAmJiBvID4gMClcbiAgICAgICAgcmV0dXJuICFzLnNldHRpbmdzLndoZWVsUHJvcGFnYXRpb247XG4gICAgfVxuICAgIHJldHVybiAhMDtcbiAgfVxuICBzLmV2ZW50LmJpbmQocy5vd25lckRvY3VtZW50LCBcImtleWRvd25cIiwgZnVuY3Rpb24obykge1xuICAgIGlmICghKG8uaXNEZWZhdWx0UHJldmVudGVkICYmIG8uaXNEZWZhdWx0UHJldmVudGVkKCkgfHwgby5kZWZhdWx0UHJldmVudGVkKSAmJiAhKCFlKCkgJiYgIWkoKSkpIHtcbiAgICAgIHZhciByID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA/IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgOiBzLm93bmVyRG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgIGlmIChyKSB7XG4gICAgICAgIGlmIChyLnRhZ05hbWUgPT09IFwiSUZSQU1FXCIpXG4gICAgICAgICAgciA9IHIuY29udGVudERvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBmb3IgKDsgci5zaGFkb3dSb290OyApXG4gICAgICAgICAgICByID0gci5zaGFkb3dSb290LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGlmIChhdihyKSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgYSA9IDAsIGwgPSAwO1xuICAgICAgc3dpdGNoIChvLndoaWNoKSB7XG4gICAgICAgIGNhc2UgMzc6XG4gICAgICAgICAgby5tZXRhS2V5ID8gYSA9IC1zLmNvbnRlbnRXaWR0aCA6IG8uYWx0S2V5ID8gYSA9IC1zLmNvbnRhaW5lcldpZHRoIDogYSA9IC0zMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzODpcbiAgICAgICAgICBvLm1ldGFLZXkgPyBsID0gcy5jb250ZW50SGVpZ2h0IDogby5hbHRLZXkgPyBsID0gcy5jb250YWluZXJIZWlnaHQgOiBsID0gMzA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzk6XG4gICAgICAgICAgby5tZXRhS2V5ID8gYSA9IHMuY29udGVudFdpZHRoIDogby5hbHRLZXkgPyBhID0gcy5jb250YWluZXJXaWR0aCA6IGEgPSAzMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0MDpcbiAgICAgICAgICBvLm1ldGFLZXkgPyBsID0gLXMuY29udGVudEhlaWdodCA6IG8uYWx0S2V5ID8gbCA9IC1zLmNvbnRhaW5lckhlaWdodCA6IGwgPSAtMzA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAgby5zaGlmdEtleSA/IGwgPSBzLmNvbnRhaW5lckhlaWdodCA6IGwgPSAtcy5jb250YWluZXJIZWlnaHQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzM6XG4gICAgICAgICAgbCA9IHMuY29udGFpbmVySGVpZ2h0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM0OlxuICAgICAgICAgIGwgPSAtcy5jb250YWluZXJIZWlnaHQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzY6XG4gICAgICAgICAgbCA9IHMuY29udGVudEhlaWdodDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzNTpcbiAgICAgICAgICBsID0gLXMuY29udGVudEhlaWdodDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzLnNldHRpbmdzLnN1cHByZXNzU2Nyb2xsWCAmJiBhICE9PSAwIHx8IHMuc2V0dGluZ3Muc3VwcHJlc3NTY3JvbGxZICYmIGwgIT09IDAgfHwgKHQuc2Nyb2xsVG9wIC09IGwsIHQuc2Nyb2xsTGVmdCArPSBhLCBCdChzKSwgbihhLCBsKSAmJiBvLnByZXZlbnREZWZhdWx0KCkpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBwdihzKSB7XG4gIHZhciB0ID0gcy5lbGVtZW50O1xuICBmdW5jdGlvbiBlKHIsIGEpIHtcbiAgICB2YXIgbCA9IE1hdGguZmxvb3IodC5zY3JvbGxUb3ApLCBwID0gdC5zY3JvbGxUb3AgPT09IDAsIHUgPSBsICsgdC5vZmZzZXRIZWlnaHQgPT09IHQuc2Nyb2xsSGVpZ2h0LCBfID0gdC5zY3JvbGxMZWZ0ID09PSAwLCBmID0gdC5zY3JvbGxMZWZ0ICsgdC5vZmZzZXRXaWR0aCA9PT0gdC5zY3JvbGxXaWR0aCwgZztcbiAgICByZXR1cm4gTWF0aC5hYnMoYSkgPiBNYXRoLmFicyhyKSA/IGcgPSBwIHx8IHUgOiBnID0gXyB8fCBmLCBnID8gIXMuc2V0dGluZ3Mud2hlZWxQcm9wYWdhdGlvbiA6ICEwO1xuICB9XG4gIGZ1bmN0aW9uIGkocikge1xuICAgIHZhciBhID0gci5kZWx0YVgsIGwgPSAtMSAqIHIuZGVsdGFZO1xuICAgIHJldHVybiAodHlwZW9mIGEgPiBcInVcIiB8fCB0eXBlb2YgbCA+IFwidVwiKSAmJiAoYSA9IC0xICogci53aGVlbERlbHRhWCAvIDYsIGwgPSByLndoZWVsRGVsdGFZIC8gNiksIHIuZGVsdGFNb2RlICYmIHIuZGVsdGFNb2RlID09PSAxICYmIChhICo9IDEwLCBsICo9IDEwKSwgYSAhPT0gYSAmJiBsICE9PSBsICYmIChhID0gMCwgbCA9IHIud2hlZWxEZWx0YSksIHIuc2hpZnRLZXkgPyBbLWwsIC1hXSA6IFthLCBsXTtcbiAgfVxuICBmdW5jdGlvbiBuKHIsIGEsIGwpIHtcbiAgICBpZiAoIU5lLmlzV2ViS2l0ICYmIHQucXVlcnlTZWxlY3RvcihcInNlbGVjdDpmb2N1c1wiKSlcbiAgICAgIHJldHVybiAhMDtcbiAgICBpZiAoIXQuY29udGFpbnMocikpXG4gICAgICByZXR1cm4gITE7XG4gICAgZm9yICh2YXIgcCA9IHI7IHAgJiYgcCAhPT0gdDsgKSB7XG4gICAgICBpZiAocC5jbGFzc0xpc3QuY29udGFpbnMoai5lbGVtZW50LmNvbnN1bWluZykpXG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIHZhciB1ID0gTHQocCk7XG4gICAgICBpZiAobCAmJiB1Lm92ZXJmbG93WS5tYXRjaCgvKHNjcm9sbHxhdXRvKS8pKSB7XG4gICAgICAgIHZhciBfID0gcC5zY3JvbGxIZWlnaHQgLSBwLmNsaWVudEhlaWdodDtcbiAgICAgICAgaWYgKF8gPiAwICYmIChwLnNjcm9sbFRvcCA+IDAgJiYgbCA8IDAgfHwgcC5zY3JvbGxUb3AgPCBfICYmIGwgPiAwKSlcbiAgICAgICAgICByZXR1cm4gITA7XG4gICAgICB9XG4gICAgICBpZiAoYSAmJiB1Lm92ZXJmbG93WC5tYXRjaCgvKHNjcm9sbHxhdXRvKS8pKSB7XG4gICAgICAgIHZhciBmID0gcC5zY3JvbGxXaWR0aCAtIHAuY2xpZW50V2lkdGg7XG4gICAgICAgIGlmIChmID4gMCAmJiAocC5zY3JvbGxMZWZ0ID4gMCAmJiBhIDwgMCB8fCBwLnNjcm9sbExlZnQgPCBmICYmIGEgPiAwKSlcbiAgICAgICAgICByZXR1cm4gITA7XG4gICAgICB9XG4gICAgICBwID0gcC5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gITE7XG4gIH1cbiAgZnVuY3Rpb24gbyhyKSB7XG4gICAgdmFyIGEgPSBpKHIpLCBsID0gYVswXSwgcCA9IGFbMV07XG4gICAgaWYgKCFuKHIudGFyZ2V0LCBsLCBwKSkge1xuICAgICAgdmFyIHUgPSAhMTtcbiAgICAgIHMuc2V0dGluZ3MudXNlQm90aFdoZWVsQXhlcyA/IHMuc2Nyb2xsYmFyWUFjdGl2ZSAmJiAhcy5zY3JvbGxiYXJYQWN0aXZlID8gKHAgPyB0LnNjcm9sbFRvcCAtPSBwICogcy5zZXR0aW5ncy53aGVlbFNwZWVkIDogdC5zY3JvbGxUb3AgKz0gbCAqIHMuc2V0dGluZ3Mud2hlZWxTcGVlZCwgdSA9ICEwKSA6IHMuc2Nyb2xsYmFyWEFjdGl2ZSAmJiAhcy5zY3JvbGxiYXJZQWN0aXZlICYmIChsID8gdC5zY3JvbGxMZWZ0ICs9IGwgKiBzLnNldHRpbmdzLndoZWVsU3BlZWQgOiB0LnNjcm9sbExlZnQgLT0gcCAqIHMuc2V0dGluZ3Mud2hlZWxTcGVlZCwgdSA9ICEwKSA6ICh0LnNjcm9sbFRvcCAtPSBwICogcy5zZXR0aW5ncy53aGVlbFNwZWVkLCB0LnNjcm9sbExlZnQgKz0gbCAqIHMuc2V0dGluZ3Mud2hlZWxTcGVlZCksIEJ0KHMpLCB1ID0gdSB8fCBlKGwsIHApLCB1ICYmICFyLmN0cmxLZXkgJiYgKHIuc3RvcFByb3BhZ2F0aW9uKCksIHIucHJldmVudERlZmF1bHQoKSk7XG4gICAgfVxuICB9XG4gIHR5cGVvZiB3aW5kb3cub253aGVlbCA8IFwidVwiID8gcy5ldmVudC5iaW5kKHQsIFwid2hlZWxcIiwgbykgOiB0eXBlb2Ygd2luZG93Lm9ubW91c2V3aGVlbCA8IFwidVwiICYmIHMuZXZlbnQuYmluZCh0LCBcIm1vdXNld2hlZWxcIiwgbyk7XG59XG5mdW5jdGlvbiBfdihzKSB7XG4gIGlmICghTmUuc3VwcG9ydHNUb3VjaCAmJiAhTmUuc3VwcG9ydHNJZVBvaW50ZXIpXG4gICAgcmV0dXJuO1xuICB2YXIgdCA9IHMuZWxlbWVudDtcbiAgZnVuY3Rpb24gZShtLCBiKSB7XG4gICAgdmFyIHYgPSBNYXRoLmZsb29yKHQuc2Nyb2xsVG9wKSwgQyA9IHQuc2Nyb2xsTGVmdCwgdyA9IE1hdGguYWJzKG0pLCBFID0gTWF0aC5hYnMoYik7XG4gICAgaWYgKEUgPiB3KSB7XG4gICAgICBpZiAoYiA8IDAgJiYgdiA9PT0gcy5jb250ZW50SGVpZ2h0IC0gcy5jb250YWluZXJIZWlnaHQgfHwgYiA+IDAgJiYgdiA9PT0gMClcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5zY3JvbGxZID09PSAwICYmIGIgPiAwICYmIE5lLmlzQ2hyb21lO1xuICAgIH0gZWxzZSBpZiAodyA+IEUgJiYgKG0gPCAwICYmIEMgPT09IHMuY29udGVudFdpZHRoIC0gcy5jb250YWluZXJXaWR0aCB8fCBtID4gMCAmJiBDID09PSAwKSlcbiAgICAgIHJldHVybiAhMDtcbiAgICByZXR1cm4gITA7XG4gIH1cbiAgZnVuY3Rpb24gaShtLCBiKSB7XG4gICAgdC5zY3JvbGxUb3AgLT0gYiwgdC5zY3JvbGxMZWZ0IC09IG0sIEJ0KHMpO1xuICB9XG4gIHZhciBuID0ge30sIG8gPSAwLCByID0ge30sIGEgPSBudWxsO1xuICBmdW5jdGlvbiBsKG0pIHtcbiAgICByZXR1cm4gbS50YXJnZXRUb3VjaGVzID8gbS50YXJnZXRUb3VjaGVzWzBdIDogbTtcbiAgfVxuICBmdW5jdGlvbiBwKG0pIHtcbiAgICByZXR1cm4gbS5wb2ludGVyVHlwZSAmJiBtLnBvaW50ZXJUeXBlID09PSBcInBlblwiICYmIG0uYnV0dG9ucyA9PT0gMCA/ICExIDogISEobS50YXJnZXRUb3VjaGVzICYmIG0udGFyZ2V0VG91Y2hlcy5sZW5ndGggPT09IDEgfHwgbS5wb2ludGVyVHlwZSAmJiBtLnBvaW50ZXJUeXBlICE9PSBcIm1vdXNlXCIgJiYgbS5wb2ludGVyVHlwZSAhPT0gbS5NU1BPSU5URVJfVFlQRV9NT1VTRSk7XG4gIH1cbiAgZnVuY3Rpb24gdShtKSB7XG4gICAgaWYgKHAobSkpIHtcbiAgICAgIHZhciBiID0gbChtKTtcbiAgICAgIG4ucGFnZVggPSBiLnBhZ2VYLCBuLnBhZ2VZID0gYi5wYWdlWSwgbyA9ICgvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkuZ2V0VGltZSgpLCBhICE9PSBudWxsICYmIGNsZWFySW50ZXJ2YWwoYSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIF8obSwgYiwgdikge1xuICAgIGlmICghdC5jb250YWlucyhtKSlcbiAgICAgIHJldHVybiAhMTtcbiAgICBmb3IgKHZhciBDID0gbTsgQyAmJiBDICE9PSB0OyApIHtcbiAgICAgIGlmIChDLmNsYXNzTGlzdC5jb250YWlucyhqLmVsZW1lbnQuY29uc3VtaW5nKSlcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgdmFyIHcgPSBMdChDKTtcbiAgICAgIGlmICh2ICYmIHcub3ZlcmZsb3dZLm1hdGNoKC8oc2Nyb2xsfGF1dG8pLykpIHtcbiAgICAgICAgdmFyIEUgPSBDLnNjcm9sbEhlaWdodCAtIEMuY2xpZW50SGVpZ2h0O1xuICAgICAgICBpZiAoRSA+IDAgJiYgKEMuc2Nyb2xsVG9wID4gMCAmJiB2IDwgMCB8fCBDLnNjcm9sbFRvcCA8IEUgJiYgdiA+IDApKVxuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgIH1cbiAgICAgIGlmIChiICYmIHcub3ZlcmZsb3dYLm1hdGNoKC8oc2Nyb2xsfGF1dG8pLykpIHtcbiAgICAgICAgdmFyIFQgPSBDLnNjcm9sbFdpZHRoIC0gQy5jbGllbnRXaWR0aDtcbiAgICAgICAgaWYgKFQgPiAwICYmIChDLnNjcm9sbExlZnQgPiAwICYmIGIgPCAwIHx8IEMuc2Nyb2xsTGVmdCA8IFQgJiYgYiA+IDApKVxuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgIH1cbiAgICAgIEMgPSBDLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHJldHVybiAhMTtcbiAgfVxuICBmdW5jdGlvbiBmKG0pIHtcbiAgICBpZiAocChtKSkge1xuICAgICAgdmFyIGIgPSBsKG0pLCB2ID0geyBwYWdlWDogYi5wYWdlWCwgcGFnZVk6IGIucGFnZVkgfSwgQyA9IHYucGFnZVggLSBuLnBhZ2VYLCB3ID0gdi5wYWdlWSAtIG4ucGFnZVk7XG4gICAgICBpZiAoXyhtLnRhcmdldCwgQywgdykpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGkoQywgdyksIG4gPSB2O1xuICAgICAgdmFyIEUgPSAoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpLmdldFRpbWUoKSwgVCA9IEUgLSBvO1xuICAgICAgVCA+IDAgJiYgKHIueCA9IEMgLyBULCByLnkgPSB3IC8gVCwgbyA9IEUpLCBlKEMsIHcpICYmIG0ucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZygpIHtcbiAgICBzLnNldHRpbmdzLnN3aXBlRWFzaW5nICYmIChjbGVhckludGVydmFsKGEpLCBhID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG4gICAgICBpZiAocy5pc0luaXRpYWxpemVkKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoYSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghci54ICYmICFyLnkpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChhKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKE1hdGguYWJzKHIueCkgPCAwLjAxICYmIE1hdGguYWJzKHIueSkgPCAwLjAxKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoYSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghcy5lbGVtZW50KSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoYSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGkoci54ICogMzAsIHIueSAqIDMwKSwgci54ICo9IDAuOCwgci55ICo9IDAuODtcbiAgICB9LCAxMCkpO1xuICB9XG4gIE5lLnN1cHBvcnRzVG91Y2ggPyAocy5ldmVudC5iaW5kKHQsIFwidG91Y2hzdGFydFwiLCB1KSwgcy5ldmVudC5iaW5kKHQsIFwidG91Y2htb3ZlXCIsIGYpLCBzLmV2ZW50LmJpbmQodCwgXCJ0b3VjaGVuZFwiLCBnKSkgOiBOZS5zdXBwb3J0c0llUG9pbnRlciAmJiAod2luZG93LlBvaW50ZXJFdmVudCA/IChzLmV2ZW50LmJpbmQodCwgXCJwb2ludGVyZG93blwiLCB1KSwgcy5ldmVudC5iaW5kKHQsIFwicG9pbnRlcm1vdmVcIiwgZiksIHMuZXZlbnQuYmluZCh0LCBcInBvaW50ZXJ1cFwiLCBnKSkgOiB3aW5kb3cuTVNQb2ludGVyRXZlbnQgJiYgKHMuZXZlbnQuYmluZCh0LCBcIk1TUG9pbnRlckRvd25cIiwgdSksIHMuZXZlbnQuYmluZCh0LCBcIk1TUG9pbnRlck1vdmVcIiwgZiksIHMuZXZlbnQuYmluZCh0LCBcIk1TUG9pbnRlclVwXCIsIGcpKSk7XG59XG52YXIgZnYgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICBoYW5kbGVyczogW1wiY2xpY2stcmFpbFwiLCBcImRyYWctdGh1bWJcIiwgXCJrZXlib2FyZFwiLCBcIndoZWVsXCIsIFwidG91Y2hcIl0sXG4gICAgbWF4U2Nyb2xsYmFyTGVuZ3RoOiBudWxsLFxuICAgIG1pblNjcm9sbGJhckxlbmd0aDogbnVsbCxcbiAgICBzY3JvbGxpbmdUaHJlc2hvbGQ6IDFlMyxcbiAgICBzY3JvbGxYTWFyZ2luT2Zmc2V0OiAwLFxuICAgIHNjcm9sbFlNYXJnaW5PZmZzZXQ6IDAsXG4gICAgc3VwcHJlc3NTY3JvbGxYOiAhMSxcbiAgICBzdXBwcmVzc1Njcm9sbFk6ICExLFxuICAgIHN3aXBlRWFzaW5nOiAhMCxcbiAgICB1c2VCb3RoV2hlZWxBeGVzOiAhMSxcbiAgICB3aGVlbFByb3BhZ2F0aW9uOiAhMCxcbiAgICB3aGVlbFNwZWVkOiAxXG4gIH07XG59LCBtdiA9IHtcbiAgXCJjbGljay1yYWlsXCI6IGh2LFxuICBcImRyYWctdGh1bWJcIjogZHYsXG4gIGtleWJvYXJkOiB1dixcbiAgd2hlZWw6IHB2LFxuICB0b3VjaDogX3Zcbn0sIFVpID0gZnVuY3Rpb24odCwgZSkge1xuICB2YXIgaSA9IHRoaXM7XG4gIGlmIChlID09PSB2b2lkIDAgJiYgKGUgPSB7fSksIHR5cGVvZiB0ID09IFwic3RyaW5nXCIgJiYgKHQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHQpKSwgIXQgfHwgIXQubm9kZU5hbWUpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwibm8gZWxlbWVudCBpcyBzcGVjaWZpZWQgdG8gaW5pdGlhbGl6ZSBQZXJmZWN0U2Nyb2xsYmFyXCIpO1xuICB0aGlzLmVsZW1lbnQgPSB0LCB0LmNsYXNzTGlzdC5hZGQoai5tYWluKSwgdGhpcy5zZXR0aW5ncyA9IGZ2KCk7XG4gIGZvciAodmFyIG4gaW4gZSlcbiAgICB0aGlzLnNldHRpbmdzW25dID0gZVtuXTtcbiAgdGhpcy5jb250YWluZXJXaWR0aCA9IG51bGwsIHRoaXMuY29udGFpbmVySGVpZ2h0ID0gbnVsbCwgdGhpcy5jb250ZW50V2lkdGggPSBudWxsLCB0aGlzLmNvbnRlbnRIZWlnaHQgPSBudWxsO1xuICB2YXIgbyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0LmNsYXNzTGlzdC5hZGQoai5zdGF0ZS5mb2N1cyk7XG4gIH0sIHIgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdC5jbGFzc0xpc3QucmVtb3ZlKGouc3RhdGUuZm9jdXMpO1xuICB9O1xuICB0aGlzLmlzUnRsID0gTHQodCkuZGlyZWN0aW9uID09PSBcInJ0bFwiLCB0aGlzLmlzUnRsID09PSAhMCAmJiB0LmNsYXNzTGlzdC5hZGQoai5ydGwpLCB0aGlzLmlzTmVnYXRpdmVTY3JvbGwgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcCA9IHQuc2Nyb2xsTGVmdCwgdSA9IG51bGw7XG4gICAgcmV0dXJuIHQuc2Nyb2xsTGVmdCA9IC0xLCB1ID0gdC5zY3JvbGxMZWZ0IDwgMCwgdC5zY3JvbGxMZWZ0ID0gcCwgdTtcbiAgfSgpLCB0aGlzLm5lZ2F0aXZlU2Nyb2xsQWRqdXN0bWVudCA9IHRoaXMuaXNOZWdhdGl2ZVNjcm9sbCA/IHQuc2Nyb2xsV2lkdGggLSB0LmNsaWVudFdpZHRoIDogMCwgdGhpcy5ldmVudCA9IG5ldyBzaSgpLCB0aGlzLm93bmVyRG9jdW1lbnQgPSB0Lm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQsIHRoaXMuc2Nyb2xsYmFyWFJhaWwgPSB3cyhqLmVsZW1lbnQucmFpbChcInhcIikpLCB0LmFwcGVuZENoaWxkKHRoaXMuc2Nyb2xsYmFyWFJhaWwpLCB0aGlzLnNjcm9sbGJhclggPSB3cyhqLmVsZW1lbnQudGh1bWIoXCJ4XCIpKSwgdGhpcy5zY3JvbGxiYXJYUmFpbC5hcHBlbmRDaGlsZCh0aGlzLnNjcm9sbGJhclgpLCB0aGlzLnNjcm9sbGJhclguc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIiwgMCksIHRoaXMuZXZlbnQuYmluZCh0aGlzLnNjcm9sbGJhclgsIFwiZm9jdXNcIiwgbyksIHRoaXMuZXZlbnQuYmluZCh0aGlzLnNjcm9sbGJhclgsIFwiYmx1clwiLCByKSwgdGhpcy5zY3JvbGxiYXJYQWN0aXZlID0gbnVsbCwgdGhpcy5zY3JvbGxiYXJYV2lkdGggPSBudWxsLCB0aGlzLnNjcm9sbGJhclhMZWZ0ID0gbnVsbDtcbiAgdmFyIGEgPSBMdCh0aGlzLnNjcm9sbGJhclhSYWlsKTtcbiAgdGhpcy5zY3JvbGxiYXJYQm90dG9tID0gcGFyc2VJbnQoYS5ib3R0b20sIDEwKSwgaXNOYU4odGhpcy5zY3JvbGxiYXJYQm90dG9tKSA/ICh0aGlzLmlzU2Nyb2xsYmFyWFVzaW5nQm90dG9tID0gITEsIHRoaXMuc2Nyb2xsYmFyWFRvcCA9IFcoYS50b3ApKSA6IHRoaXMuaXNTY3JvbGxiYXJYVXNpbmdCb3R0b20gPSAhMCwgdGhpcy5yYWlsQm9yZGVyWFdpZHRoID0gVyhhLmJvcmRlckxlZnRXaWR0aCkgKyBXKGEuYm9yZGVyUmlnaHRXaWR0aCksIG90KHRoaXMuc2Nyb2xsYmFyWFJhaWwsIHsgZGlzcGxheTogXCJibG9ja1wiIH0pLCB0aGlzLnJhaWxYTWFyZ2luV2lkdGggPSBXKGEubWFyZ2luTGVmdCkgKyBXKGEubWFyZ2luUmlnaHQpLCBvdCh0aGlzLnNjcm9sbGJhclhSYWlsLCB7IGRpc3BsYXk6IFwiXCIgfSksIHRoaXMucmFpbFhXaWR0aCA9IG51bGwsIHRoaXMucmFpbFhSYXRpbyA9IG51bGwsIHRoaXMuc2Nyb2xsYmFyWVJhaWwgPSB3cyhqLmVsZW1lbnQucmFpbChcInlcIikpLCB0LmFwcGVuZENoaWxkKHRoaXMuc2Nyb2xsYmFyWVJhaWwpLCB0aGlzLnNjcm9sbGJhclkgPSB3cyhqLmVsZW1lbnQudGh1bWIoXCJ5XCIpKSwgdGhpcy5zY3JvbGxiYXJZUmFpbC5hcHBlbmRDaGlsZCh0aGlzLnNjcm9sbGJhclkpLCB0aGlzLnNjcm9sbGJhclkuc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIiwgMCksIHRoaXMuZXZlbnQuYmluZCh0aGlzLnNjcm9sbGJhclksIFwiZm9jdXNcIiwgbyksIHRoaXMuZXZlbnQuYmluZCh0aGlzLnNjcm9sbGJhclksIFwiYmx1clwiLCByKSwgdGhpcy5zY3JvbGxiYXJZQWN0aXZlID0gbnVsbCwgdGhpcy5zY3JvbGxiYXJZSGVpZ2h0ID0gbnVsbCwgdGhpcy5zY3JvbGxiYXJZVG9wID0gbnVsbDtcbiAgdmFyIGwgPSBMdCh0aGlzLnNjcm9sbGJhcllSYWlsKTtcbiAgdGhpcy5zY3JvbGxiYXJZUmlnaHQgPSBwYXJzZUludChsLnJpZ2h0LCAxMCksIGlzTmFOKHRoaXMuc2Nyb2xsYmFyWVJpZ2h0KSA/ICh0aGlzLmlzU2Nyb2xsYmFyWVVzaW5nUmlnaHQgPSAhMSwgdGhpcy5zY3JvbGxiYXJZTGVmdCA9IFcobC5sZWZ0KSkgOiB0aGlzLmlzU2Nyb2xsYmFyWVVzaW5nUmlnaHQgPSAhMCwgdGhpcy5zY3JvbGxiYXJZT3V0ZXJXaWR0aCA9IHRoaXMuaXNSdGwgPyBsdih0aGlzLnNjcm9sbGJhclkpIDogbnVsbCwgdGhpcy5yYWlsQm9yZGVyWVdpZHRoID0gVyhsLmJvcmRlclRvcFdpZHRoKSArIFcobC5ib3JkZXJCb3R0b21XaWR0aCksIG90KHRoaXMuc2Nyb2xsYmFyWVJhaWwsIHsgZGlzcGxheTogXCJibG9ja1wiIH0pLCB0aGlzLnJhaWxZTWFyZ2luSGVpZ2h0ID0gVyhsLm1hcmdpblRvcCkgKyBXKGwubWFyZ2luQm90dG9tKSwgb3QodGhpcy5zY3JvbGxiYXJZUmFpbCwgeyBkaXNwbGF5OiBcIlwiIH0pLCB0aGlzLnJhaWxZSGVpZ2h0ID0gbnVsbCwgdGhpcy5yYWlsWVJhdGlvID0gbnVsbCwgdGhpcy5yZWFjaCA9IHtcbiAgICB4OiB0LnNjcm9sbExlZnQgPD0gMCA/IFwic3RhcnRcIiA6IHQuc2Nyb2xsTGVmdCA+PSB0aGlzLmNvbnRlbnRXaWR0aCAtIHRoaXMuY29udGFpbmVyV2lkdGggPyBcImVuZFwiIDogbnVsbCxcbiAgICB5OiB0LnNjcm9sbFRvcCA8PSAwID8gXCJzdGFydFwiIDogdC5zY3JvbGxUb3AgPj0gdGhpcy5jb250ZW50SGVpZ2h0IC0gdGhpcy5jb250YWluZXJIZWlnaHQgPyBcImVuZFwiIDogbnVsbFxuICB9LCB0aGlzLmlzQWxpdmUgPSAhMCwgdGhpcy5zZXR0aW5ncy5oYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gbXZbcF0oaSk7XG4gIH0pLCB0aGlzLmxhc3RTY3JvbGxUb3AgPSBNYXRoLmZsb29yKHQuc2Nyb2xsVG9wKSwgdGhpcy5sYXN0U2Nyb2xsTGVmdCA9IHQuc2Nyb2xsTGVmdCwgdGhpcy5ldmVudC5iaW5kKHRoaXMuZWxlbWVudCwgXCJzY3JvbGxcIiwgZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiBpLm9uU2Nyb2xsKHApO1xuICB9KSwgQnQodGhpcyk7XG59O1xuVWkucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmlzQWxpdmUgJiYgKHRoaXMubmVnYXRpdmVTY3JvbGxBZGp1c3RtZW50ID0gdGhpcy5pc05lZ2F0aXZlU2Nyb2xsID8gdGhpcy5lbGVtZW50LnNjcm9sbFdpZHRoIC0gdGhpcy5lbGVtZW50LmNsaWVudFdpZHRoIDogMCwgb3QodGhpcy5zY3JvbGxiYXJYUmFpbCwgeyBkaXNwbGF5OiBcImJsb2NrXCIgfSksIG90KHRoaXMuc2Nyb2xsYmFyWVJhaWwsIHsgZGlzcGxheTogXCJibG9ja1wiIH0pLCB0aGlzLnJhaWxYTWFyZ2luV2lkdGggPSBXKEx0KHRoaXMuc2Nyb2xsYmFyWFJhaWwpLm1hcmdpbkxlZnQpICsgVyhMdCh0aGlzLnNjcm9sbGJhclhSYWlsKS5tYXJnaW5SaWdodCksIHRoaXMucmFpbFlNYXJnaW5IZWlnaHQgPSBXKEx0KHRoaXMuc2Nyb2xsYmFyWVJhaWwpLm1hcmdpblRvcCkgKyBXKEx0KHRoaXMuc2Nyb2xsYmFyWVJhaWwpLm1hcmdpbkJvdHRvbSksIG90KHRoaXMuc2Nyb2xsYmFyWFJhaWwsIHsgZGlzcGxheTogXCJub25lXCIgfSksIG90KHRoaXMuc2Nyb2xsYmFyWVJhaWwsIHsgZGlzcGxheTogXCJub25lXCIgfSksIEJ0KHRoaXMpLCBvbih0aGlzLCBcInRvcFwiLCAwLCAhMSwgITApLCBvbih0aGlzLCBcImxlZnRcIiwgMCwgITEsICEwKSwgb3QodGhpcy5zY3JvbGxiYXJYUmFpbCwgeyBkaXNwbGF5OiBcIlwiIH0pLCBvdCh0aGlzLnNjcm9sbGJhcllSYWlsLCB7IGRpc3BsYXk6IFwiXCIgfSkpO1xufTtcblVpLnByb3RvdHlwZS5vblNjcm9sbCA9IGZ1bmN0aW9uKHQpIHtcbiAgdGhpcy5pc0FsaXZlICYmIChCdCh0aGlzKSwgb24odGhpcywgXCJ0b3BcIiwgdGhpcy5lbGVtZW50LnNjcm9sbFRvcCAtIHRoaXMubGFzdFNjcm9sbFRvcCksIG9uKFxuICAgIHRoaXMsXG4gICAgXCJsZWZ0XCIsXG4gICAgdGhpcy5lbGVtZW50LnNjcm9sbExlZnQgLSB0aGlzLmxhc3RTY3JvbGxMZWZ0XG4gICksIHRoaXMubGFzdFNjcm9sbFRvcCA9IE1hdGguZmxvb3IodGhpcy5lbGVtZW50LnNjcm9sbFRvcCksIHRoaXMubGFzdFNjcm9sbExlZnQgPSB0aGlzLmVsZW1lbnQuc2Nyb2xsTGVmdCk7XG59O1xuVWkucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5pc0FsaXZlICYmICh0aGlzLmV2ZW50LnVuYmluZEFsbCgpLCBQZSh0aGlzLnNjcm9sbGJhclgpLCBQZSh0aGlzLnNjcm9sbGJhclkpLCBQZSh0aGlzLnNjcm9sbGJhclhSYWlsKSwgUGUodGhpcy5zY3JvbGxiYXJZUmFpbCksIHRoaXMucmVtb3ZlUHNDbGFzc2VzKCksIHRoaXMuZWxlbWVudCA9IG51bGwsIHRoaXMuc2Nyb2xsYmFyWCA9IG51bGwsIHRoaXMuc2Nyb2xsYmFyWSA9IG51bGwsIHRoaXMuc2Nyb2xsYmFyWFJhaWwgPSBudWxsLCB0aGlzLnNjcm9sbGJhcllSYWlsID0gbnVsbCwgdGhpcy5pc0FsaXZlID0gITEpO1xufTtcblVpLnByb3RvdHlwZS5yZW1vdmVQc0NsYXNzZXMgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5lbGVtZW50LmNsYXNzTmFtZSA9IHRoaXMuZWxlbWVudC5jbGFzc05hbWUuc3BsaXQoXCIgXCIpLmZpbHRlcihmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuICF0Lm1hdGNoKC9ecHMoWy1fXS4rfCkkLyk7XG4gIH0pLmpvaW4oXCIgXCIpO1xufTtcbmNvbnN0IHBvID0gXCJwZXJmZWN0U2Nyb2xsYmFyXCIsIGd2ID0gXCJwZXJmZWN0LXNjcm9sbGJhclwiLCB4cyA9IFwidGUucGVyZmVjdFNjcm9sbGJhclwiLCBPdCA9IFwidGVcIiwgU3QgPSBcInBzXCIsIF9vID0gW1xuICB7IHRlOiBgc2Nyb2xsWC4ke090fS4ke1N0fWAsIHBzOiBcInBzLXNjcm9sbC14XCIgfSxcbiAgeyB0ZTogYHNjcm9sbFkuJHtPdH0uJHtTdH1gLCBwczogXCJwcy1zY3JvbGwteVwiIH0sXG4gIHsgdGU6IGBzY3JvbGxVcC4ke090fS4ke1N0fWAsIHBzOiBcInBzLXNjcm9sbC11cFwiIH0sXG4gIHsgdGU6IGBzY3JvbGxEb3duLiR7T3R9LiR7U3R9YCwgcHM6IFwicHMtc2Nyb2xsLWRvd25cIiB9LFxuICB7IHRlOiBgc2Nyb2xsTGVmdC4ke090fS4ke1N0fWAsIHBzOiBcInBzLXNjcm9sbC1sZWZ0XCIgfSxcbiAgeyB0ZTogYHNjcm9sbFJpZ2h0LiR7T3R9LiR7U3R9YCwgcHM6IFwicHMtc2Nyb2xsLXJpZ2h0XCIgfSxcbiAgeyB0ZTogYHNjcm9sbFhFbmQuJHtPdH0uJHtTdH1gLCBwczogXCJwcy14LXJlYWNoLWVuZFwiIH0sXG4gIHsgdGU6IGBzY3JvbGxZRW5kLiR7T3R9LiR7U3R9YCwgcHM6IFwicHMteS1yZWFjaC1lbmRcIiB9LFxuICB7IHRlOiBgc2Nyb2xsWFN0YXJ0LiR7T3R9LiR7U3R9YCwgcHM6IFwicHMteC1yZWFjaC1zdGFydFwiIH0sXG4gIHsgdGU6IGBzY3JvbGxZU3RhcnQuJHtPdH0uJHtTdH1gLCBwczogXCJwcy15LXJlYWNoLXN0YXJ0XCIgfVxuXSwgYnYgPSB7XG4gIGhhbmRsZXJzOiBbXCJjbGljay1yYWlsXCIsIFwiZHJhZy10aHVtYlwiLCBcImtleWJvYXJkXCIsIFwid2hlZWxcIiwgXCJ0b3VjaFwiXSxcbiAgd2hlZWxTcGVlZDogMSxcbiAgd2hlZWxQcm9wYWdhdGlvbjogITAsXG4gIHN3aXBlRWFzaW5nOiAhMCxcbiAgbWluU2Nyb2xsYmFyTGVuZ3RoOiBudWxsLFxuICBtYXhTY3JvbGxiYXJMZW5ndGg6IG51bGwsXG4gIHNjcm9sbGluZ1RocmVzaG9sZDogMWUzLFxuICB1c2VCb3RoV2hlZWxBeGVzOiAhMSxcbiAgc3VwcHJlc3NTY3JvbGxYOiAhMSxcbiAgc3VwcHJlc3NTY3JvbGxZOiAhMSxcbiAgc2Nyb2xsWE1hcmdpbk9mZnNldDogMCxcbiAgc2Nyb2xsWU1hcmdpbk9mZnNldDogMCxcbiAgcG9zaXRpb25SaWdodDogITBcbn0sIHZ2ID0ge1xuICBoYW5kbGVyczogXCIoc3RyaW5nfGFycmF5KVwiLFxuICB3aGVlbFNwZWVkOiBcIm51bWJlclwiLFxuICB3aGVlbFByb3BhZ2F0aW9uOiBcImJvb2xlYW5cIixcbiAgc3dpcGVFYXNpbmc6IFwiYm9vbGVhblwiLFxuICBtaW5TY3JvbGxiYXJMZW5ndGg6IFwiKG51bWJlcnxudWxsKVwiLFxuICBtYXhTY3JvbGxiYXJMZW5ndGg6IFwiKG51bWJlcnxudWxsKVwiLFxuICBzY3JvbGxpbmdUaHJlc2hvbGQ6IFwibnVtYmVyXCIsXG4gIHVzZUJvdGhXaGVlbEF4ZXM6IFwiYm9vbGVhblwiLFxuICBzdXBwcmVzc1Njcm9sbFg6IFwiYm9vbGVhblwiLFxuICBzdXBwcmVzc1Njcm9sbFk6IFwiYm9vbGVhblwiLFxuICBzY3JvbGxYTWFyZ2luT2Zmc2V0OiBcIm51bWJlclwiLFxuICBzY3JvbGxZTWFyZ2luT2Zmc2V0OiBcIm51bWJlclwiLFxuICBwb3NpdGlvblJpZ2h0OiBcImJvb2xlYW5cIlxufSwgVHYgPSB7XG4gIHBzOiBcImdyb3VwL3BzIG92ZXJmbG93LWhpZGRlbiBbb3ZlcmZsb3ctYW5jaG9yOm5vbmVdIHRvdWNoLW5vbmVcIixcbiAgcmFpbFg6IFwiZ3JvdXAveCBhYnNvbHV0ZSBib3R0b20tMCBoLVswLjkzNzVyZW1dIGhpZGRlbiBvcGFjaXR5LTAgdHJhbnNpdGlvbi1bYmFja2dyb3VuZC1jb2xvcixfb3BhY2l0eV0gZHVyYXRpb24tMjAwIGVhc2UtbGluZWFyIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIHotWzEwMzVdIGdyb3VwLVsmLnBzLS1hY3RpdmUteF0vcHM6YmxvY2sgZ3JvdXAtaG92ZXIvcHM6b3BhY2l0eS02MCBncm91cC1mb2N1cy9wczpvcGFjaXR5LTYwIGdyb3VwLVsmLnBzLS1zY3JvbGxpbmcteF0vcHM6b3BhY2l0eS02MCBob3Zlcjohb3BhY2l0eS05MCBmb2N1czohb3BhY2l0eS05MCBbJi5wcy0tY2xpY2tpbmddOiFvcGFjaXR5LTkwIG91dGxpbmUtbm9uZVwiLFxuICByYWlsWENvbG9yczogXCJncm91cC1bJi5wcy0tYWN0aXZlLXhdL3BzOmJnLXRyYW5zcGFyZW50IGhvdmVyOiFiZy1bI2VlZV0gZm9jdXM6IWJnLVsjZWVlXSBbJi5wcy0tY2xpY2tpbmddOiFiZy1bI2VlZV0gZGFyazpob3ZlcjohYmctWyM1NTVdIGRhcms6Zm9jdXM6IWJnLVsjNTU1XSBkYXJrOlsmLnBzLS1jbGlja2luZ106IWJnLVsjNTU1XVwiLFxuICByYWlsWFRodW1iOiBcImFic29sdXRlIGJvdHRvbS0wLjUgcm91bmRlZC1tZCBoLTEuNSBncm91cC1mb2N1cy9wczpvcGFjaXR5LTEwMCBncm91cC1hY3RpdmUvcHM6b3BhY2l0eS0xMDAgW3RyYW5zaXRpb246YmFja2dyb3VuZC1jb2xvcl8uMnNfbGluZWFyLF9oZWlnaHRfLjJzX2Vhc2UtaW4tb3V0XSBncm91cC1ob3Zlci94OmgtWzExcHhdIGdyb3VwLWZvY3VzL3g6aC1bMC42ODc1cmVtXSBncm91cC1bJi5wcy0tY2xpY2tpbmddL3g6YmctWyM5OTldIGdyb3VwLVsmLnBzLS1jbGlja2luZ10veDpoLVsxMXB4XSBvdXRsaW5lLW5vbmVcIixcbiAgcmFpbFhUaHVtYkNvbG9yczogXCJiZy1bI2FhYV0gZ3JvdXAtaG92ZXIveDpiZy1bIzk5OV0gZ3JvdXAtZm9jdXMveDpiZy1bIzk5OV1cIixcbiAgcmFpbFk6IFwiZ3JvdXAveSBhYnNvbHV0ZSByaWdodC0wIHctWzAuOTM3NXJlbV0gaGlkZGVuIG9wYWNpdHktMCB0cmFuc2l0aW9uLVtiYWNrZ3JvdW5kLWNvbG9yLF9vcGFjaXR5XSBkdXJhdGlvbi0yMDAgZWFzZS1saW5lYXIgbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmUgei1bMTAzNV0gZ3JvdXAtWyYucHMtLWFjdGl2ZS15XS9wczpibG9jayBncm91cC1ob3Zlci9wczpvcGFjaXR5LTYwIGdyb3VwLWZvY3VzL3BzOm9wYWNpdHktNjAgZ3JvdXAtWyYucHMtLXNjcm9sbGluZy15XS9wczpvcGFjaXR5LTYwIGhvdmVyOiFvcGFjaXR5LTkwIGZvY3VzOiFvcGFjaXR5LTkwIFsmLnBzLS1jbGlja2luZ106IW9wYWNpdHktOTAgb3V0bGluZS1ub25lXCIsXG4gIHJhaWxZQ29sb3JzOiBcImdyb3VwLVsmLnBzLS1hY3RpdmUteV0vcHM6YmctdHJhbnNwYXJlbnQgaG92ZXI6IWJnLVsjZWVlXSBmb2N1czohYmctWyNlZWVdIFsmLnBzLS1jbGlja2luZ106IWJnLVsjZWVlXSBkYXJrOmhvdmVyOiFiZy1bIzU1NV0gZGFyazpmb2N1czohYmctWyM1NTVdIGRhcms6WyYucHMtLWNsaWNraW5nXTohYmctWyM1NTVdXCIsXG4gIHJhaWxZVGh1bWI6IFwiYWJzb2x1dGUgcmlnaHQtMC41IHJvdW5kZWQtbWQgdy0xLjUgZ3JvdXAtZm9jdXMvcHM6b3BhY2l0eS0xMDAgZ3JvdXAtYWN0aXZlL3BzOm9wYWNpdHktMTAwIFt0cmFuc2l0aW9uOmJhY2tncm91bmQtY29sb3JfLjJzX2xpbmVhcixfd2lkdGhfLjJzX2Vhc2UtaW4tb3V0LF9vcGFjaXR5XSBncm91cC1ob3Zlci95OnctWzExcHhdIGdyb3VwLWZvY3VzL3k6dy1bMC42ODc1cmVtXSBncm91cC1bJi5wcy0tY2xpY2tpbmddL3k6dy1bMTFweF0gb3V0bGluZS1ub25lXCIsXG4gIHJhaWxZVGh1bWJDb2xvcnM6IFwiYmctWyNhYWFdIGdyb3VwLWhvdmVyL3k6YmctWyM5OTldIGdyb3VwLWZvY3VzL3k6YmctWyM5OTldIGdyb3VwLVsmLnBzLS1jbGlja2luZ10veTpiZy1bIzk5OV1cIlxufSwgRXYgPSB7XG4gIHBzOiBcInN0cmluZ1wiLFxuICByYWlsWDogXCJzdHJpbmdcIixcbiAgcmFpbFhDb2xvcnM6IFwic3RyaW5nXCIsXG4gIHJhaWxYVGh1bWI6IFwic3RyaW5nXCIsXG4gIHJhaWxYVGh1bWJDb2xvcnM6IFwic3RyaW5nXCIsXG4gIHJhaWxZOiBcInN0cmluZ1wiLFxuICByYWlsWUNvbG9yczogXCJzdHJpbmdcIixcbiAgcmFpbFlUaHVtYjogXCJzdHJpbmdcIixcbiAgcmFpbFlUaHVtYkNvbG9yczogXCJzdHJpbmdcIlxufTtcbmNsYXNzIGZyIHtcbiAgY29uc3RydWN0b3IodCwgZSA9IHt9LCBpID0ge30pIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gdCwgdGhpcy5fb3B0aW9ucyA9IHRoaXMuX2dldENvbmZpZyhlKSwgdGhpcy5fY2xhc3NlcyA9IHRoaXMuX2dldENsYXNzZXMoaSksIHRoaXMucGVyZmVjdFNjcm9sbGJhciA9IG51bGwsIHRoaXMuX29ic2VydmVyID0gbnVsbCwgdGhpcy5fcHNDbGFzc2VzID0gW1xuICAgICAge1xuICAgICAgICBwczogXCJwc19fcmFpbC14XCIsXG4gICAgICAgIHRlOiB0aGlzLl9jbGFzc2VzLnJhaWxYLFxuICAgICAgICB0ZUNvbG9yOiB0aGlzLl9jbGFzc2VzLnJhaWxYQ29sb3JzXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBwczogXCJwc19fcmFpbC15XCIsXG4gICAgICAgIHRlOiB0aGlzLl9jbGFzc2VzLnJhaWxZLFxuICAgICAgICB0ZUNvbG9yOiB0aGlzLl9jbGFzc2VzLnJhaWxZQ29sb3JzXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBwczogXCJwc19fdGh1bWIteFwiLFxuICAgICAgICB0ZTogdGhpcy5fY2xhc3Nlcy5yYWlsWFRodW1iLFxuICAgICAgICB0ZUNvbG9yOiB0aGlzLl9jbGFzc2VzLnJhaWxYVGh1bWJDb2xvcnNcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHBzOiBcInBzX190aHVtYi15XCIsXG4gICAgICAgIHRlOiB0aGlzLl9jbGFzc2VzLnJhaWxZVGh1bWIsXG4gICAgICAgIHRlQ29sb3I6IHRoaXMuX2NsYXNzZXMucmFpbFlUaHVtYkNvbG9yc1xuICAgICAgfVxuICAgIF0sIHRoaXMuX2VsZW1lbnQgJiYgKHkuc2V0RGF0YSh0LCB4cywgdGhpcyksIGguYWRkQ2xhc3ModGhpcy5fZWxlbWVudCwgZ3YpKSwgdGhpcy5pbml0KCk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIHBvO1xuICB9XG4gIGdldCByYWlsWCgpIHtcbiAgICByZXR1cm4gZC5maW5kT25lKFwiLnBzX19yYWlsLXhcIiwgdGhpcy5fZWxlbWVudCk7XG4gIH1cbiAgZ2V0IHJhaWxZKCkge1xuICAgIHJldHVybiBkLmZpbmRPbmUoXCIucHNfX3JhaWwteVwiLCB0aGlzLl9lbGVtZW50KTtcbiAgfVxuICBfZ2V0Q29uZmlnKHQpIHtcbiAgICBjb25zdCBlID0gaC5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gZS5oYW5kbGVycyAhPT0gdm9pZCAwICYmIChlLmhhbmRsZXJzID0gZS5oYW5kbGVycy5zcGxpdChcIiBcIikpLCB0ID0ge1xuICAgICAgLi4uYnYsXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIEQocG8sIHQsIHZ2KSwgdDtcbiAgfVxuICBfZ2V0Q2xhc3Nlcyh0KSB7XG4gICAgY29uc3QgZSA9IGguZ2V0RGF0YUNsYXNzQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLlR2LFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBEKHBvLCB0LCBFdiksIHQ7XG4gIH1cbiAgLy8gUHVibGljXG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5fb3B0aW9ucy5wb3NpdGlvblJpZ2h0ICYmIHRoaXMuX29ic2VydmVyLmRpc2Nvbm5lY3QoKSwgeS5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIHhzKSwgdGhpcy5fZWxlbWVudCA9IG51bGwsIHRoaXMuX2RhdGFBdHRyT3B0aW9ucyA9IG51bGwsIHRoaXMuX29wdGlvbnMgPSBudWxsLCB0aGlzLnBlcmZlY3RTY3JvbGxiYXIuZGVzdHJveSgpLCB0aGlzLnJlbW92ZUV2ZW50KF9vKSwgdGhpcy5wZXJmZWN0U2Nyb2xsYmFyID0gbnVsbDtcbiAgfVxuICBpbml0KCkge1xuICAgIGlmICh0aGlzLnBlcmZlY3RTY3JvbGxiYXIgPSBuZXcgVWkodGhpcy5fZWxlbWVudCwgdGhpcy5fb3B0aW9ucyksIHRoaXMuX2FkZFBlcmZlY3RTY3JvbGxiYXJTdHlsZXMoKSwgdGhpcy5fdXBkYXRlU2Nyb2xsUG9zaXRpb24oKSwgdGhpcy5wZXJmZWN0U2Nyb2xsYmFyLnVwZGF0ZSgpLCB0aGlzLl9pbml0RXZlbnRzKF9vKSwgdGhpcy5fb3B0aW9ucy5wb3NpdGlvblJpZ2h0KSB7XG4gICAgICB0aGlzLl9vYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcigoKSA9PiB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuX3VwZGF0ZVNjcm9sbFBvc2l0aW9uKCk7XG4gICAgICAgIH0sIDEwMCk7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHQgPSB7XG4gICAgICAgIGF0dHJpYnV0ZXM6ICEwLFxuICAgICAgICBhdHRyaWJ1dGVGaWx0ZXI6IFtcImNsYXNzXCIsIFwiY2xhc3NOYW1lXCJdXG4gICAgICB9O1xuICAgICAgdGhpcy5fb2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLl9lbGVtZW50LCB0KTtcbiAgICB9XG4gIH1cbiAgX3VwZGF0ZVNjcm9sbFBvc2l0aW9uKCkge1xuICAgIGNvbnN0IHQgPSBnZXRDb21wdXRlZFN0eWxlKHRoaXMuX2VsZW1lbnQpLmdldFByb3BlcnR5VmFsdWUoXCJoZWlnaHRcIiksIGUgPSBnZXRDb21wdXRlZFN0eWxlKHRoaXMuX2VsZW1lbnQpLmdldFByb3BlcnR5VmFsdWUoXCJ3aWR0aFwiKTtcbiAgICB0aGlzLnJhaWxYICYmICh0aGlzLnJhaWxYLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGVZKGNhbGMoLTEwMCUgKyAke3RoaXMuX2NhblRyYW5zZm9ybSh0KSA/IHQgOiBcIjBweFwifSkpYCksIHRoaXMucmFpbFkgJiYgKHRoaXMucmFpbFkuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZVgoY2FsYygtMTAwJSArICR7dGhpcy5fY2FuVHJhbnNmb3JtKGUpID8gZSA6IFwiMHB4XCJ9KSlgKTtcbiAgfVxuICBfY2FuVHJhbnNmb3JtKHQpIHtcbiAgICByZXR1cm4gdCAmJiB0LmluY2x1ZGVzKFwicHhcIik7XG4gIH1cbiAgdXBkYXRlKCkge1xuICAgIHJldHVybiB0aGlzLnBlcmZlY3RTY3JvbGxiYXIudXBkYXRlKCk7XG4gIH1cbiAgX2luaXRFdmVudHModCA9IFtdKSB7XG4gICAgdC5mb3JFYWNoKFxuICAgICAgKHsgcHM6IGUsIHRlOiBpIH0pID0+IGMub24oXG4gICAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICAgIGUsXG4gICAgICAgIChuKSA9PiBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgaSwgeyBlOiBuIH0pXG4gICAgICApXG4gICAgKTtcbiAgfVxuICBfYWRkUGVyZmVjdFNjcm9sbGJhclN0eWxlcygpIHtcbiAgICB0aGlzLl9wc0NsYXNzZXMuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgY29uc3QgZSA9IGQuZmluZE9uZShgLiR7dC5wc31gLCB0aGlzLl9lbGVtZW50KTtcbiAgICAgIGguYWRkQ2xhc3MoZSwgdC50ZSksIGguYWRkQ2xhc3MoZSwgdC50ZUNvbG9yKTtcbiAgICB9KSwgaC5hZGRDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl9jbGFzc2VzLnBzKSwgaC5yZW1vdmVDbGFzcyh0aGlzLl9lbGVtZW50LCBcInBzXCIpO1xuICB9XG4gIHJlbW92ZUV2ZW50KHQpIHtcbiAgICBsZXQgZSA9IFtdO1xuICAgIHR5cGVvZiB0ID09IFwic3RyaW5nXCIgJiYgKGUgPSBfby5maWx0ZXIoKHsgdGU6IGkgfSkgPT4gaSA9PT0gdCkpLCBlLmZvckVhY2goKHsgcHM6IGksIHRlOiBuIH0pID0+IHtcbiAgICAgIGMub2ZmKHRoaXMuX2VsZW1lbnQsIGkpLCBjLm9mZih0aGlzLl9lbGVtZW50LCBuKTtcbiAgICB9KTtcbiAgfVxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0KSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGxldCBlID0geS5nZXREYXRhKHRoaXMsIHhzKTtcbiAgICAgIGNvbnN0IGkgPSB0eXBlb2YgdCA9PSBcIm9iamVjdFwiICYmIHQ7XG4gICAgICBpZiAoISghZSAmJiAvZGlzcG9zZXxoaWRlLy50ZXN0KHQpKSAmJiAoZSB8fCAoZSA9IG5ldyBmcih0aGlzLCBpKSksIHR5cGVvZiB0ID09IFwic3RyaW5nXCIpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZVt0XSA+IFwidVwiKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7dH1cImApO1xuICAgICAgICBlW3RdKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGdldEluc3RhbmNlKHQpIHtcbiAgICByZXR1cm4geS5nZXREYXRhKHQsIHhzKTtcbiAgfVxuICBzdGF0aWMgZ2V0T3JDcmVhdGVJbnN0YW5jZSh0LCBlID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSh0KSB8fCBuZXcgdGhpcyh0LCB0eXBlb2YgZSA9PSBcIm9iamVjdFwiID8gZSA6IG51bGwpO1xuICB9XG59XG5jb25zdCBtaCA9IGZyLCBDdiA9IFwiZGF0YS10ZS1kYXRhdGFibGUtc2VsZWN0LXJlZlwiLCBBdiA9IFwiZGF0YS10ZS1kYXRhdGFibGUtcGFnaW5hdGlvbi1uYXYtcmVmXCIsIHl2ID0gXCJkYXRhLXRlLWRhdGF0YWJsZS1wYWdpbmF0aW9uLXJpZ2h0LXJlZlwiLCB3diA9IFwiZGF0YS10ZS1kYXRhdGFibGUtcGFnaW5hdGlvbi1sZWZ0LXJlZlwiLCBrdiA9IFwiZGF0YS10ZS1kYXRhdGFibGUtcGFnaW5hdGlvbi1zdGFydC1yZWZcIiwgeHYgPSBcImRhdGEtdGUtZGF0YXRhYmxlLXBhZ2luYXRpb24tZW5kLXJlZlwiLCBPdiA9ICh7XG4gIHRleHQ6IHMsXG4gIGVudHJpZXM6IHQsXG4gIGVudHJpZXNPcHRpb25zOiBlLFxuICBmdWxsUGFnaW5hdGlvbjogaSxcbiAgcm93c1RleHQ6IG4sXG4gIGFsbFRleHQ6IG8sXG4gIHBhZ2luYXRpb25TdGFydEljb25UZW1wbGF0ZTogcixcbiAgcGFnaW5hdGlvbkxlZnRJY29uVGVtcGxhdGU6IGEsXG4gIHBhZ2luYXRpb25SaWdodEljb25UZW1wbGF0ZTogbCxcbiAgcGFnaW5hdGlvbkVuZEljb25UZW1wbGF0ZTogcCxcbiAgY2xhc3NlczogdVxufSwgXywgZikgPT4ge1xuICBjb25zdCBnID0gZS5tYXAoKG0pID0+IG0gPT09IFwiQWxsXCIgPyBgPG9wdGlvbiB2YWx1ZT1cIiR7bX1cIiAke20gPT09IHQgPyBcInNlbGVjdGVkXCIgOiBcIlwifT4ke299PC9vcHRpb24+YCA6IGA8b3B0aW9uIHZhbHVlPVwiJHttfVwiICR7bSA9PT0gdCA/IFwic2VsZWN0ZWRcIiA6IFwiXCJ9PiR7bX08L29wdGlvbj5gKS5qb2luKGBcbmApO1xuICByZXR1cm4gYFxuPGRpdiBjbGFzcz1cIiR7dS5wYWdpbmF0aW9ufSAke2YgPyBgJHt1LnBhZ2luYXRpb25Cb3JkZXJlZH1gIDogXCJcIn0gJHt1LmJvcmRlckNvbG9yfSAke3UuY29sb3J9XCI+XG4gIDxkaXYgY2xhc3M9XCIke3Uuc2VsZWN0SXRlbXNXcmFwcGVyfVwiPiAgXG4gICAgPHAgY2xhc3M9XCIke3UucGFnaW5hdGlvblJvd3NUZXh0fSAke18gPyBgJHt1LmxvYWRpbmdQYWdpbmF0aW9uUm93c1RleHR9YCA6IFwiXCJ9XCI+JHtufTwvcD5cbiAgICA8ZGl2IGNsYXNzPVwiJHt1LnNlbGVjdFdyYXBwZXJ9ICR7XyA/IGAke3UubG9hZGluZ1BhZ2luYXRpb25TZWxlY3RXcmFwcGVyfWAgOiBcIlwifVwiPlxuICAgICAgPHNlbGVjdCBuYW1lPVwiZW50cmllc1wiXG4gICAgICAgICR7XyA/IFwiZGlzYWJsZWRcIiA6IFwiXCJ9IGNsYXNzPVwic2VsZWN0XCIgJHtDdn0+XG4gICAgICAgICR7Z31cbiAgICAgIDwvc2VsZWN0PlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbiAgPGRpdiBjbGFzcz1cIiR7dS5wYWdpbmF0aW9uTmF2fSAke18gPyBgJHt1LmxvYWRpbmdQYWdpbmF0aW9uTmF2fWAgOiBcIlwifVwiICR7QXZ9PlxuICAke3N9XG4gIDwvZGl2PlxuICA8ZGl2IGNsYXNzPVwiJHt1LnBhZ2luYXRpb25CdXR0b25zV3JhcHBlcn1cIj5cbiAgICAke2kgPyBgPGJ1dHRvbiBkYXRhLXRlLXJpcHBsZS1pbml0IGRhdGEtdGUtcmlwcGxlLWNvbG9yPVwiZGFya1wiIGNsYXNzPVwiJHt1LnBhZ2luYXRpb25TdGFydEJ1dHRvbn1cIiAke2t2fT5cbiAgICAgICAgICAgJHtyfVxuICAgICAgICAgIDwvYnV0dG9uPmAgOiBcIlwifVxuICAgIDxidXR0b24gZGF0YS10ZS1yaXBwbGUtaW5pdCBkYXRhLXRlLXJpcHBsZS1jb2xvcj1cImRhcmtcIiBjbGFzcz1cIiR7dS5wYWdpbmF0aW9uTGVmdEJ1dHRvbn1cIiAke3d2fT5cbiAgICAgICR7YX1cbiAgPC9idXR0b24+XG4gICAgPGJ1dHRvbiBkYXRhLXRlLXJpcHBsZS1pbml0IGRhdGEtdGUtcmlwcGxlLWNvbG9yPVwiZGFya1wiIGNsYXNzPVwiJHt1LnBhZ2luYXRpb25SaWdodEJ1dHRvbn1cIiAke3l2fT5cbiAgICAgICR7bH1cbiAgPC9idXR0b24+XG4gICAgJHtpID8gYDxidXR0b24gZGF0YS10ZS1yaXBwbGUtaW5pdCBkYXRhLXRlLXJpcHBsZS1jb2xvcj1cImRhcmtcIiBjbGFzcz1cIiR7dS5wYWdpbmF0aW9uRW5kQnV0dG9ufVwiICR7eHZ9PlxuICAgICAgICAgICAke3B9XG4gICAgICAgICAgPC9idXR0b24+YCA6IFwiXCJ9XG4gIDwvZGl2PlxuPC9kaXY+XG5gO1xufSwgU3YgPSBcImRhdGEtdGUtZGF0YXRhYmxlLXNvcnQtaWNvbi1yZWZcIiwgSXYgPSBcImRhdGEtdGUtZGF0YXRhYmxlLWhlYWRlci1jaGVja2JveC1yZWZcIiwgRHYgPSAocywgdCwgZSwgaSwgbiwgbywgciwgYSkgPT4ge1xuICBjb25zdCBsID0gZSA/IGBcbiAgPHRoIHNjb3BlPVwiY29sXCI+XG4gICAgPGRpdiBjbGFzcz1cIiR7YS5jaGVja2JveEhlYWRlcldyYXBwZXJ9XCI+XG4gICAgICA8aW5wdXRcbiAgICAgICAgY2xhc3M9XCIke2EuY2hlY2tib3hIZWFkZXJ9XCJcbiAgICAgICAgdHlwZT1cImNoZWNrYm94XCJcbiAgICAgICAgdmFsdWU9XCJcIlxuICAgICAgICAke0l2fVxuICAgICAgICAvPlxuICAgIDwvZGl2PlxuICA8L3RoPlxuICBgIDogJzx0aCBzY29wZT1cImNvbFwiPjwvdGg+JywgcCA9IHMubWFwKCh1LCBfKSA9PiB7XG4gICAgY29uc3QgZiA9IHUuZml4ZWQgPyBzLmZpbHRlcigoZywgbSkgPT4gZy5maXhlZCA9PT0gdS5maXhlZCAmJiBtIDwgXykucmVkdWNlKChnLCBtKSA9PiBnICsgbS53aWR0aCwgMCkgOiBudWxsO1xuICAgIHJldHVybiBgPHRoIGNsYXNzPVwiJHthLmNvbHVtbn0gJHtpID8gYCR7YS50YWJsZUJvcmRlcmVkfWAgOiBcIlwifSAke2EuYm9yZGVyQ29sb3J9ICR7biA/IGAke2Euc219YCA6IFwiXCJ9ICR7dS5maXhlZCA/IGAke2EuZml4ZWRIZWFkZXJ9ICR7YS5jb2xvcn1gIDogXCJcIn0gJHtvID8gYCR7YS5sb2FkaW5nQ29sdW1ufWAgOiBcIlwifVwiIHN0eWxlPVwiJHt1LmZpeGVkID8gYCR7dS5maXhlZCA9PT0gXCJyaWdodFwiID8gXCJyaWdodFwiIDogXCJsZWZ0XCJ9OiAke2Z9cHg7YCA6IFwiXCJ9XCIgc2NvcGU9XCJjb2xcIj4ke3Uuc29ydCA/IGA8ZGl2IGNsYXNzPVwiJHthLnNvcnRJY29uV3JhcHBlcn1cIj48c3BhbiBjbGFzcz1cIiR7YS5zb3J0SWNvbn0gJHtvID8gXCJpbnZpc2libGVcIiA6IFwiXCJ9XCIgZGF0YS10ZS1zb3J0PVwiJHt1LmZpZWxkfVwiICR7U3Z9PiR7cn08L3NwYW4+YCA6IFwiXCJ9IDxzcGFuIGNsYXNzPVwiJHt1LnNvcnQgPyBcIlwiIDogXCJwbC1bMThweF1cIn1cIj4ke3UubGFiZWx9PC9zcGFuPjwvZGl2PjwvdGg+YDtcbiAgfSk7XG4gIHJldHVybiBbdCA/IGwgOiBcIlwiLCAuLi5wXS5qb2luKGBcbmApO1xufSwgJHYgPSBcImRhdGEtdGUtZGF0YXRhYmxlLXJvdy1yZWZcIiwgTHYgPSBcImRhdGEtdGUtZGF0YXRhYmxlLXJvdy1jaGVja2JveC1yZWZcIiwgTnYgPSBcImRhdGEtdGUtZGF0YXRhYmxlLWNlbGwtcmVmXCIsIE12ID0gKHtcbiAgcm93czogcyxcbiAgY29sdW1uczogdCxcbiAgbm9Gb3VuZE1lc3NhZ2U6IGUsXG4gIGVkaXQ6IGksXG4gIHNlbGVjdGFibGU6IG4sXG4gIGxvYWRpbmc6IG8sXG4gIGJvcmRlcmVkOiByLFxuICBib3JkZXJsZXNzOiBhLFxuICBzdHJpcGVkOiBsLFxuICBob3ZlcjogcCxcbiAgc206IHUsXG4gIGNsYXNzZXM6IF9cbn0pID0+IHtcbiAgY29uc3QgZiA9IHMubWFwKChnKSA9PiB7XG4gICAgY29uc3QgbSA9IGBcbiAgICAgIDx0ZCBkYXRhLXRlLWZpZWxkPVwiY2hlY2tib3hcIiBjbGFzcz1cIiR7ciA/IGAke18udGFibGVCb3JkZXJlZH0gJHtfLmJvcmRlckNvbG9yfWAgOiBcIlwifVwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiJHtfLmNoZWNrYm94Um93V3JhcHBlcn1cIj5cbiAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgIGNsYXNzPVwiJHtfLmNoZWNrYm94Um93fVwiXG4gICAgICAgICAgICB0eXBlPVwiY2hlY2tib3hcIlxuICAgICAgICAgICAgdmFsdWU9XCJcIlxuICAgICAgICAgICAgZGF0YS10ZS1yb3ctaW5kZXg9XCIke2cucm93SW5kZXh9XCIgICR7THZ9Lz5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L3RkPmAsIGIgPSB0Lm1hcCgodiwgQykgPT4ge1xuICAgICAgY29uc3QgdyA9IHt9O1xuICAgICAgaWYgKHYud2lkdGggJiYgKHdbXCJtaW4td2lkdGhcIl0gPSBgJHt2LndpZHRoIC0gMX1weGAsIHdbXCJtYXgtd2lkdGhcIl0gPSBgJHt2LndpZHRofXB4YCwgdy53aWR0aCA9IGAke3Yud2lkdGh9cHhgKSwgdi5maXhlZCkge1xuICAgICAgICBjb25zdCBUID0gdC5maWx0ZXIoKEEsIGspID0+IEEuZml4ZWQgPT09IHYuZml4ZWQgJiYgayA8IEMpLnJlZHVjZSgoQSwgaykgPT4gQSArIGsud2lkdGgsIDApO1xuICAgICAgICB3W3YuZml4ZWQgPT09IFwicmlnaHRcIiA/IFwicmlnaHRcIiA6IFwibGVmdFwiXSA9IGAke1R9cHhgO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGA8dGQgc3R5bGU9XCIke09iamVjdC5rZXlzKHcpLm1hcCgoVCkgPT4gYCR7VH06ICR7d1tUXX1gKS5qb2luKFwiOyBcIil9XCIgY2xhc3M9XCIke18ucm93SXRlbX0gJHtfLmJvcmRlckNvbG9yfSAke2kgPyBgJHtfLmVkaXR9YCA6IFwiXCJ9ICR7ciA/IGAke18udGFibGVCb3JkZXJlZH1gIDogXCJcIn0gJHt1ID8gYCR7Xy5zbX1gIDogXCJcIn0gJHt2LmZpeGVkID8gYCR7Xy5maXhlZEhlYWRlcn0gJHtfLmNvbG9yfWAgOiBcIlwifVwiICR7TnZ9IGRhdGEtdGUtZmllbGQ9XCIke3YuZmllbGR9XCIgJHtpICYmICdjb250ZW50ZWRpdGFibGU9XCJ0cnVlXCInfT4ke2dbdi5maWVsZF19PC90ZD5gO1xuICAgIH0pLmpvaW4oXCJcIik7XG4gICAgcmV0dXJuIGA8dHIgc2NvcGU9XCJyb3dcIiBjbGFzcz1cIiR7Xy5yb3d9ICR7Xy5ib3JkZXJDb2xvcn0gJHtfLnJvd0FuaW1hdGlvbn0gJHtsID8gYCR7Xy5zdHJpcGVkfWAgOiBcIlwifSAke2EgPyBgJHtfLmJvcmRlcmxlc3N9YCA6IFwiXCJ9ICR7cCA/IGAke18uaG92ZXJSb3d9YCA6IFwiXCJ9XCIgZGF0YS10ZS1pbmRleD1cIiR7Zy5yb3dJbmRleH1cIiAkeyR2fT4ke24gPyBtIDogXCJcIn0ke2J9PC90cj5gO1xuICB9KTtcbiAgcmV0dXJuIHMubGVuZ3RoID4gMCB8fCBvID8gZi5qb2luKGBcbmApIDogYDx0ciBjbGFzcz1cIiR7Xy5ub0ZvdW5kTWVzc2FnZVdyYXBwZXJ9ICR7Xy5ib3JkZXJDb2xvcn1cIj48dGQgY2xhc3M9XCIke18ubm9Gb3VuZE1lc3NhZ2V9XCI+JHtlfTwvdGQ+PC90cj5gO1xufSwgUnYgPSBcImRhdGEtdGUtZGF0YXRhYmxlLWlubmVyLXJlZlwiLCBQdiA9IFwiZGF0YS10ZS1kYXRhdGFibGUtaGVhZGVyLXJlZlwiLCB3bCA9ICh7XG4gIGNvbHVtbnM6IHMsXG4gIHJvd3M6IHQsXG4gIG5vRm91bmRNZXNzYWdlOiBlLFxuICBlZGl0OiBpLFxuICBtdWx0aTogbixcbiAgc2VsZWN0YWJsZTogbyxcbiAgbG9hZGluZzogcixcbiAgbG9hZGluZ01lc3NhZ2U6IGEsXG4gIHBhZ2luYXRpb246IGwsXG4gIGJvcmRlcmVkOiBwLFxuICBib3JkZXJsZXNzOiB1LFxuICBzdHJpcGVkOiBfLFxuICBob3ZlcjogZixcbiAgZml4ZWRIZWFkZXI6IGcsXG4gIHNtOiBtLFxuICBzb3J0SWNvblRlbXBsYXRlOiBiLFxuICBjbGFzc2VzOiB2XG59KSA9PiB7XG4gIGNvbnN0IEMgPSBNdih7XG4gICAgcm93czogdCxcbiAgICBjb2x1bW5zOiBzLFxuICAgIG5vRm91bmRNZXNzYWdlOiBlLFxuICAgIGVkaXQ6IGksXG4gICAgbG9hZGluZzogcixcbiAgICBzZWxlY3RhYmxlOiBvLFxuICAgIGJvcmRlcmVkOiBwLFxuICAgIGJvcmRlcmxlc3M6IHUsXG4gICAgc3RyaXBlZDogXyxcbiAgICBob3ZlcjogZixcbiAgICBzbTogbSxcbiAgICBjbGFzc2VzOiB2XG4gIH0pLCB3ID0gRHYoXG4gICAgcyxcbiAgICBvLFxuICAgIG4sXG4gICAgcCxcbiAgICBtLFxuICAgIHIsXG4gICAgYixcbiAgICB2XG4gICk7XG4gIHJldHVybiB7IHRhYmxlOiBgXG48ZGl2IGNsYXNzPVwiJHt2LmNvbG9yfVwiICR7UnZ9PlxuICA8dGFibGUgY2xhc3M9XCIke3YudGFibGV9XCI+XG4gICAgPHRoZWFkIGNsYXNzPVwiJHt2LnRhYmxlSGVhZGVyfSAke3AgPyBgJHt2LnRhYmxlQm9yZGVyZWR9YCA6IFwiXCJ9ICR7dSA/IGAke3YuYm9yZGVybGVzc31gIDogXCJcIn0gJHt2LmJvcmRlckNvbG9yfVwiICR7UHZ9PlxuICAgICAgPHRyPlxuICAgICAgICAke3d9XG4gICAgICA8L3RyPlxuICAgIDwvdGhlYWQ+XG4gICAgPHRib2R5IGNsYXNzPVwiJHtnID8gYCR7di5maXhlZEhlYWRlckJvZHl9YCA6IFwiXCJ9XCI+XG4gICAgICAke3IgPyBcIlwiIDogQ31cbiAgICA8L3Rib2R5PlxuICA8L3RhYmxlPlxuPC9kaXY+XG4ke3IgPyBgXG4gIDxkaXYgY2xhc3M9XCIke3YubG9hZGluZ0l0ZW1zV3JhcHBlcn1cIj5cbiAgICA8ZGl2IGNsYXNzPVwiJHt2LmxvYWRpbmdQcm9ncmVzc0JhcldyYXBwZXJ9XCI+XG4gICAgICA8ZGl2IGNsYXNzPVwiJHt2LmxvYWRpbmdQcm9ncmVzc0Jhcn1cIj48L2Rpdj5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG48cCBjbGFzcz1cIiR7di5sb2FkaW5nTWVzc2FnZX1cIj4ke2F9PC9wPlxuYCA6IFwiXCJ9XG4ke2wuZW5hYmxlID8gT3YobCwgciwgcCkgOiBcIlwifVxuICBgLCByb3dzOiBDLCBjb2x1bW46IHcgfTtcbn0sIEJ2ID0gKHsgcm93czogcywgZmllbGQ6IHQsIG9yZGVyOiBlIH0pID0+IHMuc29ydCgobiwgbykgPT4ge1xuICBsZXQgciA9IG5bdF0sIGEgPSBvW3RdO1xuICByZXR1cm4gdHlwZW9mIHIgPT0gXCJzdHJpbmdcIiAmJiAociA9IHIudG9Mb3dlckNhc2UoKSksIHR5cGVvZiBhID09IFwic3RyaW5nXCIgJiYgKGEgPSBhLnRvTG93ZXJDYXNlKCkpLCByIDwgYSA/IGUgPT09IFwiZGVzY1wiID8gMSA6IC0xIDogciA+IGEgPyBlID09PSBcImRlc2NcIiA/IC0xIDogMSA6IDA7XG59KSwgSHYgPSAocywgdCwgZSkgPT4ge1xuICBpZiAoIXQpXG4gICAgcmV0dXJuIHM7XG4gIGNvbnN0IGkgPSAobikgPT4ge1xuICAgIGNvbnN0IG8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHJldHVybiBvLmlubmVySFRNTCA9IG4sIG4gPSBvLnRleHRDb250ZW50IHx8IG8uaW5uZXJUZXh0IHx8IFwiXCIsIG4udG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpLm1hdGNoKHQudG9Mb3dlckNhc2UoKSk7XG4gIH07XG4gIHJldHVybiBzLmZpbHRlcigobikgPT4ge1xuICAgIGlmIChlICYmIHR5cGVvZiBlID09IFwic3RyaW5nXCIpXG4gICAgICByZXR1cm4gaShuW2VdKTtcbiAgICBsZXQgbyA9IE9iamVjdC52YWx1ZXMobik7XG4gICAgcmV0dXJuIGUgJiYgQXJyYXkuaXNBcnJheShlKSAmJiAobyA9IE9iamVjdC5rZXlzKG4pLmZpbHRlcigocikgPT4gZS5pbmNsdWRlcyhyKSkubWFwKChyKSA9PiBuW3JdKSksIG8uZmlsdGVyKChyKSA9PiBpKHIpKS5sZW5ndGggPiAwO1xuICB9KTtcbn0sIGtsID0gKHsgcm93czogcywgZW50cmllczogdCwgYWN0aXZlUGFnZTogZSB9KSA9PiB7XG4gIGNvbnN0IGkgPSBlICogdDtcbiAgcmV0dXJuIHMuc2xpY2UoaSwgaSArIE51bWJlcih0KSk7XG59LCBOaSA9IFwiZGF0YXRhYmxlXCIsIGZ0ID0gYGRhdGEtdGUtJHtOaX1gLCBFaSA9IGB0ZS4ke05pfWAsIF9uID0gYC4ke0VpfWAsIFZ2ID0gYFske2Z0fS1pbm5lci1yZWZdYCwgZm8gPSBgWyR7ZnR9LWNlbGwtcmVmXWAsIFd2ID0gYFske2Z0fS1oZWFkZXItcmVmXWAsIEZ2ID0gYFske2Z0fS1oZWFkZXItY2hlY2tib3gtcmVmXWAsIFl2ID0gYFske2Z0fS1wYWdpbmF0aW9uLXJpZ2h0LXJlZl1gLCBqdiA9IGBbJHtmdH0tcGFnaW5hdGlvbi1sZWZ0LXJlZl1gLCBLdiA9IGBbJHtmdH0tcGFnaW5hdGlvbi1zdGFydC1yZWZdYCwgenYgPSBgWyR7ZnR9LXBhZ2luYXRpb24tZW5kLXJlZl1gLCBVdiA9IGBbJHtmdH0tcGFnaW5hdGlvbi1uYXYtcmVmXWAsIFh2ID0gYFske2Z0fS1zZWxlY3QtcmVmXWAsIG1vID0gYFske2Z0fS1zb3J0LWljb24tcmVmXWAsIGZpID0gYFske2Z0fS1yb3ctcmVmXWAsIGdvID0gYFske2Z0fS1yb3ctY2hlY2tib3gtcmVmXWAsIEd2ID0gYHNlbGVjdFJvd3Mke19ufWAsIHhsID0gYHJlbmRlciR7X259YCwgcXYgPSBgcm93Q2xpY2ske19ufWAsIFp2ID0gYHVwZGF0ZSR7X259YCwgUXYgPSBgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cImN1cnJlbnRDb2xvclwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIzXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCI+XG4gIDxwYXRoIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIGQ9XCJNNC41IDEwLjVMMTIgM20wIDBsNy41IDcuNU0xMiAzdjE4XCIgLz5cbjwvc3ZnPmAsIEp2ID0gYDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjEuNVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGNsYXNzPVwidy00IGgtNFwiPlxuICA8cGF0aCBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBkPVwiTTE4Ljc1IDE5LjVsLTcuNS03LjUgNy41LTcuNW0tNiAxNUw1LjI1IDEybDcuNS03LjVcIiAvPlxuPC9zdmc+YCwgdFQgPSBgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMS41XCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgY2xhc3M9XCJ3LTQgaC00XCI+XG4gIDxwYXRoIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIGQ9XCJNMTUuNzUgMTkuNUw4LjI1IDEybDcuNS03LjVcIiAvPlxuPC9zdmc+YCwgZVQgPSBgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMS41XCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgY2xhc3M9XCJ3LTQgaC00XCI+XG4gIDxwYXRoIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIGQ9XCJNOC4yNSA0LjVsNy41IDcuNS03LjUgNy41XCIgLz5cbjwvc3ZnPmAsIGlUID0gYDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjEuNVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGNsYXNzPVwidy00IGgtNFwiPlxuICA8cGF0aCBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBkPVwiTTExLjI1IDQuNWw3LjUgNy41LTcuNSA3LjVtLTYtMTVsNy41IDcuNS03LjUgNy41XCIvPlxuPC9zdmc+YCwgc1QgPSBcImJvcmRlci1uZXV0cmFsLTIwMCBkYXJrOmJvcmRlci1uZXV0cmFsLTUwMFwiLCBuVCA9IFwiYm9yZGVyLW5vbmVcIiwgb1QgPSBcInJlbGF0aXZlIGZsb2F0LWxlZnQgLW1sLVsxLjVyZW1dIG1yLVs2cHhdIG10LVswLjE1cmVtXSBoLVsxLjEyNXJlbV0gdy1bMS4xMjVyZW1dIGFwcGVhcmFuY2Utbm9uZSByb3VuZGVkLVswLjI1cmVtXSBib3JkZXItWzAuMTI1cmVtXSBib3JkZXItc29saWQgYm9yZGVyLW5ldXRyYWwtMzAwIG91dGxpbmUtbm9uZSBiZWZvcmU6cG9pbnRlci1ldmVudHMtbm9uZSBiZWZvcmU6YWJzb2x1dGUgYmVmb3JlOmgtWzAuODc1cmVtXSBiZWZvcmU6dy1bMC44NzVyZW1dIGJlZm9yZTpzY2FsZS0wIGJlZm9yZTpyb3VuZGVkLWZ1bGwgYmVmb3JlOmJnLXRyYW5zcGFyZW50IGJlZm9yZTpvcGFjaXR5LTAgYmVmb3JlOnNoYWRvdy1bMHB4XzBweF8wcHhfMTNweF90cmFuc3BhcmVudF0gYmVmb3JlOmNvbnRlbnQtWycnXSBjaGVja2VkOmJvcmRlci1wcmltYXJ5IGNoZWNrZWQ6YmctcHJpbWFyeSBjaGVja2VkOmJlZm9yZTpvcGFjaXR5LVswLjE2XSBjaGVja2VkOmFmdGVyOmFic29sdXRlIGNoZWNrZWQ6YWZ0ZXI6LW10LXB4IGNoZWNrZWQ6YWZ0ZXI6bWwtWzAuMjVyZW1dIGNoZWNrZWQ6YWZ0ZXI6YmxvY2sgY2hlY2tlZDphZnRlcjpoLVswLjgxMjVyZW1dIGNoZWNrZWQ6YWZ0ZXI6dy1bMC4zNzVyZW1dIGNoZWNrZWQ6YWZ0ZXI6cm90YXRlLTQ1IGNoZWNrZWQ6YWZ0ZXI6Ym9yZGVyLVswLjEyNXJlbV0gY2hlY2tlZDphZnRlcjpib3JkZXItbC0wIGNoZWNrZWQ6YWZ0ZXI6Ym9yZGVyLXQtMCBjaGVja2VkOmFmdGVyOmJvcmRlci1zb2xpZCBjaGVja2VkOmFmdGVyOmJvcmRlci13aGl0ZSBjaGVja2VkOmFmdGVyOmJnLXRyYW5zcGFyZW50IGNoZWNrZWQ6YWZ0ZXI6Y29udGVudC1bJyddIGhvdmVyOmN1cnNvci1wb2ludGVyIGhvdmVyOmJlZm9yZTpvcGFjaXR5LVswLjA0XSBob3ZlcjpiZWZvcmU6c2hhZG93LVswcHhfMHB4XzBweF8xM3B4X3JnYmEoMCwwLDAsMC42KV0gZm9jdXM6c2hhZG93LW5vbmUgZm9jdXM6dHJhbnNpdGlvbi1bYm9yZGVyLWNvbG9yXzAuMnNdIGZvY3VzOmJlZm9yZTpzY2FsZS0xMDAgZm9jdXM6YmVmb3JlOm9wYWNpdHktWzAuMTJdIGZvY3VzOmJlZm9yZTpzaGFkb3ctWzBweF8wcHhfMHB4XzEzcHhfcmdiYSgwLDAsMCwwLjYpXSBmb2N1czpiZWZvcmU6dHJhbnNpdGlvbi1bYm94LXNoYWRvd18wLjJzLHRyYW5zZm9ybV8wLjJzXSBmb2N1czphZnRlcjphYnNvbHV0ZSBmb2N1czphZnRlcjp6LVsxXSBmb2N1czphZnRlcjpibG9jayBmb2N1czphZnRlcjpoLVswLjg3NXJlbV0gZm9jdXM6YWZ0ZXI6dy1bMC44NzVyZW1dIGZvY3VzOmFmdGVyOnJvdW5kZWQtWzAuMTI1cmVtXSBmb2N1czphZnRlcjpjb250ZW50LVsnJ10gY2hlY2tlZDpmb2N1czpiZWZvcmU6c2NhbGUtMTAwIGNoZWNrZWQ6Zm9jdXM6YmVmb3JlOnNoYWRvdy1bMHB4XzBweF8wcHhfMTNweF8jM2I3MWNhXSBjaGVja2VkOmZvY3VzOmJlZm9yZTp0cmFuc2l0aW9uLVtib3gtc2hhZG93XzAuMnMsdHJhbnNmb3JtXzAuMnNdIGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6LW10LXB4IGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6bWwtWzAuMjVyZW1dIGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6aC1bMC44MTI1cmVtXSBjaGVja2VkOmZvY3VzOmFmdGVyOnctWzAuMzc1cmVtXSBjaGVja2VkOmZvY3VzOmFmdGVyOnJvdGF0ZS00NSBjaGVja2VkOmZvY3VzOmFmdGVyOnJvdW5kZWQtbm9uZSBjaGVja2VkOmZvY3VzOmFmdGVyOmJvcmRlci1bMC4xMjVyZW1dIGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6Ym9yZGVyLWwtMCBjaGVja2VkOmZvY3VzOmFmdGVyOmJvcmRlci10LTAgY2hlY2tlZDpmb2N1czphZnRlcjpib3JkZXItc29saWQgY2hlY2tlZDpmb2N1czphZnRlcjpib3JkZXItd2hpdGUgY2hlY2tlZDpmb2N1czphZnRlcjpiZy10cmFuc3BhcmVudCBkYXJrOmJvcmRlci1uZXV0cmFsLTYwMCBkYXJrOmNoZWNrZWQ6Ym9yZGVyLXByaW1hcnkgZGFyazpjaGVja2VkOmJnLXByaW1hcnkgZGFyazpmb2N1czpiZWZvcmU6c2hhZG93LVswcHhfMHB4XzBweF8xM3B4X3JnYmEoMjU1LDI1NSwyNTUsMC40KV0gZGFyazpjaGVja2VkOmZvY3VzOmJlZm9yZTpzaGFkb3ctWzBweF8wcHhfMHB4XzEzcHhfIzNiNzFjYV0gZGFyazpib3JkZXItbmV1dHJhbC00MDBcIiwgclQgPSBcIm1iLVswLjEyNXJlbV0gbWluLWgtWzEuNXJlbV0gcGwtWzEuNXJlbV0gbWwtMyBmbGV4IGl0ZW1zLWNlbnRlclwiLCBhVCA9IFwicmVsYXRpdmUgZmxvYXQtbGVmdCAtbWwtWzEuNXJlbV0gbXItWzZweF0gbXQtWzAuMTVyZW1dIGgtWzEuMTI1cmVtXSB3LVsxLjEyNXJlbV0gYXBwZWFyYW5jZS1ub25lIHJvdW5kZWQtWzAuMjVyZW1dIGJvcmRlci1bMC4xMjVyZW1dIGJvcmRlci1zb2xpZCBib3JkZXItbmV1dHJhbC0zMDAgb3V0bGluZS1ub25lIGJlZm9yZTpwb2ludGVyLWV2ZW50cy1ub25lIGJlZm9yZTphYnNvbHV0ZSBiZWZvcmU6aC1bMC44NzVyZW1dIGJlZm9yZTp3LVswLjg3NXJlbV0gYmVmb3JlOnNjYWxlLTAgYmVmb3JlOnJvdW5kZWQtZnVsbCBiZWZvcmU6YmctdHJhbnNwYXJlbnQgYmVmb3JlOm9wYWNpdHktMCBiZWZvcmU6c2hhZG93LVswcHhfMHB4XzBweF8xM3B4X3RyYW5zcGFyZW50XSBiZWZvcmU6Y29udGVudC1bJyddIGNoZWNrZWQ6Ym9yZGVyLXByaW1hcnkgY2hlY2tlZDpiZy1wcmltYXJ5IGNoZWNrZWQ6YmVmb3JlOm9wYWNpdHktWzAuMTZdIGNoZWNrZWQ6YWZ0ZXI6YWJzb2x1dGUgY2hlY2tlZDphZnRlcjotbXQtcHggY2hlY2tlZDphZnRlcjptbC1bMC4yNXJlbV0gY2hlY2tlZDphZnRlcjpibG9jayBjaGVja2VkOmFmdGVyOmgtWzAuODEyNXJlbV0gY2hlY2tlZDphZnRlcjp3LVswLjM3NXJlbV0gY2hlY2tlZDphZnRlcjpyb3RhdGUtNDUgY2hlY2tlZDphZnRlcjpib3JkZXItWzAuMTI1cmVtXSBjaGVja2VkOmFmdGVyOmJvcmRlci1sLTAgY2hlY2tlZDphZnRlcjpib3JkZXItdC0wIGNoZWNrZWQ6YWZ0ZXI6Ym9yZGVyLXNvbGlkIGNoZWNrZWQ6YWZ0ZXI6Ym9yZGVyLXdoaXRlIGNoZWNrZWQ6YWZ0ZXI6YmctdHJhbnNwYXJlbnQgY2hlY2tlZDphZnRlcjpjb250ZW50LVsnJ10gaG92ZXI6Y3Vyc29yLXBvaW50ZXIgaG92ZXI6YmVmb3JlOm9wYWNpdHktWzAuMDRdIGhvdmVyOmJlZm9yZTpzaGFkb3ctWzBweF8wcHhfMHB4XzEzcHhfcmdiYSgwLDAsMCwwLjYpXSBmb2N1czpzaGFkb3ctbm9uZSBmb2N1czp0cmFuc2l0aW9uLVtib3JkZXItY29sb3JfMC4yc10gZm9jdXM6YmVmb3JlOnNjYWxlLTEwMCBmb2N1czpiZWZvcmU6b3BhY2l0eS1bMC4xMl0gZm9jdXM6YmVmb3JlOnNoYWRvdy1bMHB4XzBweF8wcHhfMTNweF9yZ2JhKDAsMCwwLDAuNildIGZvY3VzOmJlZm9yZTp0cmFuc2l0aW9uLVtib3gtc2hhZG93XzAuMnMsdHJhbnNmb3JtXzAuMnNdIGZvY3VzOmFmdGVyOmFic29sdXRlIGZvY3VzOmFmdGVyOnotWzFdIGZvY3VzOmFmdGVyOmJsb2NrIGZvY3VzOmFmdGVyOmgtWzAuODc1cmVtXSBmb2N1czphZnRlcjp3LVswLjg3NXJlbV0gZm9jdXM6YWZ0ZXI6cm91bmRlZC1bMC4xMjVyZW1dIGZvY3VzOmFmdGVyOmNvbnRlbnQtWycnXSBjaGVja2VkOmZvY3VzOmJlZm9yZTpzY2FsZS0xMDAgY2hlY2tlZDpmb2N1czpiZWZvcmU6c2hhZG93LVswcHhfMHB4XzBweF8xM3B4XyMzYjcxY2FdIGNoZWNrZWQ6Zm9jdXM6YmVmb3JlOnRyYW5zaXRpb24tW2JveC1zaGFkb3dfMC4ycyx0cmFuc2Zvcm1fMC4yc10gY2hlY2tlZDpmb2N1czphZnRlcjotbXQtcHggY2hlY2tlZDpmb2N1czphZnRlcjptbC1bMC4yNXJlbV0gY2hlY2tlZDpmb2N1czphZnRlcjpoLVswLjgxMjVyZW1dIGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6dy1bMC4zNzVyZW1dIGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6cm90YXRlLTQ1IGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6cm91bmRlZC1ub25lIGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6Ym9yZGVyLVswLjEyNXJlbV0gY2hlY2tlZDpmb2N1czphZnRlcjpib3JkZXItbC0wIGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6Ym9yZGVyLXQtMCBjaGVja2VkOmZvY3VzOmFmdGVyOmJvcmRlci1zb2xpZCBjaGVja2VkOmZvY3VzOmFmdGVyOmJvcmRlci13aGl0ZSBjaGVja2VkOmZvY3VzOmFmdGVyOmJnLXRyYW5zcGFyZW50IGRhcms6Ym9yZGVyLW5ldXRyYWwtNjAwIGRhcms6Y2hlY2tlZDpib3JkZXItcHJpbWFyeSBkYXJrOmNoZWNrZWQ6YmctcHJpbWFyeSBkYXJrOmZvY3VzOmJlZm9yZTpzaGFkb3ctWzBweF8wcHhfMHB4XzEzcHhfcmdiYSgyNTUsMjU1LDI1NSwwLjQpXSBkYXJrOmNoZWNrZWQ6Zm9jdXM6YmVmb3JlOnNoYWRvdy1bMHB4XzBweF8wcHhfMTNweF8jM2I3MWNhXSBkYXJrOmJvcmRlci1uZXV0cmFsLTQwMFwiLCBsVCA9IFwibWItWzAuMTI1cmVtXSBtaW4taC1bMS41cmVtXSBwbC1bMS41cmVtXSBtbC0zIGZsZXggaXRlbXMtY2VudGVyXCIsIGNUID0gXCJiZy13aGl0ZSBkYXJrOmJnLW5ldXRyYWwtODAwXCIsIGhUID0gXCJweS00IHBsLTEgdGV4dC1jbGlwIG92ZXJmbG93LWhpZGRlbiB0ZXh0LVsjMjEyNTI5XSBkYXJrOnRleHQtd2hpdGVcIiwgZFQgPSBcImZvY3VzOm91dGxpbmUtbm9uZVwiLCB1VCA9IFwic3RpY2t5IHRvcC0wIHotMzBcIiwgcFQgPSBcInN0aWNreSB6LTEwIGJnLWluaGVyaXRcIiwgX1QgPSBcImhvdmVyOmJnLW5ldXRyYWwtMTAwIGRhcms6aG92ZXI6YmctbmV1dHJhbC03MDBcIiwgZlQgPSBcInBvaW50ZXItZXZlbnRzLW5vbmUgY3Vyc29yLW5vbmUgdGV4dC1uZXV0cmFsLTQwMCBkYXJrOnRleHQtbmV1dHJhbC0zMDBcIiwgbVQgPSBcImgtWzJweF0gcmVsYXRpdmUgdy1mdWxsIG92ZXJmbG93LWhpZGRlblwiLCBnVCA9IFwidGV4dC1jZW50ZXIgdGV4dC1uZXV0cmFsLTUwMCBmb250LWxpZ2ggdGV4dC1zbSBteS00IGRhcms6dGV4dC1uZXV0cmFsLTQwMFwiLCBiVCA9IFwidGV4dC1uZXV0cmFsLTUwMCBkYXJrOnRleHQtbmV1dHJhbC0zMDBcIiwgdlQgPSBcInRleHQtbmV1dHJhbC01MDAgZGFyazp0ZXh0LW5ldXRyYWwtMzAwXCIsIFRUID0gXCJwb2ludGVyLWV2ZW50cy1ub25lIGN1cnNvci1ub25lXCIsIEVUID0gXCJoLWZ1bGwgdy1bNDUlXSBiZy1wcmltYXJ5LTQwMCBkYXJrOmJnLXByaW1hcnktNjAwXCIsIENUID0gXCJoLWZ1bGwgYW5pbWF0ZS1bcHJvZ3Jlc3NfM3NfZWFzZS1pbi1vdXRfaW5maW5pdGVdXCIsIEFUID0gXCJwbC0yIHB5LTMgZm9udC1saWdodCB0ZXh0LXNtIGRhcms6dGV4dC1uZXV0cmFsLTMwMFwiLCB5VCA9IFwiYm9yZGVyLWJcIiwgd1QgPSBcImZsZXggbWQ6ZmxleC1yb3cganVzdGlmeS1lbmQgaXRlbXMtY2VudGVyIHB5LTIgc3BhY2UteC00IHRleHQtc20gZmxleC1jb2wgbGVhZGluZy1bMS42XVwiLCBrVCA9IFwiYm9yZGVyIGJvcmRlci10LTBcIiwgeFQgPSBcIm9yZGVyLTEgbXktMyBtZDpvcmRlci1ub25lIG1kOm15LTAgbWQ6cHItMVwiLCBPVCA9IFwiaW5saW5lLWJsb2NrIHJvdW5kZWQgcC0yLjUgdGV4dC14cyBmb250LW1lZGl1bSB1cHBlcmNhc2UgbGVhZGluZy1ub3JtYWwgdHJhbnNpdGlvbiBkdXJhdGlvbi0xNTAgZWFzZS1pbi1vdXQgaG92ZXI6YmctbmV1dHJhbC0xMDAgaG92ZXI6dGV4dC1wcmltYXJ5LTYwMCBmb2N1czp0ZXh0LXByaW1hcnktNjAwIGZvY3VzOm91dGxpbmUtbm9uZSBmb2N1czpyaW5nLTAgYWN0aXZlOnRleHQtcHJpbWFyeS03MDAgZGlzYWJsZWQ6dGV4dC1zbGF0ZS0zMDAgZGlzYWJsZWQ6aG92ZXI6YmctdHJhbnNwYXJlbnQgZGFyazpob3ZlcjpiZy1uZXV0cmFsLTUwMCBkYXJrOmRpc2FibGVkOmhvdmVyOmJnLXRyYW5zcGFyZW50IGRhcms6ZGlzYWJsZWQ6dGV4dC1uZXV0cmFsLTYwMFwiLCBTVCA9IFwiaW5saW5lLWJsb2NrIHJvdW5kZWQgcC0yLjUgZm9udC1tZWRpdW0gdXBwZXJjYXNlIGxlYWRpbmctbm9ybWFsIHRyYW5zaXRpb24gZHVyYXRpb24tMTUwIGVhc2UtaW4tb3V0IGhvdmVyOmJnLW5ldXRyYWwtMTAwIGhvdmVyOnRleHQtcHJpbWFyeS02MDAgZm9jdXM6dGV4dC1wcmltYXJ5LTYwMCBmb2N1czpvdXRsaW5lLW5vbmUgZm9jdXM6cmluZy0wIGFjdGl2ZTp0ZXh0LXByaW1hcnktNzAwIGRpc2FibGVkOnRleHQtc2xhdGUtMzAwIGRpc2FibGVkOmhvdmVyOmJnLXRyYW5zcGFyZW50IGRhcms6aG92ZXI6YmctbmV1dHJhbC01MDAgZGFyazpkaXNhYmxlZDpob3ZlcjpiZy10cmFuc3BhcmVudCBkYXJrOmRpc2FibGVkOnRleHQtbmV1dHJhbC02MDBcIiwgSVQgPSBcImZvbnQtbm9ybWFsIG9yZGVyLTIgbWItMyBtZDpvcmRlci1ub25lIG1kOm1iLTBcIiwgRFQgPSBcImlubGluZS1ibG9jayByb3VuZGVkIHAtMi41IGZvbnQtbWVkaXVtIHVwcGVyY2FzZSBsZWFkaW5nLW5vcm1hbCB0cmFuc2l0aW9uIGR1cmF0aW9uLTE1MCBlYXNlLWluLW91dCBob3ZlcjpiZy1uZXV0cmFsLTEwMCBob3Zlcjp0ZXh0LXByaW1hcnktNjAwIGZvY3VzOnRleHQtcHJpbWFyeS02MDAgZm9jdXM6b3V0bGluZS1ub25lIGZvY3VzOnJpbmctMCBhY3RpdmU6dGV4dC1wcmltYXJ5LTcwMCBkaXNhYmxlZDp0ZXh0LXNsYXRlLTMwMCBkaXNhYmxlZDpob3ZlcjpiZy10cmFuc3BhcmVudCBkYXJrOmhvdmVyOmJnLW5ldXRyYWwtNTAwIGRhcms6ZGlzYWJsZWQ6aG92ZXI6YmctdHJhbnNwYXJlbnQgZGFyazpkaXNhYmxlZDp0ZXh0LW5ldXRyYWwtNjAwXCIsICRUID0gXCJmb250LWxpZ2h0XCIsIExUID0gXCJpbmxpbmUtYmxvY2sgcm91bmRlZCBwLTIuNSBmb250LW1lZGl1bSB1cHBlcmNhc2UgbGVhZGluZy1ub3JtYWwgdHJhbnNpdGlvbiBkdXJhdGlvbi0xNTAgZWFzZS1pbi1vdXQgaG92ZXI6YmctbmV1dHJhbC0xMDAgaG92ZXI6dGV4dC1wcmltYXJ5LTYwMCBmb2N1czp0ZXh0LXByaW1hcnktNjAwIGZvY3VzOm91dGxpbmUtbm9uZSBmb2N1czpyaW5nLTAgYWN0aXZlOnRleHQtcHJpbWFyeS03MDAgZGlzYWJsZWQ6dGV4dC1zbGF0ZS0zMDAgZGlzYWJsZWQ6aG92ZXI6YmctdHJhbnNwYXJlbnQgZGFyazpob3ZlcjpiZy1uZXV0cmFsLTUwMCBkYXJrOmRpc2FibGVkOmhvdmVyOmJnLXRyYW5zcGFyZW50IGRhcms6ZGlzYWJsZWQ6dGV4dC1uZXV0cmFsLTYwMFwiLCBOVCA9IFwiYm9yZGVyLWJcIiwgTVQgPSBcInRyYW5zaXRpb24gZWFzZS1pbi1vdXQgZHVyYXRpb24tMzAwIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lXCIsIFJUID0gXCJ3aGl0ZXNwYWNlLW5vd3JhcCB0ZXh0LWNsaXAgb3ZlcmZsb3ctaGlkZGVuIHB4LVsxLjRyZW1dIHB5LTRcIiwgUFQgPSBcInJlbGF0aXZlXCIsIEJUID0gXCIhYmctbmV1dHJhbC0xMDAgZGFyazohYmctbmV1dHJhbC02MDBcIiwgSFQgPSBcImZsZXggaXRlbXMtY2VudGVyIHNwYWNlLXgtNCBvcmRlci0zIG1kOm9yZGVyLW5vbmVcIiwgVlQgPSBcInctWzcwcHhdXCIsIFdUID0gXCIhcHktMlwiLCBGVCA9IFwidy1bMTVweF0gaC1bMTBweF0gb3JpZ2luLWJvdHRvbSBmb250LWJsYWNrIG1yLTEgb3BhY2l0eS0wIHRleHQtbmV1dHJhbC01MDAgZ3JvdXAtaG92ZXI6b3BhY2l0eS0xMDAgdHJhbnNpdGlvbiBob3ZlcjplYXNlLWluLW91dCB0cmFuc2Zvcm0gZWFzZS1saW5lYXIgZHVyYXRpb24tMzAwIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIGRhcms6dGV4dC1uZXV0cmFsLTQwMFwiLCBZVCA9IFwiZmxleCBmbGV4LXJvdyBncm91cFwiLCBqVCA9IFwiWyY6bnRoLWNoaWxkKG9kZCldOmJnLW5ldXRyYWwtNTAgWyY6bnRoLWNoaWxkKG9kZCldOmRhcms6YmctbmV1dHJhbC03MDBcIiwgS1QgPSBcImJvcmRlclwiLCB6VCA9IFwiYm9yZGVyLWIgZm9udC1ub3JtYWwgcHgtWzEuNHJlbV1cIiwgVVQgPSBcInRleHQtbGVmdCB0ZXh0LXNtIGZvbnQtbGlnaHQgdy1mdWxsIGxlYWRpbmctWzEuNl1cIiwgWFQgPSB7XG4gIGJvcmRlcmVkOiBcImJvb2xlYW5cIixcbiAgYm9yZGVybGVzczogXCJib29sZWFuXCIsXG4gIGNsaWNrYWJsZVJvd3M6IFwiYm9vbGVhblwiLFxuICBkZWZhdWx0VmFsdWU6IFwic3RyaW5nXCIsXG4gIGVkaXQ6IFwiYm9vbGVhblwiLFxuICBlbnRyaWVzOiBcIihudW1iZXJ8c3RyaW5nKVwiLFxuICBlbnRyaWVzT3B0aW9uczogXCJhcnJheVwiLFxuICBmdWxsUGFnaW5hdGlvbjogXCJib29sZWFuXCIsXG4gIGhvdmVyOiBcImJvb2xlYW5cIixcbiAgbG9hZGluZzogXCJib29sZWFuXCIsXG4gIGxvYWRpbmdNZXNzYWdlOiBcInN0cmluZ1wiLFxuICBtYXhXaWR0aDogXCIobnVsbHxudW1iZXJ8c3RyaW5nKVwiLFxuICBtYXhIZWlnaHQ6IFwiKG51bGx8bnVtYmVyfHN0cmluZylcIixcbiAgbXVsdGk6IFwiYm9vbGVhblwiLFxuICBub0ZvdW5kTWVzc2FnZTogXCJzdHJpbmdcIixcbiAgcGFnaW5hdGlvbjogXCJib29sZWFuXCIsXG4gIHNlbGVjdGFibGU6IFwiYm9vbGVhblwiLFxuICBzbTogXCJib29sZWFuXCIsXG4gIHNvcnRGaWVsZDogXCIobnVsbHxzdHJpbmcpXCIsXG4gIHNvcnRPcmRlcjogXCJzdHJpbmdcIixcbiAgZml4ZWRIZWFkZXI6IFwiYm9vbGVhblwiLFxuICBzdHJpcGVkOiBcImJvb2xlYW5cIixcbiAgcm93c1RleHQ6IFwic3RyaW5nXCIsXG4gIG9mVGV4dDogXCJzdHJpbmdcIixcbiAgYWxsVGV4dDogXCJzdHJpbmdcIixcbiAgZm9yY2VTb3J0OiBcImJvb2xlYW5cIixcbiAgc29ydEljb25UZW1wbGF0ZTogXCJzdHJpbmdcIixcbiAgcGFnaW5hdGlvblN0YXJ0SWNvblRlbXBsYXRlOiBcInN0cmluZ1wiLFxuICBwYWdpbmF0aW9uRW5kSWNvblRlbXBsYXRlOiBcInN0cmluZ1wiLFxuICBwYWdpbmF0aW9uTGVmdEljb25UZW1wbGF0ZTogXCJzdHJpbmdcIixcbiAgcGFnaW5hdGlvblJpZ2h0SWNvblRlbXBsYXRlOiBcInN0cmluZ1wiXG59LCBHVCA9IHtcbiAgYm9yZGVyZWQ6ICExLFxuICBib3JkZXJsZXNzOiAhMSxcbiAgY2xpY2thYmxlUm93czogITEsXG4gIGRlZmF1bHRWYWx1ZTogXCItXCIsXG4gIGVkaXQ6ICExLFxuICBlbnRyaWVzOiAxMCxcbiAgZW50cmllc09wdGlvbnM6IFsxMCwgMjUsIDUwLCAyMDBdLFxuICBmaXhlZEhlYWRlcjogITEsXG4gIGZ1bGxQYWdpbmF0aW9uOiAhMSxcbiAgaG92ZXI6ICExLFxuICBsb2FkaW5nOiAhMSxcbiAgbG9hZGluZ01lc3NhZ2U6IFwiTG9hZGluZyByZXN1bHRzLi4uXCIsXG4gIG1heFdpZHRoOiBudWxsLFxuICBtYXhIZWlnaHQ6IG51bGwsXG4gIG11bHRpOiAhMSxcbiAgbm9Gb3VuZE1lc3NhZ2U6IFwiTm8gbWF0Y2hpbmcgcmVzdWx0cyBmb3VuZFwiLFxuICBwYWdpbmF0aW9uOiAhMCxcbiAgc2VsZWN0YWJsZTogITEsXG4gIHNtOiAhMSxcbiAgc29ydEZpZWxkOiBudWxsLFxuICBzb3J0T3JkZXI6IFwiYXNjXCIsXG4gIHN0cmlwZWQ6ICExLFxuICByb3dzVGV4dDogXCJSb3dzIHBlciBwYWdlOlwiLFxuICBvZlRleHQ6IFwib2ZcIixcbiAgYWxsVGV4dDogXCJBbGxcIixcbiAgZm9yY2VTb3J0OiAhMSxcbiAgc29ydEljb25UZW1wbGF0ZTogUXYsXG4gIHBhZ2luYXRpb25TdGFydEljb25UZW1wbGF0ZTogSnYsXG4gIHBhZ2luYXRpb25FbmRJY29uVGVtcGxhdGU6IGlULFxuICBwYWdpbmF0aW9uTGVmdEljb25UZW1wbGF0ZTogdFQsXG4gIHBhZ2luYXRpb25SaWdodEljb25UZW1wbGF0ZTogZVRcbn0sIHFUID0ge1xuICBsYWJlbDogXCJzdHJpbmdcIixcbiAgZmllbGQ6IFwic3RyaW5nXCIsXG4gIGZpeGVkOiBcIihib29sZWFufHN0cmluZylcIixcbiAgZm9ybWF0OiBcIihmdW5jdGlvbnxudWxsKVwiLFxuICB3aWR0aDogXCIobnVtYmVyfG51bGwpXCIsXG4gIHNvcnQ6IFwiYm9vbGVhblwiLFxuICBjb2x1bW5JbmRleDogXCJudW1iZXJcIlxufSwgWlQgPSB7XG4gIGxhYmVsOiBcIlwiLFxuICBmaWVsZDogXCJcIixcbiAgZml4ZWQ6ICExLFxuICBmb3JtYXQ6IG51bGwsXG4gIHdpZHRoOiBudWxsLFxuICBzb3J0OiAhMCxcbiAgY29sdW1uSW5kZXg6IDBcbn0sIFFUID0ge1xuICB0YWJsZTogVVQsXG4gIHRhYmxlSGVhZGVyOiB6VCxcbiAgY29sdW1uOiBoVCxcbiAgcGFnaW5hdGlvbjogd1QsXG4gIHNlbGVjdFdyYXBwZXI6IFZULFxuICBzY3JvbGw6IFBULFxuICB0YWJsZUJvcmRlcmVkOiBLVCxcbiAgcGFnaW5hdGlvbkJvcmRlcmVkOiBrVCxcbiAgYm9yZGVybGVzczogblQsXG4gIGNoZWNrYm94Um93V3JhcHBlcjogbFQsXG4gIGNoZWNrYm94Um93OiBhVCxcbiAgY2hlY2tib3hIZWFkZXJXcmFwcGVyOiByVCxcbiAgY2hlY2tib3hIZWFkZXI6IG9ULFxuICByb3c6IE5ULFxuICByb3dJdGVtOiBSVCxcbiAgc3RyaXBlZDogalQsXG4gIHNvcnRJY29uV3JhcHBlcjogWVQsXG4gIHNvcnRJY29uOiBGVCxcbiAgcGFnaW5hdGlvblJvd3NUZXh0OiAkVCxcbiAgcGFnaW5hdGlvbk5hdjogSVQsXG4gIHBhZ2luYXRpb25CdXR0b25zV3JhcHBlcjogeFQsXG4gIGhvdmVyUm93OiBfVCxcbiAgYm9yZGVyQ29sb3I6IHNULFxuICBjb2xvcjogY1QsXG4gIGZpeGVkSGVhZGVyOiB1VCxcbiAgZml4ZWRIZWFkZXJCb2R5OiBwVCxcbiAgc2VsZWN0YWJsZVJvdzogQlQsXG4gIHJvd0FuaW1hdGlvbjogTVQsXG4gIHNtOiBXVCxcbiAgZWRpdDogZFQsXG4gIHNlbGVjdEl0ZW1zV3JhcHBlcjogSFQsXG4gIHBhZ2luYXRpb25TdGFydEJ1dHRvbjogTFQsXG4gIHBhZ2luYXRpb25MZWZ0QnV0dG9uOiBTVCxcbiAgcGFnaW5hdGlvblJpZ2h0QnV0dG9uOiBEVCxcbiAgcGFnaW5hdGlvbkVuZEJ1dHRvbjogT1QsXG4gIGxvYWRpbmdJdGVtc1dyYXBwZXI6IG1ULFxuICBsb2FkaW5nUHJvZ3Jlc3NCYXJXcmFwcGVyOiBDVCxcbiAgbG9hZGluZ1Byb2dyZXNzQmFyOiBFVCxcbiAgbG9hZGluZ01lc3NhZ2U6IGdULFxuICBsb2FkaW5nUGFnaW5hdGlvblJvd3NUZXh0OiB2VCxcbiAgbG9hZGluZ1BhZ2luYXRpb25TZWxlY3RXcmFwcGVyOiBUVCxcbiAgbG9hZGluZ1BhZ2luYXRpb25OYXY6IGJULFxuICBsb2FkaW5nQ29sdW1uOiBmVCxcbiAgbm9Gb3VuZE1lc3NhZ2VXcmFwcGVyOiB5VCxcbiAgbm9Gb3VuZE1lc3NhZ2U6IEFUXG59LCBKVCA9IHtcbiAgdGFibGU6IFwic3RyaW5nXCIsXG4gIHRhYmxlSGVhZGVyOiBcInN0cmluZ1wiLFxuICBjb2x1bW46IFwic3RyaW5nXCIsXG4gIHBhZ2luYXRpb246IFwic3RyaW5nXCIsXG4gIHNlbGVjdFdyYXBwZXI6IFwic3RyaW5nXCIsXG4gIHNjcm9sbDogXCJzdHJpbmdcIixcbiAgdGFibGVCb3JkZXJlZDogXCJzdHJpbmdcIixcbiAgcGFnaW5hdGlvbkJvcmRlcmVkOiBcInN0cmluZ1wiLFxuICBib3JkZXJsZXNzOiBcInN0cmluZ1wiLFxuICBjaGVja2JveFJvd1dyYXBwZXI6IFwic3RyaW5nXCIsXG4gIGNoZWNrYm94Um93OiBcInN0cmluZ1wiLFxuICBjaGVja2JveEhlYWRlcldyYXBwZXI6IFwic3RyaW5nXCIsXG4gIGNoZWNrYm94SGVhZGVyOiBcInN0cmluZ1wiLFxuICByb3c6IFwic3RyaW5nXCIsXG4gIHJvd0l0ZW06IFwic3RyaW5nXCIsXG4gIHN0cmlwZWQ6IFwic3RyaW5nXCIsXG4gIHNvcnRJY29uV3JhcHBlcjogXCJzdHJpbmdcIixcbiAgc29ydEljb246IFwic3RyaW5nXCIsXG4gIHBhZ2luYXRpb25Sb3dzVGV4dDogXCJzdHJpbmdcIixcbiAgcGFnaW5hdGlvbk5hdjogXCJzdHJpbmdcIixcbiAgcGFnaW5hdGlvbkJ1dHRvbnNXcmFwcGVyOiBcInN0cmluZ1wiLFxuICBob3ZlclJvdzogXCJzdHJpbmdcIixcbiAgYm9yZGVyQ29sb3I6IFwic3RyaW5nXCIsXG4gIGNvbG9yOiBcInN0cmluZ1wiLFxuICBmaXhlZEhlYWRlcjogXCJzdHJpbmdcIixcbiAgZml4ZWRIZWFkZXJCb2R5OiBcInN0cmluZ1wiLFxuICBzZWxlY3RhYmxlUm93OiBcInN0cmluZ1wiLFxuICByb3dBbmltYXRpb246IFwic3RyaW5nXCIsXG4gIHNtOiBcInN0cmluZ1wiLFxuICBlZGl0OiBcInN0cmluZ1wiLFxuICBzZWxlY3RJdGVtc1dyYXBwZXI6IFwic3RyaW5nXCIsXG4gIHBhZ2luYXRpb25TdGFydEJ1dHRvbjogXCJzdHJpbmdcIixcbiAgcGFnaW5hdGlvbkxlZnRCdXR0b246IFwic3RyaW5nXCIsXG4gIHBhZ2luYXRpb25SaWdodEJ1dHRvbjogXCJzdHJpbmdcIixcbiAgcGFnaW5hdGlvbkVuZEJ1dHRvbjogXCJzdHJpbmdcIixcbiAgbG9hZGluZ0l0ZW1zV3JhcHBlcjogXCJzdHJpbmdcIixcbiAgbG9hZGluZ1Byb2dyZXNzQmFyV3JhcHBlcjogXCJzdHJpbmdcIixcbiAgbG9hZGluZ1Byb2dyZXNzQmFyOiBcInN0cmluZ1wiLFxuICBsb2FkaW5nTWVzc2FnZTogXCJzdHJpbmdcIixcbiAgbG9hZGluZ1BhZ2luYXRpb25Sb3dzVGV4dDogXCJzdHJpbmdcIixcbiAgbG9hZGluZ1BhZ2luYXRpb25TZWxlY3RXcmFwcGVyOiBcInN0cmluZ1wiLFxuICBsb2FkaW5nUGFnaW5hdGlvbk5hdjogXCJzdHJpbmdcIixcbiAgbG9hZGluZ0NvbHVtbjogXCJzdHJpbmdcIixcbiAgbm9Gb3VuZE1lc3NhZ2VXcmFwcGVyOiBcInN0cmluZ1wiLFxuICBub0ZvdW5kTWVzc2FnZTogXCJzdHJpbmdcIlxufTtcbmNsYXNzIGdoIHtcbiAgY29uc3RydWN0b3IodCwgZSA9IHt9LCBpID0ge30sIG4gPSB7fSkge1xuICAgIHRoaXMuX2VsZW1lbnQgPSB0LCB0aGlzLl9vcHRpb25zID0gdGhpcy5fZ2V0T3B0aW9ucyhpKSwgdGhpcy5fY2xhc3NlcyA9IHRoaXMuX2dldENsYXNzZXMobiksIHRoaXMuX3NvcnRSZXZlcnNlID0gITEsIHRoaXMuX2FjdGl2ZVBhZ2UgPSAwLCB0aGlzLl9zZWFyY2ggPSBcIlwiLCB0aGlzLl9zZWFyY2hDb2x1bW4gPSBudWxsLCB0aGlzLl9wYWdpbmF0aW9uTGVmdCA9IG51bGwsIHRoaXMuX3BhZ2luYXRpb25SaWdodCA9IG51bGwsIHRoaXMuX3BhZ2luYXRpb25TdGFydCA9IG51bGwsIHRoaXMuX3BhZ2luYXRpb25FbmQgPSBudWxsLCB0aGlzLl9zZWxlY3QgPSBudWxsLCB0aGlzLl9zZWxlY3RJbnN0YW5jZSA9IG51bGwsIHRoaXMuX3NlbGVjdGVkID0gW10sIHRoaXMuX2NoZWNrYm94ZXMgPSBudWxsLCB0aGlzLl9oZWFkZXJDaGVja2JveCA9IG51bGwsIHRoaXMuX3Jvd3MgPSB0aGlzLl9nZXRSb3dzKGUucm93cyksIHRoaXMuX2NvbHVtbnMgPSB0aGlzLl9nZXRDb2x1bW5zKGUuY29sdW1ucyksIHRoaXMuX2VsZW1lbnQgJiYgKHkuc2V0RGF0YSh0LCBFaSwgdGhpcyksIHRoaXMuX3BlcmZlY3RTY3JvbGxiYXIgPSBudWxsLCB0aGlzLl9zZXR1cCgpKTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gTmk7XG4gIH1cbiAgZ2V0IGNvbHVtbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbHVtbnMubWFwKCh0LCBlKSA9PiB7XG4gICAgICBsZXQgaSA9IHtcbiAgICAgICAgLi4uWlQsXG4gICAgICAgIGZpZWxkOiBgZmllbGRfJHtlfWAsXG4gICAgICAgIGNvbHVtbkluZGV4OiBlXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHR5cGVvZiB0ID09IFwic3RyaW5nXCIgPyBpLmxhYmVsID0gdCA6IHR5cGVvZiB0ID09IFwib2JqZWN0XCIgJiYgKGkgPSB7XG4gICAgICAgIC4uLmksXG4gICAgICAgIC4uLnRcbiAgICAgIH0pLCBEKFwiY29sdW1uXCIsIGksIHFUKSwgaTtcbiAgICB9KTtcbiAgfVxuICBnZXQgcm93cygpIHtcbiAgICByZXR1cm4gdGhpcy5fcm93cy5tYXAoKHQsIGUpID0+IHtcbiAgICAgIGNvbnN0IGkgPSB7XG4gICAgICAgIHJvd0luZGV4OiBlXG4gICAgICB9O1xuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodCkgPyB0aGlzLmNvbHVtbnMuZm9yRWFjaCgobiwgbykgPT4ge1xuICAgICAgICB0W29dID09PSAwID8gaVtuLmZpZWxkXSA9IHRbb10gOiBpW24uZmllbGRdID0gdFtvXSB8fCB0aGlzLl9vcHRpb25zLmRlZmF1bHRWYWx1ZTtcbiAgICAgIH0pIDogdHlwZW9mIHQgPT0gXCJvYmplY3RcIiAmJiB0aGlzLmNvbHVtbnMuZm9yRWFjaCgobikgPT4ge1xuICAgICAgICB0W24uZmllbGRdID09PSAwID8gaVtuLmZpZWxkXSA9IHRbbi5maWVsZF0gOiBpW24uZmllbGRdID0gdFtuLmZpZWxkXSB8fCB0aGlzLl9vcHRpb25zLmRlZmF1bHRWYWx1ZTtcbiAgICAgIH0pLCBpO1xuICAgIH0pO1xuICB9XG4gIGdldCBzZWFyY2hSZXN1bHQoKSB7XG4gICAgcmV0dXJuIEh2KHRoaXMucm93cywgdGhpcy5fc2VhcmNoLCB0aGlzLl9zZWFyY2hDb2x1bW4pO1xuICB9XG4gIGdldCBjb21wdXRlZFJvd3MoKSB7XG4gICAgbGV0IHQgPSBbLi4udGhpcy5zZWFyY2hSZXN1bHRdO1xuICAgIHJldHVybiB0aGlzLl9vcHRpb25zLnNvcnRPcmRlciAmJiAodCA9IEJ2KHtcbiAgICAgIHJvd3M6IHQsXG4gICAgICBmaWVsZDogdGhpcy5fb3B0aW9ucy5zb3J0RmllbGQsXG4gICAgICBvcmRlcjogdGhpcy5fb3B0aW9ucy5zb3J0T3JkZXJcbiAgICB9KSksIHRoaXMuX29wdGlvbnMucGFnaW5hdGlvbiAmJiAodGhpcy5fb3B0aW9ucy5lbnRyaWVzID09PSBcIkFsbFwiID8gdCA9IGtsKHtcbiAgICAgIHJvd3M6IHQsXG4gICAgICBlbnRyaWVzOiB0Lmxlbmd0aCxcbiAgICAgIGFjdGl2ZVBhZ2U6IHRoaXMuX2FjdGl2ZVBhZ2VcbiAgICB9KSA6IHQgPSBrbCh7XG4gICAgICByb3dzOiB0LFxuICAgICAgZW50cmllczogdGhpcy5fb3B0aW9ucy5lbnRyaWVzLFxuICAgICAgYWN0aXZlUGFnZTogdGhpcy5fYWN0aXZlUGFnZVxuICAgIH0pKSwgdDtcbiAgfVxuICBnZXQgcGFnZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29wdGlvbnMuZW50cmllcyA9PT0gXCJBbGxcIiA/IDEgOiBNYXRoLmNlaWwodGhpcy5zZWFyY2hSZXN1bHQubGVuZ3RoIC8gdGhpcy5fb3B0aW9ucy5lbnRyaWVzKTtcbiAgfVxuICBnZXQgbmF2aWdhdGlvblRleHQoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2FjdGl2ZVBhZ2UgKiB0aGlzLl9vcHRpb25zLmVudHJpZXM7XG4gICAgcmV0dXJuIHRoaXMuc2VhcmNoUmVzdWx0Lmxlbmd0aCA9PT0gMCA/IGAwICR7dGhpcy5fb3B0aW9ucy5vZlRleHR9IDBgIDogdGhpcy5fb3B0aW9ucy5lbnRyaWVzID09PSBcIkFsbFwiID8gYDEgLSAke3RoaXMuc2VhcmNoUmVzdWx0Lmxlbmd0aH0gJHt0aGlzLl9vcHRpb25zLm9mVGV4dH0gJHt0aGlzLnNlYXJjaFJlc3VsdC5sZW5ndGh9YCA6IGAke3QgKyAxfSAtICR7dGhpcy5jb21wdXRlZFJvd3MubGVuZ3RoICsgdH0gJHt0aGlzLl9vcHRpb25zLm9mVGV4dH0gJHt0aGlzLnNlYXJjaFJlc3VsdC5sZW5ndGh9YDtcbiAgfVxuICBnZXQgdGFibGVPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzOiB0aGlzLl9jbGFzc2VzLFxuICAgICAgY29sdW1uczogdGhpcy5jb2x1bW5zLFxuICAgICAgcm93czogdGhpcy5jb21wdXRlZFJvd3MsXG4gICAgICBub0ZvdW5kTWVzc2FnZTogdGhpcy5fb3B0aW9ucy5ub0ZvdW5kTWVzc2FnZSxcbiAgICAgIGVkaXQ6IHRoaXMuX29wdGlvbnMuZWRpdCxcbiAgICAgIGxvYWRpbmc6IHRoaXMuX29wdGlvbnMubG9hZGluZyxcbiAgICAgIGxvYWRlckNsYXNzOiB0aGlzLl9vcHRpb25zLmxvYWRlckNsYXNzLFxuICAgICAgbG9hZGluZ01lc3NhZ2U6IHRoaXMuX29wdGlvbnMubG9hZGluZ01lc3NhZ2UsXG4gICAgICBzZWxlY3RhYmxlOiB0aGlzLl9vcHRpb25zLnNlbGVjdGFibGUsXG4gICAgICBtdWx0aTogdGhpcy5fb3B0aW9ucy5tdWx0aSxcbiAgICAgIGJvcmRlcmVkOiB0aGlzLl9vcHRpb25zLmJvcmRlcmVkLFxuICAgICAgYm9yZGVybGVzczogdGhpcy5fb3B0aW9ucy5ib3JkZXJsZXNzLFxuICAgICAgc3RyaXBlZDogdGhpcy5fb3B0aW9ucy5zdHJpcGVkLFxuICAgICAgaG92ZXI6IHRoaXMuX29wdGlvbnMuaG92ZXIsXG4gICAgICBmaXhlZEhlYWRlcjogdGhpcy5fb3B0aW9ucy5maXhlZEhlYWRlcixcbiAgICAgIHNtOiB0aGlzLl9vcHRpb25zLnNtLFxuICAgICAgc29ydEljb25UZW1wbGF0ZTogdGhpcy5fb3B0aW9ucy5zb3J0SWNvblRlbXBsYXRlLFxuICAgICAgcGFnaW5hdGlvbjoge1xuICAgICAgICBlbmFibGU6IHRoaXMuX29wdGlvbnMucGFnaW5hdGlvbixcbiAgICAgICAgdGV4dDogdGhpcy5uYXZpZ2F0aW9uVGV4dCxcbiAgICAgICAgZW50cmllczogdGhpcy5fb3B0aW9ucy5lbnRyaWVzLFxuICAgICAgICBlbnRyaWVzT3B0aW9uczogdGhpcy5fb3B0aW9ucy5lbnRyaWVzT3B0aW9ucyxcbiAgICAgICAgZnVsbFBhZ2luYXRpb246IHRoaXMuX29wdGlvbnMuZnVsbFBhZ2luYXRpb24sXG4gICAgICAgIHJvd3NUZXh0OiB0aGlzLl9vcHRpb25zLnJvd3NUZXh0LFxuICAgICAgICBvZlRleHQ6IHRoaXMuX29wdGlvbnMub2ZUZXh0LFxuICAgICAgICBhbGxUZXh0OiB0aGlzLl9vcHRpb25zLmFsbFRleHQsXG4gICAgICAgIHBhZ2luYXRpb25TdGFydEljb25UZW1wbGF0ZTogdGhpcy5fb3B0aW9ucy5wYWdpbmF0aW9uU3RhcnRJY29uVGVtcGxhdGUsXG4gICAgICAgIHBhZ2luYXRpb25MZWZ0SWNvblRlbXBsYXRlOiB0aGlzLl9vcHRpb25zLnBhZ2luYXRpb25MZWZ0SWNvblRlbXBsYXRlLFxuICAgICAgICBwYWdpbmF0aW9uUmlnaHRJY29uVGVtcGxhdGU6IHRoaXMuX29wdGlvbnMucGFnaW5hdGlvblJpZ2h0SWNvblRlbXBsYXRlLFxuICAgICAgICBwYWdpbmF0aW9uRW5kSWNvblRlbXBsYXRlOiB0aGlzLl9vcHRpb25zLnBhZ2luYXRpb25FbmRJY29uVGVtcGxhdGUsXG4gICAgICAgIGNsYXNzZXM6IHRoaXMuX2NsYXNzZXNcbiAgICAgIH0sXG4gICAgICBmb3JjZVNvcnQ6IHRoaXMuX29wdGlvbnMuZm9yY2VTb3J0XG4gICAgfTtcbiAgfVxuICAvLyBQdWJsaWNcbiAgdXBkYXRlKHQsIGUgPSB7fSkge1xuICAgIHQgJiYgdC5yb3dzICYmICh0aGlzLl9yb3dzID0gdC5yb3dzKSwgdCAmJiB0LmNvbHVtbnMgJiYgKHRoaXMuX2NvbHVtbnMgPSB0LmNvbHVtbnMpLCB0aGlzLl9jbGVhckNsYXNzTGlzdChlKSwgdGhpcy5fb3B0aW9ucyA9IHRoaXMuX2dldE9wdGlvbnMoeyAuLi50aGlzLl9vcHRpb25zLCAuLi5lIH0pLCB0aGlzLl9zZXR1cCgpLCB0aGlzLl9wZXJmb3JtU29ydCgpO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5fc2VsZWN0SW5zdGFuY2UgJiYgdGhpcy5fc2VsZWN0SW5zdGFuY2UuZGlzcG9zZSgpLCB5LnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgRWkpLCB0aGlzLl9yZW1vdmVFdmVudExpc3RlbmVycygpLCB0aGlzLl9wZXJmZWN0U2Nyb2xsYmFyLmRlc3Ryb3koKSwgdGhpcy5fZWxlbWVudCA9IG51bGw7XG4gIH1cbiAgc2VhcmNoKHQsIGUpIHtcbiAgICB0aGlzLl9zZWFyY2ggPSB0LCB0aGlzLl9zZWFyY2hDb2x1bW4gPSBlLCB0aGlzLl9hY3RpdmVQYWdlID0gMCwgdGhpcy5fb3B0aW9ucy5wYWdpbmF0aW9uICYmIHRoaXMuX3RvZ2dsZURpc2FibGVTdGF0ZSgpLCB0aGlzLl9yZW5kZXJSb3dzKCksIHRoaXMuX29wdGlvbnMubWF4SGVpZ2h0ICYmICh0aGlzLl9wZXJmZWN0U2Nyb2xsYmFyLmVsZW1lbnQuc2Nyb2xsVG9wID0gMCwgdGhpcy5fcGVyZmVjdFNjcm9sbGJhci51cGRhdGUoKSk7XG4gIH1cbiAgc29ydCh0LCBlID0gXCJhc2NcIikge1xuICAgIHRoaXMuX29wdGlvbnMuc29ydE9yZGVyID0gZSwgdHlwZW9mIHQgPT0gXCJzdHJpbmdcIiA/IHRoaXMuX29wdGlvbnMuc29ydEZpZWxkID0gdGhpcy5jb2x1bW5zLmZpbmQoXG4gICAgICAobikgPT4gbi5sYWJlbCA9PT0gdFxuICAgICkuZmllbGQgOiB0aGlzLl9vcHRpb25zLnNvcnRGaWVsZCA9IHQuZmllbGQ7XG4gICAgY29uc3QgaSA9IGQuZmluZE9uZShcbiAgICAgIGBbZGF0YS10ZS1zb3J0PVwiJHt0aGlzLl9vcHRpb25zLnNvcnRGaWVsZH1cIl1gLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICk7XG4gICAgdGhpcy5fYWN0aXZlUGFnZSA9IDAsIHRoaXMuX3RvZ2dsZURpc2FibGVTdGF0ZSgpLCB0aGlzLl9yZW5kZXJSb3dzKCksIHRoaXMuX3NldEFjdGl2ZVNvcnRJY29uKGkpO1xuICB9XG4gIHNldEFjdGl2ZVBhZ2UodCkge1xuICAgIHQgPCB0aGlzLnBhZ2VzICYmIHRoaXMuX2NoYW5nZUFjdGl2ZVBhZ2UodCk7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfZ2V0Q2xhc3Nlcyh0KSB7XG4gICAgY29uc3QgZSA9IGguZ2V0RGF0YUNsYXNzQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLlFULFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBEKE5pLCB0LCBKVCksIHQ7XG4gIH1cbiAgX2NoYW5nZUFjdGl2ZVBhZ2UodCkge1xuICAgIHRoaXMuX2FjdGl2ZVBhZ2UgPSB0LCB0aGlzLl90b2dnbGVEaXNhYmxlU3RhdGUoKSwgdGhpcy5fcmVuZGVyUm93cygpO1xuICB9XG4gIF9jbGVhckNsYXNzTGlzdCh0KSB7XG4gICAgW1wiaG92ZXJcIiwgXCJib3JkZXJlZFwiLCBcImJvcmRlcmxlc3NcIiwgXCJzbVwiLCBcInN0cmlwZWRcIl0uZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgdGhpcy5fb3B0aW9uc1tlXSAmJiAhdFtlXSAmJiBoLnJlbW92ZURhdGFBdHRyaWJ1dGUoYGRhdGEtdGUtJHtlfWApO1xuICAgIH0pO1xuICB9XG4gIF9lbWl0U2VsZWN0RXZlbnQoKSB7XG4gICAgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEd2LCB7XG4gICAgICBzZWxlY3RlZFJvd3M6IHRoaXMucm93cy5maWx0ZXIoXG4gICAgICAgICh0KSA9PiB0aGlzLl9zZWxlY3RlZC5pbmRleE9mKHQucm93SW5kZXgpICE9PSAtMVxuICAgICAgKSxcbiAgICAgIHNlbGVjdGVkSW5kZXhlczogdGhpcy5fc2VsZWN0ZWQsXG4gICAgICBhbGxTZWxlY3RlZDogdGhpcy5fc2VsZWN0ZWQubGVuZ3RoID09PSB0aGlzLnJvd3MubGVuZ3RoXG4gICAgfSk7XG4gIH1cbiAgX2dldFJvd3ModCA9IFtdKSB7XG4gICAgY29uc3QgZSA9IGQuZmluZE9uZShcInRib2R5XCIsIHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiBlID8gWy4uLmQuZmluZChcInRyXCIsIGUpLm1hcCgobikgPT4gZC5maW5kKFwidGRcIiwgbikubWFwKChvKSA9PiBvLmlubmVySFRNTCkpLCAuLi50XSA6IHQ7XG4gIH1cbiAgX2dldENvbHVtbnModCA9IFtdKSB7XG4gICAgY29uc3QgZSA9IGQuZmluZE9uZShcInRoZWFkXCIsIHRoaXMuX2VsZW1lbnQpO1xuICAgIGlmICghZSlcbiAgICAgIHJldHVybiB0O1xuICAgIGNvbnN0IGkgPSBkLmZpbmRPbmUoXCJ0clwiLCBlKTtcbiAgICByZXR1cm4gWy4uLmQuZmluZChcInRoXCIsIGkpLm1hcCgobykgPT4gKHtcbiAgICAgIGxhYmVsOiBvLmlubmVySFRNTCxcbiAgICAgIC4uLmguZ2V0RGF0YUF0dHJpYnV0ZXMobylcbiAgICB9KSksIC4uLnRdO1xuICB9XG4gIF9nZXRDU1NWYWx1ZSh0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0ID09IFwic3RyaW5nXCIgPyB0IDogYCR7dH1weGA7XG4gIH1cbiAgX2dldE9wdGlvbnModCkge1xuICAgIGNvbnN0IGUgPSB7XG4gICAgICAuLi5HVCxcbiAgICAgIC4uLmguZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCksXG4gICAgICAuLi50XG4gICAgfTtcbiAgICByZXR1cm4gRChOaSwgZSwgWFQpLCBlO1xuICB9XG4gIF9zZXRBY3RpdmVSb3dzKCkge1xuICAgIGQuZmluZChmaSwgdGhpcy5fZWxlbWVudCkuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgdGhpcy5fc2VsZWN0ZWQuaW5jbHVkZXMoaC5nZXREYXRhQXR0cmlidXRlKHQsIFwiaW5kZXhcIikpID8gaC5hZGRDbGFzcyh0LCBgYWN0aXZlICR7dGhpcy5fY2xhc3Nlcy5zZWxlY3RhYmxlUm93fWApIDogaC5yZW1vdmVDbGFzcyh0LCBgYWN0aXZlICR7dGhpcy5fY2xhc3Nlcy5zZWxlY3RhYmxlUm93fWApO1xuICAgIH0pO1xuICB9XG4gIF9zZXRFbnRyaWVzKHQpIHtcbiAgICB0aGlzLl9vcHRpb25zID0gdGhpcy5fZ2V0T3B0aW9ucyh7XG4gICAgICAuLi50aGlzLl9vcHRpb25zLFxuICAgICAgZW50cmllczogdC50YXJnZXQudmFsdWVcbiAgICB9KSwgdGhpcy5fYWN0aXZlUGFnZSA+IHRoaXMucGFnZXMgLSAxICYmICh0aGlzLl9hY3RpdmVQYWdlID0gdGhpcy5wYWdlcyAtIDEpLCB0aGlzLl90b2dnbGVEaXNhYmxlU3RhdGUoKSwgdGhpcy5fcmVuZGVyUm93cygpO1xuICB9XG4gIF9zZXRTZWxlY3RlZCgpIHtcbiAgICBkLmZpbmQoZ28sIHRoaXMuX2VsZW1lbnQpLmZvckVhY2goXG4gICAgICAodCkgPT4ge1xuICAgICAgICBjb25zdCBlID0gaC5nZXREYXRhQXR0cmlidXRlKHQsIFwicm93SW5kZXhcIik7XG4gICAgICAgIHQuY2hlY2tlZCA9IHRoaXMuX3NlbGVjdGVkLmluY2x1ZGVzKGUpO1xuICAgICAgfVxuICAgICksIHRoaXMuX3NldEFjdGl2ZVJvd3MoKTtcbiAgfVxuICBfc2V0QWN0aXZlU29ydEljb24odCkge1xuICAgIGQuZmluZChtbywgdGhpcy5fZWxlbWVudCkuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgY29uc3QgaSA9IHRoaXMuX29wdGlvbnMuc29ydE9yZGVyID09PSBcImRlc2NcIiAmJiBlID09PSB0ID8gMTgwIDogMDtcbiAgICAgIGguc3R5bGUoZSwge1xuICAgICAgICB0cmFuc2Zvcm06IGByb3RhdGUoJHtpfWRlZylgXG4gICAgICB9KSwgZSA9PT0gdCAmJiB0aGlzLl9vcHRpb25zLnNvcnRPcmRlciA/IGguYWRkQ2xhc3MoZSwgXCJvcGFjaXR5LTEwMFwiKSA6IGgucmVtb3ZlQ2xhc3MoZSwgXCJvcGFjaXR5LTEwMFwiKTtcbiAgICB9KTtcbiAgfVxuICBfc2V0dXAoKSB7XG4gICAgdGhpcy5fcmVuZGVyVGFibGUoKSwgdGhpcy5fb3B0aW9ucy5wYWdpbmF0aW9uICYmIHRoaXMuX3NldHVwUGFnaW5hdGlvbigpLCB0aGlzLl9vcHRpb25zLmVkaXQgJiYgdGhpcy5fc2V0dXBFZGl0YWJsZSgpLCB0aGlzLl9vcHRpb25zLmNsaWNrYWJsZVJvd3MgJiYgdGhpcy5fc2V0dXBDbGlja2FibGVSb3dzKCksIHRoaXMuX29wdGlvbnMuc2VsZWN0YWJsZSAmJiB0aGlzLl9zZXR1cFNlbGVjdGFibGUoKSwgdGhpcy5fc2V0dXBTY3JvbGwoKSwgdGhpcy5fc2V0dXBTb3J0KCk7XG4gIH1cbiAgX3NldHVwQ2xpY2thYmxlUm93cygpIHtcbiAgICBkLmZpbmQoZmksIHRoaXMuX2VsZW1lbnQpLmZvckVhY2goKHQpID0+IHtcbiAgICAgIGNvbnN0IGUgPSBoLmdldERhdGFBdHRyaWJ1dGUodCwgXCJpbmRleFwiKTtcbiAgICAgIGguYWRkQ2xhc3ModCwgXCJjdXJzb3ItcG9pbnRlclwiKSwgYy5vbih0LCBcImNsaWNrXCIsIChpKSA9PiB7XG4gICAgICAgIGQubWF0Y2hlcyhpLnRhcmdldCwgZ28pIHx8IGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBxdiwge1xuICAgICAgICAgIGluZGV4OiBlLFxuICAgICAgICAgIHJvdzogdGhpcy5yb3dzW2VdXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgX3NldHVwRWRpdGFibGUoKSB7XG4gICAgZC5maW5kKGZpLCB0aGlzLl9lbGVtZW50KS5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICBjb25zdCBlID0gaC5nZXREYXRhQXR0cmlidXRlKHQsIFwiaW5kZXhcIik7XG4gICAgICBkLmZpbmQoZm8sIHQpLmZvckVhY2goKGkpID0+IHtcbiAgICAgICAgYy5vbihpLCBcImlucHV0XCIsIChuKSA9PiB0aGlzLl91cGRhdGVSb3cobiwgZSkpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgX3NldHVwU2Nyb2xsKCkge1xuICAgIGNvbnN0IHQgPSBkLmZpbmRPbmUoVnYsIHRoaXMuX2VsZW1lbnQpLCBlID0ge307XG4gICAgaWYgKHRoaXMuX29wdGlvbnMubWF4SGVpZ2h0ICYmIChlLm1heEhlaWdodCA9IHRoaXMuX2dldENTU1ZhbHVlKHRoaXMuX29wdGlvbnMubWF4SGVpZ2h0KSksIHRoaXMuX29wdGlvbnMubWF4V2lkdGgpIHtcbiAgICAgIGNvbnN0IGkgPSB0aGlzLl9nZXRDU1NWYWx1ZSh0aGlzLl9vcHRpb25zLm1heFdpZHRoKTtcbiAgICAgIGUubWF4V2lkdGggPSBpLCBoLnN0eWxlKHRoaXMuX2VsZW1lbnQsIHsgbWF4V2lkdGg6IGkgfSk7XG4gICAgfVxuICAgIGlmIChoLnN0eWxlKHQsIGUpLCBoLmFkZENsYXNzKHQsIGAke3RoaXMuX2NsYXNzZXMuc2Nyb2xsfWApLCB0aGlzLl9vcHRpb25zLmZpeGVkSGVhZGVyKSB7XG4gICAgICBsZXQgaSA9IGQuZmluZChXdiwgdGhpcy5fZWxlbWVudCk7XG4gICAgICB0aGlzLl9vcHRpb25zLnNlbGVjdGFibGUgJiYgKGkgPSBpLmZpbHRlcigobiwgbykgPT4gKGguYWRkQ2xhc3MoXG4gICAgICAgIG4sXG4gICAgICAgIGAke3RoaXMuX2NsYXNzZXMuZml4ZWRIZWFkZXJ9ICR7dGhpcy5fY2xhc3Nlcy5jb2xvcn1gXG4gICAgICApLCBvICE9PSAwKSkpLCBpLmZvckVhY2goKG4sIG8pID0+IHtcbiAgICAgICAgaC5hZGRDbGFzcyhcbiAgICAgICAgICBuLFxuICAgICAgICAgIGAke3RoaXMuX2NsYXNzZXMuZml4ZWRIZWFkZXJ9ICR7dGhpcy5fY2xhc3Nlcy5jb2xvcn1gXG4gICAgICAgICksIHRoaXMuY29sdW1uc1tvXS5maXhlZCAmJiBoLmFkZENsYXNzKG4sIFwiIXotNDBcIik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fcGVyZmVjdFNjcm9sbGJhciA9IG5ldyBtaCh0KTtcbiAgfVxuICBfc2V0dXBTb3J0KCkge1xuICAgIGQuZmluZChtbywgdGhpcy5fZWxlbWVudCkuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgY29uc3QgZSA9IGguZ2V0RGF0YUF0dHJpYnV0ZSh0LCBcInNvcnRcIiksIFtpXSA9IGQucGFyZW50cyh0LCBcInRoXCIpO1xuICAgICAgaWYgKHRoaXMuY29sdW1ucy5zb3J0KVxuICAgICAgICBoLmFkZENsYXNzKGksIFwiY3Vyc29yLXBvaW50ZXJcIik7XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybjtcbiAgICAgIGUgPT09IHRoaXMuX29wdGlvbnMuc29ydEZpZWxkICYmIHRoaXMuX3NldEFjdGl2ZVNvcnRJY29uKHQpLCBjLm9uKGksIFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgICB0aGlzLl9vcHRpb25zLnNvcnRGaWVsZCA9PT0gZSAmJiB0aGlzLl9vcHRpb25zLnNvcnRPcmRlciA9PT0gXCJhc2NcIiA/IHRoaXMuX29wdGlvbnMuc29ydE9yZGVyID0gXCJkZXNjXCIgOiB0aGlzLl9vcHRpb25zLnNvcnRGaWVsZCA9PT0gZSAmJiB0aGlzLl9vcHRpb25zLnNvcnRPcmRlciA9PT0gXCJkZXNjXCIgPyB0aGlzLl9vcHRpb25zLnNvcnRPcmRlciA9IHRoaXMuX29wdGlvbnMuZm9yY2VTb3J0ID8gXCJhc2NcIiA6IG51bGwgOiB0aGlzLl9vcHRpb25zLnNvcnRPcmRlciA9IFwiYXNjXCIsIHRoaXMuX29wdGlvbnMuc29ydEZpZWxkID0gZSwgdGhpcy5fYWN0aXZlUGFnZSA9IDAsIHRoaXMuX3BlcmZvcm1Tb3J0KCksIHRoaXMuX3NldEFjdGl2ZVNvcnRJY29uKHQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgX3BlcmZvcm1Tb3J0KCkge1xuICAgIHRoaXMuX3RvZ2dsZURpc2FibGVTdGF0ZSgpLCB0aGlzLl9yZW5kZXJSb3dzKCk7XG4gIH1cbiAgX3NldHVwU2VsZWN0YWJsZSgpIHtcbiAgICB0aGlzLl9jaGVja2JveGVzID0gZC5maW5kKGdvLCB0aGlzLl9lbGVtZW50KSwgdGhpcy5faGVhZGVyQ2hlY2tib3ggPSBkLmZpbmRPbmUoXG4gICAgICBGdixcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApLCBjLm9uKFxuICAgICAgdGhpcy5faGVhZGVyQ2hlY2tib3gsXG4gICAgICBcImlucHV0XCIsXG4gICAgICAodCkgPT4gdGhpcy5fdG9nZ2xlU2VsZWN0QWxsKHQpXG4gICAgKSwgdGhpcy5fY2hlY2tib3hlcy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICBjb25zdCBlID0gaC5nZXREYXRhQXR0cmlidXRlKHQsIFwicm93SW5kZXhcIik7XG4gICAgICBjLm9uKFxuICAgICAgICB0LFxuICAgICAgICBcImlucHV0XCIsXG4gICAgICAgIChpKSA9PiB0aGlzLl90b2dnbGVTZWxlY3RSb3coaSwgZSlcbiAgICAgICk7XG4gICAgfSk7XG4gIH1cbiAgX3NldHVwUGFnaW5hdGlvbigpIHtcbiAgICB0aGlzLl9wYWdpbmF0aW9uUmlnaHQgPSBkLmZpbmRPbmUoXG4gICAgICBZdixcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApLCB0aGlzLl9wYWdpbmF0aW9uTGVmdCA9IGQuZmluZE9uZShcbiAgICAgIGp2LFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICksIGMub24oXG4gICAgICB0aGlzLl9wYWdpbmF0aW9uUmlnaHQsXG4gICAgICBcImNsaWNrXCIsXG4gICAgICAoKSA9PiB0aGlzLl9jaGFuZ2VBY3RpdmVQYWdlKHRoaXMuX2FjdGl2ZVBhZ2UgKyAxKVxuICAgICksIGMub24oXG4gICAgICB0aGlzLl9wYWdpbmF0aW9uTGVmdCxcbiAgICAgIFwiY2xpY2tcIixcbiAgICAgICgpID0+IHRoaXMuX2NoYW5nZUFjdGl2ZVBhZ2UodGhpcy5fYWN0aXZlUGFnZSAtIDEpXG4gICAgKSwgdGhpcy5fb3B0aW9ucy5mdWxsUGFnaW5hdGlvbiAmJiAodGhpcy5fcGFnaW5hdGlvblN0YXJ0ID0gZC5maW5kT25lKFxuICAgICAgS3YsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKSwgdGhpcy5fcGFnaW5hdGlvbkVuZCA9IGQuZmluZE9uZShcbiAgICAgIHp2LFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICksIGMub24oXG4gICAgICB0aGlzLl9wYWdpbmF0aW9uU3RhcnQsXG4gICAgICBcImNsaWNrXCIsXG4gICAgICAoKSA9PiB0aGlzLl9jaGFuZ2VBY3RpdmVQYWdlKDApXG4gICAgKSwgYy5vbihcbiAgICAgIHRoaXMuX3BhZ2luYXRpb25FbmQsXG4gICAgICBcImNsaWNrXCIsXG4gICAgICAoKSA9PiB0aGlzLl9jaGFuZ2VBY3RpdmVQYWdlKHRoaXMucGFnZXMgLSAxKVxuICAgICkpLCB0aGlzLl90b2dnbGVEaXNhYmxlU3RhdGUoKSwgdGhpcy5fc2V0dXBQYWdpbmF0aW9uU2VsZWN0KCk7XG4gIH1cbiAgX3NldHVwUGFnaW5hdGlvblNlbGVjdCgpIHtcbiAgICB0aGlzLl9zZWxlY3QgPSBkLmZpbmRPbmUoWHYsIHRoaXMuX2VsZW1lbnQpLCB0aGlzLl9zZWxlY3RJbnN0YW5jZSA9IG5ldyBfcih0aGlzLl9zZWxlY3QpLCBjLm9uKFxuICAgICAgdGhpcy5fc2VsZWN0LFxuICAgICAgXCJ2YWx1ZUNoYW5nZS50ZS5zZWxlY3RcIixcbiAgICAgICh0KSA9PiB0aGlzLl9zZXRFbnRyaWVzKHQpXG4gICAgKTtcbiAgfVxuICBfcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5fb3B0aW9ucy5wYWdpbmF0aW9uICYmIChjLm9mZih0aGlzLl9wYWdpbmF0aW9uUmlnaHQsIFwiY2xpY2tcIiksIGMub2ZmKHRoaXMuX3BhZ2luYXRpb25MZWZ0LCBcImNsaWNrXCIpLCBjLm9mZih0aGlzLl9zZWxlY3QsIFwidmFsdWVDaGFuZ2UudGUuc2VsZWN0XCIpLCB0aGlzLl9vcHRpb25zLmZ1bGxQYWdpbmF0aW9uICYmIChjLm9mZih0aGlzLl9wYWdpbmF0aW9uU3RhcnQsIFwiY2xpY2tcIiksIGMub2ZmKHRoaXMuX3BhZ2luYXRpb25FbmQsIFwiY2xpY2tcIikpKSwgdGhpcy5fb3B0aW9ucy5lZGl0ICYmIGQuZmluZChmbywgdGhpcy5fZWxlbWVudCkuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgYy5vZmYodCwgXCJpbnB1dFwiKTtcbiAgICB9KSwgdGhpcy5fb3B0aW9ucy5jbGlja2FibGVSb3dzICYmIGQuZmluZChmaSwgdGhpcy5fZWxlbWVudCkuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgYy5vZmYodCwgXCJjbGlja1wiKTtcbiAgICB9KSwgZC5maW5kKG1vLCB0aGlzLl9lbGVtZW50KS5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICBjb25zdCBbZV0gPSBkLnBhcmVudHModCwgXCJ0aFwiKTtcbiAgICAgIGMub2ZmKGUsIFwiY2xpY2tcIik7XG4gICAgfSksIHRoaXMuX29wdGlvbnMuc2VsZWN0YWJsZSAmJiAoYy5vZmYodGhpcy5faGVhZGVyQ2hlY2tib3gsIFwiaW5wdXRcIiksIHRoaXMuX2NoZWNrYm94ZXMuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgYy5vZmYodCwgXCJpbnB1dFwiKTtcbiAgICB9KSk7XG4gIH1cbiAgX3JlbmRlclRhYmxlKCkge1xuICAgIHRoaXMuX2VsZW1lbnQuaW5uZXJIVE1MID0gd2wodGhpcy50YWJsZU9wdGlvbnMpLnRhYmxlLCB0aGlzLl9mb3JtYXRDZWxscygpLCBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgeGwpO1xuICB9XG4gIF9yZW5kZXJSb3dzKCkge1xuICAgIGNvbnN0IHQgPSBkLmZpbmRPbmUoXCJ0Ym9keVwiLCB0aGlzLl9lbGVtZW50KTtcbiAgICBpZiAodGhpcy5fb3B0aW9ucy5wYWdpbmF0aW9uKSB7XG4gICAgICBjb25zdCBlID0gZC5maW5kT25lKFxuICAgICAgICBVdixcbiAgICAgICAgdGhpcy5fZWxlbWVudFxuICAgICAgKTtcbiAgICAgIGUuaW5uZXJUZXh0ID0gdGhpcy5uYXZpZ2F0aW9uVGV4dDtcbiAgICB9XG4gICAgdC5pbm5lckhUTUwgPSB3bCh0aGlzLnRhYmxlT3B0aW9ucykucm93cywgdGhpcy5fZm9ybWF0Q2VsbHMoKSwgdGhpcy5fb3B0aW9ucy5lZGl0ICYmIHRoaXMuX3NldHVwRWRpdGFibGUoKSwgdGhpcy5fb3B0aW9ucy5zZWxlY3RhYmxlICYmICh0aGlzLl9zZXR1cFNlbGVjdGFibGUoKSwgdGhpcy5fc2V0U2VsZWN0ZWQoKSksIHRoaXMuX29wdGlvbnMuY2xpY2thYmxlUm93cyAmJiB0aGlzLl9zZXR1cENsaWNrYWJsZVJvd3MoKSwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHhsKTtcbiAgfVxuICBfZm9ybWF0Q2VsbHMoKSB7XG4gICAgZC5maW5kKGZpLCB0aGlzLl9lbGVtZW50KS5mb3JFYWNoKChlKSA9PiB7XG4gICAgICBjb25zdCBpID0gaC5nZXREYXRhQXR0cmlidXRlKGUsIFwiaW5kZXhcIik7XG4gICAgICBkLmZpbmQoZm8sIGUpLmZvckVhY2goKG8pID0+IHtcbiAgICAgICAgY29uc3QgciA9IGguZ2V0RGF0YUF0dHJpYnV0ZShvLCBcImZpZWxkXCIpLCBhID0gdGhpcy5jb2x1bW5zLmZpbmQoKGwpID0+IGwuZmllbGQgPT09IHIpO1xuICAgICAgICBhICYmIGEuZm9ybWF0ICE9PSBudWxsICYmIGEuZm9ybWF0KG8sIHRoaXMucm93c1tpXVtyXSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBfdG9nZ2xlRGlzYWJsZVN0YXRlKCkge1xuICAgIHRoaXMuX29wdGlvbnMucGFnaW5hdGlvbiAhPT0gITEgJiYgKHRoaXMuX2FjdGl2ZVBhZ2UgPT09IDAgfHwgdGhpcy5fb3B0aW9ucy5sb2FkaW5nID8gKHRoaXMuX3BhZ2luYXRpb25MZWZ0LnNldEF0dHJpYnV0ZShcImRpc2FibGVkXCIsIFwiXCIpLCB0aGlzLl9vcHRpb25zLmZ1bGxQYWdpbmF0aW9uICYmIHRoaXMuX3BhZ2luYXRpb25TdGFydC5zZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiLCBcIlwiKSkgOiAodGhpcy5fcGFnaW5hdGlvbkxlZnQucmVtb3ZlQXR0cmlidXRlKFwiZGlzYWJsZWRcIiksIHRoaXMuX29wdGlvbnMuZnVsbFBhZ2luYXRpb24gJiYgdGhpcy5fcGFnaW5hdGlvblN0YXJ0LnJlbW92ZUF0dHJpYnV0ZShcImRpc2FibGVkXCIpKSwgdGhpcy5fYWN0aXZlUGFnZSA9PT0gdGhpcy5wYWdlcyAtIDEgfHwgdGhpcy5fb3B0aW9ucy5sb2FkaW5nIHx8IHRoaXMucGFnZXMgPT09IDAgPyAodGhpcy5fcGFnaW5hdGlvblJpZ2h0LnNldEF0dHJpYnV0ZShcImRpc2FibGVkXCIsIFwiXCIpLCB0aGlzLl9vcHRpb25zLmZ1bGxQYWdpbmF0aW9uICYmIHRoaXMuX3BhZ2luYXRpb25FbmQuc2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIiwgXCJcIikpIDogKHRoaXMuX3BhZ2luYXRpb25SaWdodC5yZW1vdmVBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSwgdGhpcy5fb3B0aW9ucy5mdWxsUGFnaW5hdGlvbiAmJiB0aGlzLl9wYWdpbmF0aW9uRW5kLnJlbW92ZUF0dHJpYnV0ZShcImRpc2FibGVkXCIpKSk7XG4gIH1cbiAgX3RvZ2dsZVNlbGVjdEFsbCh0KSB7XG4gICAgdC50YXJnZXQuY2hlY2tlZCA/IHRoaXMuX3NlbGVjdGVkID0gdGhpcy5yb3dzLm1hcCgoZSkgPT4gZS5yb3dJbmRleCkgOiB0aGlzLl9zZWxlY3RlZCA9IFtdLCB0aGlzLl9zZXRTZWxlY3RlZCgpLCB0aGlzLl9lbWl0U2VsZWN0RXZlbnQoKTtcbiAgfVxuICBfdG9nZ2xlU2VsZWN0Um93KHQsIGUpIHtcbiAgICB0LnRhcmdldC5jaGVja2VkID8gdGhpcy5fb3B0aW9ucy5tdWx0aSAmJiAhdGhpcy5fc2VsZWN0ZWQuaW5jbHVkZXMoZSkgPyB0aGlzLl9zZWxlY3RlZCA9IFsuLi50aGlzLl9zZWxlY3RlZCwgZV0gOiAodGhpcy5fc2VsZWN0ZWQgPSBbZV0sIHRoaXMuX2NoZWNrYm94ZXMuZm9yRWFjaCgoaSkgPT4ge1xuICAgICAgaSAhPT0gdC50YXJnZXQgJiYgKGkuY2hlY2tlZCA9ICExKTtcbiAgICB9KSkgOiB0aGlzLl9zZWxlY3RlZCA9IHRoaXMuX3NlbGVjdGVkLmZpbHRlcigoaSkgPT4gaSAhPT0gZSksIHRoaXMuX29wdGlvbnMubXVsdGkgJiYgIXQudGFyZ2V0LmNoZWNrZWQgJiYgKHRoaXMuX2hlYWRlckNoZWNrYm94LmNoZWNrZWQgPSAhMSksIHRoaXMuX3NldEFjdGl2ZVJvd3MoKSwgdGhpcy5fZW1pdFNlbGVjdEV2ZW50KCk7XG4gIH1cbiAgX3VwZGF0ZVJvdyh0LCBlKSB7XG4gICAgY29uc3QgaSA9IGguZ2V0RGF0YUF0dHJpYnV0ZSh0LnRhcmdldCwgXCJmaWVsZFwiKSwgbiA9IHQudGFyZ2V0LnRleHRDb250ZW50LCBvID0gdGhpcy5fcm93c1tlXTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvKSkge1xuICAgICAgY29uc3QgYSA9IHRoaXMuY29sdW1ucy5maW5kKChsKSA9PiBsLmZpZWxkID09PSBpKS5jb2x1bW5JbmRleDtcbiAgICAgIG9bYV0gPSBuO1xuICAgIH0gZWxzZVxuICAgICAgb1tpXSA9IG47XG4gICAgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIFp2LCB7XG4gICAgICByb3dzOiB0aGlzLl9yb3dzLFxuICAgICAgY29sdW1uczogdGhpcy5fY29sdW1uc1xuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCwgZSwgaSkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICBsZXQgbiA9IHkuZ2V0RGF0YSh0aGlzLCBFaSk7XG4gICAgICBjb25zdCBvID0gdHlwZW9mIHQgPT0gXCJvYmplY3RcIiAmJiB0O1xuICAgICAgaWYgKCEoIW4gJiYgL2Rpc3Bvc2UvLnRlc3QodCkpICYmIChuIHx8IChuID0gbmV3IGdoKHRoaXMsIG8sIGUpKSwgdHlwZW9mIHQgPT0gXCJzdHJpbmdcIikpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuW3RdID4gXCJ1XCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgIG5bdF0oZSwgaSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGdldEluc3RhbmNlKHQpIHtcbiAgICByZXR1cm4geS5nZXREYXRhKHQsIEVpKTtcbiAgfVxuICBzdGF0aWMgZ2V0T3JDcmVhdGVJbnN0YW5jZSh0LCBlID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSh0KSB8fCBuZXcgdGhpcyh0LCB0eXBlb2YgZSA9PSBcIm9iamVjdFwiID8gZSA6IG51bGwpO1xuICB9XG59XG5jb25zdCBPbCA9IFwicmF0aW5nXCIsIHFzID0gXCJ0ZS5yYXRpbmdcIiwgdEUgPSBcImRhdGEtdGUtcmF0aW5nLWluaXRcIiwgZUUgPSBcIltkYXRhLXRlLXJhdGluZy1pY29uLXJlZl1cIiwgbmkgPSBgLiR7cXN9YCwgaUUgPSBcIkFycm93TGVmdFwiLCBzRSA9IFwiQXJyb3dSaWdodFwiLCBuRSA9IHtcbiAgdG9vbHRpcDogXCJzdHJpbmdcIixcbiAgdmFsdWU6IFwiKHN0cmluZ3xudW1iZXIpXCIsXG4gIHJlYWRvbmx5OiBcImJvb2xlYW5cIixcbiAgYWZ0ZXI6IFwic3RyaW5nXCIsXG4gIGJlZm9yZTogXCJzdHJpbmdcIixcbiAgZHluYW1pYzogXCJib29sZWFuXCIsXG4gIGFjdGl2ZTogXCJzdHJpbmdcIlxufSwgb0UgPSB7XG4gIHRvb2x0aXA6IFwidG9wXCIsXG4gIHZhbHVlOiBcIlwiLFxuICByZWFkb25seTogITEsXG4gIGFmdGVyOiBcIlwiLFxuICBiZWZvcmU6IFwiXCIsXG4gIGR5bmFtaWM6ICExLFxuICBhY3RpdmU6IFwiZmlsbC1jdXJyZW50XCJcbn0sIFNsID0gYG9uU2VsZWN0JHtuaX1gLCByRSA9IGBvbkhvdmVyJHtuaX1gLCBJbCA9IGBrZXl1cCR7bml9YCwgRGwgPSBgZm9jdXNvdXQke25pfWAsICRsID0gYGtleWRvd24ke25pfWAsIExsID0gYG1vdXNlZG93biR7bml9YDtcbmNsYXNzIHFDIHtcbiAgY29uc3RydWN0b3IodCwgZSkge1xuICAgIHRoaXMuX2VsZW1lbnQgPSB0LCB0aGlzLl9pY29ucyA9IGQuZmluZChlRSwgdGhpcy5fZWxlbWVudCksIHRoaXMuX29wdGlvbnMgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX2luZGV4ID0gLTEsIHRoaXMuX3NhdmVkSW5kZXggPSBudWxsLCB0aGlzLl9vcmlnaW5hbENsYXNzTGlzdCA9IFtdLCB0aGlzLl9vcmlnaW5hbEljb25zID0gW10sIHRoaXMuX2ZuID0ge30sIHRoaXMuX3Rvb2x0aXBzID0gW10sIHRoaXMuX2VsZW1lbnQgJiYgKHkuc2V0RGF0YSh0LCBxcywgdGhpcyksIHRoaXMuX2luaXQoKSk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIE9sO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgeS5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIHFzKSwgdGhpcy5fb3B0aW9ucy5yZWFkb25seSB8fCAoYy5vZmYodGhpcy5fZWxlbWVudCwgSWwpLCBjLm9mZih0aGlzLl9lbGVtZW50LCBEbCksIGMub2ZmKHRoaXMuX2VsZW1lbnQsICRsKSwgdGhpcy5fZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCB0aGlzLl9mbi5tb3VzZWxlYXZlKSwgdGhpcy5faWNvbnMuZm9yRWFjaCgodCwgZSkgPT4ge1xuICAgICAgYy5vZmYodCwgTGwpLCB0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWVudGVyXCIsIHRoaXMuX2ZuLm1vdXNlZW50ZXJbZV0pLCBoLnJlbW92ZUNsYXNzKHQsIFwiY3Vyc29yLXBvaW50ZXJcIik7XG4gICAgfSksIHRoaXMuX3Rvb2x0aXBzLmZvckVhY2goKHQpID0+IHtcbiAgICAgIHQuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKHRFKSwgdC5kaXNwb3NlKCk7XG4gICAgfSksIHRoaXMuX2ljb25zLnJlbW92ZUF0dHJpYnV0ZShcInRhYkluZGV4XCIpKSwgdGhpcy5fZWxlbWVudCA9IG51bGw7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfaW5pdCgpIHtcbiAgICB0aGlzLl9vcHRpb25zLnJlYWRvbmx5IHx8ICh0aGlzLl9iaW5kTW91c2VFbnRlcigpLCB0aGlzLl9iaW5kTW91c2VMZWF2ZSgpLCB0aGlzLl9iaW5kTW91c2VEb3duKCksIHRoaXMuX2JpbmRLZXlEb3duKCksIHRoaXMuX2JpbmRLZXlVcCgpLCB0aGlzLl9iaW5kRm9jdXNMb3N0KCksIHRoaXMuX2ljb25zLmZvckVhY2goKHQpID0+IHtcbiAgICAgIGguYWRkQ2xhc3ModCwgXCJjdXJzb3ItcG9pbnRlclwiKTtcbiAgICB9KSksIHRoaXMuX29wdGlvbnMuZHluYW1pYyAmJiAodGhpcy5fc2F2ZU9yaWdpbmFsQ2xhc3NMaXN0KCksIHRoaXMuX3NhdmVPcmlnaW5hbEljb25zKCkpLCB0aGlzLl9zZXRDdXN0b21UZXh0KCksIHRoaXMuX3NldFRvb2xUaXBzKCksIHRoaXMuX29wdGlvbnMudmFsdWUgJiYgKHRoaXMuX2luZGV4ID0gdGhpcy5fb3B0aW9ucy52YWx1ZSAtIDEsIHRoaXMuX3VwZGF0ZVJhdGluZyh0aGlzLl9pbmRleCkpO1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIGNvbnN0IGUgPSBoLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4ub0UsXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIEQoT2wsIHQsIG5FKSwgdDtcbiAgfVxuICBfYmluZE1vdXNlRW50ZXIoKSB7XG4gICAgdGhpcy5fZm4ubW91c2VlbnRlciA9IFtdLCB0aGlzLl9pY29ucy5mb3JFYWNoKCh0LCBlKSA9PiB7XG4gICAgICB0LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgIFwibW91c2VlbnRlclwiLFxuICAgICAgICAvLyB0aGlzLl9mbi5tb3VzZWVudGVyW2ldIGlzIG5lZWRlZCB0byBjcmVhdGUgcmVmZXJlbmNlIGFuZCB1bnBpbiBldmVudHMgYWZ0ZXIgY2FsbCBkaXNwb3NlXG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICB0aGlzLl9mbi5tb3VzZWVudGVyW2VdID0gKGkpID0+IHtcbiAgICAgICAgICB0aGlzLl9pbmRleCA9IHRoaXMuX2ljb25zLmluZGV4T2YoaS50YXJnZXQpLCB0aGlzLl91cGRhdGVSYXRpbmcodGhpcy5faW5kZXgpLCB0aGlzLl90cmlnZ2VyRXZlbnRzKHQsIHJFKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuICBfYmluZE1vdXNlTGVhdmUoKSB7XG4gICAgdGhpcy5fZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgXCJtb3VzZWxlYXZlXCIsXG4gICAgICAvLyB0aGlzLl9mbi5tb3VzZWxlYXZlIGlzIG5lZWRlZCB0byBjcmVhdGUgcmVmZXJlbmNlIGFuZCB1bnBpbiBldmVudHMgYWZ0ZXIgY2FsbCBkaXNwb3NlXG4gICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgIHRoaXMuX2ZuLm1vdXNlbGVhdmUgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuX3NhdmVkSW5kZXggIT09IG51bGwgPyAodGhpcy5fdXBkYXRlUmF0aW5nKHRoaXMuX3NhdmVkSW5kZXgpLCB0aGlzLl9pbmRleCA9IHRoaXMuX3NhdmVkSW5kZXgpIDogdGhpcy5fb3B0aW9ucy52YWx1ZSA/ICh0aGlzLl91cGRhdGVSYXRpbmcodGhpcy5fb3B0aW9ucy52YWx1ZSAtIDEpLCB0aGlzLl9pbmRleCA9IHRoaXMuX29wdGlvbnMudmFsdWUgLSAxKSA6ICh0aGlzLl9pbmRleCA9IC0xLCB0aGlzLl9jbGVhclJhdGluZygpKTtcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIF9iaW5kTW91c2VEb3duKCkge1xuICAgIHRoaXMuX2ljb25zLmZvckVhY2goKHQpID0+IHtcbiAgICAgIGMub24odCwgTGwsICgpID0+IHtcbiAgICAgICAgdGhpcy5fc2V0RWxlbWVudE91dGxpbmUoXCJub25lXCIpLCB0aGlzLl9zYXZlZEluZGV4ID0gdGhpcy5faW5kZXgsIHRoaXMuX3RyaWdnZXJFdmVudHModCwgU2wpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgX2JpbmRLZXlEb3duKCkge1xuICAgIHRoaXMuX2VsZW1lbnQudGFiSW5kZXggPSAwLCBjLm9uKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgICRsLFxuICAgICAgKHQpID0+IHRoaXMuX3VwZGF0ZUFmdGVyS2V5RG93bih0KVxuICAgICk7XG4gIH1cbiAgX2JpbmRLZXlVcCgpIHtcbiAgICBjLm9uKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIElsLFxuICAgICAgKCkgPT4gdGhpcy5fc2V0RWxlbWVudE91dGxpbmUoXCJhdXRvXCIpXG4gICAgKTtcbiAgfVxuICBfYmluZEZvY3VzTG9zdCgpIHtcbiAgICBjLm9uKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIERsLFxuICAgICAgKCkgPT4gdGhpcy5fc2V0RWxlbWVudE91dGxpbmUoXCJub25lXCIpXG4gICAgKTtcbiAgfVxuICBfc2V0RWxlbWVudE91dGxpbmUodCkge1xuICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUub3V0bGluZSA9IHQ7XG4gIH1cbiAgX3RyaWdnZXJFdmVudHModCwgZSkge1xuICAgIGMudHJpZ2dlcih0LCBlLCB7XG4gICAgICB2YWx1ZTogdGhpcy5faW5kZXggKyAxXG4gICAgfSk7XG4gIH1cbiAgX3VwZGF0ZUFmdGVyS2V5RG93bih0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuX2ljb25zLmxlbmd0aCAtIDEsIGkgPSB0aGlzLl9pbmRleDtcbiAgICB0LmtleSA9PT0gc0UgJiYgdGhpcy5faW5kZXggPCBlICYmICh0aGlzLl9pbmRleCArPSAxKSwgdC5rZXkgPT09IGlFICYmIHRoaXMuX2luZGV4ID4gLTEgJiYgKHRoaXMuX2luZGV4IC09IDEpLCBpICE9PSB0aGlzLl9pbmRleCAmJiAodGhpcy5fc2F2ZWRJbmRleCA9IHRoaXMuX2luZGV4LCB0aGlzLl91cGRhdGVSYXRpbmcodGhpcy5fc2F2ZWRJbmRleCksIHRoaXMuX3RyaWdnZXJFdmVudHModGhpcy5faWNvbnNbdGhpcy5fc2F2ZWRJbmRleF0sIFNsKSk7XG4gIH1cbiAgX3VwZGF0ZVJhdGluZyh0KSB7XG4gICAgdGhpcy5fY2xlYXJSYXRpbmcoKSwgdGhpcy5fb3B0aW9ucy5keW5hbWljICYmIHRoaXMuX3Jlc3RvcmVPcmlnaW5hbEljb24odCksIHRoaXMuX2ljb25zLmZvckVhY2goKGUsIGkpID0+IHtcbiAgICAgIGkgPD0gdCAmJiBoLmFkZENsYXNzKGUucXVlcnlTZWxlY3RvcihcInN2Z1wiKSwgdGhpcy5fb3B0aW9ucy5hY3RpdmUpO1xuICAgIH0pO1xuICB9XG4gIF9jbGVhclJhdGluZygpIHtcbiAgICB0aGlzLl9pY29ucy5mb3JFYWNoKCh0LCBlKSA9PiB7XG4gICAgICBjb25zdCBpID0gdC5xdWVyeVNlbGVjdG9yKFwic3ZnXCIpO1xuICAgICAgdGhpcy5fb3B0aW9ucy5keW5hbWljICYmICh0LmNsYXNzTGlzdCA9IHRoaXMuX29yaWdpbmFsQ2xhc3NMaXN0W2VdLCBpLmlubmVySFRNTCA9IHRoaXMuX29yaWdpbmFsSWNvbnNbZV0pLCBoLnJlbW92ZUNsYXNzKGksIHRoaXMuX29wdGlvbnMuYWN0aXZlKTtcbiAgICB9KTtcbiAgfVxuICBfc2V0VG9vbFRpcHMoKSB7XG4gICAgdGhpcy5faWNvbnMuZm9yRWFjaCgodCwgZSkgPT4ge1xuICAgICAgY29uc3QgaSA9IGguZ2V0RGF0YUF0dHJpYnV0ZSh0LCBcInRvZ2dsZVwiKTtcbiAgICAgIHQudGl0bGUgJiYgIWkgJiYgKGguc2V0RGF0YUF0dHJpYnV0ZSh0LCBcInRvZ2dsZVwiLCBcInRvb2x0aXBcIiksIHRoaXMuX3Rvb2x0aXBzW2VdID0gbmV3IGlpKHQsIHtcbiAgICAgICAgcGxhY2VtZW50OiB0aGlzLl9vcHRpb25zLnRvb2x0aXBcbiAgICAgIH0pKTtcbiAgICB9KTtcbiAgfVxuICBfc2V0Q3VzdG9tVGV4dCgpIHtcbiAgICB0aGlzLl9pY29ucy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICBjb25zdCBlID0gaC5nZXREYXRhQXR0cmlidXRlKHQsIFwiYWZ0ZXJcIiksIGkgPSBoLmdldERhdGFBdHRyaWJ1dGUodCwgXCJiZWZvcmVcIik7XG4gICAgICBlICYmIHQuaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYWZ0ZXJFbmRcIiwgZSksIGkgJiYgdC5pbnNlcnRBZGphY2VudEhUTUwoXCJiZWZvcmVCZWdpblwiLCBpKTtcbiAgICB9KTtcbiAgfVxuICBfc2F2ZU9yaWdpbmFsQ2xhc3NMaXN0KCkge1xuICAgIHRoaXMuX2ljb25zLmZvckVhY2goKHQpID0+IHtcbiAgICAgIGNvbnN0IGUgPSB0LmNsYXNzTGlzdC52YWx1ZTtcbiAgICAgIHRoaXMuX29yaWdpbmFsQ2xhc3NMaXN0LnB1c2goZSk7XG4gICAgfSk7XG4gIH1cbiAgX3NhdmVPcmlnaW5hbEljb25zKCkge1xuICAgIHRoaXMuX2ljb25zLmZvckVhY2goKHQpID0+IHtcbiAgICAgIGNvbnN0IGUgPSB0LnF1ZXJ5U2VsZWN0b3IoXCJzdmdcIikuaW5uZXJIVE1MO1xuICAgICAgdGhpcy5fb3JpZ2luYWxJY29ucy5wdXNoKGUpO1xuICAgIH0pO1xuICB9XG4gIF9yZXN0b3JlT3JpZ2luYWxJY29uKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5fb3JpZ2luYWxDbGFzc0xpc3RbdF0sIGkgPSB0aGlzLl9vcmlnaW5hbEljb25zW3RdO1xuICAgIHRoaXMuX2ljb25zLmZvckVhY2goKG4sIG8pID0+IHtcbiAgICAgIGlmIChvIDw9IHQpIHtcbiAgICAgICAgY29uc3QgciA9IG4ucXVlcnlTZWxlY3RvcihcInN2Z1wiKTtcbiAgICAgICAgci5pbm5lckhUTUwgPSBpLCBuLmNsYXNzTGlzdCA9IGU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBnZXRJbnN0YW5jZSh0KSB7XG4gICAgcmV0dXJuIHkuZ2V0RGF0YSh0LCBxcyk7XG4gIH1cbiAgc3RhdGljIGdldE9yQ3JlYXRlSW5zdGFuY2UodCwgZSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UodCkgfHwgbmV3IHRoaXModCwgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiA/IGUgOiBudWxsKTtcbiAgfVxufVxuY29uc3QgYm8gPSBcInBvcGNvbmZpcm1cIiwgQ2kgPSBcInRlLnBvcGNvbmZpcm1cIiwgYmggPSBgLiR7Q2l9YCwgYUUgPSBgY2FuY2VsJHtiaH1gLCBsRSA9IGBjb25maXJtJHtiaH1gLCBjRSA9IFwiW2RhdGEtdGUtcG9wY29uZmlybS1ib2R5XVwiLCB2byA9IFwiZGF0YS10ZS1wb3Bjb25maXJtLXBvcG92ZXJcIiwgaEUgPSBcImRhdGEtdGUtcG9wY29uZmlybS1tb2RhbFwiLCBObCA9IFwiZGF0YS10ZS1wb3Bjb25maXJtLWJhY2tkcm9wXCIsIGRFID0ge1xuICBwb3Bjb25maXJtTW9kZTogXCJzdHJpbmdcIixcbiAgbWVzc2FnZTogXCJzdHJpbmdcIixcbiAgY2FuY2VsVGV4dDogXCIobnVsbHxzdHJpbmcpXCIsXG4gIG9rVGV4dDogXCIobnVsbHxzdHJpbmcpXCIsXG4gIHBvcGNvbmZpcm1JY29uVGVtcGxhdGU6IFwic3RyaW5nXCIsXG4gIGNhbmNlbExhYmVsOiBcIihudWxsfHN0cmluZylcIixcbiAgY29uZmlybUxhYmVsOiBcIihudWxsfHN0cmluZylcIixcbiAgcG9zaXRpb246IFwiKG51bGx8c3RyaW5nKVwiXG59LCB1RSA9IHtcbiAgcG9wY29uZmlybU1vZGU6IFwiaW5saW5lXCIsXG4gIG1lc3NhZ2U6IFwiQXJlIHlvdSBzdXJlP1wiLFxuICBjYW5jZWxUZXh0OiBcIkNhbmNlbFwiLFxuICBva1RleHQ6IFwiT0tcIixcbiAgcG9wY29uZmlybUljb25UZW1wbGF0ZTogXCJcIixcbiAgY2FuY2VsTGFiZWw6IFwiQ2FuY2VsXCIsXG4gIGNvbmZpcm1MYWJlbDogXCJDb25maXJtXCIsXG4gIHBvc2l0aW9uOiBcImJvdHRvbVwiXG59LCBwRSA9IHtcbiAgYmFja2Ryb3A6IFwic3RyaW5nXCIsXG4gIGJvZHk6IFwic3RyaW5nXCIsXG4gIGJ0bkNhbmNlbDogXCJzdHJpbmdcIixcbiAgYnRuQ29uZmlybTogXCJzdHJpbmdcIixcbiAgYnRuc0NvbnRhaW5lcjogXCJzdHJpbmdcIixcbiAgZmFkZTogXCJzdHJpbmdcIixcbiAgaWNvbjogXCJzdHJpbmdcIixcbiAgbWVzc2FnZTogXCJzdHJpbmdcIixcbiAgbWVzc2FnZVRleHQ6IFwic3RyaW5nXCIsXG4gIG1vZGFsOiBcInN0cmluZ1wiLFxuICBwb3BvdmVyOiBcInN0cmluZ1wiXG59LCBfRSA9IHtcbiAgYmFja2Ryb3A6IFwiaC1mdWxsIHctZnVsbCB6LVsxMDcwXSBmaXhlZCB0b3AtMCBsZWZ0LTAgYmctWyMwMDAwMDA2Nl0gZmxleCBqdXN0aWZ5LWNlbnRlciBpdGVtcy1jZW50ZXJcIixcbiAgYm9keTogXCJwLVsxcmVtXSBiZy13aGl0ZSByb3VuZGVkLVswLjVyZW1dIG9wYWNpdHktMCBkYXJrOmJnLW5ldXRyYWwtNzAwXCIsXG4gIGJ0bkNhbmNlbDogXCJpbmxpbmUtYmxvY2sgcm91bmRlZCBiZy1wcmltYXJ5LTEwMCBweC00IHBiLVs1cHhdIHB0LVs2cHhdIHRleHQteHMgZm9udC1tZWRpdW0gdXBwZXJjYXNlIGxlYWRpbmctbm9ybWFsIHRleHQtcHJpbWFyeS03MDAgdHJhbnNpdGlvbiBkdXJhdGlvbi0xNTAgZWFzZS1pbi1vdXQgaG92ZXI6YmctcHJpbWFyeS1hY2NlbnQtMTAwIGZvY3VzOmJnLXByaW1hcnktYWNjZW50LTEwMCBmb2N1czpvdXRsaW5lLW5vbmUgZm9jdXM6cmluZy0wIGFjdGl2ZTpiZy1wcmltYXJ5LWFjY2VudC0yMDBcIixcbiAgYnRuQ29uZmlybTogXCJpbmxpbmUtYmxvY2sgcm91bmRlZCBiZy1wcmltYXJ5IHB4LTQgcGItWzVweF0gcHQtWzZweF0gdGV4dC14cyBmb250LW1lZGl1bSB1cHBlcmNhc2UgbGVhZGluZy1ub3JtYWwgdGV4dC13aGl0ZSBzaGFkb3ctWzBfNHB4XzlweF8tNHB4XyMzYjcxY2FdIHRyYW5zaXRpb24gZHVyYXRpb24tMTUwIGVhc2UtaW4tb3V0IGhvdmVyOmJnLXByaW1hcnktNjAwIGhvdmVyOnNoYWRvdy1bMF84cHhfOXB4Xy00cHhfcmdiYSg1OSwxMTMsMjAyLDAuMyksMF80cHhfMThweF8wX3JnYmEoNTksMTEzLDIwMiwwLjIpXSBmb2N1czpiZy1wcmltYXJ5LTYwMCBmb2N1czpzaGFkb3ctWzBfOHB4XzlweF8tNHB4X3JnYmEoNTksMTEzLDIwMiwwLjMpLDBfNHB4XzE4cHhfMF9yZ2JhKDU5LDExMywyMDIsMC4yKV0gZm9jdXM6b3V0bGluZS1ub25lIGZvY3VzOnJpbmctMCBhY3RpdmU6YmctcHJpbWFyeS03MDAgYWN0aXZlOnNoYWRvdy1bMF84cHhfOXB4Xy00cHhfcmdiYSg1OSwxMTMsMjAyLDAuMyksMF80cHhfMThweF8wX3JnYmEoNTksMTEzLDIwMiwwLjIpXSBkYXJrOnNoYWRvdy1bMF80cHhfOXB4Xy00cHhfcmdiYSg1OSwxMTMsMjAyLDAuNSldIGRhcms6aG92ZXI6c2hhZG93LVswXzhweF85cHhfLTRweF9yZ2JhKDU5LDExMywyMDIsMC4yKSwwXzRweF8xOHB4XzBfcmdiYSg1OSwxMTMsMjAyLDAuMSldIGRhcms6Zm9jdXM6c2hhZG93LVswXzhweF85cHhfLTRweF9yZ2JhKDU5LDExMywyMDIsMC4yKSwwXzRweF8xOHB4XzBfcmdiYSg1OSwxMTMsMjAyLDAuMSldIGRhcms6YWN0aXZlOnNoYWRvdy1bMF84cHhfOXB4Xy00cHhfcmdiYSg1OSwxMTMsMjAyLDAuMiksMF80cHhfMThweF8wX3JnYmEoNTksMTEzLDIwMiwwLjEpXVwiLFxuICBidG5zQ29udGFpbmVyOiBcImZsZXgganVzdGlmeS1lbmQgc3BhY2UteC0yXCIsXG4gIGZhZGU6IFwidHJhbnNpdGlvbi1vcGFjaXR5IGR1cmF0aW9uLVsxNTBtc10gZWFzZS1saW5lYXJcIixcbiAgaWNvbjogXCJwci0yXCIsXG4gIG1lc3NhZ2U6IFwiZmxleCBtYi0zXCIsXG4gIG1lc3NhZ2VUZXh0OiBcInRleHQtbmV1dHJhbC02MDAgZGFyazp0ZXh0LXdoaXRlXCIsXG4gIG1vZGFsOiBcImFic29sdXRlIHctWzMwMHB4XSB6LVsxMDgwXSBzaGFkb3ctc20gcm91bmRlZC1bMC41cmVtXVwiLFxuICBwb3BvdmVyOiBcInctWzMwMHB4XSBib3JkZXItMCByb3VuZGVkLVswLjVyZW1dIHotWzEwODBdIHNoYWRvdy1zbVwiXG59O1xuY2xhc3Mgdmgge1xuICBjb25zdHJ1Y3Rvcih0LCBlLCBpKSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX29wdGlvbnMgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX2NsYXNzZXMgPSB0aGlzLl9nZXRDbGFzc2VzKGkpLCB0aGlzLl9wb3BwZXIgPSBudWxsLCB0aGlzLl9jYW5jZWxCdXR0b24gPSBcIlwiLCB0aGlzLl9jb25maXJtQnV0dG9uID0gXCJcIiwgdGhpcy5faXNPcGVuID0gITEsIHRoaXMuX3VpZCA9IHRoaXMuX2VsZW1lbnQuaWQgPyBgcG9wY29uZmlybS0ke3RoaXMuX2VsZW1lbnQuaWR9YCA6IHJ0KFwicG9wY29uZmlybS1cIiksIHQgJiYgeS5zZXREYXRhKHQsIENpLCB0aGlzKSwgdGhpcy5fY2xpY2tIYW5kbGVyID0gdGhpcy5vcGVuLmJpbmQodGhpcyksIGMub24odGhpcy5fZWxlbWVudCwgXCJjbGlja1wiLCB0aGlzLl9jbGlja0hhbmRsZXIpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBibztcbiAgfVxuICBnZXQgY29udGFpbmVyKCkge1xuICAgIHJldHVybiBkLmZpbmRPbmUoYCMke3RoaXMuX3VpZH1gKTtcbiAgfVxuICBnZXQgcG9wY29uZmlybUJvZHkoKSB7XG4gICAgcmV0dXJuIGQuZmluZE9uZShcbiAgICAgIGNFLFxuICAgICAgdGhpcy5jb250YWluZXJcbiAgICApO1xuICB9XG4gIC8vIFB1YmxpY1xuICBkaXNwb3NlKCkge1xuICAgICh0aGlzLl9pc09wZW4gfHwgdGhpcy5jb250YWluZXIgIT09IG51bGwpICYmIHRoaXMuY2xvc2UoKSwgeS5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIENpKSwgYy5vZmYodGhpcy5fZWxlbWVudCwgXCJjbGlja1wiLCB0aGlzLl9jbGlja0hhbmRsZXIpLCB0aGlzLl9lbGVtZW50ID0gbnVsbDtcbiAgfVxuICBvcGVuKCkge1xuICAgIHRoaXMuX2lzT3BlbiB8fCAodGhpcy5fb3B0aW9ucy5wb3Bjb25maXJtTW9kZSA9PT0gXCJpbmxpbmVcIiA/IHRoaXMuX29wZW5Qb3BvdmVyKHRoaXMuX2dldFBvcG92ZXJUZW1wbGF0ZSgpKSA6IHRoaXMuX29wZW5Nb2RhbCh0aGlzLl9nZXRNb2RhbFRlbXBsYXRlKCkpLCB0aGlzLl9oYW5kbGVDYW5jZWxCdXR0b25DbGljaygpLCB0aGlzLl9oYW5kbGVDb25maXJtQnV0dG9uQ2xpY2soKSwgdGhpcy5fbGlzdGVuVG9Fc2NhcGVLZXkoKSwgdGhpcy5fbGlzdGVuVG9PdXRzaWRlQ2xpY2soKSk7XG4gIH1cbiAgY2xvc2UoKSB7XG4gICAgaWYgKHRoaXMuX2lzT3Blbikge1xuICAgICAgaWYgKHRoaXMuX3BvcHBlciAhPT0gbnVsbCB8fCBkLmZpbmRPbmUoYFske3ZvfV1gKSAhPT0gbnVsbClcbiAgICAgICAgYy5vbihcbiAgICAgICAgICB0aGlzLnBvcGNvbmZpcm1Cb2R5LFxuICAgICAgICAgIFwidHJhbnNpdGlvbmVuZFwiLFxuICAgICAgICAgIHRoaXMuX2hhbmRsZVBvcGNvbmZpcm1UcmFuc2l0aW9uRW5kLmJpbmQodGhpcylcbiAgICAgICAgKSwgaC5yZW1vdmVDbGFzcyh0aGlzLnBvcGNvbmZpcm1Cb2R5LCBcIm9wYWNpdHktMTAwXCIpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHQgPSBkLmZpbmRPbmUoXG4gICAgICAgICAgYFske05sfV1gXG4gICAgICAgICk7XG4gICAgICAgIGgucmVtb3ZlQ2xhc3ModGhpcy5wb3Bjb25maXJtQm9keSwgXCJvcGFjaXR5LTEwMFwiKSwgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0KSwgdGhpcy5faXNPcGVuID0gITE7XG4gICAgICB9XG4gICAgICBjLm9mZihkb2N1bWVudCwgXCJjbGlja1wiLCB0aGlzLl9oYW5kbGVPdXRzaWRlQ2xpY2suYmluZCh0aGlzKSksIGMub2ZmKGRvY3VtZW50LCBcImtleWRvd25cIiwgdGhpcy5faGFuZGxlRXNjYXBlS2V5LmJpbmQodGhpcykpO1xuICAgIH1cbiAgfVxuICBfaGFuZGxlUG9wY29uZmlybVRyYW5zaXRpb25FbmQodCkge1xuICAgIGlmICh0LnRhcmdldCAhPT0gdGhpcy5wb3Bjb25maXJtQm9keSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBlID0gZC5maW5kT25lKFxuICAgICAgYFske3ZvfV1gXG4gICAgKTtcbiAgICBjLm9mZih0aGlzLnBvcGNvbmZpcm1Cb2R5LCBcInRyYW5zaXRpb25lbmRcIiksIHRoaXMuX2lzT3BlbiAmJiB0ICYmIHQucHJvcGVydHlOYW1lID09PSBcIm9wYWNpdHlcIiAmJiAodGhpcy5fcG9wcGVyLmRlc3Ryb3koKSwgZSAmJiBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGUpLCB0aGlzLl9pc09wZW4gPSAhMSk7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfZ2V0UG9wb3ZlclRlbXBsYXRlKCkge1xuICAgIGNvbnN0IHQgPSAkKFwiZGl2XCIpLCBlID0gdGhpcy5fZ2V0UG9wY29uZmlybVRlbXBsYXRlKCk7XG4gICAgcmV0dXJuIHQuc2V0QXR0cmlidXRlKHZvLCBcIlwiKSwgaC5hZGRDbGFzcyh0LCB0aGlzLl9jbGFzc2VzLnBvcG92ZXIpLCB0LmlkID0gdGhpcy5fdWlkLCB0LmlubmVySFRNTCA9IGUsIHQ7XG4gIH1cbiAgX2dldE1vZGFsVGVtcGxhdGUoKSB7XG4gICAgY29uc3QgdCA9ICQoXCJkaXZcIiksIGUgPSB0aGlzLl9nZXRQb3Bjb25maXJtVGVtcGxhdGUoKTtcbiAgICByZXR1cm4gdC5zZXRBdHRyaWJ1dGUoaEUsIFwiXCIpLCBoLmFkZENsYXNzKHQsIGAke3RoaXMuX2NsYXNzZXMubW9kYWx9YCksIHQuaWQgPSB0aGlzLl91aWQsIHQuaW5uZXJIVE1MID0gZSwgdDtcbiAgfVxuICBfZ2V0UG9wY29uZmlybVRlbXBsYXRlKCkge1xuICAgIHJldHVybiBgPGRpdiBkYXRhLXRlLXBvcGNvbmZpcm0tYm9keSBjbGFzcz1cIiR7dGhpcy5fY2xhc3Nlcy5ib2R5fVwiPlxuICAgICAgPHAgY2xhc3M9XCIke3RoaXMuX2NsYXNzZXMubWVzc2FnZX1cIj5cbiAgICAgICR7dGhpcy5fb3B0aW9ucy5wb3Bjb25maXJtSWNvblRlbXBsYXRlID8gYDxzcGFuIGNsYXNzPVwiJHt0aGlzLl9jbGFzc2VzLmljb259XCI+JHt0aGlzLl9vcHRpb25zLnBvcGNvbmZpcm1JY29uVGVtcGxhdGV9PC9zcGFuPmAgOiBcIlwifVxuICAgICAgPHNwYW4gY2xhc3M9XCIke3RoaXMuX2NsYXNzZXMubWVzc2FnZVRleHR9XCI+JHt0aGlzLl9vcHRpb25zLm1lc3NhZ2V9PC9zcGFuPlxuICAgICAgPC9wPlxuICAgICAgPGRpdiBjbGFzcz1cIiR7dGhpcy5fY2xhc3Nlcy5idG5zQ29udGFpbmVyfVwiPlxuICAgICAgJHt0aGlzLl9vcHRpb25zLmNhbmNlbFRleHQgPyBgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgZGF0YS10ZS1yaXBwbGUtaW5pdCBkYXRhLXRlLXJpcHBsZS1jb2xvcj1cImxpZ2h0XCIgaWQ9XCJwb3Bjb25maXJtLWJ1dHRvbi1jYW5jZWxcIiBhcmlhLWxhYmVsPVwiJHt0aGlzLl9vcHRpb25zLmNhbmNlbExhYmVsfVwiXG4gICAgICAgIGNsYXNzPVwiJHt0aGlzLl9jbGFzc2VzLmJ0bkNhbmNlbH1cIj4ke3RoaXMuX29wdGlvbnMuY2FuY2VsVGV4dH08L2J1dHRvbj5gIDogXCJcIn1cbiAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGRhdGEtdGUtcmlwcGxlLWluaXQgZGF0YS10ZS1yaXBwbGUtY29sb3I9XCJsaWdodFwiIGlkPVwicG9wY29uZmlybS1idXR0b24tY29uZmlybVwiXG4gICAgICBhcmlhLWxhYmVsPVwiJHt0aGlzLl9vcHRpb25zLmNvbmZpcm1MYWJlbH1cIlxuICAgICAgY2xhc3M9XCIke3RoaXMuX2NsYXNzZXMuYnRuQ29uZmlybX1cIj4ke3RoaXMuX29wdGlvbnMub2tUZXh0ID8gdGhpcy5fb3B0aW9ucy5va1RleHQgOiBcIk9rXCJ9PC9idXR0b24+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5gO1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4udUUsXG4gICAgICAuLi5oLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgLi4udFxuICAgIH0sIEQoYm8sIHQsIGRFKSwgdDtcbiAgfVxuICBfZ2V0Q2xhc3Nlcyh0KSB7XG4gICAgY29uc3QgZSA9IGguZ2V0RGF0YUNsYXNzQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLl9FLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBEKGJvLCB0LCBwRSksIHQ7XG4gIH1cbiAgX29wZW5Qb3BvdmVyKHQpIHtcbiAgICB0aGlzLl9wb3BwZXIgPSBDZSh0aGlzLl9lbGVtZW50LCB0LCB7XG4gICAgICBwbGFjZW1lbnQ6IHRoaXMuX3RyYW5zbGF0ZVBvc2l0aW9uVmFsdWUoKSxcbiAgICAgIG1vZGlmaWVyczogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJvZmZzZXRcIixcbiAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBvZmZzZXQ6IFswLCA1XVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0pLCBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHQpLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGguYWRkQ2xhc3MoXG4gICAgICAgIHRoaXMucG9wY29uZmlybUJvZHksXG4gICAgICAgIGAke3RoaXMuX2NsYXNzZXMuZmFkZX0gb3BhY2l0eS0xMDBgXG4gICAgICApLCB0aGlzLl9pc09wZW4gPSAhMDtcbiAgICB9LCAwKTtcbiAgfVxuICBfb3Blbk1vZGFsKHQpIHtcbiAgICBjb25zdCBlID0gJChcImRpdlwiKTtcbiAgICBlLnNldEF0dHJpYnV0ZShObCwgXCJcIiksIGguYWRkQ2xhc3MoZSwgdGhpcy5fY2xhc3Nlcy5iYWNrZHJvcCksIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZSksIGUuYXBwZW5kQ2hpbGQodCksIGguYWRkQ2xhc3ModGhpcy5wb3Bjb25maXJtQm9keSwgXCJvcGFjaXR5LTEwMFwiKSwgdGhpcy5faXNPcGVuID0gITA7XG4gIH1cbiAgX2hhbmRsZUNhbmNlbEJ1dHRvbkNsaWNrKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICB0aGlzLl9jYW5jZWxCdXR0b24gPSBkLmZpbmRPbmUoXG4gICAgICBcIiNwb3Bjb25maXJtLWJ1dHRvbi1jYW5jZWxcIixcbiAgICAgIHRcbiAgICApLCBaZS5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMuX2NhbmNlbEJ1dHRvbiwgeyByaXBwbGVDb2xvcjogXCJsaWdodFwiIH0pLCB0aGlzLl9jYW5jZWxCdXR0b24gIT09IG51bGwgJiYgYy5vbih0aGlzLl9jYW5jZWxCdXR0b24sIFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5jbG9zZSgpLCBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgYUUpO1xuICAgIH0pO1xuICB9XG4gIF9oYW5kbGVDb25maXJtQnV0dG9uQ2xpY2soKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuY29udGFpbmVyO1xuICAgIHRoaXMuX2NvbmZpcm1CdXR0b24gPSBkLmZpbmRPbmUoXG4gICAgICBcIiNwb3Bjb25maXJtLWJ1dHRvbi1jb25maXJtXCIsXG4gICAgICB0XG4gICAgKSwgWmUuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLl9jb25maXJtQnV0dG9uLCB7IHJpcHBsZUNvbG9yOiBcImxpZ2h0XCIgfSksIGMub24odGhpcy5fY29uZmlybUJ1dHRvbiwgXCJjbGlja1wiLCAoKSA9PiB7XG4gICAgICB0aGlzLmNsb3NlKCksIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBsRSk7XG4gICAgfSk7XG4gIH1cbiAgX2xpc3RlblRvRXNjYXBlS2V5KCkge1xuICAgIGMub24oZG9jdW1lbnQsIFwia2V5ZG93blwiLCB0aGlzLl9oYW5kbGVFc2NhcGVLZXkuYmluZCh0aGlzKSk7XG4gIH1cbiAgX2hhbmRsZUVzY2FwZUtleSh0KSB7XG4gICAgdC5rZXlDb2RlID09PSBGaSAmJiB0aGlzLmNsb3NlKCk7XG4gIH1cbiAgX2xpc3RlblRvT3V0c2lkZUNsaWNrKCkge1xuICAgIGMub24oZG9jdW1lbnQsIFwiY2xpY2tcIiwgdGhpcy5faGFuZGxlT3V0c2lkZUNsaWNrLmJpbmQodGhpcykpO1xuICB9XG4gIF9oYW5kbGVPdXRzaWRlQ2xpY2sodCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLmNvbnRhaW5lciwgaSA9IHQudGFyZ2V0ID09PSBlLCBuID0gZSAmJiBlLmNvbnRhaW5zKHQudGFyZ2V0KSwgbyA9IHQudGFyZ2V0ID09PSB0aGlzLl9lbGVtZW50LCByID0gdGhpcy5fZWxlbWVudCAmJiB0aGlzLl9lbGVtZW50LmNvbnRhaW5zKHQudGFyZ2V0KTtcbiAgICAhaSAmJiAhbiAmJiAhbyAmJiAhciAmJiB0aGlzLmNsb3NlKCk7XG4gIH1cbiAgX3RyYW5zbGF0ZVBvc2l0aW9uVmFsdWUoKSB7XG4gICAgc3dpdGNoICh0aGlzLl9vcHRpb25zLnBvc2l0aW9uKSB7XG4gICAgICBjYXNlIFwidG9wIGxlZnRcIjpcbiAgICAgICAgcmV0dXJuIFwidG9wLWVuZFwiO1xuICAgICAgY2FzZSBcInRvcFwiOlxuICAgICAgICByZXR1cm4gXCJ0b3BcIjtcbiAgICAgIGNhc2UgXCJ0b3AgcmlnaHRcIjpcbiAgICAgICAgcmV0dXJuIFwidG9wLXN0YXJ0XCI7XG4gICAgICBjYXNlIFwiYm90dG9tIGxlZnRcIjpcbiAgICAgICAgcmV0dXJuIFwiYm90dG9tLWVuZFwiO1xuICAgICAgY2FzZSBcImJvdHRvbVwiOlxuICAgICAgICByZXR1cm4gXCJib3R0b21cIjtcbiAgICAgIGNhc2UgXCJib3R0b20gcmlnaHRcIjpcbiAgICAgICAgcmV0dXJuIFwiYm90dG9tLXN0YXJ0XCI7XG4gICAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgICByZXR1cm4gXCJsZWZ0XCI7XG4gICAgICBjYXNlIFwibGVmdCB0b3BcIjpcbiAgICAgICAgcmV0dXJuIFwibGVmdC1lbmRcIjtcbiAgICAgIGNhc2UgXCJsZWZ0IGJvdHRvbVwiOlxuICAgICAgICByZXR1cm4gXCJsZWZ0LXN0YXJ0XCI7XG4gICAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgICAgcmV0dXJuIFwicmlnaHRcIjtcbiAgICAgIGNhc2UgXCJyaWdodCB0b3BcIjpcbiAgICAgICAgcmV0dXJuIFwicmlnaHQtZW5kXCI7XG4gICAgICBjYXNlIFwicmlnaHQgYm90dG9tXCI6XG4gICAgICAgIHJldHVybiBcInJpZ2h0LXN0YXJ0XCI7XG4gICAgICBjYXNlIHZvaWQgMDpcbiAgICAgICAgcmV0dXJuIFwiYm90dG9tXCI7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gXCJib3R0b21cIjtcbiAgICB9XG4gIH1cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCwgZSkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBpID0geS5nZXREYXRhKHRoaXMsIENpKSwgbiA9IHR5cGVvZiB0ID09IFwib2JqZWN0XCIgJiYgdDtcbiAgICAgIGlmICghKCFpICYmIC9kaXNwb3NlLy50ZXN0KHQpKSkge1xuICAgICAgICBpZiAoIWkpXG4gICAgICAgICAgcmV0dXJuIG5ldyB2aCh0aGlzLCBuKTtcbiAgICAgICAgaWYgKHR5cGVvZiB0ID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGlbdF0gPiBcInVcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7dH1cImApO1xuICAgICAgICAgIGlbdF0oZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZ2V0SW5zdGFuY2UodCkge1xuICAgIHJldHVybiB5LmdldERhdGEodCwgQ2kpO1xuICB9XG4gIHN0YXRpYyBnZXRPckNyZWF0ZUluc3RhbmNlKHQsIGUgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKHQpIHx8IG5ldyB0aGlzKHQsIHR5cGVvZiBlID09IFwib2JqZWN0XCIgPyBlIDogbnVsbCk7XG4gIH1cbn1cbmNvbnN0IFRvID0gXCJsaWdodGJveFwiLCBBaSA9IFwidGUubGlnaHRib3hcIiwgZkUgPSBgLiR7QWl9YCwgbUUgPSBcIi5kYXRhLWFwaVwiLCBJZSA9IGBjbGljayR7ZkV9JHttRX1gLCBUaCA9IFwiW2RhdGEtdGUtbGlnaHRib3gtaW5pdF1cIiwgZ0UgPSBgJHtUaH0gaW1nOm5vdChbZGF0YS10ZS1saWdodGJveC1kaXNhYmxlZF0pYCwgTWwgPSBcImRhdGEtdGUtbGlnaHRib3gtY2FwdGlvblwiLCBiRSA9IFwiZGF0YS10ZS1saWdodGJveC1kaXNhYmxlZFwiLCBJdCA9IFwiZGF0YS10ZS1saWdodGJveC1hY3RpdmVcIiwgdkUgPSBgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cImN1cnJlbnRDb2xvclwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIzXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgY2xhc3M9XCJ3LTQgaC00XCI+XG4gIDxwYXRoIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIGQ9XCJNMTkuNSAxMmgtMTVtMCAwbDYuNzUgNi43NU00LjUgMTJsNi43NS02Ljc1XCIgLz5cbjwvc3ZnPlxuYCwgVEUgPSBgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cImN1cnJlbnRDb2xvclwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIzXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgY2xhc3M9XCJ3LTQgaC00XCI+XG4gIDxwYXRoIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIGQ9XCJNNC41IDEyaDE1bTAgMGwtNi43NS02Ljc1TTE5LjUgMTJsLTYuNzUgNi43NVwiIC8+XG48L3N2Zz5cbmAsIEVFID0gYDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjNcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBjbGFzcz1cInctNCBoLTRcIj5cbiAgPHBhdGggc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgZD1cIk0zLjc1IDMuNzV2NC41bTAtNC41aDQuNW0tNC41IDBMOSA5TTMuNzUgMjAuMjV2LTQuNW0wIDQuNWg0LjVtLTQuNSAwTDkgMTVNMjAuMjUgMy43NWgtNC41bTQuNSAwdjQuNW0wLTQuNUwxNSA5bTUuMjUgMTEuMjVoLTQuNW00LjUgMHYtNC41bTAgNC41TDE1IDE1XCIgLz5cbjwvc3ZnPlxuYCwgQ0UgPSBgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiM1wiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGNsYXNzPVwidy00IGgtNFwiPlxuICA8cGF0aCBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBkPVwiTTkgOVY0LjVNOSA5SDQuNU05IDlMMy43NSAzLjc1TTkgMTV2NC41TTkgMTVINC41TTkgMTVsLTUuMjUgNS4yNU0xNSA5aDQuNU0xNSA5VjQuNU0xNSA5bDUuMjUtNS4yNU0xNSAxNWg0LjVNMTUgMTV2NC41bTAtNC41bDUuMjUgNS4yNVwiIC8+XG48L3N2Zz5cbmAsIEFFID0gYDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjNcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBjbGFzcz1cInctNCBoLTRcIj5cbiAgPHBhdGggc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgZD1cIk0yMSAyMWwtNS4xOTctNS4xOTdtMCAwQTcuNSA3LjUgMCAxMDUuMTk2IDUuMTk2YTcuNSA3LjUgMCAwMDEwLjYwNyAxMC42MDd6TTEwLjUgNy41djZtMy0zaC02XCIgLz5cbjwvc3ZnPlxuYCwgeUUgPSBgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiM1wiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGNsYXNzPVwidy00IGgtNFwiPlxuPHBhdGggc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgZD1cIk0yMSAyMWwtNS4xOTctNS4xOTdtMCAwQTcuNSA3LjUgMCAxMDUuMTk2IDUuMTk2YTcuNSA3LjUgMCAwMDEwLjYwNyAxMC42MDd6TTEzLjUgMTAuNWgtNlwiIC8+XG48L3N2Zz5cbmAsIHdFID0gYDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjNcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBjbGFzcz1cInctNCBoLTRcIj5cbiAgPHBhdGggc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgZD1cIk02IDE4TDE4IDZNNiA2bDEyIDEyXCIgLz5cbjwvc3ZnPlxuYCwga0UgPSB7XG4gIGNvbnRhaW5lcjogXCJzdHJpbmdcIixcbiAgem9vbUxldmVsOiBcIihudW1iZXJ8c3RyaW5nKVwiLFxuICBwcmV2SWNvblRlbXBsYXRlOiBcInN0cmluZ1wiLFxuICBuZXh0SWNvblRlbXBsYXRlOiBcInN0cmluZ1wiLFxuICBzaG93RnVsbHNjcmVlbkljb25UZW1wbGF0ZTogXCJzdHJpbmdcIixcbiAgaGlkZUZ1bGxzY3JlZW5JY29uVGVtcGxhdGU6IFwic3RyaW5nXCIsXG4gIHpvb21Jbkljb25UZW1wbGF0ZTogXCJzdHJpbmdcIixcbiAgY2xvc2VJY29uVGVtcGxhdGU6IFwic3RyaW5nXCIsXG4gIHpvb21PdXRJY29uVGVtcGxhdGU6IFwic3RyaW5nXCIsXG4gIHNwaW5uZXJDb250ZW50OiBcInN0cmluZ1wiXG59LCB4RSA9IHtcbiAgY29udGFpbmVyOiBcImJvZHlcIixcbiAgem9vbUxldmVsOiAxLFxuICBwcmV2SWNvblRlbXBsYXRlOiB2RSxcbiAgbmV4dEljb25UZW1wbGF0ZTogVEUsXG4gIHNob3dGdWxsc2NyZWVuSWNvblRlbXBsYXRlOiBFRSxcbiAgaGlkZUZ1bGxzY3JlZW5JY29uVGVtcGxhdGU6IENFLFxuICB6b29tSW5JY29uVGVtcGxhdGU6IEFFLFxuICB6b29tT3V0SWNvblRlbXBsYXRlOiB5RSxcbiAgY2xvc2VJY29uVGVtcGxhdGU6IHdFLFxuICBzcGlubmVyQ29udGVudDogXCJMb2FkaW5nLi4uXCJcbn0sIE9FID0ge1xuICBjYXB0aW9uOiBcInRleHQtd2hpdGUgdGV4dC1lbGxpcHNpcyBvdmVyZmxvdy1oaWRkZW4gd2hpdGVzcGFjZS1ub3dyYXAgbXgtWzEwcHhdIHRleHQtY2VudGVyXCIsXG4gIGNhcHRpb25XcmFwcGVyOiBcImZpeGVkIGxlZnQtMCBib3R0b20tMCB3LWZ1bGwgaC1bNTBweF0gZmxleCBqdXN0aWZ5LWNlbnRlciBpdGVtcy1jZW50ZXJcIixcbiAgY2xvc2VCdG46IFwiYm9yZGVyLW5vbmUgYmctdHJhbnNwYXJlbnQgdy1bNTBweF0gaC1bNTBweF0gcHgtNCB0ZXh0LVsjYjNiM2IzXSB0cmFuc2l0aW9uLWNvbG9ycyBkdXJhdGlvbi0yMDAgZWFzZS1pbi1vdXQgaG92ZXI6dGV4dC13aGl0ZSBmb2N1czp0ZXh0LXdoaXRlIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIG91dGxpbmUtbm9uZVwiLFxuICBmdWxsc2NyZWVuQnRuOiBcImJvcmRlci1ub25lIGJnLXRyYW5zcGFyZW50IHctWzUwcHhdIGgtWzUwcHhdIHB4LTQgdGV4dC1bI2IzYjNiM10gdHJhbnNpdGlvbi1jb2xvcnMgZHVyYXRpb24tMjAwIGVhc2UtaW4tb3V0IGhvdmVyOnRleHQtd2hpdGUgZm9jdXM6dGV4dC13aGl0ZSBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBvdXRsaW5lLW5vbmVcIixcbiAgZ2FsbGVyeTogXCJpbnZpc2libGUgZml4ZWQgbGVmdC0wIHRvcC0wIHctZnVsbCBoLWZ1bGwgei1bMTEwMF0gcG9pbnRlci1ldmVudHMtbm9uZSBvcGFjaXR5LTAgYmctWyMwMDAwMDBlNl0gdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tWzQwMG1zXSBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZVwiLFxuICBnYWxsZXJ5Q29udGVudDogXCJmaXhlZCB0b3AtWzUwcHhdIGxlZnQtWzUwcHhdIHctW2NhbGMoMTAwJS0xMDBweCldIGgtW2NhbGMoMTAwJS0xMDBweCldXCIsXG4gIGdhbGxlcnlDb3VudGVyOiBcImZsZXgganVzdGlmeS1jZW50ZXIgaXRlbXMtY2VudGVyIHB4LVsxMHB4XSBtYi0wIGgtZnVsbCB0ZXh0LVsjYjNiM2IzXVwiLFxuICBpbWc6IFwiYWJzb2x1dGUgbGVmdC0wIHRvcC0wIHctZnVsbCBtYXgtaC1mdWxsIGgtYXV0byBjdXJzb3ItcG9pbnRlciBwb2ludGVyLWV2ZW50cy1hdXRvXCIsXG4gIGltZ1dyYXBwZXI6IFwiYWJzb2x1dGUgdG9wLTAgbGVmdC0wIHctZnVsbCBoLWZ1bGwgb3BhY2l0eS0wIHRyYW5zZm9ybSBzY2FsZS1bMC4yNV0gdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tWzQwMG1zXSBlYXNlLW91dCBwb2ludGVyLWV2ZW50cy1ub25lIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIG1vdGlvbi1yZWR1Y2U6dHJhbnNmb3JtLW5vbmVcIixcbiAgbGVmdFRvb2xzOiBcImZsb2F0LWxlZnQgaC1mdWxsXCIsXG4gIGxvYWRlcjogXCJmaXhlZCBsZWZ0LTAgdG9wLTAgei1bMl0gdy1mdWxsIGgtZnVsbCB0ZXh0LW5ldXRyYWwtNTAgb3BhY2l0eS0xIGZsZXgganVzdGlmeS1jZW50ZXIgaXRlbXMtY2VudGVyIHBvaW50ZXItZXZlbnRzLW5vbmUgdHJhbnNpdGlvbi1vcGFjaXR5IGR1cmF0aW9uLVsxMDAwbXNdIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lXCIsXG4gIG5leHRCdG46IFwiYm9yZGVyLW5vbmUgYmctdHJhbnNwYXJlbnQgdy1mdWxsIGgtWzUwcHhdIGZsZXgganVzdGlmeS1jZW50ZXIgaXRlbXMtY2VudGVyIHRleHQtWyNiM2IzYjNdIHRyYW5zaXRpb24tY29sb3JzIGR1cmF0aW9uLTIwMCBlYXNlLWluLW91dCBob3Zlcjp0ZXh0LXdoaXRlIGZvY3VzOnRleHQtd2hpdGUgbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmUgb3V0bGluZS1ub25lXCIsXG4gIG5leHRCdG5XcmFwcGVyOiBcImZpeGVkIHJpZ2h0LTAgdG9wLTAgdy1bNTBweF0gaC1mdWxsIGZsZXgganVzdGlmeS1jZW50ZXIgaXRlbXMtY2VudGVyIHRyYW5zaXRpb24tb3BhY2l0eSBkdXJhdGlvbi1bNDAwbXNdIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lXCIsXG4gIHByZXZCdG46IFwiYm9yZGVyLW5vbmUgYmctdHJhbnNwYXJlbnQgdy1mdWxsIGgtWzUwcHhdIGZsZXgganVzdGlmeS1jZW50ZXIgaXRlbXMtY2VudGVyIHRleHQtWyNiM2IzYjNdIHRyYW5zaXRpb24tY29sb3JzIGR1cmF0aW9uLTIwMCBlYXNlLWluLW91dCBob3Zlcjp0ZXh0LXdoaXRlIGZvY3VzOnRleHQtd2hpdGUgbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmUgb3V0bGluZS1ub25lXCIsXG4gIHByZXZCdG5XcmFwcGVyOiBcImZpeGVkIGxlZnQtMCB0b3AtMCB3LVs1MHB4XSBoLWZ1bGwgZmxleCBqdXN0aWZ5LWNlbnRlciBpdGVtcy1jZW50ZXIgdHJhbnNpdGlvbi1vcGFjaXR5IGR1cmF0aW9uLVs0MDBtc10gbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmVcIixcbiAgcmlnaHRUb29sczogXCJmbG9hdC1yaWdodFwiLFxuICBzcGlubmVyOiBcImlubGluZS1ibG9jayBoLTggdy04IGFuaW1hdGUtW3NwaW5uZXItZ3Jvd18wLjc1c19saW5lYXJfaW5maW5pdGVdIHJvdW5kZWQtZnVsbCBiZy1jdXJyZW50IGFsaWduLVstMC4xMjVlbV0gbW90aW9uLXJlZHVjZTphbmltYXRlLVtzcGlubmVyLWdyb3dfMS41c19saW5lYXJfaW5maW5pdGVdXCIsXG4gIHNwaW5uZXJDb250ZW50OiBcIiFhYnNvbHV0ZSAhLW0tcHggIWgtcHggIXctcHggIW92ZXJmbG93LWhpZGRlbiAhd2hpdGVzcGFjZS1ub3dyYXAgIWJvcmRlci0wICFwLTAgIVtjbGlwOnJlY3QoMCwwLDAsMCldXCIsXG4gIHRvb2xiYXI6IFwiYWJzb2x1dGUgdG9wLTAgbGVmdC0wIHctZnVsbCBoLVs1MHB4XSB6LTIwIHRyYW5zaXRpb24tb3BhY2l0eSBkdXJhdGlvbi1bNDAwbXNdIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lXCIsXG4gIHZlcnRpY2FsOiBcImgtZnVsbCBtYXgtaC1mdWxsIHctYXV0b1wiLFxuICB6b29tQnRuOiBcImJvcmRlci1ub25lIGJnLXRyYW5zcGFyZW50IHctWzUwcHhdIGgtWzUwcHhdIHB4LTQgdGV4dC1bI2IzYjNiM10gdHJhbnNpdGlvbi1jb2xvcnMgZHVyYXRpb24tMjAwIGVhc2UtaW4tb3V0IGhvdmVyOnRleHQtd2hpdGUgZm9jdXM6dGV4dC13aGl0ZSBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBvdXRsaW5lLW5vbmVcIlxufSwgU0UgPSB7XG4gIGNhcHRpb246IFwic3RyaW5nXCIsXG4gIGNhcHRpb25XcmFwcGVyOiBcInN0cmluZ1wiLFxuICBjbG9zZUJ0bjogXCJzdHJpbmdcIixcbiAgZnVsbHNjcmVlbkJ0bjogXCJzdHJpbmdcIixcbiAgZ2FsbGVyeTogXCJzdHJpbmdcIixcbiAgZ2FsbGVyeUNvbnRlbnQ6IFwic3RyaW5nXCIsXG4gIGdhbGxlcnlDb3VudGVyOiBcInN0cmluZ1wiLFxuICBpbWc6IFwic3RyaW5nXCIsXG4gIGltZ1dyYXBwZXI6IFwic3RyaW5nXCIsXG4gIGxlZnRUb29sczogXCJzdHJpbmdcIixcbiAgbG9hZGVyOiBcInN0cmluZ1wiLFxuICBuZXh0QnRuOiBcInN0cmluZ1wiLFxuICBuZXh0QnRuV3JhcHBlcjogXCJzdHJpbmdcIixcbiAgcHJldkJ0bjogXCJzdHJpbmdcIixcbiAgcHJldkJ0bldyYXBwZXI6IFwic3RyaW5nXCIsXG4gIHJpZ2h0VG9vbHM6IFwic3RyaW5nXCIsXG4gIHNwaW5uZXI6IFwic3RyaW5nXCIsXG4gIHNwaW5uZXJDb250ZW50OiBcInN0cmluZ1wiLFxuICB0b29sYmFyOiBcInN0cmluZ1wiLFxuICB2ZXJ0aWNhbDogXCJzdHJpbmdcIixcbiAgem9vbUJ0bjogXCJzdHJpbmdcIlxufTtcbmNsYXNzIFpzIHtcbiAgY29uc3RydWN0b3IodCwgZSA9IHt9LCBpKSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX29wdGlvbnMgPSBlLCB0aGlzLl9jbGFzc2VzID0gdGhpcy5fZ2V0Q2xhc3NlcyhpKSwgdGhpcy5fZ2V0Q29udGFpbmVyKCksIHRoaXMuX2lkID0gYGxpZ2h0Ym94LSR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDkpfWAsIHRoaXMuX2FjdGl2ZUltZyA9IDAsIHRoaXMuX2ltYWdlcyA9IFtdLCB0aGlzLl96b29tID0gMSwgdGhpcy5fZ2FsbGVyeSA9IG51bGwsIHRoaXMuX2dhbGxlcnlUb29sYmFyID0gbnVsbCwgdGhpcy5fZ2FsbGVyeUNvbnRlbnQgPSBudWxsLCB0aGlzLl9sb2FkZXIgPSBudWxsLCB0aGlzLl9pbWdDb3VudGVyID0gbnVsbCwgdGhpcy5fYW5pbWF0aW5nID0gITEsIHRoaXMuX2Z1bGxzY3JlZW4gPSAhMSwgdGhpcy5fem9vbUJ0biA9IG51bGwsIHRoaXMuX2Z1bGxzY3JlZW5CdG4gPSBudWxsLCB0aGlzLl90b29sc1RvZ2dsZVRpbWVyID0gMCwgdGhpcy5fbW91c2Vkb3duID0gITEsIHRoaXMuX21vdXNlZG93blBvc2l0aW9uWCA9IDAsIHRoaXMuX21vdXNlZG93blBvc2l0aW9uWSA9IDAsIHRoaXMuX29yaWdpbmFsUG9zaXRpb25YID0gMCwgdGhpcy5fb3JpZ2luYWxQb3NpdGlvblkgPSAwLCB0aGlzLl9wb3NpdGlvblggPSAwLCB0aGlzLl9wb3NpdGlvblkgPSAwLCB0aGlzLl96b29tVGltZXIgPSAwLCB0aGlzLl90YXBDb3VudGVyID0gMCwgdGhpcy5fdGFwVGltZSA9IDAsIHRoaXMuX3JpZ2h0QXJyb3cgPSBudWxsLCB0aGlzLl9sZWZ0QXJyb3dXcmFwcGVyID0gbnVsbCwgdGhpcy5fcmlnaHRBcnJvd1dyYXBwZXIgPSBudWxsLCB0aGlzLl9pbml0aWF0ZWQgPSAhMSwgdGhpcy5fbXVsdGl0b3VjaCA9ICExLCB0aGlzLl90b3VjaFpvb21Qb3NpdGlvbiA9IFtdLCB0aGlzLl9lbGVtZW50ICYmICh5LnNldERhdGEodCwgQWksIHRoaXMpLCB0aGlzLmluaXQoKSk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIFRvO1xuICB9XG4gIGdldCBhY3RpdmVJbWcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FjdGl2ZUltZztcbiAgfVxuICBnZXQgY3VycmVudEltZygpIHtcbiAgICByZXR1cm4gZC5maW5kT25lKFxuICAgICAgYFske0l0fV1gLFxuICAgICAgdGhpcy5fZ2FsbGVyeUNvbnRlbnRcbiAgICApO1xuICB9XG4gIGdldCBvcHRpb25zKCkge1xuICAgIGNvbnN0IHQgPSB7XG4gICAgICAuLi54RSxcbiAgICAgIC4uLmguZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCksXG4gICAgICAuLi50aGlzLl9vcHRpb25zXG4gICAgfTtcbiAgICByZXR1cm4gRChUbywgdCwga0UpLCB0O1xuICB9XG4gIC8vIFB1YmxpY1xuICBpbml0KCkge1xuICAgIHRoaXMuX2luaXRpYXRlZCB8fCAodGhpcy5fYXBwZW5kVGVtcGxhdGUoKSwgdGhpcy5faW5pdGlhdGVkID0gITApO1xuICB9XG4gIG9wZW4odCA9IDApIHtcbiAgICB0aGlzLl9nZXRJbWFnZXMoKSwgdGhpcy5fc2V0QWN0aXZlSW1nKHQpLCB0aGlzLl9zb3J0SW1hZ2VzKCksIHRoaXMuX3RyaWdnZXJFdmVudHMoXCJvcGVuXCIsIFwib3BlbmVkXCIpLCB0aGlzLl9sb2FkSW1hZ2VzKCkudGhlbigoZSkgPT4ge1xuICAgICAgdGhpcy5fcmVzaXplSW1hZ2VzKGUpLCB0aGlzLl90b2dnbGVUZW1wbGF0ZSgpLCB0aGlzLl9hZGRFdmVudHMoKSwgdGhpcy5fZm9jdXNGdWxsc2NyZWVuQnRuKCk7XG4gICAgfSk7XG4gIH1cbiAgY2xvc2UoKSB7XG4gICAgdGhpcy5yZXNldCgpLCB0aGlzLl9yZW1vdmVFdmVudHMoKSwgdGhpcy5fdG9nZ2xlVGVtcGxhdGUoKSwgdGhpcy5fdHJpZ2dlckV2ZW50cyhcImNsb3NlXCIsIFwiY2xvc2VkXCIpO1xuICB9XG4gIHNsaWRlKHQgPSBcInJpZ2h0XCIpIHtcbiAgICB0aGlzLl9hbmltYXRpbmcgPT09ICEwIHx8IHRoaXMuX2ltYWdlcy5sZW5ndGggPD0gMSB8fCAodGhpcy5fdHJpZ2dlckV2ZW50cyhcInNsaWRlXCIsIFwic2xpZGVkXCIpLCB0aGlzLl9iZWZvcmVTbGlkZUV2ZW50cygpLCB0ID09PSBcInJpZ2h0XCIgJiYgdGhpcy5fc2xpZGVIb3Jpem9udGFsbHkodCksIHQgPT09IFwibGVmdFwiICYmIHRoaXMuX3NsaWRlSG9yaXpvbnRhbGx5KHQpLCB0ID09PSBcImZpcnN0XCIgJiYgdGhpcy5fc2xpZGVUb1RhcmdldCh0KSwgdCA9PT0gXCJsYXN0XCIgJiYgdGhpcy5fc2xpZGVUb1RhcmdldCh0KSwgdGhpcy5fYWZ0ZXJTbGlkZUV2ZW50cygpKTtcbiAgfVxuICB6b29tSW4oKSB7XG4gICAgdGhpcy5fem9vbSA+PSAzIHx8ICh0aGlzLl90cmlnZ2VyRXZlbnRzKFwiem9vbUluXCIsIFwiem9vbWVkSW5cIiksIHRoaXMuX3pvb20gKz0gcGFyc2VGbG9hdCh0aGlzLm9wdGlvbnMuem9vbUxldmVsKSwgaC5zdHlsZSh0aGlzLmN1cnJlbnRJbWcucGFyZW50Tm9kZSwge1xuICAgICAgdHJhbnNmb3JtOiBgc2NhbGUoJHt0aGlzLl96b29tfSlgXG4gICAgfSksIHRoaXMuX3VwZGF0ZVpvb21CdG4oKSk7XG4gIH1cbiAgem9vbU91dCgpIHtcbiAgICB0aGlzLl96b29tIDw9IDEgfHwgKHRoaXMuX3RyaWdnZXJFdmVudHMoXCJ6b29tT3V0XCIsIFwiem9vbWVkT3V0XCIpLCB0aGlzLl96b29tIC09IHBhcnNlRmxvYXQodGhpcy5vcHRpb25zLnpvb21MZXZlbCksIGguc3R5bGUodGhpcy5jdXJyZW50SW1nLnBhcmVudE5vZGUsIHtcbiAgICAgIHRyYW5zZm9ybTogYHNjYWxlKCR7dGhpcy5fem9vbX0pYFxuICAgIH0pLCB0aGlzLl91cGRhdGVab29tQnRuKCksIHRoaXMuX3VwZGF0ZUltZ1Bvc2l0aW9uKCkpO1xuICB9XG4gIHRvZ2dsZUZ1bGxzY3JlZW4oKSB7XG4gICAgdGhpcy5fZnVsbHNjcmVlbiA9PT0gITEgPyAodGhpcy5fZnVsbHNjcmVlbkJ0bi5zZXRBdHRyaWJ1dGUoSXQsIFwiXCIpLCB0aGlzLl9mdWxsc2NyZWVuQnRuLmlubmVySFRNTCA9IHRoaXMub3B0aW9ucy5oaWRlRnVsbHNjcmVlbkljb25UZW1wbGF0ZSwgdGhpcy5fZ2FsbGVyeS5yZXF1ZXN0RnVsbHNjcmVlbiAmJiB0aGlzLl9nYWxsZXJ5LnJlcXVlc3RGdWxsc2NyZWVuKCksIHRoaXMuX2Z1bGxzY3JlZW4gPSAhMCkgOiAodGhpcy5fZnVsbHNjcmVlbkJ0bi5yZW1vdmVBdHRyaWJ1dGUoSXQpLCBkb2N1bWVudC5leGl0RnVsbHNjcmVlbiAmJiBkb2N1bWVudC5leGl0RnVsbHNjcmVlbigpLCB0aGlzLl9mdWxsc2NyZWVuID0gITEpO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMuX3Jlc3RvcmVEZWZhdWx0RnVsbHNjcmVlbigpLCB0aGlzLl9yZXN0b3JlRGVmYXVsdFBvc2l0aW9uKCksIHRoaXMuX3Jlc3RvcmVEZWZhdWx0Wm9vbSgpLCBjbGVhclRpbWVvdXQodGhpcy5fdG9vbHNUb2dnbGVUaW1lciksIGNsZWFyVGltZW91dCh0aGlzLl9kb3VibGVUYXBUaW1lcik7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICBjLm9mZihcbiAgICAgIGRvY3VtZW50LFxuICAgICAgSWUsXG4gICAgICBnRSxcbiAgICAgIHRoaXMudG9nZ2xlXG4gICAgKSwgdGhpcy5fZ2FsbGVyeUNvbnRlbnQgJiYgdGhpcy5fcmVtb3ZlRXZlbnRzKCksIHRoaXMuX2dhbGxlcnkgJiYgdGhpcy5fZ2FsbGVyeS5yZW1vdmUoKSwgeS5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIEFpKSwgdGhpcy5fZWxlbWVudCA9IG51bGw7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfZ2V0Q2xhc3Nlcyh0KSB7XG4gICAgY29uc3QgZSA9IGguZ2V0RGF0YUNsYXNzQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLk9FLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBEKFRvLCB0LCBTRSksIHQ7XG4gIH1cbiAgX2dldEltYWdlcygpIHtcbiAgICBjb25zdCBlID0gZC5maW5kKFwiaW1nXCIsIHRoaXMuX2VsZW1lbnQpLmZpbHRlcihcbiAgICAgIChpKSA9PiAhaS5oYXNBdHRyaWJ1dGUoYkUpXG4gICAgKTtcbiAgICB0aGlzLl9pbWFnZXMgPSBlO1xuICB9XG4gIF9nZXRDb250YWluZXIoKSB7XG4gICAgdGhpcy5fY29udGFpbmVyID0gZC5maW5kT25lKHRoaXMub3B0aW9ucy5jb250YWluZXIpO1xuICB9XG4gIF9zZXRBY3RpdmVJbWcodCkge1xuICAgIHRoaXMuX2FjdGl2ZUltZyA9IHR5cGVvZiB0ID09IFwibnVtYmVyXCIgPyB0IDogdGhpcy5faW1hZ2VzLmluZGV4T2YodC50YXJnZXQpO1xuICB9XG4gIF9hcHBlbmRUZW1wbGF0ZSgpIHtcbiAgICB0aGlzLl9nYWxsZXJ5ID0gJChcImRpdlwiKSwgaC5hZGRDbGFzcyh0aGlzLl9nYWxsZXJ5LCBgJHt0aGlzLl9jbGFzc2VzLmdhbGxlcnl9YCksIHRoaXMuX2VsZW1lbnQuZGF0YXNldC5pZCA9IHRoaXMuX2lkLCB0aGlzLl9nYWxsZXJ5LmlkID0gdGhpcy5faWQsIHRoaXMuX2FwcGVuZExvYWRlcigpLCB0aGlzLl9hcHBlbmRUb29sYmFyKCksIHRoaXMuX2FwcGVuZENvbnRlbnQoKSwgdGhpcy5fYXBwZW5kQXJyb3dzKCksIHRoaXMuX2FwcGVuZENhcHRpb24oKSwgdGhpcy5fY29udGFpbmVyLmFwcGVuZCh0aGlzLl9nYWxsZXJ5KTtcbiAgfVxuICBfYXBwZW5kVG9vbGJhcigpIHtcbiAgICB0aGlzLl9nYWxsZXJ5VG9vbGJhciA9ICQoXCJkaXZcIiksIHRoaXMuX2ltZ0NvdW50ZXIgPSAkKFwicFwiKSwgdGhpcy5fZnVsbHNjcmVlbkJ0biA9ICQoXCJidXR0b25cIiksIHRoaXMuX3pvb21CdG4gPSAkKFwiYnV0dG9uXCIpO1xuICAgIGNvbnN0IHQgPSAkKFwiYnV0dG9uXCIpLCBlID0gJChcImRpdlwiKSwgaSA9ICQoXCJkaXZcIik7XG4gICAgaC5hZGRDbGFzcyh0aGlzLl9nYWxsZXJ5VG9vbGJhciwgYCR7dGhpcy5fY2xhc3Nlcy50b29sYmFyfWApLCBoLmFkZENsYXNzKHRoaXMuX2ltZ0NvdW50ZXIsIGAke3RoaXMuX2NsYXNzZXMuZ2FsbGVyeUNvdW50ZXJ9YCksIGguYWRkQ2xhc3ModGhpcy5fZnVsbHNjcmVlbkJ0biwgYCR7dGhpcy5fY2xhc3Nlcy5mdWxsc2NyZWVuQnRufWApLCBoLmFkZENsYXNzKHRoaXMuX3pvb21CdG4sIGAke3RoaXMuX2NsYXNzZXMuem9vbUluQnRufWApLCBoLmFkZENsYXNzKHRoaXMuX3pvb21CdG4sIHRoaXMuX2NsYXNzZXMuem9vbUJ0biksIGguYWRkQ2xhc3MoZSwgYCR7dGhpcy5fY2xhc3Nlcy5sZWZ0VG9vbHN9YCksIGguYWRkQ2xhc3MoaSwgYCR7dGhpcy5fY2xhc3Nlcy5yaWdodFRvb2xzfWApLCBoLmFkZENsYXNzKHQsIGAke3RoaXMuX2NsYXNzZXMuY2xvc2VCdG59YCksIHRoaXMuX2Z1bGxzY3JlZW5CdG4uaW5uZXJIVE1MID0gdGhpcy5vcHRpb25zLnNob3dGdWxsc2NyZWVuSWNvblRlbXBsYXRlLCB0LmlubmVySFRNTCA9IHRoaXMub3B0aW9ucy5jbG9zZUljb25UZW1wbGF0ZSwgdGhpcy5fem9vbUJ0bi5pbm5lckhUTUwgPSB0aGlzLm9wdGlvbnMuem9vbUluSWNvblRlbXBsYXRlLCB0aGlzLl9mdWxsc2NyZWVuQnRuLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgXCJUb2dnbGUgZnVsbHNjcmVlblwiKSwgdGhpcy5fem9vbUJ0bi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIFwiWm9vbSBpblwiKSwgdC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIFwiQ2xvc2VcIiksIGMub24oXG4gICAgICB0aGlzLl9mdWxsc2NyZWVuQnRuLFxuICAgICAgSWUsXG4gICAgICAoKSA9PiB0aGlzLnRvZ2dsZUZ1bGxzY3JlZW4oKVxuICAgICksIGMub24oXG4gICAgICB0aGlzLl96b29tQnRuLFxuICAgICAgSWUsXG4gICAgICAoKSA9PiB0aGlzLl90b2dnbGVab29tKClcbiAgICApLCBjLm9uKHQsIEllLCAoKSA9PiB0aGlzLmNsb3NlKCkpLCBlLmFwcGVuZCh0aGlzLl9pbWdDb3VudGVyKSwgaS5hcHBlbmQodGhpcy5fZnVsbHNjcmVlbkJ0biksIGkuYXBwZW5kKHRoaXMuX3pvb21CdG4pLCBpLmFwcGVuZCh0KSwgdGhpcy5fZ2FsbGVyeVRvb2xiYXIuYXBwZW5kKGUpLCB0aGlzLl9nYWxsZXJ5VG9vbGJhci5hcHBlbmQoaSksIHRoaXMuX2dhbGxlcnkuYXBwZW5kKHRoaXMuX2dhbGxlcnlUb29sYmFyKTtcbiAgfVxuICBfYXBwZW5kQ29udGVudCgpIHtcbiAgICB0aGlzLl9nYWxsZXJ5Q29udGVudCA9ICQoXCJkaXZcIiksIGguYWRkQ2xhc3MoXG4gICAgICB0aGlzLl9nYWxsZXJ5Q29udGVudCxcbiAgICAgIGAke3RoaXMuX2NsYXNzZXMuZ2FsbGVyeUNvbnRlbnR9YFxuICAgICksIHRoaXMuX2dhbGxlcnkuYXBwZW5kKHRoaXMuX2dhbGxlcnlDb250ZW50KTtcbiAgfVxuICBfYXBwZW5kTG9hZGVyKCkge1xuICAgIHRoaXMuX2xvYWRlciA9ICQoXCJkaXZcIik7XG4gICAgY29uc3QgdCA9ICQoXCJkaXZcIiksIGUgPSAkKFwic3BhblwiKTtcbiAgICBoLmFkZENsYXNzKHRoaXMuX2xvYWRlciwgYCR7dGhpcy5fY2xhc3Nlcy5sb2FkZXJ9YCksIGguYWRkQ2xhc3ModCwgYCR7dGhpcy5fY2xhc3Nlcy5zcGlubmVyfWApLCBoLmFkZENsYXNzKGUsIGAke3RoaXMuX2NsYXNzZXMuc3Bpbm5lckNvbnRlbnR9YCksIHQuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInN0YXR1c1wiKSwgZS5pbm5lckhUTUwgPSB0aGlzLm9wdGlvbnMuc3Bpbm5lckNvbnRlbnQsIHQuYXBwZW5kKGUpLCB0aGlzLl9sb2FkZXIuYXBwZW5kKHQpLCB0aGlzLl9nYWxsZXJ5LmFwcGVuZCh0aGlzLl9sb2FkZXIpO1xuICB9XG4gIF9hcHBlbmRBcnJvd3MoKSB7XG4gICAgdGhpcy5fbGVmdEFycm93V3JhcHBlciA9ICQoXCJkaXZcIiksIGguYWRkQ2xhc3MoXG4gICAgICB0aGlzLl9sZWZ0QXJyb3dXcmFwcGVyLFxuICAgICAgYCR7dGhpcy5fY2xhc3Nlcy5wcmV2QnRuV3JhcHBlcn1gXG4gICAgKTtcbiAgICBjb25zdCB0ID0gJChcImJ1dHRvblwiKTtcbiAgICB0LnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgXCJQcmV2aW91c1wiKSwgaC5hZGRDbGFzcyh0LCBgJHt0aGlzLl9jbGFzc2VzLnByZXZCdG59YCksIGMub24odCwgSWUsICgpID0+IHRoaXMuc2xpZGUoXCJsZWZ0XCIpKSwgdGhpcy5fbGVmdEFycm93V3JhcHBlci5hcHBlbmQodCksIHRoaXMuX3JpZ2h0QXJyb3dXcmFwcGVyID0gJChcImRpdlwiKSwgaC5hZGRDbGFzcyhcbiAgICAgIHRoaXMuX3JpZ2h0QXJyb3dXcmFwcGVyLFxuICAgICAgYCR7dGhpcy5fY2xhc3Nlcy5uZXh0QnRuV3JhcHBlcn1gXG4gICAgKSwgdGhpcy5fcmlnaHRBcnJvdyA9ICQoXCJidXR0b25cIiksIHRoaXMuX3JpZ2h0QXJyb3cuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBcIk5leHRcIiksIGguYWRkQ2xhc3ModGhpcy5fcmlnaHRBcnJvdywgYCR7dGhpcy5fY2xhc3Nlcy5uZXh0QnRufWApLCBjLm9uKHRoaXMuX3JpZ2h0QXJyb3csIEllLCAoKSA9PiB0aGlzLnNsaWRlKCkpLCB0aGlzLl9yaWdodEFycm93V3JhcHBlci5hcHBlbmQodGhpcy5fcmlnaHRBcnJvdyksIHRoaXMuX3JpZ2h0QXJyb3cuaW5uZXJIVE1MID0gdGhpcy5vcHRpb25zLm5leHRJY29uVGVtcGxhdGUsIHQuaW5uZXJIVE1MID0gdGhpcy5vcHRpb25zLnByZXZJY29uVGVtcGxhdGUsIHRoaXMuX2dldEltYWdlcygpLCAhKHRoaXMuX2ltYWdlcy5sZW5ndGggPD0gMSkgJiYgKHRoaXMuX2dhbGxlcnkuYXBwZW5kKHRoaXMuX2xlZnRBcnJvd1dyYXBwZXIpLCB0aGlzLl9nYWxsZXJ5LmFwcGVuZCh0aGlzLl9yaWdodEFycm93V3JhcHBlcikpO1xuICB9XG4gIF9hcHBlbmRDYXB0aW9uKCkge1xuICAgIGNvbnN0IHQgPSAkKFwiZGl2XCIpLCBlID0gJChcInBcIik7XG4gICAgZS5zZXRBdHRyaWJ1dGUoTWwsIFwiXCIpLCBoLmFkZENsYXNzKHQsIGAke3RoaXMuX2NsYXNzZXMuY2FwdGlvbldyYXBwZXJ9YCksIGguYWRkQ2xhc3MoZSwgYCR7dGhpcy5fY2xhc3Nlcy5jYXB0aW9ufWApLCB0LmFwcGVuZChlKSwgdGhpcy5fZ2FsbGVyeS5hcHBlbmQodCk7XG4gIH1cbiAgX3NvcnRJbWFnZXMoKSB7XG4gICAgZm9yIChsZXQgdCA9IDA7IHQgPCB0aGlzLl9hY3RpdmVJbWc7IHQrKylcbiAgICAgIHRoaXMuX2ltYWdlcy5wdXNoKHRoaXMuX2ltYWdlcy5zaGlmdCgpKTtcbiAgfVxuICBhc3luYyBfbG9hZEltYWdlcygpIHtcbiAgICBjb25zdCB0ID0gW10sIGUgPSBbXTtcbiAgICB0aGlzLl9nYWxsZXJ5Q29udGVudC5pbm5lckhUTUwgPSBcIlwiO1xuICAgIGxldCBpID0gMDtcbiAgICByZXR1cm4gdGhpcy5faW1hZ2VzLmZvckVhY2goKG4sIG8pID0+IHtcbiAgICAgIHQucHVzaChcbiAgICAgICAgbmV3IFByb21pc2UoKHIpID0+IHtcbiAgICAgICAgICBjb25zdCBhID0gbmV3IEltYWdlKCksIGwgPSAkKFwiZGl2XCIpO1xuICAgICAgICAgIGguYWRkQ2xhc3MobCwgYCR7dGhpcy5fY2xhc3Nlcy5pbWdXcmFwcGVyfWApLCBoLmFkZENsYXNzKGEsIGAke3RoaXMuX2NsYXNzZXMuaW1nfWApLCB0aGlzLl9hZGRJbWdTdHlsZXMoYSwgbCwgaSwgbywgbiksIGwuYXBwZW5kKGEpLCB0aGlzLl9nYWxsZXJ5Q29udGVudC5hcHBlbmQobCksIGEub25sb2FkID0gciwgYS5zcmMgPSBuLmRhdGFzZXQudGVJbWcgfHwgbi5zcmMsIGUucHVzaChhKSwgaSArPSAxMDA7XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH0pLCBhd2FpdCBQcm9taXNlLmFsbCh0KSwgZTtcbiAgfVxuICBfYWRkSW1nU3R5bGVzKHQsIGUsIGksIG4sIG8pIHtcbiAgICB0LmFsdCA9IG8uYWx0LCB0LmRyYWdnYWJsZSA9ICExLCBoLnN0eWxlKGUsIHtcbiAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICBsZWZ0OiBgJHtpfSVgLFxuICAgICAgdG9wOiAwXG4gICAgfSksIChvLmRhdGFzZXQudGVDYXB0aW9uIHx8IG8uZGF0YXNldC50ZUNhcHRpb24gPT09IFwiXCIpICYmICh0LmRhdGFzZXQuY2FwdGlvbiA9IG8uZGF0YXNldC50ZUNhcHRpb24pLCBpID09PSAwID8gKG8ud2lkdGggPCBvLmhlaWdodCAmJiBoLmFkZENsYXNzKHQsIGAke3RoaXMuX2NsYXNzZXMudmVydGljYWx9YCksIGguc3R5bGUoZSwgeyBvcGFjaXR5OiAxIH0pLCB0LnNldEF0dHJpYnV0ZShJdCwgXCJcIikpIDogdC5yZW1vdmVBdHRyaWJ1dGUoSXQpLCBuID09PSB0aGlzLl9pbWFnZXMubGVuZ3RoIC0gMSAmJiB0aGlzLl9pbWFnZXMubGVuZ3RoID4gMSAmJiBoLnN0eWxlKGUsIHsgbGVmdDogXCItMTAwJVwiIH0pO1xuICB9XG4gIF9yZXNpemVJbWFnZXModCkge1xuICAgIHQuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgdGhpcy5fY2FsY3VsYXRlSW1nU2l6ZShlKTtcbiAgICB9KTtcbiAgfVxuICBfY2FsY3VsYXRlSW1nU2l6ZSh0KSB7XG4gICAgdC53aWR0aCA+PSB0LmhlaWdodCA/ICh0LnN0eWxlLndpZHRoID0gXCIxMDAlXCIsIHQuc3R5bGUubWF4V2lkdGggPSBcIjEwMCVcIiwgdC5zdHlsZS5oZWlnaHQgPSBcImF1dG9cIiwgdC5zdHlsZS50b3AgPSBgJHsodC5wYXJlbnROb2RlLm9mZnNldEhlaWdodCAtIHQuaGVpZ2h0KSAvIDJ9cHhgLCB0LnN0eWxlLmxlZnQgPSAwKSA6ICh0LnN0eWxlLmhlaWdodCA9IFwiMTAwJVwiLCB0LnN0eWxlLm1heEhlaWdodCA9IFwiMTAwJVwiLCB0LnN0eWxlLndpZHRoID0gXCJhdXRvXCIsIHQuc3R5bGUubGVmdCA9IGAkeyh0LnBhcmVudE5vZGUub2Zmc2V0V2lkdGggLSB0LndpZHRoKSAvIDJ9cHhgLCB0LnN0eWxlLnRvcCA9IDApLCB0LndpZHRoID49IHQucGFyZW50Tm9kZS5vZmZzZXRXaWR0aCAmJiAodC5zdHlsZS53aWR0aCA9IGAke3QucGFyZW50Tm9kZS5vZmZzZXRXaWR0aH1weGAsIHQuc3R5bGUuaGVpZ2h0ID0gXCJhdXRvXCIsIHQuc3R5bGUubGVmdCA9IDAsIHQuc3R5bGUudG9wID0gYCR7KHQucGFyZW50Tm9kZS5vZmZzZXRIZWlnaHQgLSB0LmhlaWdodCkgLyAyfXB4YCksIHQuaGVpZ2h0ID49IHQucGFyZW50Tm9kZS5vZmZzZXRIZWlnaHQgJiYgKHQuc3R5bGUuaGVpZ2h0ID0gYCR7dC5wYXJlbnROb2RlLm9mZnNldEhlaWdodH1weGAsIHQuc3R5bGUud2lkdGggPSBcImF1dG9cIiwgdC5zdHlsZS50b3AgPSAwLCB0LnN0eWxlLmxlZnQgPSBgJHsodC5wYXJlbnROb2RlLm9mZnNldFdpZHRoIC0gdC53aWR0aCkgLyAyfXB4YCksIHRoaXMuX3Bvc2l0aW9uWCA9IHBhcnNlRmxvYXQodC5zdHlsZS5sZWZ0KSB8fCAwLCB0aGlzLl9wb3NpdGlvblkgPSBwYXJzZUZsb2F0KHQuc3R5bGUudG9wKSB8fCAwO1xuICB9XG4gIF9vblJlc2l6ZSgpIHtcbiAgICB0aGlzLl9pbWFnZXMgPSBkLmZpbmQoXCJpbWdcIiwgdGhpcy5fZ2FsbGVyeUNvbnRlbnQpLCB0aGlzLl9pbWFnZXMuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgdGhpcy5fY2FsY3VsYXRlSW1nU2l6ZSh0KTtcbiAgICB9KTtcbiAgfVxuICBfb25GdWxsc2NyZWVuQ2hhbmdlKCkge1xuICAgIChkb2N1bWVudC53ZWJraXRJc0Z1bGxTY3JlZW4gfHwgZG9jdW1lbnQubW96RnVsbFNjcmVlbiB8fCBkb2N1bWVudC5tc0Z1bGxzY3JlZW5FbGVtZW50KSA9PT0gdm9pZCAwICYmICh0aGlzLl9mdWxsc2NyZWVuID0gITEsIHRoaXMuX2Z1bGxzY3JlZW5CdG4uaW5uZXJIVE1MID0gdGhpcy5vcHRpb25zLnNob3dGdWxsc2NyZWVuSWNvblRlbXBsYXRlLCB0aGlzLl9mdWxsc2NyZWVuQnRuLnJlbW92ZUF0dHJpYnV0ZShJdCkpO1xuICB9XG4gIF9iZWZvcmVTbGlkZUV2ZW50cygpIHtcbiAgICB0aGlzLl9hbmltYXRpb25TdGFydCgpLCB0aGlzLl9yZXN0b3JlRGVmYXVsdFpvb20oKSwgdGhpcy5fcmVzdG9yZURlZmF1bHRQb3NpdGlvbigpLCB0aGlzLl9yZXNldERvdWJsZVRhcCgpO1xuICB9XG4gIF9zbGlkZUhvcml6b250YWxseSh0KSB7XG4gICAgdGhpcy5faW1hZ2VzID0gZC5maW5kKFwiaW1nXCIsIHRoaXMuX2dhbGxlcnlDb250ZW50KSwgdGhpcy5faW1hZ2VzLmZvckVhY2goKGUpID0+IHtcbiAgICAgIGxldCBpO1xuICAgICAgdCA9PT0gXCJyaWdodFwiID8gKGkgPSBwYXJzZUludChlLnBhcmVudE5vZGUuc3R5bGUubGVmdCwgMTApIC0gMTAwLCBpIDwgLTEwMCAmJiAoaSA9ICh0aGlzLl9pbWFnZXMubGVuZ3RoIC0gMikgKiAxMDApKSA6IChpID0gcGFyc2VJbnQoZS5wYXJlbnROb2RlLnN0eWxlLmxlZnQsIDEwKSArIDEwMCwgaSA9PT0gKHRoaXMuX2ltYWdlcy5sZW5ndGggLSAxKSAqIDEwMCAmJiAoaSA9IC0xMDApKSwgdGhpcy5fc2xpZGVJbWcoZSwgaSk7XG4gICAgfSksIHRoaXMuX3VwZGF0ZUFjdGl2ZUltZyh0KTtcbiAgfVxuICBfc2xpZGVJbWcodCwgZSkge1xuICAgIGUgPT09IDAgPyAodC5zZXRBdHRyaWJ1dGUoSXQsIFwiXCIpLCBoLnN0eWxlKHQucGFyZW50Tm9kZSwgeyBvcGFjaXR5OiAxLCB0cmFuc2Zvcm06IFwic2NhbGUoMSlcIiB9KSkgOiAodC5yZW1vdmVBdHRyaWJ1dGUoSXQpLCBoLnN0eWxlKHQucGFyZW50Tm9kZSwge1xuICAgICAgb3BhY2l0eTogMCxcbiAgICAgIHRyYW5zZm9ybTogXCJzY2FsZSgwLjI1KVwiXG4gICAgfSkpLCB0LnBhcmVudE5vZGUuc3R5bGUubGVmdCA9IGAke2V9JWA7XG4gIH1cbiAgX3NsaWRlVG9UYXJnZXQodCkge1xuICAgIHQgPT09IFwiZmlyc3RcIiAmJiB0aGlzLl9hY3RpdmVJbWcgPT09IDAgfHwgdCA9PT0gXCJsYXN0XCIgJiYgdGhpcy5fYWN0aXZlSW1nID09PSB0aGlzLl9pbWFnZXMubGVuZ3RoIC0gMSB8fCAodGhpcy5yZXNldCgpLCB0aGlzLl9yZW1vdmVFdmVudHMoKSwgdGhpcy5fc2hvd0xvYWRlcigpLCB0aGlzLl9nZXRJbWFnZXMoKSwgdGhpcy5fYWN0aXZlSW1nID0gdCA9PT0gXCJmaXJzdFwiID8gMCA6IHRoaXMuX2ltYWdlcy5sZW5ndGggLSAxLCB0aGlzLl9zb3J0SW1hZ2VzKCksIGguc3R5bGUodGhpcy5jdXJyZW50SW1nLnBhcmVudE5vZGUsIHtcbiAgICAgIHRyYW5zZm9ybTogXCJzY2FsZSgwLjI1KVwiLFxuICAgICAgb3BhY2l0eTogMFxuICAgIH0pLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuX2xvYWRJbWFnZXMoKS50aGVuKChlKSA9PiB7XG4gICAgICAgIHRoaXMuX3Jlc2l6ZUltYWdlcyhlKSwgdGhpcy5fYWRkRXZlbnRzKCksIHRoaXMuX3VwZGF0ZUNhcHRpb24oKSwgdGhpcy5faGlkZUxvYWRlcigpLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBoLnN0eWxlKHRoaXMuY3VycmVudEltZy5wYXJlbnROb2RlLCB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IFwic2NhbGUoMSlcIixcbiAgICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgMTApO1xuICAgICAgfSk7XG4gICAgfSwgNDAwKSk7XG4gIH1cbiAgX3VwZGF0ZUFjdGl2ZUltZyh0KSB7XG4gICAgdCA9PT0gXCJyaWdodFwiICYmICh0aGlzLl9hY3RpdmVJbWcgPT09IHRoaXMuX2ltYWdlcy5sZW5ndGggLSAxID8gdGhpcy5fYWN0aXZlSW1nID0gMCA6IHRoaXMuX2FjdGl2ZUltZysrKSwgdCA9PT0gXCJsZWZ0XCIgJiYgKHRoaXMuX2FjdGl2ZUltZyA9PT0gMCA/IHRoaXMuX2FjdGl2ZUltZyA9IHRoaXMuX2ltYWdlcy5sZW5ndGggLSAxIDogdGhpcy5fYWN0aXZlSW1nLS0pO1xuICB9XG4gIF9hZnRlclNsaWRlRXZlbnRzKCkge1xuICAgIHRoaXMuX3VwZGF0ZUNvdW50ZXIoKSwgdGhpcy5fdXBkYXRlQ2FwdGlvbigpO1xuICB9XG4gIF91cGRhdGVDb3VudGVyKCkge1xuICAgIHRoaXMuX2ltYWdlcy5sZW5ndGggPD0gMSB8fCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuX2ltZ0NvdW50ZXIuaW5uZXJIVE1MID0gYCR7dGhpcy5fYWN0aXZlSW1nICsgMX0gLyAke3RoaXMuX2ltYWdlcy5sZW5ndGh9YDtcbiAgICB9LCAyMDApO1xuICB9XG4gIF91cGRhdGVDYXB0aW9uKCkge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgbGV0IHQgPSB0aGlzLmN1cnJlbnRJbWcuYWx0O1xuICAgICAgKHRoaXMuY3VycmVudEltZy5kYXRhc2V0LmNhcHRpb24gfHwgdGhpcy5jdXJyZW50SW1nLmRhdGFzZXQuY2FwdGlvbiA9PT0gXCJcIikgJiYgKHQgPSB0aGlzLmN1cnJlbnRJbWcuZGF0YXNldC5jYXB0aW9uKSwgZC5maW5kT25lKFxuICAgICAgICBgWyR7TWx9XWAsXG4gICAgICAgIHRoaXMuX2dhbGxlcnlcbiAgICAgICkuaW5uZXJIVE1MID0gdDtcbiAgICB9LCAyMDApO1xuICB9XG4gIF90b2dnbGVUZW1wbGF0ZSgpIHtcbiAgICB0aGlzLl9nYWxsZXJ5LnN0eWxlLnZpc2liaWxpdHkgPT09IFwidmlzaWJsZVwiID8gKGguc3R5bGUodGhpcy5jdXJyZW50SW1nLnBhcmVudE5vZGUsIHtcbiAgICAgIHRyYW5zZm9ybTogXCJzY2FsZSgwLjI1KVwiXG4gICAgfSksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5faGlkZUdhbGxlcnkoKSwgdGhpcy5fZW5hYmxlU2Nyb2xsKCksIHRoaXMuX3Nob3dMb2FkZXIoKTtcbiAgICB9LCAxMDApKSA6ICh0aGlzLl9zaG93R2FsbGVyeSgpLCB0aGlzLl9kaXNhYmxlU2Nyb2xsKCksIHRoaXMuX3VwZGF0ZUNvdW50ZXIoKSwgdGhpcy5fdXBkYXRlQ2FwdGlvbigpLCB0aGlzLl9zZXRUb29sc1RvZ2dsZVRpbW91dCgpLCB0aGlzLl9oaWRlTG9hZGVyKCkpO1xuICB9XG4gIF9zaG93TG9hZGVyKCkge1xuICAgIGguc3R5bGUodGhpcy5fbG9hZGVyLCB7IG9wYWNpdHk6IDEgfSk7XG4gIH1cbiAgX2hpZGVMb2FkZXIoKSB7XG4gICAgaC5zdHlsZSh0aGlzLl9sb2FkZXIsIHsgb3BhY2l0eTogMCB9KTtcbiAgfVxuICBfaGlkZUdhbGxlcnkoKSB7XG4gICAgaC5zdHlsZSh0aGlzLl9nYWxsZXJ5LCB7XG4gICAgICBvcGFjaXR5OiAwLFxuICAgICAgcG9pbnRlckV2ZW50czogXCJub25lXCIsXG4gICAgICB2aXNpYmlsaXR5OiBcImhpZGRlblwiXG4gICAgfSk7XG4gIH1cbiAgX3Nob3dHYWxsZXJ5KCkge1xuICAgIGguc3R5bGUodGhpcy5fZ2FsbGVyeSwge1xuICAgICAgb3BhY2l0eTogMSxcbiAgICAgIHBvaW50ZXJFdmVudHM6IFwiaW5pdGlhbFwiLFxuICAgICAgdmlzaWJpbGl0eTogXCJ2aXNpYmxlXCJcbiAgICB9KSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBoLnN0eWxlKHRoaXMuY3VycmVudEltZy5wYXJlbnROb2RlLCB7IHRyYW5zZm9ybTogXCJzY2FsZSgxKVwiIH0pO1xuICAgIH0sIDUwKTtcbiAgfVxuICBfdG9nZ2xlWm9vbSgpIHtcbiAgICB0aGlzLl96b29tICE9PSAxID8gdGhpcy56b29tT3V0KCkgOiB0aGlzLnpvb21JbigpO1xuICB9XG4gIF91cGRhdGVab29tQnRuKCkge1xuICAgIHRoaXMuX3pvb20gPiAxID8gKHRoaXMuX3pvb21CdG4uc2V0QXR0cmlidXRlKEl0LCBcIlwiKSwgdGhpcy5fem9vbUJ0bi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIFwiWm9vbSBvdXRcIiksIHRoaXMuX3pvb21CdG4uaW5uZXJIVE1MID0gdGhpcy5vcHRpb25zLnpvb21PdXRJY29uVGVtcGxhdGUpIDogKHRoaXMuX3pvb21CdG4ucmVtb3ZlQXR0cmlidXRlKEl0KSwgdGhpcy5fem9vbUJ0bi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIFwiWm9vbSBpblwiKSwgdGhpcy5fem9vbUJ0bi5pbm5lckhUTUwgPSB0aGlzLm9wdGlvbnMuem9vbUluSWNvblRlbXBsYXRlKTtcbiAgfVxuICBfdXBkYXRlSW1nUG9zaXRpb24oKSB7XG4gICAgdGhpcy5fem9vbSA9PT0gMSAmJiB0aGlzLl9yZXN0b3JlRGVmYXVsdFBvc2l0aW9uKCk7XG4gIH1cbiAgX2FkZEV2ZW50cygpIHtcbiAgICBjb25zdCB0ID0gZC5maW5kKFwiaW1nXCIsIHRoaXMuX2dhbGxlcnlDb250ZW50KTtcbiAgICB0aGlzLl9vbldpbmRvd1RvdWNobW92ZSA9IHRoaXMuX29uV2luZG93VG91Y2htb3ZlLmJpbmQodGhpcyksIHRoaXMuX29uV2luZG93VG91Y2hzdGFydCA9IHRoaXMuX29uV2luZG93VG91Y2hzdGFydC5iaW5kKHRoaXMpLCB0aGlzLl9vbkltZ01vdXNlZG93biA9IHRoaXMuX29uTW91c2Vkb3duLmJpbmQodGhpcyksIHRoaXMuX29uSW1nTW91c2Vtb3ZlID0gdGhpcy5fb25Nb3VzZW1vdmUuYmluZCh0aGlzKSwgdGhpcy5fb25JbWdXaGVlbCA9IHRoaXMuX29uWm9vbS5iaW5kKHRoaXMpLCB0aGlzLl9vbkltZ01vdXNldXAgPSB0aGlzLl9vbk1vdXNldXAuYmluZCh0aGlzKSwgdGhpcy5fb25JbWdUb3VjaGVuZCA9IHRoaXMuX29uVG91Y2hlbmQuYmluZCh0aGlzKSwgdGhpcy5fb25JbWdEb3VibGVDbGljayA9IHRoaXMuX29uRG91YmxlQ2xpY2suYmluZCh0aGlzKSwgdGhpcy5fb25XaW5kb3dSZXNpemUgPSB0aGlzLl9vblJlc2l6ZS5iaW5kKHRoaXMpLCB0aGlzLl9vbldpbmRvd0Z1bGxzY3JlZW5DaGFuZ2UgPSB0aGlzLl9vbkZ1bGxzY3JlZW5DaGFuZ2UuYmluZCh0aGlzKSwgdGhpcy5fb25BbnlJbWdBY3Rpb24gPSB0aGlzLl9yZXNldFRvb2xzVG9nZ2xlci5iaW5kKHRoaXMpLCB0aGlzLl9vbkdhbGxlcnlDbGljayA9IHRoaXMuX29uQmFja2Ryb3BDbGljay5iaW5kKHRoaXMpLCB0aGlzLl9vbktleXVwRXZlbnQgPSB0aGlzLl9vbktleXVwLmJpbmQodGhpcyksIHRoaXMuX29uUmlnaHRBcnJvd0tleWRvd25FdmVudCA9IHRoaXMuX29uUmlnaHRBcnJvd0tleWRvd24uYmluZCh0aGlzKSwgdGhpcy5fb25GdWxsc2NyZWVuQnRuS2V5ZG93bkV2ZW50ID0gdGhpcy5fb25GdWxsc2NyZWVuQnRuS2V5ZG93bi5iaW5kKHRoaXMpLCB0LmZvckVhY2goKGUpID0+IHtcbiAgICAgIGMub24oZSwgXCJtb3VzZWRvd25cIiwgdGhpcy5fb25JbWdNb3VzZWRvd24sIHtcbiAgICAgICAgcGFzc2l2ZTogITBcbiAgICAgIH0pLCBjLm9uKGUsIFwidG91Y2hzdGFydFwiLCB0aGlzLl9vbkltZ01vdXNlZG93biwge1xuICAgICAgICBwYXNzaXZlOiAhMFxuICAgICAgfSksIGMub24oZSwgXCJtb3VzZW1vdmVcIiwgdGhpcy5fb25JbWdNb3VzZW1vdmUsIHtcbiAgICAgICAgcGFzc2l2ZTogITBcbiAgICAgIH0pLCBjLm9uKGUsIFwidG91Y2htb3ZlXCIsIHRoaXMuX29uSW1nTW91c2Vtb3ZlLCB7XG4gICAgICAgIHBhc3NpdmU6ICEwXG4gICAgICB9KSwgYy5vbihlLCBcIndoZWVsXCIsIHRoaXMuX29uSW1nV2hlZWwsIHsgcGFzc2l2ZTogITAgfSksIGMub24oZSwgXCJkYmxjbGlja1wiLCB0aGlzLl9vbkltZ0RvdWJsZUNsaWNrLCB7XG4gICAgICAgIHBhc3NpdmU6ICEwXG4gICAgICB9KTtcbiAgICB9KSwgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCB0aGlzLl9vbldpbmRvd1RvdWNobW92ZSwge1xuICAgICAgcGFzc2l2ZTogITFcbiAgICB9KSwgYy5vbih3aW5kb3csIFwidG91Y2hzdGFydFwiLCB0aGlzLl9vbldpbmRvd1RvdWNoc3RhcnQpLCBjLm9uKHdpbmRvdywgXCJtb3VzZXVwXCIsIHRoaXMuX29uSW1nTW91c2V1cCksIGMub24od2luZG93LCBcInRvdWNoZW5kXCIsIHRoaXMuX29uSW1nVG91Y2hlbmQpLCBjLm9uKHdpbmRvdywgXCJyZXNpemVcIiwgdGhpcy5fb25XaW5kb3dSZXNpemUpLCBjLm9uKHdpbmRvdywgXCJvcmllbnRhdGlvbmNoYW5nZVwiLCB0aGlzLl9vbldpbmRvd1Jlc2l6ZSksIGMub24od2luZG93LCBcImtleXVwXCIsIHRoaXMuX29uS2V5dXBFdmVudCksIGMub24od2luZG93LCBcImZ1bGxzY3JlZW5jaGFuZ2VcIiwgdGhpcy5fb25XaW5kb3dGdWxsc2NyZWVuQ2hhbmdlKSwgYy5vbih0aGlzLl9nYWxsZXJ5LCBcIm1vdXNlbW92ZVwiLCB0aGlzLl9vbkFueUltZ0FjdGlvbiksIGMub24odGhpcy5fZ2FsbGVyeSwgXCJjbGlja1wiLCB0aGlzLl9vbkdhbGxlcnlDbGljayksIGMub24oXG4gICAgICB0aGlzLl9yaWdodEFycm93LFxuICAgICAgXCJrZXlkb3duXCIsXG4gICAgICB0aGlzLl9vblJpZ2h0QXJyb3dLZXlkb3duRXZlbnRcbiAgICApLCBjLm9uKFxuICAgICAgdGhpcy5fZnVsbHNjcmVlbkJ0bixcbiAgICAgIFwia2V5ZG93blwiLFxuICAgICAgdGhpcy5fb25GdWxsc2NyZWVuQnRuS2V5ZG93bkV2ZW50XG4gICAgKTtcbiAgfVxuICBfcmVtb3ZlRXZlbnRzKCkge1xuICAgIGQuZmluZChcImltZ1wiLCB0aGlzLl9nYWxsZXJ5Q29udGVudCkuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgYy5vZmYoZSwgXCJtb3VzZWRvd25cIiwgdGhpcy5fb25JbWdNb3VzZWRvd24pLCBjLm9mZihlLCBcInRvdWNoc3RhcnRcIiwgdGhpcy5fb25JbWdNb3VzZWRvd24pLCBjLm9mZihlLCBcIm1vdXNlbW92ZVwiLCB0aGlzLl9vbkltZ01vdXNlbW92ZSksIGMub2ZmKGUsIFwidG91Y2htb3ZlXCIsIHRoaXMuX29uSW1nTW91c2Vtb3ZlKSwgYy5vZmYoZSwgXCJ3aGVlbFwiLCB0aGlzLl9vbkltZ1doZWVsKSwgYy5vZmYoZSwgXCJkYmxjbGlja1wiLCB0aGlzLl9vbkltZ0RvdWJsZUNsaWNrKTtcbiAgICB9KSwgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCB0aGlzLl9vbldpbmRvd1RvdWNobW92ZSwge1xuICAgICAgcGFzc2l2ZTogITFcbiAgICB9KSwgYy5vZmYod2luZG93LCBcInRvdWNoc3RhcnRcIiwgdGhpcy5fb25XaW5kb3dUb3VjaHN0YXJ0KSwgYy5vZmYod2luZG93LCBcIm1vdXNldXBcIiwgdGhpcy5fb25JbWdNb3VzZXVwKSwgYy5vZmYod2luZG93LCBcInRvdWNoZW5kXCIsIHRoaXMuX29uSW1nVG91Y2hlbmQpLCBjLm9mZih3aW5kb3csIFwicmVzaXplXCIsIHRoaXMuX29uV2luZG93UmVzaXplKSwgYy5vZmYod2luZG93LCBcIm9yaWVudGF0aW9uY2hhbmdlXCIsIHRoaXMuX29uV2luZG93UmVzaXplKSwgYy5vZmYod2luZG93LCBcImtleXVwXCIsIHRoaXMuX29uS2V5dXBFdmVudCksIGMub2ZmKFxuICAgICAgd2luZG93LFxuICAgICAgXCJmdWxsc2NyZWVuY2hhbmdlXCIsXG4gICAgICB0aGlzLl9vbldpbmRvd0Z1bGxzY3JlZW5DaGFuZ2VcbiAgICApLCBjLm9mZih0aGlzLl9nYWxsZXJ5LCBcIm1vdXNlbW92ZVwiLCB0aGlzLl9vbkFueUltZ0FjdGlvbiksIGMub2ZmKHRoaXMuX2dhbGxlcnksIFwiY2xpY2tcIiwgdGhpcy5fb25HYWxsZXJ5Q2xpY2spLCBjLm9mZihcbiAgICAgIHRoaXMuX3JpZ2h0QXJyb3csXG4gICAgICBcImtleWRvd25cIixcbiAgICAgIHRoaXMuX29uUmlnaHRBcnJvd0tleWRvd25FdmVudFxuICAgICksIGMub2ZmKFxuICAgICAgdGhpcy5fZnVsbHNjcmVlbkJ0bixcbiAgICAgIFwia2V5ZG93blwiLFxuICAgICAgdGhpcy5fb25GdWxsc2NyZWVuQnRuS2V5ZG93bkV2ZW50XG4gICAgKTtcbiAgfVxuICBfb25Nb3VzZWRvd24odCkge1xuICAgIGNvbnN0IGUgPSB0LnRvdWNoZXMsIGkgPSBlID8gZVswXS5jbGllbnRYIDogdC5jbGllbnRYLCBuID0gZSA/IGVbMF0uY2xpZW50WSA6IHQuY2xpZW50WTtcbiAgICB0aGlzLl9vcmlnaW5hbFBvc2l0aW9uWCA9IHBhcnNlRmxvYXQodGhpcy5jdXJyZW50SW1nLnN0eWxlLmxlZnQpIHx8IDAsIHRoaXMuX29yaWdpbmFsUG9zaXRpb25ZID0gcGFyc2VGbG9hdCh0aGlzLmN1cnJlbnRJbWcuc3R5bGUudG9wKSB8fCAwLCB0aGlzLl9wb3NpdGlvblggPSB0aGlzLl9vcmlnaW5hbFBvc2l0aW9uWCwgdGhpcy5fcG9zaXRpb25ZID0gdGhpcy5fb3JpZ2luYWxQb3NpdGlvblksIHRoaXMuX21vdXNlZG93blBvc2l0aW9uWCA9IGkgKiAoMSAvIHRoaXMuX3pvb20pIC0gdGhpcy5fcG9zaXRpb25YLCB0aGlzLl9tb3VzZWRvd25Qb3NpdGlvblkgPSBuICogKDEgLyB0aGlzLl96b29tKSAtIHRoaXMuX3Bvc2l0aW9uWSwgdGhpcy5fbW91c2Vkb3duID0gITAsIHQudHlwZSA9PT0gXCJ0b3VjaHN0YXJ0XCIgJiYgdC50b3VjaGVzLmxlbmd0aCA+IDEgJiYgKHRoaXMuX211bHRpdG91Y2ggPSAhMCwgdGhpcy5fdG91Y2hab29tUG9zaXRpb24gPSB0LnRvdWNoZXMpO1xuICB9XG4gIF9vbk1vdXNlbW92ZSh0KSB7XG4gICAgaWYgKCF0aGlzLl9tb3VzZWRvd24pXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZSA9IHQudG91Y2hlcywgaSA9IGUgPyBlWzBdLmNsaWVudFggOiB0LmNsaWVudFgsIG4gPSBlID8gZVswXS5jbGllbnRZIDogdC5jbGllbnRZO1xuICAgIGlmIChlICYmIHRoaXMuX3Jlc2V0VG9vbHNUb2dnbGVyKCksICF0aGlzLl9tdWx0aXRvdWNoKVxuICAgICAgaWYgKHRoaXMuX3pvb20gIT09IDEpXG4gICAgICAgIHRoaXMuX3Bvc2l0aW9uWCA9IGkgKiAoMSAvIHRoaXMuX3pvb20pIC0gdGhpcy5fbW91c2Vkb3duUG9zaXRpb25YLCB0aGlzLl9wb3NpdGlvblkgPSBuICogKDEgLyB0aGlzLl96b29tKSAtIHRoaXMuX21vdXNlZG93blBvc2l0aW9uWSwgaC5zdHlsZSh0aGlzLmN1cnJlbnRJbWcsIHtcbiAgICAgICAgICBsZWZ0OiBgJHt0aGlzLl9wb3NpdGlvblh9cHhgLFxuICAgICAgICAgIHRvcDogYCR7dGhpcy5fcG9zaXRpb25ZfXB4YFxuICAgICAgICB9KTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5faW1hZ2VzLmxlbmd0aCA8PSAxKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5fcG9zaXRpb25YID0gaSAqICgxIC8gdGhpcy5fem9vbSkgLSB0aGlzLl9tb3VzZWRvd25Qb3NpdGlvblgsIGguc3R5bGUodGhpcy5jdXJyZW50SW1nLCB7IGxlZnQ6IGAke3RoaXMuX3Bvc2l0aW9uWH1weGAgfSk7XG4gICAgICB9XG4gIH1cbiAgX29uTW91c2V1cCh0KSB7XG4gICAgdGhpcy5fbW91c2Vkb3duID0gITEsIHRoaXMuX21vdmVJbWcodC50YXJnZXQpO1xuICB9XG4gIF9vblRvdWNoZW5kKHQpIHtcbiAgICB0aGlzLl9tb3VzZWRvd24gPSAhMSwgdGhpcy5fbXVsdGl0b3VjaCA/IHQudGFyZ2V0VG91Y2hlcy5sZW5ndGggPT09IDAgJiYgKHRoaXMuX211bHRpdG91Y2ggPSAhMSwgdGhpcy5fdG91Y2hab29tUG9zaXRpb24gPSBbXSkgOiB0aGlzLl9tdWx0aXRvdWNoIHx8ICh0aGlzLl9jaGVja0RvdWJsZVRhcCh0KSwgdGhpcy5fbW92ZUltZyh0LnRhcmdldCkpO1xuICB9XG4gIF9jYWxjdWxhdGVUb3VjaFpvb20odCkge1xuICAgIGNvbnN0IGUgPSBNYXRoLmh5cG90KFxuICAgICAgdGhpcy5fdG91Y2hab29tUG9zaXRpb25bMV0ucGFnZVggLSB0aGlzLl90b3VjaFpvb21Qb3NpdGlvblswXS5wYWdlWCxcbiAgICAgIHRoaXMuX3RvdWNoWm9vbVBvc2l0aW9uWzFdLnBhZ2VZIC0gdGhpcy5fdG91Y2hab29tUG9zaXRpb25bMF0ucGFnZVlcbiAgICApLCBpID0gTWF0aC5oeXBvdChcbiAgICAgIHQudG91Y2hlc1sxXS5wYWdlWCAtIHQudG91Y2hlc1swXS5wYWdlWCxcbiAgICAgIHQudG91Y2hlc1sxXS5wYWdlWSAtIHQudG91Y2hlc1swXS5wYWdlWVxuICAgICksIG4gPSBNYXRoLmFicyhlIC0gaSksIG8gPSB0LnZpZXcuc2NyZWVuLndpZHRoO1xuICAgIG4gPiBvICogMC4wMyAmJiAoZSA8PSBpID8gdGhpcy56b29tSW4oKSA6IHRoaXMuem9vbU91dCgpLCB0aGlzLl90b3VjaFpvb21Qb3NpdGlvbiA9IHQudG91Y2hlcyk7XG4gIH1cbiAgX29uV2luZG93VG91Y2hzdGFydCh0KSB7XG4gICAgdC50b3VjaGVzLmxlbmd0aCA+IDEgJiYgKHRoaXMuX211bHRpdG91Y2ggPSAhMCwgdGhpcy5fdG91Y2hab29tUG9zaXRpb24gPSB0LnRvdWNoZXMpO1xuICB9XG4gIF9vbldpbmRvd1RvdWNobW92ZSh0KSB7XG4gICAgdC5wcmV2ZW50RGVmYXVsdCgpLCB0LnR5cGUgPT09IFwidG91Y2htb3ZlXCIgJiYgdC50YXJnZXRUb3VjaGVzLmxlbmd0aCA+IDEgJiYgdGhpcy5fY2FsY3VsYXRlVG91Y2hab29tKHQpO1xuICB9XG4gIF9vblJpZ2h0QXJyb3dLZXlkb3duKHQpIHtcbiAgICBzd2l0Y2ggKHQua2V5Q29kZSkge1xuICAgICAgY2FzZSA5OlxuICAgICAgICBpZiAodC5zaGlmdEtleSlcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgdC5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLl9mb2N1c0Z1bGxzY3JlZW5CdG4oKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIF9vbkZ1bGxzY3JlZW5CdG5LZXlkb3duKHQpIHtcbiAgICBzd2l0Y2ggKHQua2V5Q29kZSkge1xuICAgICAgY2FzZSA5OlxuICAgICAgICBpZiAoIXQuc2hpZnRLZXkpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIHQucHJldmVudERlZmF1bHQoKSwgdGhpcy5fZm9jdXNSaWdodEFycm93KCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBfb25LZXl1cCh0KSB7XG4gICAgc3dpdGNoICh0aGlzLl9yZXNldFRvb2xzVG9nZ2xlcigpLCB0LmtleUNvZGUpIHtcbiAgICAgIGNhc2UgMzk6XG4gICAgICAgIHRoaXMuc2xpZGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM3OlxuICAgICAgICB0aGlzLnNsaWRlKFwibGVmdFwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI3OlxuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzNjpcbiAgICAgICAgdGhpcy5zbGlkZShcImZpcnN0XCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzU6XG4gICAgICAgIHRoaXMuc2xpZGUoXCJsYXN0XCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzg6XG4gICAgICAgIHRoaXMuem9vbUluKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA0MDpcbiAgICAgICAgdGhpcy56b29tT3V0KCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBfZm9jdXNGdWxsc2NyZWVuQnRuKCkge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5fZnVsbHNjcmVlbkJ0bi5mb2N1cygpO1xuICAgIH0sIDEwMCk7XG4gIH1cbiAgX2ZvY3VzUmlnaHRBcnJvdygpIHtcbiAgICB0aGlzLl9yaWdodEFycm93LmZvY3VzKCk7XG4gIH1cbiAgX21vdmVJbWcodCkge1xuICAgIGlmICh0aGlzLl9tdWx0aXRvdWNoIHx8IHRoaXMuX3pvb20gIT09IDEgfHwgdCAhPT0gdGhpcy5jdXJyZW50SW1nIHx8IHRoaXMuX2ltYWdlcy5sZW5ndGggPD0gMSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBlID0gdGhpcy5fcG9zaXRpb25YIC0gdGhpcy5fb3JpZ2luYWxQb3NpdGlvblg7XG4gICAgZSA+IDAgPyB0aGlzLnNsaWRlKFwibGVmdFwiKSA6IGUgPCAwICYmIHRoaXMuc2xpZGUoKTtcbiAgfVxuICBfY2hlY2tEb3VibGVUYXAodCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl9kb3VibGVUYXBUaW1lcik7XG4gICAgY29uc3QgaSA9ICgvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkuZ2V0VGltZSgpIC0gdGhpcy5fdGFwVGltZTtcbiAgICB0aGlzLl90YXBDb3VudGVyID4gMCAmJiBpIDwgNTAwID8gKHRoaXMuX29uRG91YmxlQ2xpY2sodCksIHRoaXMuX2RvdWJsZVRhcFRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLl90YXBUaW1lID0gKC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKS5nZXRUaW1lKCksIHRoaXMuX3RhcENvdW50ZXIgPSAwO1xuICAgIH0sIDMwMCkpIDogKHRoaXMuX3RhcENvdW50ZXIrKywgdGhpcy5fdGFwVGltZSA9ICgvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkuZ2V0VGltZSgpKTtcbiAgfVxuICBfcmVzZXREb3VibGVUYXAoKSB7XG4gICAgdGhpcy5fdGFwVGltZSA9IDAsIHRoaXMuX3RhcENvdW50ZXIgPSAwLCBjbGVhclRpbWVvdXQodGhpcy5fZG91YmxlVGFwVGltZXIpO1xuICB9XG4gIF9vbkRvdWJsZUNsaWNrKHQpIHtcbiAgICB0aGlzLl9tdWx0aXRvdWNoIHx8ICh0LnRvdWNoZXMgfHwgdGhpcy5fc2V0TmV3UG9zaXRpb25Pblpvb21Jbih0KSwgdGhpcy5fem9vbSAhPT0gMSA/IHRoaXMuX3Jlc3RvcmVEZWZhdWx0Wm9vbSgpIDogdGhpcy56b29tSW4oKSk7XG4gIH1cbiAgX29uWm9vbSh0KSB7XG4gICAgaWYgKHQuZGVsdGFZID4gMClcbiAgICAgIHRoaXMuem9vbU91dCgpO1xuICAgIGVsc2Uge1xuICAgICAgaWYgKHRoaXMuX3pvb20gPj0gMylcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdGhpcy5fc2V0TmV3UG9zaXRpb25Pblpvb21Jbih0KSwgdGhpcy56b29tSW4oKTtcbiAgICB9XG4gIH1cbiAgX29uQmFja2Ryb3BDbGljayh0KSB7XG4gICAgdGhpcy5fcmVzZXRUb29sc1RvZ2dsZXIoKSwgdC50YXJnZXQudGFnTmFtZSA9PT0gXCJESVZcIiAmJiB0aGlzLmNsb3NlKCk7XG4gIH1cbiAgX3NldE5ld1Bvc2l0aW9uT25ab29tSW4odCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl96b29tVGltZXIpLCB0aGlzLl9wb3NpdGlvblggPSB3aW5kb3cuaW5uZXJXaWR0aCAvIDIgLSB0Lm9mZnNldFggLSA1MCwgdGhpcy5fcG9zaXRpb25ZID0gd2luZG93LmlubmVySGVpZ2h0IC8gMiAtIHQub2Zmc2V0WSAtIDUwLCB0aGlzLmN1cnJlbnRJbWcuc3R5bGUudHJhbnNpdGlvbiA9IFwiYWxsIDAuNXMgZWFzZS1vdXRcIiwgdGhpcy5jdXJyZW50SW1nLnN0eWxlLmxlZnQgPSBgJHt0aGlzLl9wb3NpdGlvblh9cHhgLCB0aGlzLmN1cnJlbnRJbWcuc3R5bGUudG9wID0gYCR7dGhpcy5fcG9zaXRpb25ZfXB4YCwgdGhpcy5fem9vbVRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmN1cnJlbnRJbWcuc3R5bGUudHJhbnNpdGlvbiA9IFwibm9uZVwiO1xuICAgIH0sIDUwMCk7XG4gIH1cbiAgX3Jlc2V0VG9vbHNUb2dnbGVyKCkge1xuICAgIHRoaXMuX3Nob3dUb29scygpLCBjbGVhclRpbWVvdXQodGhpcy5fdG9vbHNUb2dnbGVUaW1lciksIHRoaXMuX3NldFRvb2xzVG9nZ2xlVGltb3V0KCk7XG4gIH1cbiAgX3NldFRvb2xzVG9nZ2xlVGltb3V0KCkge1xuICAgIHRoaXMuX3Rvb2xzVG9nZ2xlVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuX2hpZGVUb29scygpLCBjbGVhclRpbWVvdXQodGhpcy5fdG9vbHNUb2dnbGVUaW1lcik7XG4gICAgfSwgNGUzKTtcbiAgfVxuICBfaGlkZVRvb2xzKCkge1xuICAgIGguc3R5bGUodGhpcy5fZ2FsbGVyeVRvb2xiYXIsIHsgb3BhY2l0eTogMCB9KSwgaC5zdHlsZSh0aGlzLl9sZWZ0QXJyb3dXcmFwcGVyLCB7IG9wYWNpdHk6IDAgfSksIGguc3R5bGUodGhpcy5fcmlnaHRBcnJvd1dyYXBwZXIsIHsgb3BhY2l0eTogMCB9KTtcbiAgfVxuICBfc2hvd1Rvb2xzKCkge1xuICAgIGguc3R5bGUodGhpcy5fZ2FsbGVyeVRvb2xiYXIsIHsgb3BhY2l0eTogMSB9KSwgaC5zdHlsZSh0aGlzLl9sZWZ0QXJyb3dXcmFwcGVyLCB7IG9wYWNpdHk6IDEgfSksIGguc3R5bGUodGhpcy5fcmlnaHRBcnJvd1dyYXBwZXIsIHsgb3BhY2l0eTogMSB9KTtcbiAgfVxuICBfZGlzYWJsZVNjcm9sbCgpIHtcbiAgICBoLmFkZENsYXNzKGRvY3VtZW50LmJvZHksIFwib3ZlcmZsb3cteS1oaWRkZW4gcmVsYXRpdmVcIiksIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQgPiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0ICYmIGguYWRkQ2xhc3MoZG9jdW1lbnQuYm9keSwgXCJtZDpwci1bMTdweF1cIik7XG4gIH1cbiAgX2VuYWJsZVNjcm9sbCgpIHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGgucmVtb3ZlQ2xhc3MoZG9jdW1lbnQuYm9keSwgXCJvdmVyZmxvdy15LWhpZGRlbiByZWxhdGl2ZVwiKSwgaC5yZW1vdmVDbGFzcyhkb2N1bWVudC5ib2R5LCBcIm1kOnByLVsxN3B4XVwiKTtcbiAgICB9LCAzMDApO1xuICB9XG4gIF9hbmltYXRpb25TdGFydCgpIHtcbiAgICB0aGlzLl9hbmltYXRpbmcgPSAhMCwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLl9hbmltYXRpbmcgPSAhMTtcbiAgICB9LCA0MDApO1xuICB9XG4gIF9yZXN0b3JlRGVmYXVsdFpvb20oKSB7XG4gICAgdGhpcy5fem9vbSAhPT0gMSAmJiAodGhpcy5fem9vbSA9IDEsIGguc3R5bGUodGhpcy5jdXJyZW50SW1nLnBhcmVudE5vZGUsIHtcbiAgICAgIHRyYW5zZm9ybTogYHNjYWxlKCR7dGhpcy5fem9vbX0pYFxuICAgIH0pLCB0aGlzLl91cGRhdGVab29tQnRuKCksIHRoaXMuX3VwZGF0ZUltZ1Bvc2l0aW9uKCkpO1xuICB9XG4gIF9yZXN0b3JlRGVmYXVsdEZ1bGxzY3JlZW4oKSB7XG4gICAgdGhpcy5fZnVsbHNjcmVlbiAmJiB0aGlzLnRvZ2dsZUZ1bGxzY3JlZW4oKTtcbiAgfVxuICBfcmVzdG9yZURlZmF1bHRQb3NpdGlvbigpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fem9vbVRpbWVyKTtcbiAgICBjb25zdCB0ID0gdGhpcy5jdXJyZW50SW1nO1xuICAgIGguc3R5bGUodGhpcy5jdXJyZW50SW1nLnBhcmVudE5vZGUsIHsgbGVmdDogMCwgdG9wOiAwIH0pLCBoLnN0eWxlKHRoaXMuY3VycmVudEltZywge1xuICAgICAgdHJhbnNpdGlvbjogXCJhbGwgMC41cyBlYXNlLW91dFwiLFxuICAgICAgbGVmdDogMCxcbiAgICAgIHRvcDogMFxuICAgIH0pLCB0aGlzLl9jYWxjdWxhdGVJbWdTaXplKHQpLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGguc3R5bGUodGhpcy5jdXJyZW50SW1nLCB7IHRyYW5zaXRpb246IFwibm9uZVwiIH0pO1xuICAgIH0sIDUwMCk7XG4gIH1cbiAgYXN5bmMgX3RyaWdnZXJFdmVudHModCwgZSkge1xuICAgIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBgJHt0fS50ZS5saWdodGJveGApLCBlICYmIGF3YWl0IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGAke2V9LnRlLmxpZ2h0Ym94YCk7XG4gICAgfSwgNTA1KTtcbiAgfVxuICBzdGF0aWMgZ2V0SW5zdGFuY2UodCkge1xuICAgIHJldHVybiB5LmdldERhdGEodCwgQWkpO1xuICB9XG4gIHN0YXRpYyBnZXRPckNyZWF0ZUluc3RhbmNlKHQsIGUgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKHQpIHx8IG5ldyB0aGlzKHQsIHR5cGVvZiBlID09IFwib2JqZWN0XCIgPyBlIDogbnVsbCk7XG4gIH1cbiAgc3RhdGljIHRvZ2dsZSgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgY29uc3QgZSA9IGQuY2xvc2VzdChcbiAgICAgICAgdC50YXJnZXQsXG4gICAgICAgIGAke1RofWBcbiAgICAgICk7XG4gICAgICAoWnMuZ2V0SW5zdGFuY2UoZSkgfHwgbmV3IFpzKGUpKS5vcGVuKHQpO1xuICAgIH07XG4gIH1cbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0LCBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGxldCBpID0geS5nZXREYXRhKHRoaXMsIEFpKTtcbiAgICAgIGNvbnN0IG4gPSB0eXBlb2YgdCA9PSBcIm9iamVjdFwiICYmIHQ7XG4gICAgICBpZiAoISghaSAmJiAvZGlzcG9zZS8udGVzdCh0KSkgJiYgKGkgfHwgKGkgPSBuZXcgWnModGhpcywgbikpLCB0eXBlb2YgdCA9PSBcInN0cmluZ1wiKSkge1xuICAgICAgICBpZiAodHlwZW9mIGlbdF0gPiBcInVcIilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke3R9XCJgKTtcbiAgICAgICAgaVt0XShlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuY29uc3QgSUUgPSB7XG4gIGlzUmVxdWlyZWQ6IFwiVGhpcyBpcyByZXF1aXJlZFwiLFxuICBpc0VtYWlsOiBcIlBsZWFzZSBlbnRlciBhIHZhbGlkIGVtYWlsIGFkZHJlc3NcIixcbiAgaXNMb25nZXJUaGFuOiBcIlRoaXMgZmllbGQgbXVzdCBiZSBsb25nZXIgdGhhbiB7bGVuZ3RofSBjaGFyYWN0ZXJzXCIsXG4gIGlzU2hvcnRlclRoYW46IFwiVGhpcyBmaWVsZCBtdXN0IGJlIHNob3J0ZXIgdGhhbiB7bGVuZ3RofSBjaGFyYWN0ZXJzXCIsXG4gIGlzQ2hlY2tlZDogXCJUaGlzIGlzIHJlcXVpcmVkXCIsXG4gIGlzUGhvbmU6IFwiUGxlYXNlIGVudGVyIGEgdmFsaWQgcGhvbmUgbnVtYmVyXCIsXG4gIGlzTnVtYmVyOiBcIkV4cGVjdGVkIHZhbHVlIHdpdGggdHlwZSBOdW1iZXJcIixcbiAgaXNTdHJpbmc6IFwiRXhwZWN0ZWQgdmFsdWUgd2l0aCB0eXBlIFN0cmluZ1wiLFxuICBpc0Jvb2xlYW46IFwiRXhwZWN0ZWQgdmFsdWUgd2l0aCB0eXBlIEJvb2xlYW5cIixcbiAgaXNEYXRlOiBcIlBsZWFzZSBlbnRlciBhIHZhbGlkIGRhdGVcIixcbiAgaXMxMmhGb3JtYXQ6IFwiUGxlYXNlIGVudGVyIGEgdmFsaWQgdGltZSBpbiAxMmggZm9ybWF0XCIsXG4gIGlzMjRoRm9ybWF0OiBcIlBsZWFzZSBlbnRlciBhIHZhbGlkIHRpbWUgaW4gMjRoIGZvcm1hdFwiXG59LCBERSA9IHtcbiAgaXNSZXF1aXJlZDogKHMsIHQpID0+IChzID09IG51bGwgPyB2b2lkIDAgOiBzLnRyaW0oKSkgPyAhMCA6IHQsXG4gIGlzRW1haWw6IChzLCB0KSA9PiAvXlthLXpBLVowLTkuXyUrLV0rQFthLXpBLVowLTkuLV0rXFwuW2EtekEtWl17Mix9JC8udGVzdChzKSA/ICEwIDogdCxcbiAgaXNMb25nZXJUaGFuOiAocywgdCwgZSkgPT4gcy5sZW5ndGggPiBlID8gITAgOiB0LnJlcGxhY2UoXCJ7bGVuZ3RofVwiLCBlKSxcbiAgaXNTaG9ydGVyVGhhbjogKHMsIHQsIGUpID0+IHMubGVuZ3RoIDwgZSA/ICEwIDogdC5yZXBsYWNlKFwie2xlbmd0aH1cIiwgZSksXG4gIGlzQ2hlY2tlZDogKHMpID0+IHMgPyAhMCA6IFwiVGhpcyBpcyByZXF1aXJlZFwiLFxuICBpc1Bob25lOiAocywgdCkgPT4gcy5sZW5ndGggPT09IDkgPyAhMCA6IHQsXG4gIGlzTnVtYmVyOiAocywgdCkgPT4gcyAmJiAhaXNOYU4oTnVtYmVyKHMpKSA/ICEwIDogdCxcbiAgaXNTdHJpbmc6IChzLCB0KSA9PiB0eXBlb2YgcyA9PSBcInN0cmluZ1wiID8gITAgOiB0LFxuICBpc0Jvb2xlYW46IChzLCB0KSA9PiB0eXBlb2YgcyA9PSBcImJvb2xlYW5cIiA/ICEwIDogdCxcbiAgaXNEYXRlOiAocywgdCkgPT4ge1xuICAgIGNvbnN0IGUgPSAvXihbMC05XXsxLDJ9KVxcLyhbMC05XXsxLDJ9KVxcLyhbMC05XXs0fSkkLztcbiAgICByZXR1cm4gcy5tYXRjaChlKSA/ICEwIDogdDtcbiAgfSxcbiAgaXMxMmhGb3JtYXQ6IChzLCB0KSA9PiB7XG4gICAgY29uc3QgZSA9IC9eKDA/WzEtOV18MVswLTJdKTpbMC01XVswLTldIFtBUGFwXVttTV0kLztcbiAgICByZXR1cm4gcy5tYXRjaChlKSA/ICEwIDogdDtcbiAgfSxcbiAgaXMyNGhGb3JtYXQ6IChzLCB0KSA9PiB7XG4gICAgY29uc3QgZSA9IC9eKD86WzAxXVxcZHwyWzAtM10pOlswLTVdWzAtOV0kLztcbiAgICByZXR1cm4gcy5tYXRjaChlKSA/ICEwIDogdDtcbiAgfVxufSwgRW8gPSBcInZhbGlkYXRpb25cIiwgam8gPSBcInRlLnZhbGlkYXRpb25cIiwgZm4gPSBgLiR7am99YCwgRWggPSBcImRhdGEtdGUtdmFsaWRhdGVcIiwgT3MgPSBcImRhdGEtdGUtdmFsaWRhdGVkXCIsIFNzID0gXCJkYXRhLXRlLXZhbGlkYXRpb24tc3RhdGVcIiwgSXMgPSBcImRhdGEtdGUtdmFsaWRhdGlvbi1mZWVkYmFja1wiLCBDbyA9IFwiZGF0YS10ZS12YWxpZC1mZWVkYmFja1wiLCBEcyA9IFwiZGF0YS10ZS1pbnZhbGlkLWZlZWRiYWNrXCIsIFJsID0gXCJkYXRhLXRlLXZhbGlkYXRpb24tcnVsZXNldFwiLCAkRSA9IFwiZGF0YS10ZS1zdWJtaXQtYnRuLXJlZlwiLCBMRSA9IGBbJHtFaH1dYCwgTkUgPSBcIltkYXRhLXRlLWlucHV0LW5vdGNoLXJlZl0gZGl2XCIsIE1FID0gYFskeyRFfV1gLCBSRSA9IGB2YWxpZGF0ZWQke2ZufWAsIFBFID0gYHZhbGlkJHtmbn1gLCBCRSA9IGBpbnZhbGlkJHtmbn1gLCBIRSA9IGBjaGFuZ2VkJHtmbn1gLCBWRSA9IHtcbiAgdmFsaWRGZWVkYmFjazogXCJzdHJpbmdcIixcbiAgaW52YWxpZEZlZWRiYWNrOiBcInN0cmluZ1wiLFxuICBkaXNhYmxlRmVlZGJhY2s6IFwiYm9vbGVhblwiLFxuICBjdXN0b21SdWxlczogXCJvYmplY3RcIixcbiAgY3VzdG9tRXJyb3JNZXNzYWdlczogXCJvYmplY3RcIixcbiAgYWN0aXZlVmFsaWRhdGlvbjogXCJib29sZWFuXCIsXG4gIHN1Ym1pdENhbGxiYWNrOiBcIihmdW5jdGlvbnxudWxsKVwiXG59LCBQbCA9IHtcbiAgdmFsaWRGZWVkYmFjazogXCJMb29rcyBnb29kIVwiLFxuICBpbnZhbGlkRmVlZGJhY2s6IFwiU29tZXRoaW5nIGlzIHdyb25nIVwiLFxuICBkaXNhYmxlRmVlZGJhY2s6ICExLFxuICBjdXN0b21SdWxlczoge30sXG4gIGN1c3RvbUVycm9yTWVzc2FnZXM6IHt9LFxuICBhY3RpdmVWYWxpZGF0aW9uOiAhMSxcbiAgc3VibWl0Q2FsbGJhY2s6IG51bGxcbn0sIFdFID0ge1xuICAvLyBkZWZhdWx0IG5vdGNoXG4gIG5vdGNoTGVhZGluZ1ZhbGlkOiBcImJvcmRlci1bIzE0YTQ0ZF0gZGFyazpib3JkZXItWyMxNGE0NGRdIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOnNoYWRvdy1bLTFweF8wXzBfIzE0YTQ0ZCxfMF8xcHhfMF8wXyMxNGE0NGQsXzBfLTFweF8wXzBfIzE0YTQ0ZF0gZ3JvdXAtZGF0YS1bdGUtaW5wdXQtZm9jdXNlZF06Ym9yZGVyLVsjMTRhNDRkXVwiLFxuICBub3RjaE1pZGRsZVZhbGlkOiBcImJvcmRlci1bIzE0YTQ0ZF0gZGFyazpib3JkZXItWyMxNGE0NGRdIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOnNoYWRvdy1bMF8xcHhfMF8wXyMxNGE0NGRdIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOmJvcmRlci1bIzE0YTQ0ZF1cIixcbiAgbm90Y2hUcmFpbGluZ1ZhbGlkOiBcImJvcmRlci1bIzE0YTQ0ZF0gZGFyazpib3JkZXItWyMxNGE0NGRdIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOnNoYWRvdy1bMXB4XzBfMF8jMTRhNDRkLF8wXy0xcHhfMF8wXyMxNGE0NGQsXzBfMXB4XzBfMF8jMTRhNDRkXSBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpib3JkZXItWyMxNGE0NGRdXCIsXG4gIG5vdGNoTGVhZGluZ0ludmFsaWQ6IFwiYm9yZGVyLVsjZGM0YzY0XSBkYXJrOmJvcmRlci1bI2RjNGM2NF0gZ3JvdXAtZGF0YS1bdGUtaW5wdXQtZm9jdXNlZF06c2hhZG93LVstMXB4XzBfMF8jZGM0YzY0LF8wXzFweF8wXzBfI2RjNGM2NCxfMF8tMXB4XzBfMF8jZGM0YzY0XSBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpib3JkZXItWyNkYzRjNjRdXCIsXG4gIG5vdGNoTWlkZGxlSW52YWxpZDogXCJib3JkZXItWyNkYzRjNjRdIGRhcms6Ym9yZGVyLVsjZGM0YzY0XSBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpzaGFkb3ctWzBfMXB4XzBfMF8jZGM0YzY0XSBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpib3JkZXItWyNkYzRjNjRdXCIsXG4gIG5vdGNoVHJhaWxpbmdJbnZhbGlkOiBcImJvcmRlci1bI2RjNGM2NF0gZGFyazpib3JkZXItWyNkYzRjNjRdIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOnNoYWRvdy1bMXB4XzBfMF8jZGM0YzY0LF8wXy0xcHhfMF8wXyNkYzRjNjQsXzBfMXB4XzBfMF8jZGM0YzY0XSBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpib3JkZXItWyNkYzRjNjRdXCIsXG4gIC8vIGJhc2ljIGlucHV0c1xuICBiYXNpY0lucHV0VmFsaWQ6IFwiIWJvcmRlci1bIzE0YTQ0ZF0gZm9jdXM6IWJvcmRlci1bIzE0YTQ0ZF0gZm9jdXM6IXNoYWRvdy1baW5zZXRfMF8wXzBfMXB4XyMxNGE0NGRdXCIsXG4gIGJhc2ljSW5wdXRJbnZhbGlkOiBcIiFib3JkZXItWyNkYzRjNjRdIGZvY3VzOiFib3JkZXItWyNkYzRjNjRdIGZvY3VzOiFzaGFkb3ctW2luc2V0XzBfMF8wXzFweF8jZGM0YzY0XVwiLFxuICAvLyBjaGVja2JveFxuICBjaGVja2JveFZhbGlkOiBcImNoZWNrZWQ6IWJvcmRlci1bIzE0YTQ0ZF0gY2hlY2tlZDohYmctWyMxNGE0NGRdIGNoZWNrZWQ6YWZ0ZXI6IWJnLVsjMTRhNDRkXVwiLFxuICBjaGVja2JveEludmFsaWQ6IFwiY2hlY2tlZDohYm9yZGVyLVsjZGM0YzY0XSBjaGVja2VkOiFiZy1bI2RjNGM2NF0gY2hlY2tlZDphZnRlcjohYmctWyNkYzRjNjRdXCIsXG4gIHJhZGlvVmFsaWQ6IFwiY2hlY2tlZDohYm9yZGVyLVsjMTRhNDRkXSBjaGVja2VkOmFmdGVyOiFiZy1bIzE0YTQ0ZF1cIixcbiAgcmFkaW9JbnZhbGlkOiBcImNoZWNrZWQ6IWJvcmRlci1bI2RjNGM2NF0gY2hlY2tlZDphZnRlcjohYmctWyNkYzRjNjRdXCIsXG4gIC8vIGxhYmVsc1xuICBsYWJlbFZhbGlkOiBcIiF0ZXh0LVsjMTRhNDRkXVwiLFxuICBsYWJlbEludmFsaWQ6IFwiIXRleHQtWyNkYzRjNjRdXCIsXG4gIC8vIGZlZWRiYWNrXG4gIHZhbGlkRmVlZGJhY2s6IFwiYWJzb2x1dGUgdG9wLWZ1bGwgbGVmdC0wIG0tMSB3LWF1dG8gdGV4dC1zbSB0ZXh0LVsjMTRhNDRkXSBhbmltYXRlLVtmYWRlLWluXzAuM3NfYm90aF1cIixcbiAgaW52YWxpZEZlZWRiYWNrOiBcImFic29sdXRlIHRvcC1mdWxsIGxlZnQtMCBtLTEgdy1hdXRvIHRleHQtc20gdGV4dC1bI2RjNGM2NF0gYW5pbWF0ZS1bZmFkZS1pbl8wLjNzX2JvdGhdXCIsXG4gIC8vIGVsZW1lbnQgdmFsaWRhdGVkXG4gIGVsZW1lbnRWYWxpZGF0ZWQ6IFwibWItOFwiXG59LCBGRSA9IHtcbiAgbm90Y2hMZWFkaW5nVmFsaWQ6IFwic3RyaW5nXCIsXG4gIG5vdGNoTWlkZGxlVmFsaWQ6IFwic3RyaW5nXCIsXG4gIG5vdGNoVHJhaWxpbmdWYWxpZDogXCJzdHJpbmdcIixcbiAgbm90Y2hMZWFkaW5nSW52YWxpZDogXCJzdHJpbmdcIixcbiAgbm90Y2hNaWRkbGVJbnZhbGlkOiBcInN0cmluZ1wiLFxuICBub3RjaFRyYWlsaW5nSW52YWxpZDogXCJzdHJpbmdcIixcbiAgYmFzaWNJbnB1dFZhbGlkOiBcInN0cmluZ1wiLFxuICBiYXNpY0lucHV0SW52YWxpZDogXCJzdHJpbmdcIixcbiAgY2hlY2tib3hWYWxpZDogXCJzdHJpbmdcIixcbiAgY2hlY2tib3hJbnZhbGlkOiBcInN0cmluZ1wiLFxuICByYWRpb1ZhbGlkOiBcInN0cmluZ1wiLFxuICByYWRpb0ludmFsaWQ6IFwic3RyaW5nXCIsXG4gIGxhYmVsVmFsaWQ6IFwic3RyaW5nXCIsXG4gIGxhYmVsSW52YWxpZDogXCJzdHJpbmdcIixcbiAgdmFsaWRGZWVkYmFjazogXCJzdHJpbmdcIixcbiAgaW52YWxpZEZlZWRiYWNrOiBcInN0cmluZ1wiLFxuICBlbGVtZW50VmFsaWRhdGVkOiBcInN0cmluZ1wiXG59O1xuY2xhc3MgQ2ggZXh0ZW5kcyBndCB7XG4gIGNvbnN0cnVjdG9yKHQsIGUsIGkpIHtcbiAgICBzdXBlcih0KSwgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX2VsZW1lbnQgJiYgeS5zZXREYXRhKHQsIGpvLCB0aGlzKSwgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLl9jbGFzc2VzID0gdGhpcy5fZ2V0Q2xhc3NlcyhpKSwgdGhpcy5faXNWYWxpZCA9ICEwLCB0aGlzLl9zaG91bGRBcHBseUlucHV0RXZlbnRzID0gITAsIHRoaXMuX3N1Ym1pdENhbGxiYWNrID0gbnVsbCwgdGhpcy5fZXJyb3JNZXNzYWdlcyA9IHtcbiAgICAgIC4uLklFLFxuICAgICAgLi4udGhpcy5fY29uZmlnLmN1c3RvbUVycm9yTWVzc2FnZXNcbiAgICB9LCB0aGlzLl92YWxpZGF0aW9uRWxlbWVudHMgPSB0aGlzLl9nZXRWYWxpZGF0aW9uRWxlbWVudHMoKSwgdGhpcy5fdmFsaWRhdGlvbkVsZW1lbnRzLmZvckVhY2goKHsgZWxlbWVudDogbiwgaW5wdXQ6IG8gfSkgPT4ge1xuICAgICAgdGhpcy5fY3JlYXRlRmVlZGJhY2tXcmFwcGVyKG4sIG8pO1xuICAgIH0pLCB0aGlzLl92YWxpZGF0aW9uT2JzZXJ2ZXIgPSB0aGlzLl93YXRjaEZvclZhbGlkYXRpb25DaGFuZ2VzKCksIHRoaXMuX3ZhbGlkYXRpb25PYnNlcnZlci5vYnNlcnZlKHRoaXMuX2VsZW1lbnQsIHsgYXR0cmlidXRlczogITAgfSksIHRoaXMuX3N1Ym1pdEJ1dHRvbiA9IG51bGwsIHRoaXMuX2hhbmRsZVN1Ym1pdEJ1dHRvbigpLCB0aGlzLl92YWxpZGF0aW9uUmVzdWx0ID0gW107XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgIHJldHVybiBWRTtcbiAgfVxuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIFBsO1xuICB9XG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gRW87XG4gIH1cbiAgLy8gUHVibGljXG4gIGRpc3Bvc2UoKSB7XG4gICAgdmFyIHQ7XG4gICAgKHQgPSB0aGlzLl92YWxpZGF0aW9uT2JzZXJ2ZXIpID09IG51bGwgfHwgdC5kaXNjb25uZWN0KCksIHRoaXMuX3ZhbGlkYXRpb25PYnNlcnZlciA9IG51bGwsIHRoaXMuX3N1Ym1pdENhbGxiYWNrID0gbnVsbCwgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoT3MpLCB0aGlzLl9yZW1vdmVWYWxpZGF0aW9uVHJhY2VzKCksIHRoaXMuX3ZhbGlkYXRpb25SZXN1bHQgPSBbXSwgdGhpcy5fc3VibWl0QnV0dG9uICYmIGMub2ZmKHRoaXMuX3N1Ym1pdEJ1dHRvbiwgXCJjbGlja1wiKSwgdGhpcy5fY29uZmlnLmFjdGl2ZVZhbGlkYXRpb24gJiYgKHRoaXMuX3ZhbGlkYXRpb25FbGVtZW50cy5mb3JFYWNoKChlKSA9PiB7XG4gICAgICBjb25zdCB7IGlucHV0OiBpIH0gPSBlO1xuICAgICAgYy5vZmYoaSwgXCJpbnB1dFwiKTtcbiAgICB9KSwgdGhpcy5fc2hvdWxkQXBwbHlJbnB1dEV2ZW50cyA9ICEwKTtcbiAgfVxuICAvLyBQcml2YXRlXG4gIF9yZW1vdmVWYWxpZGF0aW9uVHJhY2VzKCkge1xuICAgIHRoaXMuX3JlbW92ZUZlZWRiYWNrV3JhcHBlcigpLCB0aGlzLl92YWxpZGF0aW9uRWxlbWVudHMuZm9yRWFjaCgoeyBlbGVtZW50OiB0LCBjbGFzc2VzOiBlLCBpbml0aWFsSFRNTDogaSB9KSA9PiB7XG4gICAgICB0LmNsYXNzTmFtZSA9IGUsIHQuaW5uZXJIVE1MID0gaSwgdC5yZW1vdmVBdHRyaWJ1dGUoU3MpLCB0LnJlbW92ZUF0dHJpYnV0ZShEcyksIHQucmVtb3ZlQXR0cmlidXRlKENvKTtcbiAgICB9KSwgdGhpcy5fdmFsaWRhdGlvbkVsZW1lbnRzID0gW107XG4gIH1cbiAgX2dldFZhbGlkYXRpb25FbGVtZW50cygpIHtcbiAgICByZXR1cm4gZC5maW5kKFxuICAgICAgTEUsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKS5tYXAoKGUpID0+IHtcbiAgICAgIGNvbnN0IGkgPSBkLmZpbmRPbmUoXCJpbnB1dFwiLCBlKSB8fCBkLmZpbmRPbmUoXCJ0ZXh0YXJlYVwiLCBlKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlkOiBpLm5hbWUgfHwgaS5pZCB8fCBydChcInZhbGlkYXRpb24tXCIpLFxuICAgICAgICBlbGVtZW50OiBlLFxuICAgICAgICB0eXBlOiBlLmdldEF0dHJpYnV0ZShFaCksXG4gICAgICAgIGlucHV0OiBpLFxuICAgICAgICB2YWxpZEZlZWRiYWNrOiBlLmdldEF0dHJpYnV0ZShDbyksXG4gICAgICAgIGludmFsaWRGZWVkYmFjazogZS5nZXRBdHRyaWJ1dGUoRHMpLFxuICAgICAgICBjbGFzc2VzOiBlLmNsYXNzTmFtZSxcbiAgICAgICAgaW5pdGlhbEhUTUw6IGUuaW5uZXJIVE1MLFxuICAgICAgICBydWxlc2V0OiBlLmdldEF0dHJpYnV0ZShSbClcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgX2NyZWF0ZUZlZWRiYWNrV3JhcHBlcih0LCBlKSB7XG4gICAgaWYgKHQucXVlcnlTZWxlY3RvckFsbChgWyR7SXN9XWApLmxlbmd0aCA+IDApXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgaSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgIGkuc2V0QXR0cmlidXRlKElzLCBcIlwiKSwgZS5wYXJlbnROb2RlLmFwcGVuZENoaWxkKGkpO1xuICB9XG4gIF9yZW1vdmVGZWVkYmFja1dyYXBwZXIoKSB7XG4gICAgZC5maW5kKFxuICAgICAgYFske0lzfV1gLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICkuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgZS5yZW1vdmUoKTtcbiAgICB9KTtcbiAgfVxuICBfd2F0Y2hGb3JWYWxpZGF0aW9uQ2hhbmdlcygpIHtcbiAgICByZXR1cm4gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKGUpID0+IHtcbiAgICAgIGUuZm9yRWFjaCgoaSkgPT4ge1xuICAgICAgICBjb25zdCB7IGF0dHJpYnV0ZU5hbWU6IG4gfSA9IGk7XG4gICAgICAgIG4gPT09IE9zICYmICh0aGlzLl9oYW5kbGVWYWxpZGF0aW9uKCksIHRoaXMuX2NvbmZpZy5hY3RpdmVWYWxpZGF0aW9uICYmIHRoaXMuX3Nob3VsZEFwcGx5SW5wdXRFdmVudHMgJiYgdGhpcy5fYXBwbHlJbnB1dEV2ZW50cygpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIF9oYW5kbGVWYWxpZGF0aW9uKCkge1xuICAgIHRoaXMuX2VsZW1lbnQuZ2V0QXR0cmlidXRlKE9zKSAmJiAodGhpcy5fdmFsaWRhdGlvblJlc3VsdCA9IFtdLCB0aGlzLl9pc1ZhbGlkID0gITAsIHRoaXMuX3ZhbGlkYXRpb25FbGVtZW50cy5mb3JFYWNoKFxuICAgICAgKHQpID0+IHRoaXMuX3ZhbGlkYXRlU2luZ2xlRWxlbWVudCh0KVxuICAgICksIHRoaXMuX2VtaXRFdmVudHModGhpcy5faXNWYWxpZCksIHRoaXMuX3N1Ym1pdENhbGxiYWNrICYmIHRoaXMuX3N1Ym1pdENhbGxiYWNrKHRoaXMuX2lzVmFsaWQpKTtcbiAgfVxuICBfdmFsaWRhdGVTaW5nbGVFbGVtZW50KHQpIHtcbiAgICB2YXIgcDtcbiAgICBjb25zdCB7IGVsZW1lbnQ6IGUsIHR5cGU6IGksIGlucHV0OiBuLCBydWxlc2V0OiBvLCBpZDogciB9ID0gdDtcbiAgICBvICYmIHRoaXMuX3ZhbGlkYXRlQnlSdWxlc2V0KHQpO1xuICAgIGNvbnN0IGEgPSBlLmdldEF0dHJpYnV0ZShTcyk7XG4gICAgaWYgKGEgIT09IFwidmFsaWRcIiAmJiBhICE9PSBcImludmFsaWRcIilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBsID0gYS5yZXBsYWNlKFxuICAgICAgYS5jaGFyQXQoMCksXG4gICAgICBhLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpXG4gICAgKTtcbiAgICBpID09PSBcImlucHV0XCIgJiYgdGhpcy5fcmVzdHlsZU5vdGNoZXMoZSwgbCksIGkgPT09IFwiYmFzaWNcIiAmJiB0aGlzLl9yZXN0eWxlQmFzaWNJbnB1dHMobiwgbCksIChpID09PSBcImNoZWNrYm94XCIgfHwgaSA9PT0gXCJyYWRpb1wiKSAmJiB0aGlzLl9yZXN0eWxlQ2hlY2tib3hlcyhuLCBsLCBpKSwgdGhpcy5fcmVzdHlsZUxhYmVscyhlLCBsKSwgYSA9PT0gXCJpbnZhbGlkXCIgJiYgKHRoaXMuX2lzVmFsaWQgPSAhMSksIHRoaXMuX2NvbmZpZy5kaXNhYmxlRmVlZGJhY2sgfHwgdGhpcy5fYXBwbHlGZWVkYmFjayhlLCBhKSwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEhFLCB7XG4gICAgICB2YWx1ZToge1xuICAgICAgICBuYW1lOiByLFxuICAgICAgICByZXN1bHQ6IGEsXG4gICAgICAgIHZhbGlkYXRpb246IChwID0gdGhpcy5fdmFsaWRhdGlvblJlc3VsdFtyXSkgPT0gbnVsbCA/IHZvaWQgMCA6IHAudmFsaWRhdGlvblxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIF92YWxpZGF0ZUJ5UnVsZXNldCh7IGVsZW1lbnQ6IHQsIHR5cGU6IGUsIGludmFsaWRGZWVkYmFjazogaSwgaW5wdXQ6IG4sIGlkOiBvIH0pIHtcbiAgICBjb25zdCByID0gdGhpcy5fZ2V0UnVsZXNldCh0KTtcbiAgICBpZiAoIXIubGVuZ3RoKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGEgPSBlID09PSBcImNoZWNrYm94XCIgfHwgZSA9PT0gXCJyYWRpb1wiID8gbi5jaGVja2VkIDogbi52YWx1ZTtcbiAgICBsZXQgbCA9IFwiXCIsIHAgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHUgb2Ygcikge1xuICAgICAgY29uc3QgXyA9IHUuY2FsbGJhY2soXG4gICAgICAgIGEsXG4gICAgICAgIHRoaXMuX2Vycm9yTWVzc2FnZXNbdS5uYW1lXSB8fCB0aGlzLl9jb25maWcuaW52YWxpZEZlZWRiYWNrLFxuICAgICAgICB1LnBhcmFtZXRlclxuICAgICAgKTtcbiAgICAgIHAucHVzaCh7XG4gICAgICAgIHJlc3VsdDogXyA9PT0gITAsXG4gICAgICAgIG5hbWU6IHUubmFtZSxcbiAgICAgICAgZnVsbE5hbWU6IHUuZnVsbE5hbWVcbiAgICAgIH0pLCB0eXBlb2YgXyA9PSBcInN0cmluZ1wiICYmICFsICYmIChsID0gXyk7XG4gICAgfVxuICAgIGlmICh0aGlzLl92YWxpZGF0aW9uUmVzdWx0W29dID0geyBlbGVtZW50OiB0LCB2YWxpZGF0aW9uOiBwIH0sICFsKSB7XG4gICAgICB0LnNldEF0dHJpYnV0ZShTcywgXCJ2YWxpZFwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdC5zZXRBdHRyaWJ1dGUoU3MsIFwiaW52YWxpZFwiKSwgaSB8fCB0LnNldEF0dHJpYnV0ZShEcywgbCk7XG4gIH1cbiAgX2hhbmRsZUlucHV0Q2hhbmdlKHQpIHtcbiAgICB0aGlzLl92YWxpZGF0ZVNpbmdsZUVsZW1lbnQodCk7XG4gIH1cbiAgX2dldFJ1bGVzZXQodCkge1xuICAgIGNvbnN0IGkgPSB0LmdldEF0dHJpYnV0ZShSbCkuc3BsaXQoXCJ8XCIpO1xuICAgIGxldCBuID0gW107XG4gICAgY29uc3QgbyA9IHtcbiAgICAgIC4uLkRFLFxuICAgICAgLi4udGhpcy5fY29uZmlnLmN1c3RvbVJ1bGVzXG4gICAgfTtcbiAgICByZXR1cm4gaS5mb3JFYWNoKChyKSA9PiB7XG4gICAgICBjb25zdCBhID0gdGhpcy5fZ2V0UnVsZURhdGEociwgbyk7XG4gICAgICBhLmNhbGxiYWNrID8gbi5wdXNoKGEpIDogY29uc29sZS53YXJuKGBSdWxlICR7cn0gZG9lcyBub3QgZXhpc3RgKTtcbiAgICB9KSwgbjtcbiAgfVxuICBfZ2V0UnVsZURhdGEodCwgZSkge1xuICAgIGNvbnN0IGkgPSB0LnNwbGl0KFwiKFwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgY2FsbGJhY2s6IGVbaVswXV0sXG4gICAgICBwYXJhbWV0ZXI6IGlbMV0gPyBpWzFdLnNwbGl0KFwiKVwiKVswXSA6IG51bGwsXG4gICAgICBuYW1lOiBpWzBdLFxuICAgICAgZnVsbE5hbWU6IHRcbiAgICB9O1xuICB9XG4gIF9hcHBseUZlZWRiYWNrKHQsIGUpIHtcbiAgICBjb25zdCBpID0gZC5maW5kT25lKFxuICAgICAgYFske0lzfV1gLFxuICAgICAgdFxuICAgICksIG4gPSB0LmdldEF0dHJpYnV0ZShDbykgfHwgdGhpcy5fY29uZmlnLnZhbGlkRmVlZGJhY2ssIG8gPSB0LmdldEF0dHJpYnV0ZShEcykgfHwgdGhpcy5fY29uZmlnLmludmFsaWRGZWVkYmFjaztcbiAgICBoLmFkZENsYXNzKHQsIHRoaXMuX2NsYXNzZXMuZWxlbWVudFZhbGlkYXRlZCksIGkudGV4dENvbnRlbnQgPSBlID09PSBcInZhbGlkXCIgPyBuIDogbywgaS5jbGFzc05hbWUgPSB0aGlzLl9jbGFzc2VzW2UgPT09IFwidmFsaWRcIiA/IFwidmFsaWRGZWVkYmFja1wiIDogXCJpbnZhbGlkRmVlZGJhY2tcIl07XG4gIH1cbiAgX3Jlc3R5bGVDaGVja2JveGVzKHQsIGUsIGkpIHtcbiAgICBoLnJlbW92ZUNsYXNzKHQsIHRoaXMuX2NsYXNzZXMuY2hlY2tib3hWYWxpZCksIGgucmVtb3ZlQ2xhc3ModCwgdGhpcy5fY2xhc3Nlcy5jaGVja2JveEludmFsaWQpLCBoLmFkZENsYXNzKHQsIHRoaXMuX2NsYXNzZXNbYCR7aX0ke2V9YF0pO1xuICB9XG4gIF9yZXN0eWxlQmFzaWNJbnB1dHModCwgZSkge1xuICAgIGgucmVtb3ZlQ2xhc3ModCwgdGhpcy5fY2xhc3Nlcy5iYXNpY0lucHV0VmFsaWQpLCBoLnJlbW92ZUNsYXNzKHQsIHRoaXMuX2NsYXNzZXMuYmFzaWNJbnB1dEludmFsaWQpLCBoLmFkZENsYXNzKHQsIHRoaXMuX2NsYXNzZXNbYGJhc2ljSW5wdXQke2V9YF0pO1xuICB9XG4gIF9yZXN0eWxlTm90Y2hlcyh0LCBlKSB7XG4gICAgZC5maW5kKE5FLCB0KS5mb3JFYWNoKChuLCBvKSA9PiB7XG4gICAgICBsZXQgciA9IG8gPT09IDAgPyBcIm5vdGNoTGVhZGluZ1wiIDogbyA9PT0gMSA/IFwibm90Y2hNaWRkbGVcIiA6IFwibm90Y2hUcmFpbGluZ1wiO1xuICAgICAgbi5jbGFzc05hbWUgPSBcIlwiLCBoLmFkZENsYXNzKG4sIEtjW3JdKSwgciArPSBlLCBoLmFkZENsYXNzKG4sIHRoaXMuX2NsYXNzZXNbcl0pO1xuICAgIH0pO1xuICB9XG4gIF9yZXN0eWxlTGFiZWxzKHQsIGUpIHtcbiAgICBjb25zdCBpID0gZC5maW5kKFwibGFiZWxcIiwgdCk7XG4gICAgaS5sZW5ndGggJiYgaS5mb3JFYWNoKChuKSA9PiB7XG4gICAgICBoLnJlbW92ZUNsYXNzKG4sIHRoaXMuX2NsYXNzZXMubGFiZWxWYWxpZCksIGgucmVtb3ZlQ2xhc3MobiwgdGhpcy5fY2xhc3Nlcy5sYWJlbEludmFsaWQpLCBoLmFkZENsYXNzKG4sIHRoaXMuX2NsYXNzZXNbYGxhYmVsJHtlfWBdKTtcbiAgICB9KTtcbiAgfVxuICBfZW1pdEV2ZW50cyh0KSB7XG4gICAgaWYgKGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBSRSksIHQpIHtcbiAgICAgIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBQRSwge1xuICAgICAgICB2YWx1ZTogdGhpcy5fdmFsaWRhdGlvblJlc3VsdFxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBCRSwge1xuICAgICAgdmFsdWU6IHRoaXMuX3ZhbGlkYXRpb25SZXN1bHRcbiAgICB9KTtcbiAgfVxuICBfYXBwbHlJbnB1dEV2ZW50cygpIHtcbiAgICB0aGlzLl92YWxpZGF0aW9uRWxlbWVudHMuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgY29uc3QgeyBpbnB1dDogZSB9ID0gdDtcbiAgICAgIGMub24oXG4gICAgICAgIGUsXG4gICAgICAgIFwiaW5wdXRcIixcbiAgICAgICAgKCkgPT4gdGhpcy5faGFuZGxlSW5wdXRDaGFuZ2UodClcbiAgICAgICk7XG4gICAgfSksIHRoaXMuX3Nob3VsZEFwcGx5SW5wdXRFdmVudHMgPSAhMTtcbiAgfVxuICBfaGFuZGxlU3VibWl0QnV0dG9uKCkge1xuICAgIHRoaXMuX3N1Ym1pdEJ1dHRvbiA9IGQuZmluZE9uZShcbiAgICAgIE1FLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICksIHRoaXMuX3N1Ym1pdEJ1dHRvbiAmJiBjLm9uKFxuICAgICAgdGhpcy5fc3VibWl0QnV0dG9uLFxuICAgICAgXCJjbGlja1wiLFxuICAgICAgKHQpID0+IHRoaXMuX2hhbmRsZVN1Ym1pdEJ1dHRvbkNsaWNrKHQpXG4gICAgKTtcbiAgfVxuICBfaGFuZGxlU3VibWl0QnV0dG9uQ2xpY2sodCkge1xuICAgIGlmICh0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShPcywgITApLCB0aGlzLl9jb25maWcuc3VibWl0Q2FsbGJhY2spIHtcbiAgICAgIHRoaXMuX3N1Ym1pdENhbGxiYWNrID0gKGUpID0+IHRoaXMuX2NvbmZpZy5zdWJtaXRDYWxsYmFjayh0LCBlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgX2dldENvbmZpZyh0KSB7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5QbCxcbiAgICAgIC4uLmguZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCksXG4gICAgICAuLi50eXBlb2YgdCA9PSBcIm9iamVjdFwiICYmIHQgPyB0IDoge31cbiAgICB9LCBEKEVvLCB0LCB0aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHRUeXBlKSwgdDtcbiAgfVxuICBfZ2V0Q2xhc3Nlcyh0KSB7XG4gICAgY29uc3QgZSA9IGguZ2V0RGF0YUNsYXNzQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLldFLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBEKEVvLCB0LCBGRSksIHQ7XG4gIH1cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBnZXRJbnN0YW5jZSh0KSB7XG4gICAgcmV0dXJuIHkuZ2V0RGF0YSh0LCBqbyk7XG4gIH1cbiAgc3RhdGljIGdldE9yQ3JlYXRlSW5zdGFuY2UodCwgZSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UodCkgfHwgbmV3IHRoaXModCwgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiA/IGUgOiBudWxsKTtcbiAgfVxuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgZSA9IENoLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcyk7XG4gICAgICBpZiAodHlwZW9mIHQgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAoZVt0XSA9PT0gdm9pZCAwIHx8IHQuc3RhcnRzV2l0aChcIl9cIikgfHwgdCA9PT0gXCJjb25zdHJ1Y3RvclwiKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7dH1cImApO1xuICAgICAgICBlW3RdKHRoaXMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5jbGFzcyBYaSB7XG4gIF9nZXRDb29yZGluYXRlcyh0KSB7XG4gICAgY29uc3QgW2VdID0gdC50b3VjaGVzO1xuICAgIHJldHVybiB7XG4gICAgICB4OiBlLmNsaWVudFgsXG4gICAgICB5OiBlLmNsaWVudFlcbiAgICB9O1xuICB9XG4gIF9nZXREaXJlY3Rpb24oeyB4OiB0LCB5OiBlIH0pIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDoge1xuICAgICAgICBkaXJlY3Rpb246IHQgPCAwID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCIsXG4gICAgICAgIHZhbHVlOiBNYXRoLmFicyh0KVxuICAgICAgfSxcbiAgICAgIHk6IHtcbiAgICAgICAgZGlyZWN0aW9uOiBlIDwgMCA/IFwidXBcIiA6IFwiZG93blwiLFxuICAgICAgICB2YWx1ZTogTWF0aC5hYnMoZSlcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIF9nZXRPcmlnaW4oeyB4OiB0LCB5OiBlIH0sIHsgeDogaSwgeTogbiB9KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHQgLSBpLFxuICAgICAgeTogZSAtIG5cbiAgICB9O1xuICB9XG4gIF9nZXREaXN0YW5jZUJldHdlZW5Ud29Qb2ludHModCwgZSwgaSwgbikge1xuICAgIHJldHVybiBNYXRoLmh5cG90KGUgLSB0LCBuIC0gaSk7XG4gIH1cbiAgX2dldE1pZFBvaW50KHsgeDE6IHQsIHgyOiBlLCB5MTogaSwgeTI6IG4gfSkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiAodCArIGUpIC8gMixcbiAgICAgIHk6IChpICsgbikgLyAyXG4gICAgfTtcbiAgfVxuICBfZ2V0VmVjdG9yTGVuZ3RoKHsgeDE6IHQsIHgyOiBlLCB5MTogaSwgeTI6IG4gfSkge1xuICAgIHJldHVybiBNYXRoLnNxcnQoKGUgLSB0KSAqKiAyICsgKG4gLSBpKSAqKiAyKTtcbiAgfVxuICBfZ2V0UmlnaHRNb3N0VG91Y2godCkge1xuICAgIGxldCBlID0gbnVsbDtcbiAgICBjb25zdCBpID0gTnVtYmVyLk1JTl9WQUxVRTtcbiAgICByZXR1cm4gdC5mb3JFYWNoKChuKSA9PiB7XG4gICAgICBuLmNsaWVudFggPiBpICYmIChlID0gbik7XG4gICAgfSksIGU7XG4gIH1cbiAgX2dldEFuZ2xlKHQsIGUsIGksIG4pIHtcbiAgICByZXR1cm4gTWF0aC5hdGFuMihuIC0gZSwgaSAtIHQpO1xuICB9XG4gIF9nZXRBbmd1bGFyRGlzdGFuY2UodCwgZSkge1xuICAgIHJldHVybiBlIC0gdDtcbiAgfVxuICBfZ2V0Q2VudGVyWFkoeyB4MTogdCwgeDI6IGUsIHkxOiBpLCB5MjogbiB9KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHQgKyAoZSAtIHQpIC8gMixcbiAgICAgIHk6IGkgKyAobiAtIGkpIC8gMlxuICAgIH07XG4gIH1cbiAgX2dldFBpbmNoVG91Y2hPcmlnaW4odCkge1xuICAgIGNvbnN0IFtlLCBpXSA9IHQsIG4gPSB7XG4gICAgICB4MTogZS5jbGllbnRYLFxuICAgICAgeDI6IGkuY2xpZW50WCxcbiAgICAgIHkxOiBlLmNsaWVudFksXG4gICAgICB5MjogaS5jbGllbnRZXG4gICAgfTtcbiAgICByZXR1cm4gW3RoaXMuX2dldFZlY3Rvckxlbmd0aChuKSwgdGhpcy5fZ2V0Q2VudGVyWFkobildO1xuICB9XG4gIF9nZXRQb3NpdGlvbih7IHgxOiB0LCB4MjogZSwgeTE6IGksIHkyOiBuIH0pIHtcbiAgICByZXR1cm4geyB4MTogdCwgeDI6IGUsIHkxOiBpLCB5MjogbiB9O1xuICB9XG59XG5jb25zdCBBbyA9IFwicHJlc3NcIiwgWUUgPSBcInByZXNzdXBcIiwgakUgPSB7XG4gIHRpbWU6IFwibnVtYmVyXCIsXG4gIHBvaW50ZXJzOiBcIm51bWJlclwiXG59LCBLRSA9IHtcbiAgdGltZTogMjUwLFxuICBwb2ludGVyczogMVxufTtcbmNsYXNzIHpFIGV4dGVuZHMgWGkge1xuICBjb25zdHJ1Y3Rvcih0LCBlID0ge30pIHtcbiAgICBzdXBlcigpLCB0aGlzLl9lbGVtZW50ID0gdCwgdGhpcy5fb3B0aW9ucyA9IHRoaXMuX2dldENvbmZpZyhlKSwgdGhpcy5fdGltZXIgPSBudWxsO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBBbztcbiAgfVxuICBoYW5kbGVUb3VjaFN0YXJ0KHQpIHtcbiAgICBjb25zdCB7IHRpbWU6IGUsIHBvaW50ZXJzOiBpIH0gPSB0aGlzLl9vcHRpb25zO1xuICAgIHQudG91Y2hlcy5sZW5ndGggPT09IGkgJiYgKHRoaXMuX3RpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgQW8sIHsgdG91Y2g6IHQsIHRpbWU6IGUgfSksIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBZRSwgeyB0b3VjaDogdCB9KTtcbiAgICB9LCBlKSk7XG4gIH1cbiAgaGFuZGxlVG91Y2hFbmQoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcbiAgfVxuICBfZ2V0Q29uZmlnKHQpIHtcbiAgICBjb25zdCBlID0ge1xuICAgICAgLi4uS0UsXG4gICAgICAuLi5oLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgLi4udFxuICAgIH07XG4gICAgcmV0dXJuIEQoQW8sIGUsIGpFKSwgZTtcbiAgfVxufVxuY29uc3QgVUUgPSBcInN3aXBlXCIsIFhFID0ge1xuICB0aHJlc2hvbGQ6IFwibnVtYmVyXCIsXG4gIGRpcmVjdGlvbjogXCJzdHJpbmdcIlxufSwgR0UgPSB7XG4gIHRocmVzaG9sZDogMTAsXG4gIGRpcmVjdGlvbjogXCJhbGxcIlxufTtcbmNsYXNzIHFFIHtcbiAgY29uc3RydWN0b3IodCwgZSkge1xuICAgIHRoaXMuX2VsZW1lbnQgPSB0LCB0aGlzLl9zdGFydFBvc2l0aW9uID0gbnVsbCwgdGhpcy5fb3B0aW9ucyA9IHRoaXMuX2dldENvbmZpZyhlKTtcbiAgfVxuICBoYW5kbGVUb3VjaFN0YXJ0KHQpIHtcbiAgICB0aGlzLl9zdGFydFBvc2l0aW9uID0gdGhpcy5fZ2V0Q29vcmRpbmF0ZXModCk7XG4gIH1cbiAgaGFuZGxlVG91Y2hNb3ZlKHQpIHtcbiAgICBpZiAoIXRoaXMuX3N0YXJ0UG9zaXRpb24pXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZSA9IHRoaXMuX2dldENvb3JkaW5hdGVzKHQpLCBpID0ge1xuICAgICAgeDogZS54IC0gdGhpcy5fc3RhcnRQb3NpdGlvbi54LFxuICAgICAgeTogZS55IC0gdGhpcy5fc3RhcnRQb3NpdGlvbi55XG4gICAgfSwgbiA9IHRoaXMuX2dldERpcmVjdGlvbihpKTtcbiAgICBpZiAodGhpcy5fb3B0aW9ucy5kaXJlY3Rpb24gPT09IFwiYWxsXCIpIHtcbiAgICAgIGlmIChuLnkudmFsdWUgPCB0aGlzLl9vcHRpb25zLnRocmVzaG9sZCAmJiBuLngudmFsdWUgPCB0aGlzLl9vcHRpb25zLnRocmVzaG9sZClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgciA9IG4ueS52YWx1ZSA+IG4ueC52YWx1ZSA/IG4ueS5kaXJlY3Rpb24gOiBuLnguZGlyZWN0aW9uO1xuICAgICAgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGBzd2lwZSR7cn1gLCB7IHRvdWNoOiB0IH0pLCBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgXCJzd2lwZVwiLCB7IHRvdWNoOiB0LCBkaXJlY3Rpb246IHIgfSksIHRoaXMuX3N0YXJ0UG9zaXRpb24gPSBudWxsO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBvID0gdGhpcy5fb3B0aW9ucy5kaXJlY3Rpb24gPT09IFwibGVmdFwiIHx8IHRoaXMuX29wdGlvbnMgPT09IFwicmlnaHRcIiA/IFwieFwiIDogXCJ5XCI7XG4gICAgbltvXS5kaXJlY3Rpb24gPT09IHRoaXMuX29wdGlvbnMuZGlyZWN0aW9uICYmIG5bb10udmFsdWUgPiB0aGlzLl9vcHRpb25zLnRocmVzaG9sZCAmJiAoYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGBzd2lwZSR7bltvXS5kaXJlY3Rpb259YCwge1xuICAgICAgdG91Y2g6IHRcbiAgICB9KSwgdGhpcy5fc3RhcnRQb3NpdGlvbiA9IG51bGwpO1xuICB9XG4gIGhhbmRsZVRvdWNoRW5kKCkge1xuICAgIHRoaXMuX3N0YXJ0UG9zaXRpb24gPSBudWxsO1xuICB9XG4gIF9nZXRDb29yZGluYXRlcyh0KSB7XG4gICAgY29uc3QgW2VdID0gdC50b3VjaGVzO1xuICAgIHJldHVybiB7XG4gICAgICB4OiBlLmNsaWVudFgsXG4gICAgICB5OiBlLmNsaWVudFlcbiAgICB9O1xuICB9XG4gIF9nZXREaXJlY3Rpb24odCkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiB7XG4gICAgICAgIGRpcmVjdGlvbjogdC54IDwgMCA/IFwibGVmdFwiIDogXCJyaWdodFwiLFxuICAgICAgICB2YWx1ZTogTWF0aC5hYnModC54KVxuICAgICAgfSxcbiAgICAgIHk6IHtcbiAgICAgICAgZGlyZWN0aW9uOiB0LnkgPCAwID8gXCJ1cFwiIDogXCJkb3duXCIsXG4gICAgICAgIHZhbHVlOiBNYXRoLmFicyh0LnkpXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBfZ2V0Q29uZmlnKHQpIHtcbiAgICBjb25zdCBlID0ge1xuICAgICAgLi4uR0UsXG4gICAgICAuLi5oLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgLi4udFxuICAgIH07XG4gICAgcmV0dXJuIEQoVUUsIGUsIFhFKSwgZTtcbiAgfVxufVxuY29uc3QgcXQgPSBcInBhblwiLCBaRSA9IGAke3F0fXN0YXJ0YCwgUUUgPSBgJHtxdH1lbmRgLCBKRSA9IGAke3F0fW1vdmVgLCB0MCA9IFwibGVmdFwiLCBlMCA9IFwicmlnaHRcIiwgaTAgPSB7XG4gIHRocmVzaG9sZDogXCJudW1iZXJcIixcbiAgZGlyZWN0aW9uOiBcInN0cmluZ1wiLFxuICBwb2ludGVyczogXCJudW1iZXJcIlxufSwgczAgPSB7XG4gIHRocmVzaG9sZDogMjAsXG4gIGRpcmVjdGlvbjogXCJhbGxcIixcbiAgcG9pbnRlcnM6IDFcbn07XG5jbGFzcyBuMCBleHRlbmRzIFhpIHtcbiAgY29uc3RydWN0b3IodCwgZSA9IHt9KSB7XG4gICAgc3VwZXIoKSwgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX29wdGlvbnMgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX3N0YXJ0VG91Y2ggPSBudWxsO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBxdDtcbiAgfVxuICBoYW5kbGVUb3VjaFN0YXJ0KHQpIHtcbiAgICB0aGlzLl9zdGFydFRvdWNoID0gdGhpcy5fZ2V0Q29vcmRpbmF0ZXModCksIHRoaXMuX21vdmVkVG91Y2ggPSB0LCBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgWkUsIHsgdG91Y2g6IHQgfSk7XG4gIH1cbiAgaGFuZGxlVG91Y2hNb3ZlKHQpIHtcbiAgICB0LnR5cGUgPT09IFwidG91Y2htb3ZlXCIgJiYgdC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGNvbnN0IHsgdGhyZXNob2xkOiBlLCBkaXJlY3Rpb246IGkgfSA9IHRoaXMuX29wdGlvbnMsIG4gPSB0aGlzLl9nZXRDb29yZGluYXRlcyh0KSwgbyA9IHRoaXMuX2dldENvb3JkaW5hdGVzKHRoaXMuX21vdmVkVG91Y2gpLCByID0gdGhpcy5fZ2V0T3JpZ2luKG4sIHRoaXMuX3N0YXJ0VG91Y2gpLCBhID0gdGhpcy5fZ2V0T3JpZ2luKG4sIG8pLCBsID0gdGhpcy5fZ2V0RGlyZWN0aW9uKHIpLCBwID0gdGhpcy5fZ2V0RGlyZWN0aW9uKGEpLCB7IHg6IHUsIHk6IF8gfSA9IGw7XG4gICAgaWYgKGkgPT09IFwiYWxsXCIgJiYgKF8udmFsdWUgPiBlIHx8IHUudmFsdWUgPiBlKSkge1xuICAgICAgY29uc3QgZyA9IF8udmFsdWUgPiB1LnZhbHVlID8gXy5kaXJlY3Rpb24gOiB1LmRpcmVjdGlvbjtcbiAgICAgIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBgJHtxdH0ke2d9YCwgeyB0b3VjaDogdCB9KSwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHF0LCB7XG4gICAgICAgIC4uLmEsXG4gICAgICAgIHRvdWNoOiB0XG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgZiA9IGkgPT09IHQwIHx8IGkgPT09IGUwID8gXCJ4XCIgOiBcInlcIjtcbiAgICBwW2ZdLmRpcmVjdGlvbiA9PT0gaSAmJiBsW2ZdLnZhbHVlID4gZSAmJiBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgYCR7cXR9JHtpfWAsIHtcbiAgICAgIHRvdWNoOiB0LFxuICAgICAgW2ZdOiBuW2ZdIC0gb1tmXVxuICAgIH0pLCB0aGlzLl9tb3ZlZFRvdWNoID0gdCwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEpFLCB7IHRvdWNoOiB0IH0pO1xuICB9XG4gIGhhbmRsZVRvdWNoRW5kKHQpIHtcbiAgICB0LnR5cGUgPT09IFwidG91Y2hlbmRcIiAmJiB0LnByZXZlbnREZWZhdWx0KCksIHRoaXMuX21vdmVkVG91Y2ggPSBudWxsLCB0aGlzLl9zdGFydFRvdWNoID0gbnVsbCwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIFFFLCB7IHRvdWNoOiB0IH0pO1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIGNvbnN0IGUgPSB7XG4gICAgICAuLi5zMCxcbiAgICAgIC4uLmguZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCksXG4gICAgICAuLi50XG4gICAgfTtcbiAgICByZXR1cm4gRChxdCwgZSwgaTApLCBlO1xuICB9XG59XG5jb25zdCBZZSA9IFwicGluY2hcIiwgbzAgPSBgJHtZZX1lbmRgLCByMCA9IGAke1llfXN0YXJ0YCwgYTAgPSBgJHtZZX1tb3ZlYCwgbDAgPSB7XG4gIHRocmVzaG9sZDogXCJudW1iZXJcIixcbiAgcG9pbnRlcnM6IFwibnVtYmVyXCJcbn0sIGMwID0ge1xuICB0aHJlc2hvbGQ6IDEwLFxuICBwb2ludGVyczogMlxufTtcbmNsYXNzIGgwIGV4dGVuZHMgWGkge1xuICBjb25zdHJ1Y3Rvcih0LCBlID0ge30pIHtcbiAgICBzdXBlcigpLCB0aGlzLl9lbGVtZW50ID0gdCwgdGhpcy5fb3B0aW9ucyA9IHRoaXMuX2dldENvbmZpZyhlKSwgdGhpcy5fc3RhcnRUb3VjaCA9IG51bGwsIHRoaXMuX29yaWdpbiA9IG51bGwsIHRoaXMuX3RvdWNoID0gbnVsbCwgdGhpcy5fbWF0aCA9IG51bGwsIHRoaXMuX3JhdGlvID0gbnVsbDtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gWWU7XG4gIH1cbiAgZ2V0IGlzTnVtYmVyKCkge1xuICAgIHJldHVybiB0eXBlb2YgdGhpcy5fc3RhcnRUb3VjaCA9PSBcIm51bWJlclwiICYmIHR5cGVvZiB0aGlzLl90b3VjaCA9PSBcIm51bWJlclwiICYmIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHNcbiAgICAhaXNOYU4odGhpcy5fc3RhcnRUb3VjaCkgJiYgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtZ2xvYmFsc1xuICAgICFpc05hTih0aGlzLl90b3VjaCk7XG4gIH1cbiAgaGFuZGxlVG91Y2hTdGFydCh0KSB7XG4gICAgaWYgKHQudG91Y2hlcy5sZW5ndGggIT09IHRoaXMuX29wdGlvbnMucG9pbnRlcnMpXG4gICAgICByZXR1cm47XG4gICAgdC50eXBlID09PSBcInRvdWNoc3RhcnRcIiAmJiB0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgY29uc3QgW2UsIGldID0gdGhpcy5fZ2V0UGluY2hUb3VjaE9yaWdpbih0LnRvdWNoZXMpO1xuICAgIHRoaXMuX3RvdWNoID0gZSwgdGhpcy5fb3JpZ2luID0gaSwgdGhpcy5fc3RhcnRUb3VjaCA9IHRoaXMuX3RvdWNoLCBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgcjAsIHtcbiAgICAgIHRvdWNoOiB0LFxuICAgICAgcmF0aW86IHRoaXMuX3JhdGlvLFxuICAgICAgb3JpZ2luOiB0aGlzLl9vcmlnaW5cbiAgICB9KTtcbiAgfVxuICBoYW5kbGVUb3VjaE1vdmUodCkge1xuICAgIGNvbnN0IHsgdGhyZXNob2xkOiBlLCBwb2ludGVyczogaSB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICB0LnRvdWNoZXMubGVuZ3RoID09PSBpICYmICh0LnR5cGUgPT09IFwidG91Y2htb3ZlXCIgJiYgdC5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLl90b3VjaCA9IHRoaXMuX2dldFBpbmNoVG91Y2hPcmlnaW4odC50b3VjaGVzKVswXSwgdGhpcy5fcmF0aW8gPSB0aGlzLl90b3VjaCAvIHRoaXMuX3N0YXJ0VG91Y2gsIHRoaXMuaXNOdW1iZXIgJiYgKHRoaXMuX29yaWdpbi54ID4gZSB8fCB0aGlzLl9vcmlnaW4ueSA+IGUpICYmICh0aGlzLl9zdGFydFRvdWNoID0gdGhpcy5fdG91Y2gsIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBZZSwge1xuICAgICAgdG91Y2g6IHQsXG4gICAgICByYXRpbzogdGhpcy5fcmF0aW8sXG4gICAgICBvcmlnaW46IHRoaXMuX29yaWdpblxuICAgIH0pLCBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgYTAsIHtcbiAgICAgIHRvdWNoOiB0LFxuICAgICAgcmF0aW86IHRoaXMuX3JhdGlvLFxuICAgICAgb3JpZ2luOiB0aGlzLl9vcmlnaW5cbiAgICB9KSkpO1xuICB9XG4gIGhhbmRsZVRvdWNoRW5kKHQpIHtcbiAgICB0aGlzLmlzTnVtYmVyICYmICh0aGlzLl9zdGFydFRvdWNoID0gbnVsbCwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIG8wLCB7XG4gICAgICB0b3VjaDogdCxcbiAgICAgIHJhdGlvOiB0aGlzLl9yYXRpbyxcbiAgICAgIG9yaWdpbjogdGhpcy5fb3JpZ2luXG4gICAgfSkpO1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIGNvbnN0IGUgPSB7XG4gICAgICAuLi5jMCxcbiAgICAgIC4uLmguZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCksXG4gICAgICAuLi50XG4gICAgfTtcbiAgICByZXR1cm4gRChZZSwgZSwgbDApLCBlO1xuICB9XG59XG5jb25zdCB5byA9IFwidGFwXCIsIGQwID0ge1xuICBpbnRlcnZhbDogXCJudW1iZXJcIixcbiAgdGltZTogXCJudW1iZXJcIixcbiAgdGFwczogXCJudW1iZXJcIixcbiAgcG9pbnRlcnM6IFwibnVtYmVyXCJcbn0sIHUwID0ge1xuICBpbnRlcnZhbDogNTAwLFxuICB0aW1lOiAyNTAsXG4gIHRhcHM6IDEsXG4gIHBvaW50ZXJzOiAxXG59O1xuY2xhc3MgcDAgZXh0ZW5kcyBYaSB7XG4gIGNvbnN0cnVjdG9yKHQsIGUpIHtcbiAgICBzdXBlcigpLCB0aGlzLl9lbGVtZW50ID0gdCwgdGhpcy5fb3B0aW9ucyA9IHRoaXMuX2dldENvbmZpZyhlKSwgdGhpcy5fdGltZXIgPSBudWxsLCB0aGlzLl90YXBDb3VudCA9IDA7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIHlvO1xuICB9XG4gIGhhbmRsZVRvdWNoU3RhcnQodCkge1xuICAgIGNvbnN0IHsgeDogZSwgeTogaSB9ID0gdGhpcy5fZ2V0Q29vcmRpbmF0ZXModCksIHsgaW50ZXJ2YWw6IG4sIHRhcHM6IG8sIHBvaW50ZXJzOiByIH0gPSB0aGlzLl9vcHRpb25zO1xuICAgIHJldHVybiB0LnRvdWNoZXMubGVuZ3RoID09PSByICYmICh0aGlzLl90YXBDb3VudCArPSAxLCB0aGlzLl90YXBDb3VudCA9PT0gMSAmJiAodGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuX3RhcENvdW50ID0gMDtcbiAgICB9LCBuKSksIHRoaXMuX3RhcENvdW50ID09PSBvICYmIChjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpLCB0aGlzLl90YXBDb3VudCA9IDAsIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCB5bywge1xuICAgICAgdG91Y2g6IHQsXG4gICAgICBvcmlnaW46IHtcbiAgICAgICAgeDogZSxcbiAgICAgICAgeTogaVxuICAgICAgfVxuICAgIH0pKSksIHQ7XG4gIH1cbiAgaGFuZGxlVG91Y2hFbmQoKSB7XG4gIH1cbiAgaGFuZGxlVG91Y2hNb3ZlKCkge1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIGNvbnN0IGUgPSB7XG4gICAgICAuLi51MCxcbiAgICAgIC4uLmguZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCksXG4gICAgICAuLi50XG4gICAgfTtcbiAgICByZXR1cm4gRCh5bywgZSwgZDApLCBlO1xuICB9XG59XG5jb25zdCBNaSA9IFwicm90YXRlXCIsIF8wID0gYCR7TWl9ZW5kYCwgZjAgPSBgJHtNaX1zdGFydGAsIG0wID0ge1xuICBhbmdsZTogXCJudW1iZXJcIixcbiAgcG9pbnRlcnM6IFwibnVtYmVyXCJcbn0sIGcwID0ge1xuICBhbmdsZTogMCxcbiAgcG9pbnRlcnM6IDJcbn07XG5jbGFzcyBiMCBleHRlbmRzIFhpIHtcbiAgY29uc3RydWN0b3IodCwgZSkge1xuICAgIHN1cGVyKCksIHRoaXMuX2VsZW1lbnQgPSB0LCB0aGlzLl9vcHRpb25zID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLl9vcmlnaW4gPSB7fTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gTWk7XG4gIH1cbiAgaGFuZGxlVG91Y2hTdGFydCh0KSB7XG4gICAgdC50eXBlID09PSBcInRvdWNoc3RhcnRcIiAmJiB0LnByZXZlbnREZWZhdWx0KCksICEodC50b3VjaGVzLmxlbmd0aCA8IDIpICYmICh0aGlzLl9zdGFydFRvdWNoID0gdCwgdGhpcy5fb3JpZ2luID0ge30sIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBmMCwgeyB0b3VjaDogdCB9KSk7XG4gIH1cbiAgaGFuZGxlVG91Y2hNb3ZlKHQpIHtcbiAgICB0LnR5cGUgPT09IFwidG91Y2htb3ZlXCIgJiYgdC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGxldCBlLCBpO1xuICAgIGNvbnN0IG4gPSB0LnRvdWNoZXM7XG4gICAgaWYgKG4ubGVuZ3RoID09PSAxICYmIHRoaXMuX29wdGlvbnMucG9pbnRlcnMgPT09IDEpIHtcbiAgICAgIGNvbnN0IHsgbGVmdDogbywgdG9wOiByLCB3aWR0aDogYSwgaGVpZ2h0OiBsIH0gPSB0aGlzLl9lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgZSA9IHtcbiAgICAgICAgeDogbyArIGEgLyAyLFxuICAgICAgICB5OiByICsgbCAvIDJcbiAgICAgIH0sIGkgPSBuWzBdO1xuICAgIH0gZWxzZSBpZiAodC50b3VjaGVzLmxlbmd0aCA9PT0gMiAmJiB0aGlzLl9vcHRpb25zLnBvaW50ZXJzID09PSAyKSB7XG4gICAgICBjb25zdCBbbywgcl0gPSB0LnRvdWNoZXMsIGEgPSB7XG4gICAgICAgIHgxOiByLmNsaWVudFgsXG4gICAgICAgIHgyOiBvLmNsaWVudFgsXG4gICAgICAgIHkxOiByLmNsaWVudFksXG4gICAgICAgIHkyOiBvLmNsaWVudFlcbiAgICAgIH07XG4gICAgICBlID0gdGhpcy5fZ2V0TWlkUG9pbnQoYSksIGkgPSB0aGlzLl9nZXRSaWdodE1vc3RUb3VjaCh0LnRvdWNoZXMpO1xuICAgIH0gZWxzZVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuY3VycmVudEFuZ2xlID0gdGhpcy5fZ2V0QW5nbGUoXG4gICAgICBlLngsXG4gICAgICBlLnksXG4gICAgICBpLmNsaWVudFgsXG4gICAgICBpLmNsaWVudFlcbiAgICApLCB0aGlzLl9vcmlnaW4uaW5pdGlhbEFuZ2xlID8gKHRoaXMuX29yaWdpbi5jaGFuZ2UgPSB0aGlzLl9nZXRBbmd1bGFyRGlzdGFuY2UoXG4gICAgICB0aGlzLl9vcmlnaW4ucHJldmlvdXNBbmdsZSxcbiAgICAgIHRoaXMuY3VycmVudEFuZ2xlXG4gICAgKSwgdGhpcy5fb3JpZ2luLmRpc3RhbmNlICs9IHRoaXMuX29yaWdpbi5jaGFuZ2UpIDogKHRoaXMuX29yaWdpbi5pbml0aWFsQW5nbGUgPSB0aGlzLl9vcmlnaW4ucHJldmlvdXNBbmdsZSA9IHRoaXMuY3VycmVudEFuZ2xlLCB0aGlzLl9vcmlnaW4uZGlzdGFuY2UgPSB0aGlzLl9vcmlnaW4uY2hhbmdlID0gMCksIHRoaXMuX29yaWdpbi5wcmV2aW91c0FuZ2xlID0gdGhpcy5jdXJyZW50QW5nbGUsIHRoaXMucm90YXRlID0ge1xuICAgICAgY3VycmVudEFuZ2xlOiB0aGlzLmN1cnJlbnRBbmdsZSxcbiAgICAgIGRpc3RhbmNlOiB0aGlzLl9vcmlnaW4uZGlzdGFuY2UsXG4gICAgICBjaGFuZ2U6IHRoaXMuX29yaWdpbi5jaGFuZ2VcbiAgICB9LCBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgTWksIHsgLi4udGhpcy5yb3RhdGUsIHRvdWNoOiB0IH0pO1xuICB9XG4gIGhhbmRsZVRvdWNoRW5kKHQpIHtcbiAgICB0LnR5cGUgPT09IFwidG91Y2hlbmRcIiAmJiB0LnByZXZlbnREZWZhdWx0KCksIHRoaXMuX29yaWdpbiA9IHt9LCBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgXzAsIHsgdG91Y2g6IHQgfSk7XG4gIH1cbiAgX2dldENvbmZpZyh0KSB7XG4gICAgY29uc3QgZSA9IHtcbiAgICAgIC4uLmcwLFxuICAgICAgLi4uaC5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KSxcbiAgICAgIC4uLnRcbiAgICB9O1xuICAgIHJldHVybiBEKE1pLCBlLCBtMCksIGU7XG4gIH1cbn1cbmNvbnN0IEtvID0gXCJ0b3VjaFwiLCB3byA9IGB0ZS4ke0tvfWAsIHYwID0ge1xuICBldmVudDogXCJzdHJpbmdcIlxufSwgVDAgPSB7XG4gIGV2ZW50OiBcInN3aXBlXCJcbn07XG5jbGFzcyBBaCB7XG4gIGNvbnN0cnVjdG9yKHQsIGUgPSB7fSkge1xuICAgIHRoaXMuX2VsZW1lbnQgPSB0LCB0aGlzLl9vcHRpb25zID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLl9ldmVudCA9IHRoaXMuX29wdGlvbnMuZXZlbnQsIHRoaXMuc3dpcGUgPSB0aGlzLl9ldmVudCA9PT0gXCJzd2lwZVwiID8gbmV3IHFFKHQsIGUpIDogbnVsbCwgdGhpcy5wcmVzcyA9IHRoaXMuX2V2ZW50ID09PSBcInByZXNzXCIgPyBuZXcgekUodCwgZSkgOiBudWxsLCB0aGlzLnBhbiA9IHRoaXMuX2V2ZW50ID09PSBcInBhblwiID8gbmV3IG4wKHQsIGUpIDogbnVsbCwgdGhpcy5waW5jaCA9IHRoaXMuX2V2ZW50ID09PSBcInBpbmNoXCIgPyBuZXcgaDAodCwgZSkgOiBudWxsLCB0aGlzLnRhcCA9IHRoaXMuX2V2ZW50ID09PSBcInRhcFwiID8gbmV3IHAwKHQsIGUpIDogbnVsbCwgdGhpcy5yb3RhdGUgPSB0aGlzLl9ldmVudCA9PT0gXCJyb3RhdGVcIiA/IG5ldyBiMCh0LCBlKSA6IG51bGwsIHRoaXMuX3RvdWNoU3RhcnRIYW5kbGVyID0gKGkpID0+IHRoaXMuX2hhbmRsZVRvdWNoU3RhcnQoaSksIHRoaXMuX3RvdWNoTW92ZUhhbmRsZXIgPSAoaSkgPT4gdGhpcy5faGFuZGxlVG91Y2hNb3ZlKGkpLCB0aGlzLl90b3VjaEVuZEhhbmRsZXIgPSAoaSkgPT4gdGhpcy5faGFuZGxlVG91Y2hFbmQoaSksIGMub24odGhpcy5fZWxlbWVudCwgXCJ0b3VjaHN0YXJ0XCIsIHRoaXMuX3RvdWNoU3RhcnRIYW5kbGVyKSwgYy5vbih0aGlzLl9lbGVtZW50LCBcInRvdWNobW92ZVwiLCB0aGlzLl90b3VjaE1vdmVIYW5kbGVyKSwgYy5vbih0aGlzLl9lbGVtZW50LCBcInRvdWNoZW5kXCIsIHRoaXMuX3RvdWNoRW5kSGFuZGxlciksIHRoaXMuX2VsZW1lbnQgJiYgeS5zZXREYXRhKHQsIHdvLCB0aGlzKTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gS287XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICBjLm9mZih0aGlzLl9lbGVtZW50LCBcInRvdWNoc3RhcnRcIiwgdGhpcy5fdG91Y2hTdGFydEhhbmRsZXIpLCBjLm9mZih0aGlzLl9lbGVtZW50LCBcInRvdWNobW92ZVwiLCB0aGlzLl90b3VjaE1vdmVIYW5kbGVyKSwgYy5vZmYodGhpcy5fZWxlbWVudCwgXCJ0b3VjaGVuZFwiLCB0aGlzLl90b3VjaEVuZEhhbmRsZXIpLCB0aGlzLnN3aXBlID0gbnVsbCwgdGhpcy5wcmVzcyA9IG51bGwsIHRoaXMucGFuID0gbnVsbCwgdGhpcy5waW5jaCA9IG51bGwsIHRoaXMudGFwID0gbnVsbCwgdGhpcy5yb3RhdGUgPSBudWxsO1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIGNvbnN0IGUgPSB7XG4gICAgICAuLi5UMCxcbiAgICAgIC4uLmguZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCksXG4gICAgICAuLi50XG4gICAgfTtcbiAgICByZXR1cm4gRChLbywgZSwgdjApLCBlO1xuICB9XG4gIF9oYW5kbGVUb3VjaFN0YXJ0KHQpIHtcbiAgICB0aGlzW3RoaXMuX2V2ZW50XS5oYW5kbGVUb3VjaFN0YXJ0KHQpO1xuICB9XG4gIF9oYW5kbGVUb3VjaE1vdmUodCkge1xuICAgIHRoaXNbdGhpcy5fZXZlbnRdLmhhbmRsZVRvdWNoTW92ZSAmJiB0aGlzW3RoaXMuX2V2ZW50XS5oYW5kbGVUb3VjaE1vdmUodCk7XG4gIH1cbiAgX2hhbmRsZVRvdWNoRW5kKHQpIHtcbiAgICB0aGlzW3RoaXMuX2V2ZW50XS5oYW5kbGVUb3VjaEVuZCh0KTtcbiAgfVxuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgbGV0IGUgPSB5LmdldERhdGEodGhpcywgd28pO1xuICAgICAgY29uc3QgaSA9IHR5cGVvZiB0ID09IFwib2JqZWN0XCIgJiYgdDtcbiAgICAgIGlmICghKCFlICYmIC9kaXNwb3NlLy50ZXN0KHQpKSAmJiAoZSB8fCAoZSA9IG5ldyBBaCh0aGlzLCBpKSksIHR5cGVvZiB0ID09IFwic3RyaW5nXCIpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZVt0XSA+IFwidVwiKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7dH1cImApO1xuICAgICAgICByZXR1cm4gZVt0XTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZ2V0SW5zdGFuY2UodCkge1xuICAgIHJldHVybiB5LmdldERhdGEodCwgd28pO1xuICB9XG4gIHN0YXRpYyBnZXRPckNyZWF0ZUluc3RhbmNlKHQsIGUgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKHQpIHx8IG5ldyB0aGlzKHQsIHR5cGVvZiBlID09IFwib2JqZWN0XCIgPyBlIDogbnVsbCk7XG4gIH1cbn1cbmNvbnN0IHpvID0gXCJzbW9vdGhTY3JvbGxcIiwgeWkgPSBgdGUuJHt6b31gLCBtciA9IGAuJHt5aX1gLCBFMCA9IHtcbiAgY29udGFpbmVyOiBcInN0cmluZ1wiLFxuICBvZmZzZXQ6IFwibnVtYmVyXCIsXG4gIGVhc2luZzogXCJzdHJpbmdcIixcbiAgZHVyYXRpb246IFwibnVtYmVyXCJcbn0sIEMwID0ge1xuICBjb250YWluZXI6IFwiYm9keVwiLFxuICBvZmZzZXQ6IDAsXG4gIGVhc2luZzogXCJsaW5lYXJcIixcbiAgZHVyYXRpb246IDUwMFxufSwgQTAgPSBgc2Nyb2xsU3RhcnQke21yfWAsIHkwID0gYHNjcm9sbEVuZCR7bXJ9YCwgdzAgPSBgc2Nyb2xsQ2FuY2VsJHttcn1gO1xuY2xhc3MgeWgge1xuICBjb25zdHJ1Y3Rvcih0LCBlID0ge30pIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gdCwgdGhpcy5fb3B0aW9ucyA9IHRoaXMuX2dldENvbmZpZyhlKSwgdGhpcy5faHJlZiA9IHRoaXMuX2VsZW1lbnQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSwgdGhpcy5pc0NhbmNlbCA9ICExLCB0aGlzLl9lbGVtZW50ICYmICh5LnNldERhdGEodCwgeWksIHRoaXMpLCB0aGlzLl9zZXR1cCgpKTtcbiAgfVxuICAvLyBnZXR0ZXJzXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gem87XG4gIH1cbiAgZ2V0IGlzV2luZG93KCkge1xuICAgIHJldHVybiB0aGlzLl9vcHRpb25zLmNvbnRhaW5lciA9PT0gXCJib2R5XCI7XG4gIH1cbiAgZ2V0IGNvbnRhaW5lclRvU2Nyb2xsKCkge1xuICAgIHJldHVybiB0aGlzLmlzV2luZG93ID8gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IDogZC5maW5kT25lKFxuICAgICAgdGhpcy5fb3B0aW9ucy5jb250YWluZXIsXG4gICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnRcbiAgICApO1xuICB9XG4gIGdldCBlbEZyb21IcmVmRXhpc3QoKSB7XG4gICAgcmV0dXJuICEhZC5maW5kT25lKHRoaXMuX2hyZWYsIHRoaXMuY29udGFpbmVyVG9TY3JvbGwpO1xuICB9XG4gIGdldCBvZmZzZXRGcm9tRWwoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuY29udGFpbmVyVG9TY3JvbGwuc2Nyb2xsVG9wLCBlID0gZC5maW5kT25lKHRoaXMuX2hyZWYsIHRoaXMuY29udGFpbmVyVG9TY3JvbGwpO1xuICAgIGlmICh0aGlzLmlzV2luZG93KVxuICAgICAgcmV0dXJuIGgub2Zmc2V0KGUpLnRvcCAtIHRoaXMuX29wdGlvbnMub2Zmc2V0ICsgdDtcbiAgICBjb25zdCBpID0gZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS55LCBuID0gdGhpcy5jb250YWluZXJUb1Njcm9sbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS55O1xuICAgIHJldHVybiBpIC0gbiAtIHRoaXMuX29wdGlvbnMub2Zmc2V0ICsgdDtcbiAgfVxuICBnZXQgZWFzaW5nRnVuY3Rpb24oKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX29wdGlvbnMuZWFzaW5nLCBlID0gYF9tb3Rpb24ke3RbMF0udG9VcHBlckNhc2UoKX0ke3Quc2xpY2UoMSl9YDtcbiAgICByZXR1cm4gdGhpc1tlXSA/IHRoaXNbZV0gOiB0aGlzLl9tb3Rpb25MaW5lYXI7XG4gIH1cbiAgLy8gcHVibGljXG4gIGRpc3Bvc2UoKSB7XG4gICAgYy5vZmYodGhpcy5fZWxlbWVudCwgXCJjbGlja1wiLCB0aGlzLl9oYW5kbGVDbGljayksIHkucmVtb3ZlRGF0YSh0aGlzLl9lbGVtZW50LCB5aSksIHRoaXMuX2VsZW1lbnQgPSBudWxsO1xuICB9XG4gIGNhbmNlbFNjcm9sbCgpIHtcbiAgICB0aGlzLmlzQ2FuY2VsID0gITA7XG4gIH1cbiAgLy8gcHJpdmF0ZVxuICBfZ2V0Q29uZmlnKHQpIHtcbiAgICBjb25zdCBlID0ge1xuICAgICAgLi4uQzAsXG4gICAgICAuLi5oLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgLi4udFxuICAgIH07XG4gICAgcmV0dXJuIEQoem8sIGUsIEUwKSwgZTtcbiAgfVxuICBfaW5WaWV3cG9ydCgpIHtcbiAgICBpZiAodGhpcy5pc1dpbmRvdylcbiAgICAgIHJldHVybiAhMDtcbiAgICBjb25zdCB0ID0gdGhpcy5jb250YWluZXJUb1Njcm9sbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4gdC50b3AgPj0gMCAmJiB0LmJvdHRvbSA8PSAod2luZG93LmlubmVySGVpZ2h0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQpO1xuICB9XG4gIF9zZXR1cCgpIHtcbiAgICBjb25zdCB0ID0gdHlwZW9mIHRoaXMuX2hyZWYgPCBcInVcIiwgZSA9IHRoaXMuX2hyZWYuaW5jbHVkZXMoXCIjXCIpO1xuICAgIHQgJiYgZSAmJiB0aGlzLmVsRnJvbUhyZWZFeGlzdCAmJiAodGhpcy5fc2Nyb2xsT25DbGlja0V2ZW50KCksIHRoaXMuX3ByZXZlbnROYXRpdmVTY3JvbGwoKSk7XG4gIH1cbiAgX3Njcm9sbE9uQ2xpY2tFdmVudCgpIHtcbiAgICBjLm9uKHRoaXMuX2VsZW1lbnQsIFwiY2xpY2tcIiwgKHQpID0+IHtcbiAgICAgIHRoaXMuX2hhbmRsZUNsaWNrKHQpO1xuICAgIH0pO1xuICB9XG4gIF9oYW5kbGVDbGljayh0KSB7XG4gICAgdC5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLmlzQ2FuY2VsID0gITEsIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBBMCk7XG4gICAgY29uc3QgZSA9IHRoaXMuY29udGFpbmVyVG9TY3JvbGwsIGkgPSB0aGlzLmNvbnRhaW5lclRvU2Nyb2xsLnNjcm9sbFRvcCwgbiA9IHRoaXMub2Zmc2V0RnJvbUVsLCBvID0gMCwgciA9IDEgLyB0aGlzLl9vcHRpb25zLmR1cmF0aW9uLCBhID0gNC4yNSwgbCA9IHRoaXMuZWFzaW5nRnVuY3Rpb247XG4gICAgdGhpcy5faW5WaWV3cG9ydCgpID8gdGhpcy5fc2Nyb2xsT25OZXh0VGljayhcbiAgICAgIGUsXG4gICAgICBpLFxuICAgICAgbixcbiAgICAgIG8sXG4gICAgICByLFxuICAgICAgYSxcbiAgICAgIGxcbiAgICApIDogKHRoaXMuX3Njcm9sbE9uTmV4dFRpY2soXG4gICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXG4gICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wLFxuICAgICAgdGhpcy5jb250YWluZXJUb1Njcm9sbC5vZmZzZXRUb3AsXG4gICAgICBvLFxuICAgICAgcixcbiAgICAgIGEsXG4gICAgICBsXG4gICAgKSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLl9zY3JvbGxPbk5leHRUaWNrKFxuICAgICAgICBlLFxuICAgICAgICBpLFxuICAgICAgICBuLFxuICAgICAgICBvLFxuICAgICAgICByLFxuICAgICAgICBhLFxuICAgICAgICBsXG4gICAgICApLCB0aGlzLmlzQ2FuY2VsID0gITE7XG4gICAgfSwgdGhpcy5fb3B0aW9ucy5kdXJhdGlvbikpO1xuICB9XG4gIF9zY3JvbGxPbk5leHRUaWNrKHQsIGUsIGksIG4sIG8sIHIsIGEpIHtcbiAgICBjb25zdCBsID0gbiA8IDAsIHAgPSBuID4gMSwgdSA9IG8gPD0gMDtcbiAgICBpZiAobCB8fCBwIHx8IHUgfHwgdGhpcy5pc0NhbmNlbCkge1xuICAgICAgaWYgKHRoaXMuaXNDYW5jZWwpIHtcbiAgICAgICAgdGhpcy5pc0luVmlld3BvcnQgJiYgKHRoaXMuaXNDYW5jZWwgPSAhMSksIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCB3MCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCB5MCksIHQuc2Nyb2xsVG9wID0gaTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdC5zY3JvbGxUbyh7XG4gICAgICB0b3A6IGUgLSAoZSAtIGkpICogYShuKVxuICAgIH0pLCBuICs9IG8gKiByLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuX3Njcm9sbE9uTmV4dFRpY2soXG4gICAgICAgIHQsXG4gICAgICAgIGUsXG4gICAgICAgIGksXG4gICAgICAgIG4sXG4gICAgICAgIG8sXG4gICAgICAgIHIsXG4gICAgICAgIGFcbiAgICAgICk7XG4gICAgfSk7XG4gIH1cbiAgX3ByZXZlbnREZWZhdWx0KHQpIHtcbiAgICB0LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbiAgX3ByZXZlbnROYXRpdmVTY3JvbGwoKSB7XG4gICAgbGV0IHQgPSAhMTtcbiAgICB0cnkge1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgIFwidGVzdFwiLFxuICAgICAgICBudWxsLFxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sIFwicGFzc2l2ZVwiLCB7XG4gICAgICAgICAgZ2V0OiAoKSA9PiB0ID0gITBcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSBjYXRjaCAobikge1xuICAgICAgdGhpcy5fc2Nyb2xsRXJyb3IgPSBuO1xuICAgIH1cbiAgICBjb25zdCBlID0gdCA/IHsgcGFzc2l2ZTogITEgfSA6ICExLCBpID0gXCJvbndoZWVsXCIgaW4gJChcImRpdlwiKSA/IFwid2hlZWxcIiA6IFwibW91c2V3aGVlbFwiO1xuICAgIHRoaXMuaXNXaW5kb3cgJiYgKHRoaXMuX2RlbGV0ZVNjcm9sbE9uU3RhcnQoZSwgaSksIHRoaXMuX2FkZFNjcm9sbE9uRW5kKGUsIGkpLCB0aGlzLl9hZGRTY3JvbGxPbkNhbmNlbChlLCBpKSk7XG4gIH1cbiAgX2RlbGV0ZVNjcm9sbE9uU3RhcnQodCwgZSkge1xuICAgIGMub24odGhpcy5fZWxlbWVudCwgXCJzY3JvbGxTdGFydC50ZS5zbW9vdGhTY3JvbGxcIiwgKCkgPT4ge1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoZSwgdGhpcy5fcHJldmVudERlZmF1bHQsIHQpLCB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCB0aGlzLl9wcmV2ZW50RGVmYXVsdCwgdCk7XG4gICAgfSk7XG4gIH1cbiAgX2FkZFNjcm9sbE9uRW5kKHQsIGUpIHtcbiAgICBjLm9uKHRoaXMuX2VsZW1lbnQsIFwic2Nyb2xsRW5kLnRlLnNtb290aFNjcm9sbFwiLCAoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihlLCB0aGlzLl9wcmV2ZW50RGVmYXVsdCwgdCksIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIHRoaXMuX3ByZXZlbnREZWZhdWx0LCB0KTtcbiAgICB9KTtcbiAgfVxuICBfYWRkU2Nyb2xsT25DYW5jZWwodCwgZSkge1xuICAgIGMub24odGhpcy5fZWxlbWVudCwgXCJzY3JvbGxDYW5jZWwudGUuc21vb3RoU2Nyb2xsXCIsICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKGUsIHRoaXMuX3ByZXZlbnREZWZhdWx0LCB0KSwgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgdGhpcy5fcHJldmVudERlZmF1bHQsIHQpO1xuICAgIH0pO1xuICB9XG4gIC8vIE1vdGlvbnNcbiAgLy8gTGluZWFyXG4gIF9tb3Rpb25MaW5lYXIodCkge1xuICAgIHJldHVybiB0O1xuICB9XG4gIC8vIEVhc2UtSW5cbiAgX21vdGlvbkVhc2VJblF1YWQodCkge1xuICAgIHJldHVybiB0ICogdDtcbiAgfVxuICBfbW90aW9uRWFzZUluQ3ViaWModCkge1xuICAgIHJldHVybiB0ICogdCAqIHQ7XG4gIH1cbiAgX21vdGlvbkVhc2VJblF1YXJ0KHQpIHtcbiAgICByZXR1cm4gdCAqIHQgKiB0ICogdDtcbiAgfVxuICBfbW90aW9uRWFzZUluUXVpbnQodCkge1xuICAgIHJldHVybiB0ICogdCAqIHQgKiB0ICogdDtcbiAgfVxuICAvLyBFYXNlLUluLU91dFxuICBfbW90aW9uRWFzZUluT3V0UXVhZCh0KSB7XG4gICAgcmV0dXJuIHQgPCAwLjUgPyAyICogdCAqIHQgOiAtMSArICg0IC0gMiAqIHQpICogdDtcbiAgfVxuICBfbW90aW9uRWFzZUluT3V0Q3ViaWModCkge1xuICAgIHJldHVybiB0IC89IDAuNSwgdCA8IDEgPyB0ICogdCAqIHQgLyAyIDogKHQgLT0gMiwgKHQgKiB0ICogdCArIDIpIC8gMik7XG4gIH1cbiAgX21vdGlvbkVhc2VJbk91dFF1YXJ0KHQpIHtcbiAgICByZXR1cm4gdCAvPSAwLjUsIHQgPCAxID8gMC41ICogdCAqIHQgKiB0ICogdCA6ICh0IC09IDIsIC0odCAqIHQgKiB0ICogdCAtIDIpIC8gMik7XG4gIH1cbiAgX21vdGlvbkVhc2VJbk91dFF1aW50KHQpIHtcbiAgICByZXR1cm4gdCAvPSAwLjUsIHQgPCAxID8gdCAqIHQgKiB0ICogdCAqIHQgLyAyIDogKHQgLT0gMiwgKHQgKiB0ICogdCAqIHQgKiB0ICsgMikgLyAyKTtcbiAgfVxuICAvLyBFYXNlLU91dFxuICBfbW90aW9uRWFzZU91dFF1YWQodCkge1xuICAgIHJldHVybiAtdCAqICh0IC0gMik7XG4gIH1cbiAgX21vdGlvbkVhc2VPdXRDdWJpYyh0KSB7XG4gICAgcmV0dXJuIHQtLSwgdCAqIHQgKiB0ICsgMTtcbiAgfVxuICBfbW90aW9uRWFzZU91dFF1YXJ0KHQpIHtcbiAgICByZXR1cm4gdC0tLCAtKHQgKiB0ICogdCAqIHQgLSAxKTtcbiAgfVxuICBfbW90aW9uRWFzZU91dFF1aW50KHQpIHtcbiAgICByZXR1cm4gdC0tLCB0ICogdCAqIHQgKiB0ICogdCArIDE7XG4gIH1cbiAgLy8gc3RhdGljXG4gIHN0YXRpYyBnZXRJbnN0YW5jZSh0KSB7XG4gICAgcmV0dXJuIHkuZ2V0RGF0YSh0LCB5aSk7XG4gIH1cbiAgc3RhdGljIGdldE9yQ3JlYXRlSW5zdGFuY2UodCwgZSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UodCkgfHwgbmV3IHRoaXModCwgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiA/IGUgOiBudWxsKTtcbiAgfVxuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgbGV0IGUgPSB5LmdldERhdGEodGhpcywgeWkpO1xuICAgICAgY29uc3QgaSA9IHR5cGVvZiB0ID09IFwib2JqZWN0XCIgJiYgdDtcbiAgICAgIGlmIChlIHx8IChlID0gbmV3IHloKHRoaXMsIGkpKSwgdHlwZW9mIHQgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAodHlwZW9mIGVbdF0gPiBcInVcIilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke3R9XCJgKTtcbiAgICAgICAgZVt0XSh0aGlzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuY29uc3QgQmwgPSBcImxhenlMb2FkXCIsICRzID0gXCJ0ZS5sYXp5TG9hZFwiLCBrMCA9IFwiW2RhdGEtdGUtbGF6eS1sb2FkLWluaXRdXCIsIEhsID0gXCJkYXRhLXRlLWxhenktbG9hZFwiLCB4MCA9IFwib25Mb2FkLnRlLmxhenlcIiwgTzAgPSBcIm9uRXJyb3IudGUubGF6eVwiLCBWbCA9IFtcImltZ1wiLCBcInZpZGVvXCJdLCBTMCA9IHtcbiAgbGF6eVNyYzogXCIoc3RyaW5nfG51bGwpXCIsXG4gIGxhenlEZWxheTogXCJudW1iZXJcIixcbiAgbGF6eUFuaW1hdGlvbjogXCJzdHJpbmdcIixcbiAgbGF6eU9mZnNldDogXCJudW1iZXJcIixcbiAgbGF6eVBsYWNlaG9sZGVyOiBcIihzdHJpbmd8dW5kZWZpbmVkKVwiLFxuICBsYXp5RXJyb3I6IFwiKHN0cmluZ3x1bmRlZmluZWQpXCJcbn0sIEkwID0ge1xuICBsYXp5U3JjOiBudWxsLFxuICBsYXp5RGVsYXk6IDUwMCxcbiAgbGF6eUFuaW1hdGlvbjogXCJbZmFkZS1pbl8xc19lYXNlLWluLW91dF1cIixcbiAgbGF6eU9mZnNldDogMFxufTtcbmNsYXNzIFVvIHtcbiAgY29uc3RydWN0b3IodCwgZSkge1xuICAgIHRoaXMuX2VsZW1lbnQgPSB0LCB0aGlzLl9lbGVtZW50ICYmIHkuc2V0RGF0YSh0LCAkcywgdGhpcyksIHRoaXMuX29wdGlvbnMgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuc2Nyb2xsSGFuZGxlciA9IHRoaXMuX3Njcm9sbEhhbmRsZXIuYmluZCh0aGlzKSwgdGhpcy5lcnJvckhhbmRsZXIgPSB0aGlzLl9zZXRFbGVtZW50RXJyb3IuYmluZCh0aGlzKSwgdGhpcy5fY2hpbGRyZW5JbnN0YW5jZXMgPSBudWxsLCB0aGlzLl9pbml0KCk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIEJsO1xuICB9XG4gIGdldCBvZmZzZXRWYWx1ZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIH1cbiAgZ2V0IGluVmlld3BvcnQoKSB7XG4gICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICBjb25zdCB0ID0gdGhpcy5wYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICByZXR1cm4gdC55ID4gMCAmJiB0LnkgPCB3aW5kb3cuaW5uZXJIZWlnaHQgJiYgdGhpcy5vZmZzZXRWYWx1ZXMueSA+PSB0LnkgJiYgdGhpcy5vZmZzZXRWYWx1ZXMueSA8PSB0LnkgKyB0LmhlaWdodCAmJiB0aGlzLm9mZnNldFZhbHVlcy55IDw9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMub2Zmc2V0VmFsdWVzLnRvcCArIHRoaXMuX29wdGlvbnMubGF6eU9mZnNldCA8PSB3aW5kb3cuaW5uZXJIZWlnaHQgJiYgdGhpcy5vZmZzZXRWYWx1ZXMuYm90dG9tID49IDA7XG4gIH1cbiAgZ2V0IHBhcmVudCgpIHtcbiAgICBjb25zdCBbdF0gPSBkLnBhcmVudHMoXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgazBcbiAgICApO1xuICAgIHJldHVybiB0O1xuICB9XG4gIGdldCBub2RlKCkge1xuICAgIHJldHVybiB0aGlzLl9lbGVtZW50Lm5vZGVOYW1lO1xuICB9XG4gIGdldCBpc0NvbnRhaW5lcigpIHtcbiAgICByZXR1cm4gIWQubWF0Y2hlcyh0aGlzLl9lbGVtZW50LCBWbCk7XG4gIH1cbiAgLy8gUHVibGljXG4gIGRpc3Bvc2UoKSB7XG4gICAgeS5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsICRzKSwgdGhpcy5fYW5pbWF0aW9uICYmICh0aGlzLl9hbmltYXRpb24uZGlzcG9zZSgpLCB0aGlzLl9hbmltYXRpb24gPSBudWxsKSwgdGhpcy5fZWxlbWVudCA9IG51bGwsIHRoaXMuX2NoaWxkcmVuSW5zdGFuY2VzICYmIHRoaXMuX2NoaWxkcmVuSW5zdGFuY2VzLmZvckVhY2goKHQpID0+IHQuZGlzcG9zZSgpKTtcbiAgfVxuICAvLyBQcml2YXRlXG4gIF9pbml0KCkge1xuICAgIGlmICh0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShIbCwgXCJcIiksIHRoaXMuaXNDb250YWluZXIpIHtcbiAgICAgIHRoaXMuX3NldHVwQ29udGFpbmVyKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3NldHVwRWxlbWVudCgpO1xuICB9XG4gIF9zZXR1cEVsZW1lbnQoKSB7XG4gICAgYy5vbmUodGhpcy5fZWxlbWVudCwgXCJlcnJvclwiLCB0aGlzLmVycm9ySGFuZGxlciksIHRoaXMuX29wdGlvbnMubGF6eVBsYWNlaG9sZGVyICYmIHRoaXMuX3NldFBsYWNlaG9sZGVyKCksIHRoaXMuX2FuaW1hdGlvbiA9IG5ldyBwcih0aGlzLl9lbGVtZW50LCB7XG4gICAgICBhbmltYXRpb246IGAke3RoaXMuX29wdGlvbnMubGF6eUFuaW1hdGlvbn1gLFxuICAgICAgYW5pbWF0aW9uU3RhcnQ6IFwib25Mb2FkXCJcbiAgICB9KSwgYy5vbmUodGhpcy5fZWxlbWVudCwgXCJsb2FkXCIsICgpID0+IHRoaXMuX3Njcm9sbEhhbmRsZXIoKSksIHRoaXMucGFyZW50ICYmIGMub24odGhpcy5wYXJlbnQsIFwic2Nyb2xsXCIsIHRoaXMuc2Nyb2xsSGFuZGxlciksIGMub24od2luZG93LCBcInNjcm9sbFwiLCB0aGlzLnNjcm9sbEhhbmRsZXIpO1xuICB9XG4gIF9zY3JvbGxIYW5kbGVyKCkge1xuICAgIHRoaXMuaW5WaWV3cG9ydCAmJiAodGhpcy5fdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5fc2V0U3JjKCksIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKEhsKSwgdGhpcy5fcmVtb3ZlQXR0cnMoKSwgdGhpcy5fYW5pbWF0aW9uLmluaXQoKTtcbiAgICB9LCB0aGlzLl9vcHRpb25zLmxhenlEZWxheSksIHRoaXMucGFyZW50ICYmIGMub2ZmKHRoaXMucGFyZW50LCBcInNjcm9sbFwiLCB0aGlzLnNjcm9sbEhhbmRsZXIpLCBjLm9mZih3aW5kb3csIFwic2Nyb2xsXCIsIHRoaXMuc2Nyb2xsSGFuZGxlcikpO1xuICB9XG4gIF9zZXRFbGVtZW50RXJyb3IoKSB7XG4gICAgIXRoaXMuX29wdGlvbnMubGF6eUVycm9yIHx8IHRoaXMuX2VsZW1lbnQuc3JjID09PSB0aGlzLl9vcHRpb25zLmxhenlFcnJvciA/IHRoaXMuX2VsZW1lbnQuYWx0ID0gXCI0MDQgbm90IGZvdW5kXCIgOiB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcInNyY1wiLCB0aGlzLl9vcHRpb25zLmxhenlFcnJvciksIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBPMCk7XG4gIH1cbiAgX3NldFNyYygpIHtcbiAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcInNyY1wiLCB0aGlzLl9vcHRpb25zLmxhenlTcmMpLCBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgeDApO1xuICB9XG4gIF9zZXRQbGFjZWhvbGRlcigpIHtcbiAgICB0aGlzLm5vZGUgPT09IFwiSU1HXCIgPyB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcInNyY1wiLCB0aGlzLl9vcHRpb25zLmxhenlQbGFjZWhvbGRlcikgOiB0aGlzLm5vZGUgPT09IFwiVklERU9cIiAmJiB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcInBvc3RlclwiLCB0aGlzLl9vcHRpb25zLmxhenlQbGFjZWhvbGRlcik7XG4gIH1cbiAgX3JlbW92ZUF0dHJzKCkge1xuICAgIFtcInNyY1wiLCBcImRlbGF5XCIsIFwiYW5pbWF0aW9uXCIsIFwicGxhY2Vob2xkZXJcIiwgXCJvZmZzZXRcIiwgXCJlcnJvclwiXS5mb3JFYWNoKFxuICAgICAgKHQpID0+IHtcbiAgICAgICAgaC5yZW1vdmVEYXRhQXR0cmlidXRlKHRoaXMuX2VsZW1lbnQsIGBsYXp5LSR7dH1gKTtcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIF9zZXR1cENvbnRhaW5lcigpIHtcbiAgICB0aGlzLl9jaGlsZHJlbkluc3RhbmNlcyA9IGQuY2hpbGRyZW4oXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgVmxcbiAgICApLm1hcCgodCkgPT4gbmV3IFVvKHQsIHRoaXMuX29wdGlvbnMpKTtcbiAgfVxuICBfZ2V0Q29uZmlnKHQpIHtcbiAgICBjb25zdCBlID0ge1xuICAgICAgLi4uSTAsXG4gICAgICAuLi50LFxuICAgICAgLi4uaC5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KVxuICAgIH07XG4gICAgcmV0dXJuIEQoQmwsIGUsIFMwKSwgZTtcbiAgfVxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGdldEluc3RhbmNlKHQpIHtcbiAgICByZXR1cm4geS5nZXREYXRhKHQsICRzKTtcbiAgfVxuICBzdGF0aWMgZ2V0T3JDcmVhdGVJbnN0YW5jZSh0LCBlID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSh0KSB8fCBuZXcgdGhpcyh0LCB0eXBlb2YgZSA9PSBcIm9iamVjdFwiID8gZSA6IG51bGwpO1xuICB9XG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICBsZXQgZSA9IHkuZ2V0RGF0YSh0aGlzLCAkcyk7XG4gICAgICBjb25zdCBpID0gdHlwZW9mIHQgPT0gXCJvYmplY3RcIiAmJiB0O1xuICAgICAgaWYgKGUgfHwgKGUgPSBuZXcgVW8odGhpcywgaSkpLCB0eXBlb2YgdCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZVt0XSA+IFwidVwiKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7dH1cImApO1xuICAgICAgICBlW3RdKHRoaXMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5jb25zdCBXbCA9IFwiY2xpcGJvYXJkXCIsIHdpID0gXCJ0ZS5jbGlwYm9hcmRcIiwgRDAgPSBgLiR7d2l9YCwgJDAgPSB7XG4gIGNsaXBib2FyZFRhcmdldDogbnVsbFxufSwgTDAgPSB7XG4gIGNsaXBib2FyZFRhcmdldDogXCJudWxsfHN0cmluZ1wiXG59LCBOMCA9IGBjb3B5JHtEMH1gO1xuY2xhc3Mgd2gge1xuICBjb25zdHJ1Y3Rvcih0LCBlID0ge30pIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gdCwgdGhpcy5fb3B0aW9ucyA9IGUsIHRoaXMuX2VsZW1lbnQgJiYgKHkuc2V0RGF0YSh0LCB3aSwgdGhpcyksIHRoaXMuX2luaXRDb3B5ID0gdGhpcy5faW5pdENvcHkuYmluZCh0aGlzKSwgdGhpcy5fc2V0dXAoKSk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIFdsO1xuICB9XG4gIGdldCBvcHRpb25zKCkge1xuICAgIGNvbnN0IHQgPSB7XG4gICAgICAuLi4kMCxcbiAgICAgIC4uLmguZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCksXG4gICAgICAuLi50aGlzLl9vcHRpb25zXG4gICAgfTtcbiAgICByZXR1cm4gRChXbCwgdCwgTDApLCB0O1xuICB9XG4gIGdldCBjbGlwYm9hcmRUYXJnZXQoKSB7XG4gICAgcmV0dXJuIGQuZmluZE9uZSh0aGlzLm9wdGlvbnMuY2xpcGJvYXJkVGFyZ2V0KTtcbiAgfVxuICBnZXQgY29weVRleHQoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuY2xpcGJvYXJkVGFyZ2V0Lmhhc0F0dHJpYnV0ZShcbiAgICAgIFwiZGF0YS10ZS1jbGlwYm9hcmQtdGV4dFwiXG4gICAgKSwgZSA9IHRoaXMuY2xpcGJvYXJkVGFyZ2V0LnZhbHVlLCBpID0gdGhpcy5jbGlwYm9hcmRUYXJnZXQudGV4dENvbnRlbnQ7XG4gICAgcmV0dXJuIHQgPyB0aGlzLmNsaXBib2FyZFRhcmdldC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXRlLWNsaXBib2FyZC10ZXh0XCIpIDogZSB8fCBpO1xuICB9XG4gIC8vIFB1YmxpY1xuICBkaXNwb3NlKCkge1xuICAgIGMub2ZmKHRoaXMuX2VsZW1lbnQsIFwiY2xpY2tcIiwgdGhpcy5faW5pdENvcHkpLCB5LnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgd2kpLCB0aGlzLl9lbGVtZW50ID0gbnVsbDtcbiAgfVxuICAvLyBQcml2YXRlXG4gIF9zZXR1cCgpIHtcbiAgICBjLm9uKHRoaXMuX2VsZW1lbnQsIFwiY2xpY2tcIiwgdGhpcy5faW5pdENvcHkpO1xuICB9XG4gIF9pbml0Q29weSgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fY3JlYXRlTmV3SW5wdXQoKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHQpLCB0aGlzLl9zZWxlY3RJbnB1dCh0KSwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIE4wLCB7XG4gICAgICBjb3B5VGV4dDogdGhpcy5jb3B5VGV4dFxuICAgIH0pLCB0LnJlbW92ZSgpO1xuICB9XG4gIF9jcmVhdGVOZXdJbnB1dCgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5jbGlwYm9hcmRUYXJnZXQudGFnTmFtZSA9PT0gXCJURVhUQVJFQVwiID8gXCJ0ZXh0YXJlYVwiIDogXCJpbnB1dFwiLCBlID0gJCh0KTtcbiAgICByZXR1cm4gZS52YWx1ZSA9IHRoaXMuY29weVRleHQsIGguYWRkQ2xhc3MoZSwgXCItbGVmdC1bOTk5OXB4XSBhYnNvbHV0ZVwiKSwgZTtcbiAgfVxuICBfc2VsZWN0SW5wdXQodCkge1xuICAgIHQuc2VsZWN0KCksIHQuZm9jdXMoKSwgdC5zZXRTZWxlY3Rpb25SYW5nZSgwLCA5OTk5OSksIGRvY3VtZW50LmV4ZWNDb21tYW5kKFwiY29weVwiKTtcbiAgfVxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0KSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGxldCBlID0geS5nZXREYXRhKHRoaXMsIHdpKTtcbiAgICAgIGNvbnN0IGkgPSB0eXBlb2YgdCA9PSBcIm9iamVjdFwiICYmIHQ7XG4gICAgICBpZiAoZSB8fCAoZSA9IG5ldyB3aCh0aGlzLCBpKSksIHR5cGVvZiB0ID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlW3RdID4gXCJ1XCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgIGVbdF0odGhpcyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGdldEluc3RhbmNlKHQpIHtcbiAgICByZXR1cm4geS5nZXREYXRhKHQsIHdpKTtcbiAgfVxuICBzdGF0aWMgZ2V0T3JDcmVhdGVJbnN0YW5jZSh0LCBlID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSh0KSB8fCBuZXcgdGhpcyh0LCB0eXBlb2YgZSA9PSBcIm9iamVjdFwiID8gZSA6IG51bGwpO1xuICB9XG59XG5jb25zdCBYbyA9IFwiaW5maW5pdGVTY3JvbGxcIiwgTHMgPSBgdGUuJHtYb31gLCBNMCA9IHtcbiAgaW5maW5pdGVEaXJlY3Rpb246IFwieVwiXG59LCBSMCA9IHtcbiAgaW5maW5pdGVEaXJlY3Rpb246IFwic3RyaW5nXCJcbn07XG5jbGFzcyBraCB7XG4gIGNvbnN0cnVjdG9yKHQsIGUpIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gdCwgdGhpcy5fZWxlbWVudCAmJiB5LnNldERhdGEodCwgTHMsIHRoaXMpLCB0aGlzLl9vcHRpb25zID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLnNjcm9sbEhhbmRsZXIgPSB0aGlzLl9zY3JvbGxIYW5kbGVyLmJpbmQodGhpcyksIHRoaXMuX2luaXQoKTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gWG87XG4gIH1cbiAgZ2V0IHJlY3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIH1cbiAgZ2V0IGNvbmRpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fZWxlbWVudCA9PT0gd2luZG93ID8gTWF0aC5hYnMoXG4gICAgICB3aW5kb3cuc2Nyb2xsWSArIHdpbmRvdy5pbm5lckhlaWdodCAtIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHRcbiAgICApIDwgMSA6IHRoaXMuX29wdGlvbnMuaW5maW5pdGVEaXJlY3Rpb24gPT09IFwieFwiID8gdGhpcy5yZWN0LndpZHRoICsgdGhpcy5fZWxlbWVudC5zY3JvbGxMZWZ0ICsgMTAgPj0gdGhpcy5fZWxlbWVudC5zY3JvbGxXaWR0aCA6IE1hdGguY2VpbCh0aGlzLnJlY3QuaGVpZ2h0ICsgdGhpcy5fZWxlbWVudC5zY3JvbGxUb3ApID49IHRoaXMuX2VsZW1lbnQuc2Nyb2xsSGVpZ2h0O1xuICB9XG4gIC8vIFB1YmxpY1xuICBkaXNwb3NlKCkge1xuICAgIGMub2ZmKHRoaXMuX2VsZW1lbnQsIFwic2Nyb2xsXCIsIHRoaXMuc2Nyb2xsSGFuZGxlciksIHkucmVtb3ZlRGF0YSh0aGlzLl9lbGVtZW50LCBMcyksIHRoaXMuX2VsZW1lbnQgPSBudWxsO1xuICB9XG4gIC8vIFByaXZhdGVcbiAgX2luaXQoKSB7XG4gICAgYy5vbih0aGlzLl9lbGVtZW50LCBcInNjcm9sbFwiLCAoKSA9PiB0aGlzLl9zY3JvbGxIYW5kbGVyKCkpO1xuICB9XG4gIF9zY3JvbGxIYW5kbGVyKCkge1xuICAgIHRoaXMuY29uZGl0aW9uICYmIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBcImNvbXBsZXRlLnRlLmluZmluaXRlU2Nyb2xsXCIpLCBjLm9mZih0aGlzLl9lbGVtZW50LCBcInNjcm9sbFwiLCB0aGlzLnNjcm9sbEhhbmRsZXIpO1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIGNvbnN0IGUgPSB7XG4gICAgICAuLi5NMCxcbiAgICAgIC4uLnRoaXMuX2VsZW1lbnQgIT09IHdpbmRvdyA/IGguZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCkgOiB7fSxcbiAgICAgIC4uLnRcbiAgICB9O1xuICAgIHJldHVybiBEKFhvLCBlLCBSMCksIGU7XG4gIH1cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBnZXRJbnN0YW5jZSh0KSB7XG4gICAgcmV0dXJuIHkuZ2V0RGF0YSh0LCBMcyk7XG4gIH1cbiAgc3RhdGljIGdldE9yQ3JlYXRlSW5zdGFuY2UodCwgZSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UodCkgfHwgbmV3IHRoaXModCwgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiA/IGUgOiBudWxsKTtcbiAgfVxuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgbGV0IGUgPSB5LmdldERhdGEodGhpcywgTHMpO1xuICAgICAgY29uc3QgaSA9IHR5cGVvZiB0ID09IFwib2JqZWN0XCIgJiYgdDtcbiAgICAgIGlmIChlIHx8IChlID0gbmV3IGtoKHRoaXMsIGkpKSwgdHlwZW9mIHQgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAodHlwZW9mIGVbdF0gPiBcInVcIilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke3R9XCJgKTtcbiAgICAgICAgZVt0XSh0aGlzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gUDAoeyBiYWNrZHJvcElEOiBzIH0sIHQpIHtcbiAgY29uc3QgZSA9ICQoXCJkaXZcIik7XG4gIHJldHVybiBoLmFkZENsYXNzKFxuICAgIGUsXG4gICAgYCR7dC5iYWNrZHJvcH0gJHt0LmJhY2tkcm9wQ29sb3J9YFxuICApLCBlLmlkID0gcywgZTtcbn1cbmNvbnN0IFJpID0gXCJsb2FkaW5nTWFuYWdlbWVudFwiLCBOcyA9IGB0ZS4ke1JpfWAsIEIwID0gXCJbZGF0YS10ZS1sb2FkaW5nLWljb24tcmVmXVwiLCBIMCA9IFwiW2RhdGEtdGUtbG9hZGluZy10ZXh0LXJlZl1cIiwgVjAgPSBgc2hvdy50ZS4ke1JpfWAsIFcwID0ge1xuICBiYWNrZHJvcDogXCIobnVsbHxib29sZWFuKVwiLFxuICBiYWNrZHJvcElEOiBcIihudWxsfHN0cmluZ3xudW1iZXIpXCIsXG4gIGRlbGF5OiBcIihudWxsfG51bWJlcilcIixcbiAgbG9hZGVyOiBcIihudWxsfHN0cmluZ3xudW1iZXIpXCIsXG4gIHBhcmVudFNlbGVjdG9yOiBcIihudWxsfHN0cmluZylcIixcbiAgbG9hZGluZ0ljb246IFwiYm9vbGVhblwiLFxuICBsb2FkaW5nVGV4dDogXCJib29sZWFuXCIsXG4gIHNjcm9sbDogXCJib29sZWFuXCJcbn0sIEYwID0ge1xuICBiYWNrZHJvcDogITAsXG4gIGJhY2tkcm9wSUQ6IG51bGwsXG4gIGRlbGF5OiAwLFxuICBsb2FkZXI6IFwiXCIsXG4gIHBhcmVudFNlbGVjdG9yOiBudWxsLFxuICBzY3JvbGw6ICEwLFxuICBsb2FkaW5nVGV4dDogITAsXG4gIGxvYWRpbmdJY29uOiAhMFxufSwgWTAgPSB7XG4gIGxvYWRpbmdTcGlubmVyOiBcImFic29sdXRlIHRvcC1bNTAlXSBsZWZ0LVs1MCVdIC10cmFuc2xhdGUteC1bNTAlXSAtdHJhbnNsYXRlLXktWzUwJV0gZmxleCBmbGV4LWNvbCBqdXN0aWZ5LWNlbnRlciBpdGVtcy1jZW50ZXIgei00MFwiLFxuICBzcGlubmVyQ29sb3I6IFwidGV4dC1wcmltYXJ5IGRhcms6dGV4dC1wcmltYXJ5LTQwMFwiLFxuICBiYWNrZHJvcDogXCJ3LWZ1bGwgaC1mdWxsIGZpeGVkIHRvcC0wIGxlZnQtMCBib3R0b20tMCByaWdodC0wIHotMzBcIixcbiAgYmFja2Ryb3BDb2xvcjogXCJiZy1bcmdiYSgwLDAsMCwwLjQpXVwiXG59LCBqMCA9IHtcbiAgbG9hZGluZ1NwaW5uZXI6IFwic3RyaW5nXCIsXG4gIHNwaW5uZXJDb2xvcjogXCJzdHJpbmdcIixcbiAgYmFja2Ryb3A6IFwic3RyaW5nXCIsXG4gIGJhY2tkcm9wQ29sb3I6IFwic3RyaW5nXCJcbn07XG5jbGFzcyB4aCB7XG4gIGNvbnN0cnVjdG9yKHQsIGUgPSB7fSwgaSkge1xuICAgIHRoaXMuX2VsZW1lbnQgPSB0LCB0aGlzLl9vcHRpb25zID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLl9jbGFzc2VzID0gdGhpcy5fZ2V0Q2xhc3NlcyhpKSwgdGhpcy5fZWxlbWVudCAmJiB5LnNldERhdGEodCwgTnMsIHRoaXMpLCB0aGlzLl9iYWNrZHJvcEVsZW1lbnQgPSBudWxsLCB0aGlzLl9wYXJlbnRFbGVtZW50ID0gZC5maW5kT25lKHRoaXMuX29wdGlvbnMucGFyZW50U2VsZWN0b3IpLCB0aGlzLl9sb2FkaW5nSWNvbiA9IGQuZmluZE9uZShcbiAgICAgIEIwLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICksIHRoaXMuX2xvYWRpbmdUZXh0ID0gZC5maW5kT25lKFxuICAgICAgSDAsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKSwgdGhpcy5pbml0KCk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIFJpO1xuICB9XG4gIC8vIFB1YmxpY1xuICBpbml0KCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9sb2FkaW5nSWNvbi5jbG9uZU5vZGUoITApLCBlID0gdGhpcy5fbG9hZGluZ1RleHQuY2xvbmVOb2RlKCEwKTtcbiAgICB0aGlzLl9yZW1vdmVFbGVtZW50c09uU3RhcnQoKSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBoLmFkZENsYXNzKFxuICAgICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgICBgJHt0aGlzLl9jbGFzc2VzLmxvYWRpbmdTcGlubmVyfSAke3RoaXMuX2NsYXNzZXMuc3Bpbm5lckNvbG9yfWBcbiAgICAgICksIHRoaXMuX3NldEJhY2tkcm9wKCksIHRoaXMuX3NldExvYWRpbmdJY29uKHQpLCB0aGlzLl9zZXRMb2FkaW5nVGV4dChlKSwgdGhpcy5fc2V0U2Nyb2xsT3B0aW9uKCksIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBWMCk7XG4gICAgfSwgdGhpcy5fb3B0aW9ucy5kZWxheSk7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB5LnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgTnMpLCBoLnJlbW92ZUNsYXNzKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIGAke3RoaXMuX2NsYXNzZXMubG9hZGluZ1NwaW5uZXJ9ICR7dGhpcy5fY2xhc3Nlcy5zcGlubmVyQ29sb3J9YFxuICAgICk7XG4gICAgY29uc3QgdCA9IHRoaXMuX29wdGlvbnMuZGVsYXk7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLl9yZW1vdmVCYWNrZHJvcCgpLCB0aGlzLl9iYWNrZHJvcEVsZW1lbnQgPSBudWxsLCB0aGlzLl9lbGVtZW50ID0gbnVsbCwgdGhpcy5fb3B0aW9ucyA9IG51bGw7XG4gICAgfSwgdCk7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfc2V0QmFja2Ryb3AoKSB7XG4gICAgY29uc3QgeyBiYWNrZHJvcDogdCB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICB0ICYmICh0aGlzLl9iYWNrZHJvcEVsZW1lbnQgPSBQMCh0aGlzLl9vcHRpb25zLCB0aGlzLl9jbGFzc2VzKSwgdGhpcy5fcGFyZW50RWxlbWVudCAhPT0gbnVsbCA/IChoLmFkZENsYXNzKHRoaXMuX2VsZW1lbnQsIFwiYWJzb2x1dGVcIiksIGguYWRkQ2xhc3ModGhpcy5fcGFyZW50RWxlbWVudCwgXCJyZWxhdGl2ZVwiKSwgaC5hZGRDbGFzcyh0aGlzLl9iYWNrZHJvcEVsZW1lbnQsIFwiYWJzb2x1dGVcIiksIHRoaXMuX3BhcmVudEVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fYmFja2Ryb3BFbGVtZW50KSkgOiAoaC5hZGRDbGFzcyh0aGlzLl9lbGVtZW50LCBcIiFmaXhlZFwiKSwgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLl9iYWNrZHJvcEVsZW1lbnQpLCBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuX2VsZW1lbnQpKSk7XG4gIH1cbiAgX3JlbW92ZUJhY2tkcm9wKCkge1xuICAgIGNvbnN0IHsgYmFja2Ryb3A6IHQgfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgdCAmJiAodGhpcy5fcGFyZW50RWxlbWVudCAhPT0gbnVsbCA/IChoLnJlbW92ZUNsYXNzKHRoaXMuX2VsZW1lbnQsIFwiYWJzb2x1dGVcIiksIGgucmVtb3ZlQ2xhc3ModGhpcy5fcGFyZW50RWxlbWVudCwgXCJyZWxhdGl2ZVwiKSwgdGhpcy5fYmFja2Ryb3BFbGVtZW50LnJlbW92ZSgpKSA6ICh0aGlzLl9iYWNrZHJvcEVsZW1lbnQucmVtb3ZlKCksIHRoaXMuX2VsZW1lbnQucmVtb3ZlKCkpKTtcbiAgfVxuICBfc2V0TG9hZGluZ0ljb24odCkge1xuICAgIGlmICghdGhpcy5fb3B0aW9ucy5sb2FkaW5nSWNvbikge1xuICAgICAgdC5yZW1vdmUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZWxlbWVudC5hcHBlbmRDaGlsZCh0KSwgdC5pZCA9IHRoaXMuX29wdGlvbnMubG9hZGVyO1xuICB9XG4gIF9zZXRMb2FkaW5nVGV4dCh0KSB7XG4gICAgaWYgKCF0aGlzLl9vcHRpb25zLmxvYWRpbmdUZXh0KSB7XG4gICAgICB0LnJlbW92ZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9lbGVtZW50LmFwcGVuZENoaWxkKHQpO1xuICB9XG4gIF9yZW1vdmVFbGVtZW50c09uU3RhcnQoKSB7XG4gICAgdGhpcy5fZWxlbWVudCAhPT0gbnVsbCAmJiAodGhpcy5fbG9hZGluZ0ljb24ucmVtb3ZlKCksIHRoaXMuX2xvYWRpbmdUZXh0LnJlbW92ZSgpKTtcbiAgfVxuICBfc2V0U2Nyb2xsT3B0aW9uKCkge1xuICAgIGlmICh0aGlzLl9vcHRpb25zLnNjcm9sbCkge1xuICAgICAgaWYgKHRoaXMuX3BhcmVudEVsZW1lbnQgPT09IG51bGwpIHtcbiAgICAgICAgaC5hZGRDbGFzcyhkb2N1bWVudC5ib2R5LCBcIm92ZXJmbG93LWF1dG9cIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGguYWRkQ2xhc3ModGhpcy5fcGFyZW50RWxlbWVudCwgXCJvdmVyZmxvdy1hdXRvXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5fcGFyZW50RWxlbWVudCA9PT0gbnVsbCkge1xuICAgICAgICBoLmFkZENsYXNzKGRvY3VtZW50LmJvZHksIFwib3ZlcmZsb3ctaGlkZGVuXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBoLmFkZENsYXNzKHRoaXMuX3BhcmVudEVsZW1lbnQsIFwib3ZlcmZsb3ctaGlkZGVuXCIpO1xuICAgIH1cbiAgfVxuICBfZ2V0Q29uZmlnKHQpIHtcbiAgICBjb25zdCBlID0ge1xuICAgICAgLi4uRjAsXG4gICAgICAuLi5oLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgLi4udFxuICAgIH07XG4gICAgcmV0dXJuIEQoUmksIGUsIFcwKSwgZTtcbiAgfVxuICBfZ2V0Q2xhc3Nlcyh0KSB7XG4gICAgY29uc3QgZSA9IGguZ2V0RGF0YUNsYXNzQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLlkwLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBEKFJpLCB0LCBqMCksIHQ7XG4gIH1cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBnZXRJbnN0YW5jZSh0KSB7XG4gICAgcmV0dXJuIHkuZ2V0RGF0YSh0LCBOcyk7XG4gIH1cbiAgc3RhdGljIGdldE9yQ3JlYXRlSW5zdGFuY2UodCwgZSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UodCkgfHwgbmV3IHRoaXModCwgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiA/IGUgOiBudWxsKTtcbiAgfVxuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgbGV0IGUgPSB5LmdldERhdGEodGhpcywgTnMpO1xuICAgICAgY29uc3QgaSA9IHR5cGVvZiB0ID09IFwib2JqZWN0XCIgJiYgdDtcbiAgICAgIGlmIChlIHx8IChlID0gbmV3IHhoKHRoaXMsIGkpKSwgdHlwZW9mIHQgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAodHlwZW9mIGVbdF0gPiBcInVcIilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke3R9XCJgKTtcbiAgICAgICAgZVt0XSh0aGlzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuY29uc3QgSzAgPSAocykgPT4ge1xuICBjb25zdCB0ID0gL14oMD9bMS05XXwxWzAxMl0pKDpbMC01XVxcZCkgW0FQYXBdW21NXSQvLCBlID0gL14oWzAtOV18MFswLTldfDFbMC05XXwyWzAtM10pOlswLTVdWzAtOV0oOlswLTVdWzAtOV0pPyQvO1xuICByZXR1cm4gcy5tYXRjaCh0KSB8fCBzLm1hdGNoKGUpO1xufSwgejAgPSAocykgPT4gcyAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocykgPT09IFwiW29iamVjdCBEYXRlXVwiICYmICFpc05hTihzKSwgVTAgPSAocykgPT4gcy5nZXRNb250aCgpLCBYMCA9IChzKSA9PiBzLmdldEZ1bGxZZWFyKCksIEcwID0gKHMpID0+IHMubWF0Y2goL1teKGRteSldezEsfS9nKSwgcTAgPSAocywgdCwgZSwgaSkgPT4ge1xuICBsZXQgbjtcbiAgZVswXSAhPT0gZVsxXSA/IG4gPSBlWzBdICsgZVsxXSA6IG4gPSBlWzBdO1xuICBjb25zdCBvID0gbmV3IFJlZ0V4cChgWyR7bn1dYCksIHIgPSBzLnNwbGl0KG8pLCBhID0gdC5zcGxpdChvKSwgbCA9IHQuaW5kZXhPZihcIm1tbVwiKSAhPT0gLTEsIHAgPSBbXTtcbiAgZm9yIChsZXQgYiA9IDA7IGIgPCBhLmxlbmd0aDsgYisrKVxuICAgIGFbYl0uaW5kZXhPZihcInl5XCIpICE9PSAtMSAmJiAocFswXSA9IHsgdmFsdWU6IHJbYl0sIGZvcm1hdDogYVtiXSB9KSwgYVtiXS5pbmRleE9mKFwibVwiKSAhPT0gLTEgJiYgKHBbMV0gPSB7IHZhbHVlOiByW2JdLCBmb3JtYXQ6IGFbYl0gfSksIGFbYl0uaW5kZXhPZihcImRcIikgIT09IC0xICYmIGFbYl0ubGVuZ3RoIDw9IDIgJiYgKHBbMl0gPSB7IHZhbHVlOiByW2JdLCBmb3JtYXQ6IGFbYl0gfSk7XG4gIGxldCB1O1xuICB0LmluZGV4T2YoXCJtbW1tXCIpICE9PSAtMSA/IHUgPSBpLm1vbnRoc0Z1bGwgOiB1ID0gaS5tb250aHNTaG9ydDtcbiAgY29uc3QgXyA9IE51bWJlcihwWzBdLnZhbHVlKSwgZiA9IGwgPyBaMChwWzFdLnZhbHVlLCB1KSA6IE51bWJlcihwWzFdLnZhbHVlKSAtIDEsIGcgPSBOdW1iZXIocFsyXS52YWx1ZSk7XG4gIHJldHVybiBFdChfLCBmLCBnKTtcbn0sIFowID0gKHMsIHQpID0+IHQuZmluZEluZGV4KChlKSA9PiBlID09PSBzKSwgUTAgPSAocywgdCwgZSkgPT4gYFxuICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cIiR7ZS5waWNrZXJJY29ufVwiIGRhdGEtdGUtZGF0ZXBpY2tlci10b2dnbGUtYnV0dG9uLXJlZj5cbiAgICAke3N9XG4gIDwvYnV0dG9uPlxuICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cIiR7ZS5waWNrZXJJY29ufVwiIGRhdGEtdGUtdGltZXBpY2tlci10b2dnbGUtYnV0dG9uLXJlZj5cbiAgICAke3R9XG4gIDwvYnV0dG9uPlxuYCwgSjAgPSAocywgdCkgPT4gYFxuICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cIiR7dC50b2dnbGVCdXR0b259XCIgZGF0YS10ZS1kYXRlLXRpbWVwaWNrZXItdG9nZ2xlLXJlZj5cbiAgICAke3N9IFxuICA8L2J1dHRvbj5cbmAsIFFzID0gXCJkYXRldGltZXBpY2tlclwiLCBraSA9IGB0ZS4ke1FzfWAsIGdyID0gYC4ke2tpfWAsIE9oID0gXCJkYXRhLXRlLWRhdGVwaWNrZXItaW5pdFwiLCBTaCA9IFwiZGF0YS10ZS10aW1lcGlja2VyLWluaXRcIiwgdEMgPSBcImRhdGEtdGUtZGF0ZXBpY2tlci1oZWFkZXJcIiwgZUMgPSBcImRhdGEtdGUtZGF0ZXBpY2tlci1jYW5jZWwtYnV0dG9uLXJlZlwiLCBpQyA9IFwiZGF0YS10ZS1kYXRlcGlja2VyLW9rLWJ1dHRvbi1yZWZcIiwga28gPSBcImRhdGEtdGUtdGltZXBpY2tlci13cmFwcGVyXCIsIEZsID0gXCJkYXRhLXRlLXRpbWVwaWNrZXItY2FuY2VsXCIsIHNDID0gXCJkYXRhLXRlLXRpbWVwaWNrZXItc3VibWl0XCIsIG5DID0gXCJkYXRhLXRlLXRpbWVwaWNrZXItY2xlYXJcIiwgWWwgPSBcImRhdGEtdGUtYnV0dG9ucy10aW1lcGlja2VyXCIsIG9DID0gXCJkYXRhLXRlLWRhdGUtdGltZXBpY2tlci10b2dnbGUtcmVmXCIsIHJDID0gXCJkYXRhLXRlLWRhdGVwaWNrZXItdG9nZ2xlLWJ1dHRvbi1yZWZcIiwgYUMgPSBcImRhdGEtdGUtdGltZXBpY2tlci10b2dnbGUtYnV0dG9uLXJlZlwiLCBsQyA9IGBbJHtTaH1dYCwgY0MgPSBgWyR7T2h9XWAsIGhDID0gYFske29DfV1gLCBkQyA9IGBbJHthQ31dYCwgdUMgPSBcIltkYXRhLXRlLWlucHV0LW5vdGNoLXJlZl1cIiwgcEMgPSBcIltkYXRhLXRlLWRhdGUtdGltZXBpY2tlci10b2dnbGUtcmVmXVwiLCBfQyA9IFwiW2RhdGEtdGUtdGltZXBpY2tlci1lbGVtZW50cy13cmFwcGVyXVwiLCBmQyA9IFwiW2RhdGEtdGUtdGltZXBpY2tlci1jbG9jay13cmFwcGVyXVwiLCBtQyA9IGBvcGVuJHtncn1gLCBnQyA9IGBjbG9zZSR7Z3J9YCwgYkMgPSBgZGF0ZXRpbWVDaGFuZ2Uke2dyfWAsIGpsID0gXCJjbG9zZS50ZS5kYXRlcGlja2VyXCIsIEtsID0gXCJpbnB1dC50ZS50aW1lcGlja2VyXCIsIERlID0gJChcImRpdlwiKSwgemwgPSB7XG4gIGlubGluZTogITEsXG4gIHRvZ2dsZUJ1dHRvbjogITAsXG4gIGNvbnRhaW5lcjogXCJib2R5XCIsXG4gIGRpc2FibGVkOiAhMSxcbiAgZGlzYWJsZVBhc3Q6ICExLFxuICBkaXNhYmxlRnV0dXJlOiAhMSxcbiAgZGVmYXVsdFRpbWU6IFwiXCIsXG4gIGRlZmF1bHREYXRlOiBcIlwiLFxuICB0aW1lcGlja2VyOiB7fSxcbiAgZGF0ZXBpY2tlcjoge30sXG4gIHNob3dGb3JtYXQ6ICExLFxuICBkYXRlVGltZXBpY2tlclRvZ2dsZUljb25UZW1wbGF0ZTogYDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBmaWxsPVwiY3VycmVudENvbG9yXCI+XG4gIDxwYXRoIGZpbGwtcnVsZT1cImV2ZW5vZGRcIiBkPVwiTTYuNzUgMi4yNUEuNzUuNzUgMCAwMTcuNSAzdjEuNWg5VjNBLjc1Ljc1IDAgMDExOCAzdjEuNWguNzVhMyAzIDAgMDEzIDN2MTEuMjVhMyAzIDAgMDEtMyAzSDUuMjVhMyAzIDAgMDEtMy0zVjcuNWEzIDMgMCAwMTMtM0g2VjNhLjc1Ljc1IDAgMDEuNzUtLjc1em0xMy41IDlhMS41IDEuNSAwIDAwLTEuNS0xLjVINS4yNWExLjUgMS41IDAgMDAtMS41IDEuNXY3LjVhMS41IDEuNSAwIDAwMS41IDEuNWgxMy41YTEuNSAxLjUgMCAwMDEuNS0xLjV2LTcuNXpcIiBjbGlwLXJ1bGU9XCJldmVub2RkXCIgLz5cbiAgPC9zdmc+YCxcbiAgZGF0ZXBpY2tlclRvZ2dsZUljb25UZW1wbGF0ZTogYDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBmaWxsPVwiY3VycmVudENvbG9yXCI+XG4gIDxwYXRoIGZpbGwtcnVsZT1cImV2ZW5vZGRcIiBkPVwiTTYuNzUgMi4yNUEuNzUuNzUgMCAwMTcuNSAzdjEuNWg5VjNBLjc1Ljc1IDAgMDExOCAzdjEuNWguNzVhMyAzIDAgMDEzIDN2MTEuMjVhMyAzIDAgMDEtMyAzSDUuMjVhMyAzIDAgMDEtMy0zVjcuNWEzIDMgMCAwMTMtM0g2VjNhLjc1Ljc1IDAgMDEuNzUtLjc1em0xMy41IDlhMS41IDEuNSAwIDAwLTEuNS0xLjVINS4yNWExLjUgMS41IDAgMDAtMS41IDEuNXY3LjVhMS41IDEuNSAwIDAwMS41IDEuNWgxMy41YTEuNSAxLjUgMCAwMDEuNS0xLjV2LTcuNXpcIiBjbGlwLXJ1bGU9XCJldmVub2RkXCIgLz5cbiAgPC9zdmc+YCxcbiAgdGltZXBpY2tlclRvZ2dsZUljb25UZW1wbGF0ZTogYDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjEuNVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiPlxuICA8cGF0aCBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBkPVwiTTEyIDZ2Nmg0LjVtNC41IDBhOSA5IDAgMTEtMTggMCA5IDkgMCAwMTE4IDB6XCIgLz5cbiAgPC9zdmc+YFxufSwgdkMgPSB7XG4gIGlubGluZTogXCJib29sZWFuXCIsXG4gIHRvZ2dsZUJ1dHRvbjogXCJib29sZWFuXCIsXG4gIGNvbnRhaW5lcjogXCJzdHJpbmdcIixcbiAgZGlzYWJsZWQ6IFwiYm9vbGVhblwiLFxuICBkaXNhYmxlUGFzdDogXCJib29sZWFuXCIsXG4gIGRpc2FibGVGdXR1cmU6IFwiYm9vbGVhblwiLFxuICBkZWZhdWx0VGltZTogXCIoc3RyaW5nfGRhdGV8bnVtYmVyKVwiLFxuICBkZWZhdWx0RGF0ZTogXCIoc3RyaW5nfGRhdGV8bnVtYmVyKVwiLFxuICB0aW1lcGlja2VyOiBcIm9iamVjdFwiLFxuICBkYXRlcGlja2VyOiBcIm9iamVjdFwiLFxuICBzaG93Rm9ybWF0OiBcImJvb2xlYW5cIixcbiAgZGF0ZVRpbWVwaWNrZXJUb2dnbGVJY29uVGVtcGxhdGU6IFwic3RyaW5nXCIsXG4gIGRhdGVwaWNrZXJUb2dnbGVJY29uVGVtcGxhdGU6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJUb2dnbGVJY29uVGVtcGxhdGU6IFwic3RyaW5nXCJcbn0sIFRDID0ge1xuICB0b2dnbGVCdXR0b246IFwiZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jb250ZW50LWNlbnRlciBbJj5zdmddOnctNSBbJj5zdmddOmgtNSBhYnNvbHV0ZSBvdXRsaW5lLW5vbmUgYm9yZGVyLW5vbmUgYmctdHJhbnNwYXJlbnQgcmlnaHQtMC41IHRvcC0xLzIgLXRyYW5zbGF0ZS14LTEvMiAtdHJhbnNsYXRlLXktMS8yIGhvdmVyOnRleHQtcHJpbWFyeSBmb2N1czp0ZXh0LXByaW1hcnkgZGFyazpob3Zlcjp0ZXh0LXByaW1hcnktNDAwIGRhcms6Zm9jdXM6dGV4dC1wcmltYXJ5LTQwMCBkYXJrOnRleHQtbmV1dHJhbC0yMDBcIixcbiAgcGlja2VySWNvbjogXCJbJj5zdmddOnctNiBbJj5zdmddOmgtNiBbJj5zdmddOm14LWF1dG8gWyY+c3ZnXTpwb2ludGVyLWV2ZW50cy1ub25lIHctMS8yIHB4LTEuNSBweS1bMXB4XSByb3VuZGVkLVsxMHB4XSBtaW4taC1bNDBweF0gY3Vyc29yLXBvaW50ZXIgb3V0bGluZS1ub25lIGJvcmRlci1ub25lIHRleHQtd2hpdGUgaG92ZXI6YmctcHJpbWFyeS02MDAgZGFyazpob3ZlcjpiZy1uZXV0cmFsLTYwMFwiLFxuICBidXR0b25zQ29udGFpbmVyOiBcImZsZXgganVzdGlmeS1ldmVubHkgaXRlbXMtZW5kIGJnLXByaW1hcnkgZGFyazpiZy16aW5jLTgwMCBkYXJrOmRhdGEtW3RlLWJ1dHRvbnMtdGltZXBpY2tlcl06YmctemluYy03MDBcIixcbiAgdGltZXBpY2tlcjoge30sXG4gIGRhdGVwaWNrZXI6IHt9XG59LCBFQyA9IHtcbiAgdG9nZ2xlQnV0dG9uOiBcInN0cmluZ1wiLFxuICBwaWNrZXJJY29uOiBcInN0cmluZ1wiLFxuICBidXR0b25zQ29udGFpbmVyOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VyOiBcIm9iamVjdFwiLFxuICBkYXRlcGlja2VyOiBcIm9iamVjdFwiXG59O1xuY2xhc3MgSWgge1xuICBjb25zdHJ1Y3Rvcih0LCBlLCBpKSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX2lucHV0ID0gZC5maW5kT25lKFwiaW5wdXRcIiwgdGhpcy5fZWxlbWVudCksIHRoaXMuX29wdGlvbnMgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX2NsYXNzZXMgPSB0aGlzLl9nZXRDbGFzc2VzKGkpLCB0aGlzLl90aW1lcGlja2VyID0gbnVsbCwgdGhpcy5fZGF0ZXBpY2tlciA9IG51bGwsIHRoaXMuX2RhdGVWYWx1ZSA9IHRoaXMuX29wdGlvbnMuZGVmYXVsdERhdGUgPyB0aGlzLl9vcHRpb25zLmRlZmF1bHREYXRlIDogXCJcIiwgdGhpcy5fdGltZVZhbHVlID0gdGhpcy5fb3B0aW9ucy5kZWZhdWx0VGltZSA/IHRoaXMuX29wdGlvbnMuZGVmYXVsdFRpbWUgOiBcIlwiLCB0aGlzLl9pc0ludmFsaWRUaW1lRm9ybWF0ID0gITEsIHRoaXMuX2Zvcm1hdCA9IHRoaXMuX29wdGlvbnMuZGF0ZXBpY2tlci5mb3JtYXQgPyB0aGlzLl9vcHRpb25zLmRhdGVwaWNrZXIuZm9ybWF0IDogXCJkZC9tbS95eXl5XCIsIHRoaXMuX2NhbmNlbCA9ICExLCB0aGlzLl9zY3JvbGxCYXIgPSBuZXcgcWUoKSwgdGhpcy5fZWxlbWVudCAmJiB5LnNldERhdGEodCwga2ksIHRoaXMpLCB0aGlzLl9pbml0KCk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIFFzO1xuICB9XG4gIGdldCB0b2dnbGVCdXR0b24oKSB7XG4gICAgcmV0dXJuIGQuZmluZE9uZShoQywgdGhpcy5fZWxlbWVudCk7XG4gIH1cbiAgZ2V0IG5vdGNoKCkge1xuICAgIHJldHVybiBkLmZpbmRPbmUodUMsIHRoaXMuX2VsZW1lbnQpO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgYy5vZmYodGhpcy5fZWxlbWVudCwgXCJjbGlja1wiLCB0aGlzLl9vcGVuRGF0ZVBpY2tlciksIGMub2ZmKHRoaXMuX2lucHV0LCBcImlucHV0XCIsIHRoaXMuX2hhbmRsZUlucHV0KSwgYy5vZmYodGhpcy5fZWxlbWVudCwgXCJjbGlja1wiKSwgeS5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIGtpKSwgdGhpcy5fcmVtb3ZlVGltZVBpY2tlcigpLCB0aGlzLl9yZW1vdmVEYXRlcGlja2VyKCksIHRoaXMudG9nZ2xlQnV0dG9uLnJlbW92ZSgpLCB0aGlzLl9vcHRpb25zID0gemwsIHRoaXMuX3RpbWVwaWNrZXIgPSBudWxsLCB0aGlzLl9kYXRlcGlja2VyID0gbnVsbCwgdGhpcy5fZGF0ZVZhbHVlID0gbnVsbCwgdGhpcy5fdGltZVZhbHVlID0gbnVsbCwgdGhpcy5faXNJbnZhbGlkVGltZUZvcm1hdCA9IG51bGw7XG4gIH1cbiAgdXBkYXRlKHQgPSB7fSkge1xuICAgIGNvbnN0IGUgPSB0aGlzLl9nZXRDb25maWcoeyAuLi50aGlzLl9vcHRpb25zLCAuLi50IH0pO1xuICAgIHRoaXMuZGlzcG9zZSgpLCB0aGlzLl9vcHRpb25zID0gZSwgdGhpcy5faW5pdCgpO1xuICB9XG4gIC8vIFByaXZhdGVcbiAgX2luaXQoKSB7XG4gICAgdGhpcy5fYWRkRGF0ZXBpY2tlcigpLCB0aGlzLl9hZGRUaW1lUGlja2VyKCksIHRoaXMuX2FwcGVuZFRvZ2dsZUJ1dHRvbigpLCB0aGlzLl9saXN0ZW5Ub1RvZ2dsZUNsaWNrKCksIHRoaXMuX2xpc3RlblRvVXNlcklucHV0KCksIHRoaXMuX2Rpc2FibGVJbnB1dCgpLCB0aGlzLl9zZXRJbml0aWFsRGVmYXVsdElucHV0KCksIHRoaXMuX2FwcGx5Rm9ybWF0UGxhY2Vob2xkZXIoKSwgdGhpcy5fb3B0aW9ucy5kaXNhYmxlUGFzdCAmJiB0aGlzLl9oYW5kbGVUaW1lcGlja2VyRGlzYWJsZVBhc3QoKSwgdGhpcy5fb3B0aW9ucy5kaXNhYmxlRnV0dXJlICYmIHRoaXMuX2hhbmRsZVRpbWVwaWNrZXJEaXNhYmxlRnV0dXJlKCk7XG4gIH1cbiAgX3JlbW92ZURhdGVwaWNrZXIoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2VsZW1lbnQucXVlcnlTZWxlY3RvcihjQyk7XG4gICAgdCAmJiB0LnJlbW92ZSgpO1xuICB9XG4gIF9hZGREYXRlcGlja2VyKCkge1xuICAgIGNvbnN0IHQgPSAkKFwiZGl2XCIpO1xuICAgIHQuaWQgPSB0aGlzLl9lbGVtZW50LmlkID8gYGRhdGVwaWNrZXItJHt0aGlzLl9lbGVtZW50LmlkfWAgOiBydChcImRhdGVwaWNrZXItXCIpO1xuICAgIGNvbnN0IGUgPSAnPGlucHV0IHR5cGU9XCJ0ZXh0XCI+JztcbiAgICB0LmlubmVySFRNTCA9IGUsIHQuc2V0QXR0cmlidXRlKE9oLCBcIlwiKSwgdGhpcy5fZWxlbWVudC5hcHBlbmRDaGlsZCh0KSwgaC5hZGRDbGFzcyh0LCBcImhpZGRlblwiKTtcbiAgICBsZXQgaSA9IHtcbiAgICAgIC4uLnRoaXMuX29wdGlvbnMuZGF0ZXBpY2tlcixcbiAgICAgIGNvbnRhaW5lcjogdGhpcy5fb3B0aW9ucy5jb250YWluZXIsXG4gICAgICBkaXNhYmxlUGFzdDogdGhpcy5fb3B0aW9ucy5kaXNhYmxlUGFzdCxcbiAgICAgIGRpc2FibGVGdXR1cmU6IHRoaXMuX29wdGlvbnMuZGlzYWJsZUZ1dHVyZVxuICAgIH07XG4gICAgKHRoaXMuX29wdGlvbnMuaW5saW5lIHx8IHRoaXMuX29wdGlvbnMuZGF0ZXBpY2tlci5pbmxpbmUpICYmIChpID0geyAuLi5pLCBpbmxpbmU6ICEwIH0pLCB0aGlzLl9kYXRlcGlja2VyID0gbmV3IE5tKHQsIGksIHtcbiAgICAgIC4uLnRoaXMuX2NsYXNzZXMuZGF0ZXBpY2tlclxuICAgIH0pLCB0aGlzLl9kYXRlcGlja2VyLl9pbnB1dC52YWx1ZSA9IHRoaXMuX2RhdGVWYWx1ZTtcbiAgfVxuICBfcmVtb3ZlVGltZVBpY2tlcigpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fZWxlbWVudC5xdWVyeVNlbGVjdG9yKGxDKTtcbiAgICB0ICYmICh0LnJlbW92ZSgpLCB0aGlzLl9zY3JvbGxCYXIucmVzZXQoKSk7XG4gIH1cbiAgX2FkZFRpbWVQaWNrZXIoKSB7XG4gICAgY29uc3QgdCA9ICQoXCJkaXZcIik7XG4gICAgdC5pZCA9IHRoaXMuX2VsZW1lbnQuaWQgPyBgdGltZXBpY2tlci0ke3RoaXMuX2VsZW1lbnQuaWR9YCA6IHJ0KFwidGltZXBpY2tlci1cIik7XG4gICAgY29uc3QgZSA9ICc8aW5wdXQgdHlwZT1cInRleHRcIj4nO1xuICAgIHQuaW5uZXJIVE1MID0gZSwgdC5zZXRBdHRyaWJ1dGUoU2gsIFwiXCIpLCB0aGlzLl9lbGVtZW50LmFwcGVuZENoaWxkKHQpLCBoLmFkZENsYXNzKHQsIFwiaGlkZGVuXCIpO1xuICAgIGxldCBpID0ge1xuICAgICAgLi4udGhpcy5fb3B0aW9ucy50aW1lcGlja2VyLFxuICAgICAgY29udGFpbmVyOiB0aGlzLl9vcHRpb25zLmNvbnRhaW5lclxuICAgIH07XG4gICAgKHRoaXMuX29wdGlvbnMuaW5saW5lIHx8IHRoaXMuX29wdGlvbnMudGltZXBpY2tlci5pbmxpbmUpICYmIChpID0geyB0aW1lcGlja2VyT3B0aW9uczogaSwgaW5saW5lOiAhMCB9KSwgdGhpcy5fdGltZXBpY2tlciA9IG5ldyBuZyh0LCBpLCB7XG4gICAgICAuLi50aGlzLl9jbGFzc2VzLnRpbWVwaWNrZXJcbiAgICB9KSwgdGhpcy5fdGltZXBpY2tlci5pbnB1dC52YWx1ZSA9IHRoaXMuX3RpbWVWYWx1ZTtcbiAgfVxuICBfYWRkSWNvbkJ1dHRvbnMoKSB7XG4gICAgaWYgKGguYWRkQ2xhc3MoRGUsIHRoaXMuX2NsYXNzZXMuYnV0dG9uc0NvbnRhaW5lciksIERlLmlubmVySFRNTCA9IFEwKFxuICAgICAgdGhpcy5fb3B0aW9ucy5kYXRlcGlja2VyVG9nZ2xlSWNvblRlbXBsYXRlLFxuICAgICAgdGhpcy5fb3B0aW9ucy50aW1lcGlja2VyVG9nZ2xlSWNvblRlbXBsYXRlLFxuICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICksIERlLnJlbW92ZUF0dHJpYnV0ZShZbCksICEodGhpcy5fb3B0aW9ucy5pbmxpbmUgfHwgdGhpcy5fb3B0aW9ucy5kYXRlcGlja2VyLmlubGluZSkpIHtcbiAgICAgIGlmICh0aGlzLl9zY3JvbGxCYXIuaGlkZSgpLCB0aGlzLl9kYXRlcGlja2VyLl9pc09wZW4pXG4gICAgICAgIGQuZmluZE9uZShcbiAgICAgICAgICBgWyR7dEN9XWAsXG4gICAgICAgICAgZG9jdW1lbnQuYm9keVxuICAgICAgICApLmFwcGVuZENoaWxkKERlKTtcbiAgICAgIGVsc2UgaWYgKHRoaXMuX3RpbWVwaWNrZXIuX21vZGFsICYmICF0aGlzLl9vcHRpb25zLnRpbWVwaWNrZXIuaW5saW5lKSB7XG4gICAgICAgIGNvbnN0IHQgPSBkLmZpbmRPbmUoXG4gICAgICAgICAgX0MsXG4gICAgICAgICAgZG9jdW1lbnQuYm9keVxuICAgICAgICApLCBlID0gZC5maW5kT25lKFxuICAgICAgICAgIGZDLFxuICAgICAgICAgIGRvY3VtZW50LmJvZHlcbiAgICAgICAgKTtcbiAgICAgICAgRGUuc2V0QXR0cmlidXRlKFlsLCBcIlwiKSwgdC5pbnNlcnRCZWZvcmUoRGUsIGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBfZW5hYmxlT3JEaXNhYmxlVG9nZ2xlQnV0dG9uKCkge1xuICAgIHRoaXMuX29wdGlvbnMuZGlzYWJsZWQgPyAodGhpcy50b2dnbGVCdXR0b24uZGlzYWJsZWQgPSAhMCwgaC5hZGRDbGFzcyh0aGlzLnRvZ2dsZUJ1dHRvbiwgXCJwb2ludGVyLWV2ZW50cy1ub25lXCIpKSA6ICh0aGlzLnRvZ2dsZUJ1dHRvbi5kaXNhYmxlZCA9ICExLCBoLnJlbW92ZUNsYXNzKHRoaXMudG9nZ2xlQnV0dG9uLCBcInBvaW50ZXItZXZlbnRzLW5vbmVcIikpO1xuICB9XG4gIF9hcHBlbmRUb2dnbGVCdXR0b24oKSB7XG4gICAgdGhpcy5fb3B0aW9ucy50b2dnbGVCdXR0b24gJiYgKHRoaXMuX2VsZW1lbnQuaW5zZXJ0QWRqYWNlbnRIVE1MKFxuICAgICAgXCJiZWZvcmVlbmRcIixcbiAgICAgIEowKFxuICAgICAgICB0aGlzLl9vcHRpb25zLmRhdGVUaW1lcGlja2VyVG9nZ2xlSWNvblRlbXBsYXRlLFxuICAgICAgICB0aGlzLl9jbGFzc2VzXG4gICAgICApXG4gICAgKSwgdGhpcy5fZW5hYmxlT3JEaXNhYmxlVG9nZ2xlQnV0dG9uKCkpO1xuICB9XG4gIF9hcHBseUZvcm1hdFBsYWNlaG9sZGVyKCkge1xuICAgIHRoaXMuX29wdGlvbnMuc2hvd0Zvcm1hdCAmJiAodGhpcy5faW5wdXQucGxhY2Vob2xkZXIgPSB0aGlzLl9mb3JtYXQpO1xuICB9XG4gIF9saXN0ZW5Ub0NhbmNlbENsaWNrKCkge1xuICAgIGNvbnN0IHQgPSBkLmZpbmRPbmUoXG4gICAgICBgWyR7ZUN9XWAsXG4gICAgICBkb2N1bWVudC5ib2R5XG4gICAgKTtcbiAgICBjLm9uZSh0LCBcIm1vdXNlZG93blwiLCAoKSA9PiB7XG4gICAgICB0aGlzLl9jYW5jZWwgPSAhMCwgdGhpcy5fc2Nyb2xsQmFyLnJlc2V0KCksIGMub2ZmKHQsIFwibW91c2Vkb3duXCIpO1xuICAgIH0pO1xuICB9XG4gIF9saXN0ZW5Ub1RvZ2dsZUNsaWNrKCkge1xuICAgIGMub24odGhpcy5fZWxlbWVudCwgXCJjbGlja1wiLCBwQywgKHQpID0+IHtcbiAgICAgIHQucHJldmVudERlZmF1bHQoKSwgdGhpcy5fb3BlbkRhdGVQaWNrZXIoKTtcbiAgICB9KTtcbiAgfVxuICBfbGlzdGVuVG9Vc2VySW5wdXQoKSB7XG4gICAgYy5vbih0aGlzLl9pbnB1dCwgXCJpbnB1dFwiLCAodCkgPT4ge1xuICAgICAgdGhpcy5faGFuZGxlSW5wdXQodC50YXJnZXQudmFsdWUpO1xuICAgIH0pO1xuICB9XG4gIF9kaXNhYmxlSW5wdXQoKSB7XG4gICAgdGhpcy5fb3B0aW9ucy5kaXNhYmxlZCAmJiAodGhpcy5faW5wdXQuZGlzYWJsZWQgPSBcInRydWVcIik7XG4gIH1cbiAgX2dldENvbmZpZyh0KSB7XG4gICAgY29uc3QgZSA9IGguZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi56bCxcbiAgICAgIC4uLmUsXG4gICAgICAuLi50XG4gICAgfSwgRChRcywgdCwgdkMpLCB0O1xuICB9XG4gIF9nZXRDbGFzc2VzKHQpIHtcbiAgICBjb25zdCBlID0gaC5nZXREYXRhQ2xhc3NBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uVEMsXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIEQoUXMsIHQsIEVDKSwgdDtcbiAgfVxuICBfaGFuZGxlSW5wdXQodCkge1xuICAgIGNvbnN0IGUgPSB0LnNwbGl0KFwiLCBcIiksIGkgPSBHMCh0aGlzLl9mb3JtYXQpLCBuID0gZVswXSwgbyA9IGVbMV0gfHwgXCJcIiwgciA9IHEwKFxuICAgICAgbixcbiAgICAgIHRoaXMuX2Zvcm1hdCxcbiAgICAgIGksXG4gICAgICB0aGlzLl9kYXRlcGlja2VyLl9vcHRpb25zXG4gICAgKTtcbiAgICBlLmxlbmd0aCA9PT0gMiAmJiAoejAocikgJiYgSzAobykgPyAodGhpcy5fZGF0ZVZhbHVlID0gbiwgdGhpcy5fdGltZVZhbHVlID0gbywgdGhpcy5fZGF0ZXBpY2tlci5faW5wdXQudmFsdWUgPSB0aGlzLl9kYXRlVmFsdWUsIHRoaXMuX2RhdGVwaWNrZXIuX2FjdGl2ZURhdGUgPSB0aGlzLl9kYXRlVmFsdWUsIHRoaXMuX2RhdGVwaWNrZXIuX3NlbGVjdGVkWWVhciA9IFgwKHIpLCB0aGlzLl9kYXRlcGlja2VyLl9zZWxlY3RlZE1vbnRoID0gVTAociksIHRoaXMuX2RhdGVwaWNrZXIuX2hlYWRlckRhdGUgPSByLCB0aGlzLl90aW1lcGlja2VyLmlucHV0LnZhbHVlID0gdGhpcy5fdGltZVZhbHVlLCB0aGlzLl90aW1lcGlja2VyLl9pc0ludmFsaWRUaW1lRm9ybWF0ID0gITEpIDogKHRoaXMuX2RhdGVwaWNrZXIuX2FjdGl2ZURhdGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSwgdGhpcy5fZGF0ZXBpY2tlci5fc2VsZWN0ZWREYXRlID0gbnVsbCwgdGhpcy5fZGF0ZXBpY2tlci5fc2VsZWN0ZWRNb250aCA9IG51bGwsIHRoaXMuX2RhdGVwaWNrZXIuX3NlbGVjdGVkWWVhciA9IG51bGwsIHRoaXMuX2RhdGVwaWNrZXIuX2hlYWRlckRhdGUgPSBudWxsLCB0aGlzLl9kYXRlcGlja2VyLl9oZWFkZXJNb250aCA9IG51bGwsIHRoaXMuX2RhdGVwaWNrZXIuX2hlYWRlclllYXIgPSBudWxsLCB0aGlzLl90aW1lcGlja2VyLl9pc0ludmFsaWRUaW1lRm9ybWF0ID0gITApKTtcbiAgfVxuICBfb3BlbkRhdGVQaWNrZXIoKSB7XG4gICAgaWYgKGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBtQykuZGVmYXVsdFByZXZlbnRlZClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9kYXRlcGlja2VyLm9wZW4oKSwgdGhpcy5fb3B0aW9ucy5pbmxpbmUgfHwgdGhpcy5fc2Nyb2xsQmFyLmhpZGUoKSwgKHRoaXMuX29wdGlvbnMuaW5saW5lIHx8IHRoaXMuX29wdGlvbnMuZGF0ZXBpY2tlci5pbmxpbmUpICYmIHRoaXMuX29wZW5Ecm9wZG93bkRhdGUoKSwgdGhpcy5fYWRkSWNvbkJ1dHRvbnMoKSwgdGhpcy5fbGlzdGVuVG9DYW5jZWxDbGljaygpLCB0aGlzLl9vcHRpb25zLmlubGluZSAmJiB0aGlzLl9kYXRlcGlja2VyLl9pc09wZW4gJiYgaC5hZGRDbGFzcyh0aGlzLnRvZ2dsZUJ1dHRvbiwgXCJwb2ludGVyLWV2ZW50cy1ub25lXCIpLCBjLm9uZSh0aGlzLl9kYXRlcGlja2VyLl9lbGVtZW50LCBqbCwgKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuX2RhdGVWYWx1ZSA9IHRoaXMuX2RhdGVwaWNrZXIuX2lucHV0LnZhbHVlLCB0aGlzLl91cGRhdGVJbnB1dFZhbHVlKCksIHRoaXMuX2NhbmNlbCkge1xuICAgICAgICB0aGlzLl9jYW5jZWwgPSAhMTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYy5vbih0aGlzLl9kYXRlcGlja2VyLmNvbnRhaW5lciwgXCJjbGlja1wiLCAoaSkgPT4ge1xuICAgICAgICAhdGhpcy5fZGF0ZXBpY2tlci5fc2VsZWN0ZWREYXRlICYmIGkudGFyZ2V0Lmhhc0F0dHJpYnV0ZShpQykgfHwgdGhpcy5fb3BlblRpbWVQaWNrZXIoKTtcbiAgICAgIH0pLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgZC5maW5kT25lKFxuICAgICAgICAgIGBbJHtrb31dYCxcbiAgICAgICAgICBkb2N1bWVudC5ib2R5XG4gICAgICAgICkgfHwgdGhpcy5fc2Nyb2xsQmFyLnJlc2V0KCk7XG4gICAgICB9LCAxMCksIHRoaXMuX29wdGlvbnMuaW5saW5lICYmIGgucmVtb3ZlQ2xhc3ModGhpcy50b2dnbGVCdXR0b24sIFwicG9pbnRlci1ldmVudHMtbm9uZVwiKTtcbiAgICB9KTtcbiAgICBjb25zdCBlID0gZC5maW5kT25lKFxuICAgICAgZEMsXG4gICAgICBkb2N1bWVudC5ib2R5XG4gICAgKTtcbiAgICBjLm9uKGUsIFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fZGF0ZXBpY2tlci5jbG9zZSgpLCB0aGlzLl9zY3JvbGxCYXIuaGlkZSgpLCBjLnRyaWdnZXIodGhpcy5fZGF0ZXBpY2tlci5fZWxlbWVudCwgamwpO1xuICAgIH0pO1xuICB9XG4gIF9oYW5kbGVUaW1lcGlja2VyRGlzYWJsZVBhc3QoKSB7XG4gICAgY29uc3QgdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgIHQuc2V0SG91cnMoMCwgMCwgMCwgMCksIGMub24oXG4gICAgICB0aGlzLl9kYXRlcGlja2VyLl9lbGVtZW50LFxuICAgICAgXCJkYXRlQ2hhbmdlLnRlLmRhdGVwaWNrZXJcIixcbiAgICAgICgpID0+IHtcbiAgICAgICAgdGhpcy5fZGF0ZXBpY2tlci5fc2VsZWN0ZWREYXRlLmdldFRpbWUoKSA9PT0gdC5nZXRUaW1lKCkgPyB0aGlzLl90aW1lcGlja2VyLnVwZGF0ZSh7IGRpc2FibGVQYXN0OiAhMCB9KSA6IHRoaXMuX3RpbWVwaWNrZXIudXBkYXRlKHsgZGlzYWJsZVBhc3Q6ICExIH0pO1xuICAgICAgfVxuICAgICk7XG4gIH1cbiAgX2hhbmRsZVRpbWVwaWNrZXJEaXNhYmxlRnV0dXJlKCkge1xuICAgIGNvbnN0IHQgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICB0LnNldEhvdXJzKDAsIDAsIDAsIDApLCBjLm9uKFxuICAgICAgdGhpcy5fZGF0ZXBpY2tlci5fZWxlbWVudCxcbiAgICAgIFwiZGF0ZUNoYW5nZS50ZS5kYXRlcGlja2VyXCIsXG4gICAgICAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2RhdGVwaWNrZXIuX3NlbGVjdGVkRGF0ZS5nZXRUaW1lKCkgPT09IHQuZ2V0VGltZSgpID8gdGhpcy5fdGltZXBpY2tlci51cGRhdGUoeyBkaXNhYmxlRnV0dXJlOiAhMCB9KSA6IHRoaXMuX3RpbWVwaWNrZXIudXBkYXRlKHsgZGlzYWJsZUZ1dHVyZTogITEgfSk7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBfaGFuZGxlRXNjYXBlS2V5KCkge1xuICAgIGMub25lKGRvY3VtZW50LmJvZHksIFwia2V5dXBcIiwgKCkgPT4ge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGQuZmluZE9uZShcbiAgICAgICAgICBgWyR7a299XWAsXG4gICAgICAgICAgZG9jdW1lbnQuYm9keVxuICAgICAgICApIHx8IHRoaXMuX3Njcm9sbEJhci5yZXNldCgpO1xuICAgICAgfSwgMjUwKTtcbiAgICB9KTtcbiAgfVxuICBfaGFuZGxlQ2FuY2VsQnV0dG9uKCkge1xuICAgIGNvbnN0IHQgPSBkLmZpbmRPbmUoXG4gICAgICBgWyR7Rmx9XWAsXG4gICAgICBkb2N1bWVudC5ib2R5XG4gICAgKTtcbiAgICBjLm9uZSh0LCBcIm1vdXNlZG93blwiLCAoKSA9PiB7XG4gICAgICB0aGlzLl9zY3JvbGxCYXIucmVzZXQoKTtcbiAgICB9KTtcbiAgfVxuICBfb3BlbkRyb3Bkb3duRGF0ZSgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fZGF0ZXBpY2tlci5fcG9wcGVyO1xuICAgIHQuc3RhdGUuZWxlbWVudHMucmVmZXJlbmNlID0gdGhpcy5faW5wdXQsIHRoaXMuX3Njcm9sbEJhci5yZXNldCgpO1xuICB9XG4gIF9vcGVuVGltZVBpY2tlcigpIHtcbiAgICBjLnRyaWdnZXIodGhpcy5fdGltZXBpY2tlci5lbGVtZW50VG9nZ2xlLCBcImNsaWNrXCIpLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICh0aGlzLl9hZGRJY29uQnV0dG9ucygpLCAodGhpcy5fb3B0aW9ucy5pbmxpbmUgfHwgdGhpcy5fb3B0aW9ucy50aW1lcGlja2VyLmlubGluZSkgJiYgdGhpcy5fb3BlbkRyb3Bkb3duVGltZSgpLCB0aGlzLl90aW1lcGlja2VyLl9tb2RhbCkge1xuICAgICAgICBjb25zdCB0ID0gZC5maW5kT25lKFxuICAgICAgICAgIGBbJHtGbH1dYCxcbiAgICAgICAgICBkb2N1bWVudC5ib2R5XG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuX2hhbmRsZUVzY2FwZUtleSgpLCB0aGlzLl9oYW5kbGVDYW5jZWxCdXR0b24oKSwgYy5vbih0aGlzLl90aW1lcGlja2VyLl9tb2RhbCwgXCJjbGlja1wiLCAoZSkgPT4ge1xuICAgICAgICAgIChlLnRhcmdldC5oYXNBdHRyaWJ1dGUoa28pIHx8IGUudGFyZ2V0Lmhhc0F0dHJpYnV0ZShzQykpICYmIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsQmFyLnJlc2V0KCk7XG4gICAgICAgICAgfSwgMjAwKSwgZS50YXJnZXQuaGFzQXR0cmlidXRlKG5DKSAmJiBjLnRyaWdnZXIoXG4gICAgICAgICAgICB0aGlzLl90aW1lcGlja2VyLl9lbGVtZW50LFxuICAgICAgICAgICAgS2xcbiAgICAgICAgICApLCBlLnRhcmdldC5oYXNBdHRyaWJ1dGUockMpICYmIChjLnRyaWdnZXIodCwgXCJjbGlja1wiKSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9vcGVuRGF0ZVBpY2tlcigpLCB0aGlzLl9zY3JvbGxCYXIuaGlkZSgpO1xuICAgICAgICAgIH0sIDIwMCkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KSwgYy5vbmUodGhpcy5fdGltZXBpY2tlci5fZWxlbWVudCwgS2wsICgpID0+IHtcbiAgICAgIHRoaXMuX3RpbWVWYWx1ZSA9IHRoaXMuX3RpbWVwaWNrZXIuaW5wdXQudmFsdWUsIHRoaXMuX3VwZGF0ZUlucHV0VmFsdWUoKSwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGdDKTtcbiAgICB9KTtcbiAgfVxuICBfb3BlbkRyb3Bkb3duVGltZSgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fdGltZXBpY2tlci5fcG9wcGVyO1xuICAgIHQuc3RhdGUuZWxlbWVudHMucmVmZXJlbmNlID0gdGhpcy5faW5wdXQsIHQudXBkYXRlKCksIHRoaXMuX3Njcm9sbEJhci5yZXNldCgpO1xuICB9XG4gIF9zZXRJbml0aWFsRGVmYXVsdElucHV0KCkge1xuICAgICh0aGlzLl9vcHRpb25zLmRlZmF1bHREYXRlIHx8IHRoaXMuX29wdGlvbnMuZGVmYXVsdFRpbWUpICYmIHRoaXMuX3VwZGF0ZUlucHV0VmFsdWUoKTtcbiAgfVxuICBfdXBkYXRlSW5wdXRWYWx1ZSgpIHtcbiAgICB0aGlzLl90aW1lVmFsdWUgJiYgdGhpcy5fZGF0ZVZhbHVlICYmICh0aGlzLl9pbnB1dC52YWx1ZSA9IGAke3RoaXMuX2RhdGVWYWx1ZX0sICR7dGhpcy5fdGltZVZhbHVlfWAsIGMudHJpZ2dlcihcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBiQ1xuICAgICkuZGVmYXVsdFByZXZlbnRlZCkgfHwgKGMudHJpZ2dlcih0aGlzLl9pbnB1dCwgXCJmb2N1c1wiKSwgdGhpcy5ub3RjaCAmJiB0aGlzLm5vdGNoLnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtdGUtaW5wdXQtZm9jdXNlZFwiKSk7XG4gIH1cbiAgLy8gc3RhdGljXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCwgZSkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICBsZXQgaSA9IHkuZ2V0RGF0YSh0aGlzLCBraSk7XG4gICAgICBjb25zdCBuID0gdHlwZW9mIHQgPT0gXCJvYmplY3RcIiAmJiB0O1xuICAgICAgaWYgKCEoIWkgJiYgL2Rpc3Bvc2UvLnRlc3QodCkpICYmIChpIHx8IChpID0gbmV3IEloKHRoaXMsIG4pKSwgdHlwZW9mIHQgPT0gXCJzdHJpbmdcIikpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpW3RdID4gXCJ1XCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgIGlbdF0oZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGdldEluc3RhbmNlKHQpIHtcbiAgICByZXR1cm4geS5nZXREYXRhKHQsIGtpKTtcbiAgfVxuICBzdGF0aWMgZ2V0T3JDcmVhdGVJbnN0YW5jZSh0LCBlID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSh0KSB8fCBuZXcgdGhpcyh0LCB0eXBlb2YgZSA9PSBcIm9iamVjdFwiID8gZSA6IG51bGwpO1xuICB9XG59XG5jb25zdCBKcyA9IFwic3RpY2t5XCIsIHhpID0gYHRlLiR7SnN9YCwgRGggPSBgLiR7eGl9YCwgQ0MgPSBgYWN0aXZlJHtEaH1gLCBBQyA9IGBpbmFjdGl2ZSR7RGh9YCwgeUMgPSB7XG4gIHN0aWNreUFuaW1hdGlvblN0aWNreTogXCJcIixcbiAgc3RpY2t5QW5pbWF0aW9uVW5zdGlja3k6IFwiXCIsXG4gIHN0aWNreUJvdW5kYXJ5OiAhMSxcbiAgc3RpY2t5RGVsYXk6IDAsXG4gIHN0aWNreURpcmVjdGlvbjogXCJkb3duXCIsXG4gIHN0aWNreU1lZGlhOiAwLFxuICBzdGlja3lPZmZzZXQ6IDAsXG4gIHN0aWNreVBvc2l0aW9uOiBcInRvcFwiLFxuICBzdGlja3laSW5kZXg6IDEwMFxufSwgd0MgPSB7XG4gIHN0aWNreUFuaW1hdGlvblN0aWNreTogXCJzdHJpbmdcIixcbiAgc3RpY2t5QW5pbWF0aW9uVW5zdGlja3k6IFwic3RyaW5nXCIsXG4gIHN0aWNreUJvdW5kYXJ5OiBcIihib29sZWFufHN0cmluZylcIixcbiAgc3RpY2t5RGVsYXk6IFwibnVtYmVyXCIsXG4gIHN0aWNreURpcmVjdGlvbjogXCJzdHJpbmdcIixcbiAgc3RpY2t5TWVkaWE6IFwibnVtYmVyXCIsXG4gIHN0aWNreU9mZnNldDogXCJudW1iZXJcIixcbiAgc3RpY2t5UG9zaXRpb246IFwic3RyaW5nXCIsXG4gIHN0aWNreVpJbmRleDogXCIoc3RyaW5nfG51bWJlcilcIlxufSwga0MgPSB7XG4gIHN0aWNreUFjdGl2ZTogXCJcIlxufSwgeEMgPSB7XG4gIHN0aWNreUFjdGl2ZTogXCJzdHJpbmdcIlxufTtcbmNsYXNzICRoIHtcbiAgY29uc3RydWN0b3IodCwgZSwgaSkge1xuICAgIHRoaXMuX2VsZW1lbnQgPSB0LCB0aGlzLl9oaWRkZW5FbGVtZW50ID0gbnVsbCwgdGhpcy5fZWxlbWVudFBvc2l0aW9uU3R5bGVzID0ge30sIHRoaXMuX3Njcm9sbERpcmVjdGlvbiA9IFwiXCIsIHRoaXMuX2lzU3RpY2tlZCA9ICExLCB0aGlzLl9lbGVtZW50T2Zmc2V0VG9wID0gbnVsbCwgdGhpcy5fc2Nyb2xsVG9wID0gMCwgdGhpcy5fcHVzaFBvaW50ID0gXCJcIiwgdGhpcy5fbWFudWFsbHlEZWFjdGl2YXRlZCA9ICExLCB0aGlzLl9lbGVtZW50ICYmICh0aGlzLl9vcHRpb25zID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLl9jbGFzc2VzID0gdGhpcy5fZ2V0Q2xhc3NlcyhpKSwgeS5zZXREYXRhKHQsIHhpLCB0aGlzKSwgdGhpcy5faW5pdCgpKTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gSnM7XG4gIH1cbiAgLy8gUHVibGljXG4gIGRpc3Bvc2UoKSB7XG4gICAgY29uc3QgeyBzdGlja3lBbmltYXRpb25VbnN0aWNreTogdCB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICBsZXQgeyBhbmltYXRpb25EdXJhdGlvbjogZSB9ID0gZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLl9lbGVtZW50KTtcbiAgICBlID0gdCAhPT0gXCJcIiA/IHBhcnNlRmxvYXQoZSkgKiAxZTMgOiAwLCB0aGlzLl9kaXNhYmxlU3RpY2t5KCksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgeS5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIHhpKSwgdGhpcy5fZWxlbWVudCA9IG51bGwsIHRoaXMuX29wdGlvbnMgPSBudWxsLCB0aGlzLl9oaWRkZW5FbGVtZW50ID0gbnVsbCwgdGhpcy5fZWxlbWVudFBvc2l0aW9uU3R5bGVzID0gbnVsbCwgdGhpcy5fc2Nyb2xsRGlyZWN0aW9uID0gbnVsbCwgdGhpcy5faXNTdGlja2VkID0gbnVsbCwgdGhpcy5fZWxlbWVudE9mZnNldFRvcCA9IG51bGwsIHRoaXMuX3Njcm9sbFRvcCA9IG51bGwsIHRoaXMuX3B1c2hQb2ludCA9IG51bGwsIHRoaXMuX21hbnVhbGx5RGVhY3RpdmF0ZWQgPSBudWxsO1xuICAgIH0sIGUpO1xuICB9XG4gIGFjdGl2ZSgpIHtcbiAgICB0aGlzLl9pc1N0aWNrZWQgfHwgKHRoaXMuX2NyZWF0ZUhpZGRlbkVsZW1lbnQoKSwgdGhpcy5fZW5hYmxlU3RpY2t5KCksIHRoaXMuX2NoYW5nZUJvdW5kYXJ5UG9zaXRpb24oKSwgdGhpcy5faXNTdGlja2VkID0gITAsIHRoaXMuX21hbnVhbGx5RGVhY3RpdmF0ZWQgPSAhMSk7XG4gIH1cbiAgaW5hY3RpdmUoKSB7XG4gICAgdGhpcy5faXNTdGlja2VkICYmICh0aGlzLl9kaXNhYmxlU3RpY2t5KCksIHRoaXMuX2lzU3RpY2tlZCA9ICExLCB0aGlzLl9tYW51YWxseURlYWN0aXZhdGVkID0gITApO1xuICB9XG4gIC8vIFByaXZhdGVcbiAgX2luaXQoKSB7XG4gICAgdGhpcy5fdXNlckFjdGl2aXR5TGlzdGVuZXIoKTtcbiAgfVxuICBfdXNlckFjdGl2aXR5TGlzdGVuZXIoKSB7XG4gICAgYy5vbih3aW5kb3csIFwicmVzaXplXCIsICgpID0+IHtcbiAgICAgIHRoaXMuX3VwZGF0ZUVsZW1lbnRQb3NpdGlvbigpLCB0aGlzLl91cGRhdGVFbGVtZW50T2Zmc2V0KCk7XG4gICAgfSksIGMub24od2luZG93LCBcInNjcm9sbFwiLCAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuX2VsZW1lbnQgfHwgd2luZG93LmlubmVyV2lkdGggPD0gdGhpcy5fb3B0aW9ucy5zdGlja3lNZWRpYSB8fCB0aGlzLl9tYW51YWxseURlYWN0aXZhdGVkKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCB0ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCB7IHN0aWNreURpcmVjdGlvbjogZSB9ID0gdGhpcy5fb3B0aW9ucywgaSA9IHdpbmRvdy5wYWdlWU9mZnNldCB8fCB0LnNjcm9sbFRvcDtcbiAgICAgIHRoaXMuX3VwZGF0ZUVsZW1lbnRPZmZzZXQoKSwgdGhpcy5fdXBkYXRlUHVzaFBvaW50KCksIHRoaXMuX3VwZGF0ZVNjcm9sbERpcmVjdGlvbihpKSwgdGhpcy5fY2xlYXJJblByb2dyZXNzQW5pbWF0aW9ucygpO1xuICAgICAgY29uc3QgbiA9IFt0aGlzLl9zY3JvbGxEaXJlY3Rpb24sIFwiYm90aFwiXS5pbmNsdWRlcyhcbiAgICAgICAgZVxuICAgICAgKSwgbyA9IHRoaXMuX3B1c2hQb2ludCA8PSBpLCByID0gbyAmJiAhdGhpcy5faXNTdGlja2VkICYmIG4sIGEgPSAoIW8gfHwgIW4pICYmIHRoaXMuX2lzU3RpY2tlZDtcbiAgICAgIHIgJiYgKHRoaXMuX2NyZWF0ZUhpZGRlbkVsZW1lbnQoKSwgdGhpcy5fZW5hYmxlU3RpY2t5KCksIHRoaXMuX2NoYW5nZUJvdW5kYXJ5UG9zaXRpb24oKSwgdGhpcy5faXNTdGlja2VkID0gITApLCBhICYmICh0aGlzLl9kaXNhYmxlU3RpY2t5KCksIHRoaXMuX2lzU3RpY2tlZCA9ICExKSwgdGhpcy5faXNTdGlja2VkICYmICh0aGlzLl91cGRhdGVQb3NpdGlvbih7IHN0eWxlczogdGhpcy5fZWxlbWVudFBvc2l0aW9uU3R5bGVzIH0pLCB0aGlzLl9jaGFuZ2VCb3VuZGFyeVBvc2l0aW9uKCkpLCB0aGlzLl9zY3JvbGxUb3AgPSBpIDw9IDAgPyAwIDogaTtcbiAgICB9KTtcbiAgfVxuICBfdXBkYXRlUHVzaFBvaW50KCkge1xuICAgIHRoaXMuX29wdGlvbnMuc3RpY2t5UG9zaXRpb24gPT09IFwidG9wXCIgPyB0aGlzLl9wdXNoUG9pbnQgPSB0aGlzLl9lbGVtZW50T2Zmc2V0VG9wIC0gdGhpcy5fb3B0aW9ucy5zdGlja3lEZWxheSA6IHRoaXMuX3B1c2hQb2ludCA9IHRoaXMuX2VsZW1lbnRPZmZzZXRUb3AgKyB0aGlzLl9lbGVtZW50LmhlaWdodCAtIGRvY3VtZW50LmJvZHkuc2Nyb2xsSGVpZ2h0ICsgdGhpcy5fb3B0aW9ucy5zdGlja3lEZWxheTtcbiAgfVxuICBfdXBkYXRlRWxlbWVudE9mZnNldCgpIHtcbiAgICB0aGlzLl9oaWRkZW5FbGVtZW50ID8gdGhpcy5fZWxlbWVudE9mZnNldFRvcCA9IHRoaXMuX2hpZGRlbkVsZW1lbnQub2Zmc2V0VG9wIDogdGhpcy5fZWxlbWVudE9mZnNldFRvcCA9IHRoaXMuX2VsZW1lbnQub2Zmc2V0VG9wLCB0aGlzLl9vcHRpb25zLnN0aWNreUFuaW1hdGlvblVuc3RpY2t5ICYmICh0aGlzLl9lbGVtZW50T2Zmc2V0VG9wICs9IHRoaXMuX2VsZW1lbnQuaGVpZ2h0IHx8IDApO1xuICB9XG4gIF91cGRhdGVFbGVtZW50UG9zaXRpb24oKSB7XG4gICAgaWYgKHRoaXMuX2hpZGRlbkVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IHsgbGVmdDogdCB9ID0gdGhpcy5faGlkZGVuRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHRoaXMuX2VsZW1lbnRQb3NpdGlvblN0eWxlcyA9IHtcbiAgICAgICAgbGVmdDogYCR7dH1weGBcbiAgICAgIH07XG4gICAgfSBlbHNlXG4gICAgICB0aGlzLl9lbGVtZW50UG9zaXRpb25TdHlsZXMgPSB7fTtcbiAgICB0aGlzLl9zZXRTdHlsZSh0aGlzLl9lbGVtZW50LCB0aGlzLl9lbGVtZW50UG9zaXRpb25TdHlsZXMpO1xuICB9XG4gIF91cGRhdGVTY3JvbGxEaXJlY3Rpb24odCkge1xuICAgIHQgPiB0aGlzLl9zY3JvbGxUb3AgPyB0aGlzLl9zY3JvbGxEaXJlY3Rpb24gPSBcImRvd25cIiA6IHRoaXMuX3Njcm9sbERpcmVjdGlvbiA9IFwidXBcIjtcbiAgfVxuICBfY2xlYXJJblByb2dyZXNzQW5pbWF0aW9ucygpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fc2Nyb2xsRGlyZWN0aW9uID09PSBcInVwXCIsIGUgPSB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhcbiAgICAgIHRoaXMuX29wdGlvbnMuc3RpY2t5QW5pbWF0aW9uVW5zdGlja3lcbiAgICApLCBpID0gd2luZG93LnNjcm9sbFkgPD0gdGhpcy5fZWxlbWVudE9mZnNldFRvcCAtIHRoaXMuX2VsZW1lbnQuaGVpZ2h0O1xuICAgIHQgJiYgZSAmJiBpICYmICh0aGlzLl9yZW1vdmVVbnN0aWNreUFuaW1hdGlvbigpLCB0aGlzLl9yZXNldFN0eWxlcygpLCB0aGlzLl9yZW1vdmVIaWRkZW5FbGVtZW50KCkpO1xuICB9XG4gIF9lbmFibGVTdGlja3koKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3RpY2t5QW5pbWF0aW9uU3RpY2t5OiB0LFxuICAgICAgc3RpY2t5QW5pbWF0aW9uVW5zdGlja3k6IGUsXG4gICAgICBzdGlja3lPZmZzZXQ6IGksXG4gICAgICBzdGlja3lQb3NpdGlvbjogbixcbiAgICAgIHN0aWNreVpJbmRleDogb1xuICAgIH0gPSB0aGlzLl9vcHRpb25zLCB7IGhlaWdodDogciwgbGVmdDogYSwgd2lkdGg6IGwgfSA9IHRoaXMuX2VsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgdCAhPT0gXCJcIiAmJiB0aGlzLl90b2dnbGVDbGFzcyhcbiAgICAgIHQsXG4gICAgICBlLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICksIHRoaXMuX3RvZ2dsZUNsYXNzKHRoaXMuX2NsYXNzZXMuc3RpY2t5QWN0aXZlLCBcIlwiLCB0aGlzLl9lbGVtZW50KSwgdGhpcy5fc2V0U3R5bGUodGhpcy5fZWxlbWVudCwge1xuICAgICAgdG9wOiBuID09PSBcInRvcFwiICYmIGAkezAgKyBpfXB4YCxcbiAgICAgIGJvdHRvbTogbiA9PT0gXCJib3R0b21cIiAmJiBgJHswICsgaX1weGAsXG4gICAgICBoZWlnaHQ6IGAke3J9cHhgLFxuICAgICAgd2lkdGg6IGAke2x9cHhgLFxuICAgICAgbGVmdDogYCR7YX1weGAsXG4gICAgICB6SW5kZXg6IGAke299YCxcbiAgICAgIHBvc2l0aW9uOiBcImZpeGVkXCJcbiAgICB9KSwgdGhpcy5faGlkZGVuRWxlbWVudC5oaWRkZW4gPSAhMSwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIENDKTtcbiAgfVxuICBfY2hhbmdlQm91bmRhcnlQb3NpdGlvbigpIHtcbiAgICBjb25zdCB7IHN0aWNreVBvc2l0aW9uOiB0LCBzdGlja3lCb3VuZGFyeTogZSwgc3RpY2t5T2Zmc2V0OiBpIH0gPSB0aGlzLl9vcHRpb25zLCB7IGhlaWdodDogbiB9ID0gdGhpcy5fZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgbyA9IHtcbiAgICAgIGhlaWdodDogdGhpcy5fZWxlbWVudC5wYXJlbnRFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCxcbiAgICAgIC4uLnRoaXMuX2dldE9mZnNldCh0aGlzLl9lbGVtZW50LnBhcmVudEVsZW1lbnQpXG4gICAgfTtcbiAgICBsZXQgcjtcbiAgICBjb25zdCBhID0gZC5maW5kT25lKGUpO1xuICAgIGEgPyByID0gdGhpcy5fZ2V0T2Zmc2V0KGEpLnRvcCAtIG4gLSBpIDogciA9IG8uaGVpZ2h0ICsgb1t0XSAtIG4gLSBpO1xuICAgIGNvbnN0IGwgPSB0ID09PSBcInRvcFwiLCBwID0gdCA9PT0gXCJib3R0b21cIiwgdSA9IGUsIF8gPSByIDwgMCwgZiA9IHIgPiBvLmhlaWdodCAtIG47XG4gICAgbGV0IGc7XG4gICAgbCAmJiAoXyAmJiB1ID8gZyA9IHsgdG9wOiBgJHtpICsgcn1weGAgfSA6IGcgPSB7IHRvcDogYCR7aSArIDB9cHhgIH0pLCBwICYmIChfICYmIHUgPyBnID0geyBib3R0b206IGAke2kgKyByfXB4YCB9IDogZiAmJiB1ID8gZyA9IHsgYm90dG9tOiBgJHtpICsgby5ib3R0b219cHhgIH0gOiBnID0geyBib3R0b206IGAke2kgKyAwfXB4YCB9KSwgdGhpcy5fc2V0U3R5bGUodGhpcy5fZWxlbWVudCwgZyk7XG4gIH1cbiAgX2Rpc2FibGVTdGlja3koKSB7XG4gICAgY29uc3QgeyBzdGlja3lBbmltYXRpb25VbnN0aWNreTogdCwgc3RpY2t5QW5pbWF0aW9uU3RpY2t5OiBlIH0gPSB0aGlzLl9vcHRpb25zO1xuICAgIGxldCB7IGFuaW1hdGlvbkR1cmF0aW9uOiBpIH0gPSBnZXRDb21wdXRlZFN0eWxlKHRoaXMuX2VsZW1lbnQpO1xuICAgIGkgPSB0ICE9PSBcIlwiID8gcGFyc2VGbG9hdChpKSAqIDFlMyA6IDAsIHRoaXMuX29wdGlvbnMuc3RpY2t5QW5pbWF0aW9uVW5zdGlja3kgIT09IFwiXCIgJiYgdGhpcy5fdG9nZ2xlQ2xhc3MoXG4gICAgICB0LFxuICAgICAgZSxcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKGUpIHx8ICh0aGlzLl9yZW1vdmVVbnN0aWNreUFuaW1hdGlvbigpLCB0aGlzLl9yZXNldFN0eWxlcygpLCB0aGlzLl9yZW1vdmVIaWRkZW5FbGVtZW50KCksIHRoaXMuX3RvZ2dsZUNsYXNzKFwiXCIsIHRoaXMuX2NsYXNzZXMuc3RpY2t5QWN0aXZlLCB0aGlzLl9lbGVtZW50KSwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEFDKSk7XG4gICAgfSwgaSk7XG4gIH1cbiAgX2NyZWF0ZUhpZGRlbkVsZW1lbnQoKSB7XG4gICAgdGhpcy5faGlkZGVuRWxlbWVudCB8fCAodGhpcy5faGlkZGVuRWxlbWVudCA9IHRoaXMuX2NvcHlFbGVtZW50KHRoaXMuX2VsZW1lbnQpKTtcbiAgfVxuICBfcmVtb3ZlSGlkZGVuRWxlbWVudCgpIHtcbiAgICB0aGlzLl9oaWRkZW5FbGVtZW50ICYmICh0aGlzLl9oaWRkZW5FbGVtZW50LnJlbW92ZSgpLCB0aGlzLl9oaWRkZW5FbGVtZW50ID0gbnVsbCk7XG4gIH1cbiAgX3JlbW92ZVVuc3RpY2t5QW5pbWF0aW9uKCkge1xuICAgIHRoaXMuX3RvZ2dsZUNsYXNzKFwiXCIsIHRoaXMuX29wdGlvbnMuc3RpY2t5QW5pbWF0aW9uVW5zdGlja3ksIHRoaXMuX2VsZW1lbnQpO1xuICB9XG4gIF9yZXNldFN0eWxlcygpIHtcbiAgICB0aGlzLl9zZXRTdHlsZSh0aGlzLl9lbGVtZW50LCB7XG4gICAgICB0b3A6IG51bGwsXG4gICAgICBib3R0b206IG51bGwsXG4gICAgICBwb3NpdGlvbjogbnVsbCxcbiAgICAgIGxlZnQ6IG51bGwsXG4gICAgICB6SW5kZXg6IG51bGwsXG4gICAgICB3aWR0aDogbnVsbCxcbiAgICAgIGhlaWdodDogbnVsbFxuICAgIH0pO1xuICB9XG4gIF91cGRhdGVQb3NpdGlvbih7IHN0eWxlczogdCB9KSB7XG4gICAgdGhpcy5fc2V0U3R5bGUodGhpcy5fZWxlbWVudCwgdCk7XG4gIH1cbiAgX3RvZ2dsZUNsYXNzKHQsIGUsIGkpIHtcbiAgICB0ICYmIGguYWRkQ2xhc3MoaSwgdCksIGUgJiYgaC5yZW1vdmVDbGFzcyhpLCBlKTtcbiAgfVxuICBfZ2V0T2Zmc2V0KHQpIHtcbiAgICBjb25zdCBlID0gaC5vZmZzZXQodCksIGkgPSB0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBuID0gZS5sZWZ0ID09PSAwICYmIGUudG9wID09PSAwID8gMCA6IHdpbmRvdy5pbm5lckhlaWdodCAtIGkuYm90dG9tO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5lLFxuICAgICAgYm90dG9tOiBuXG4gICAgfTtcbiAgfVxuICBfY29weUVsZW1lbnQodCkge1xuICAgIGNvbnN0IHsgaGVpZ2h0OiBlLCB3aWR0aDogaSB9ID0gdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgbiA9IHQuY2xvbmVOb2RlKCExKTtcbiAgICByZXR1cm4gbi5oaWRkZW4gPSAhMCwgdGhpcy5fc2V0U3R5bGUobiwge1xuICAgICAgaGVpZ2h0OiBgJHtlfXB4YCxcbiAgICAgIHdpZHRoOiBgJHtpfXB4YCxcbiAgICAgIG9wYWNpdHk6IFwiMFwiXG4gICAgfSksIHQucGFyZW50RWxlbWVudC5pbnNlcnRCZWZvcmUobiwgdCksIG47XG4gIH1cbiAgX2dldENvbmZpZyh0ID0ge30pIHtcbiAgICBjb25zdCBlID0gaC5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLnlDLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBEKEpzLCB0LCB3QyksIHQ7XG4gIH1cbiAgX2dldENsYXNzZXModCkge1xuICAgIGNvbnN0IGUgPSBoLmdldERhdGFDbGFzc0F0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5rQyxcbiAgICAgIC4uLmUsXG4gICAgICAuLi50XG4gICAgfSwgRChKcywgdCwgeEMpLCB0O1xuICB9XG4gIF9zZXRTdHlsZSh0LCBlKSB7XG4gICAgT2JqZWN0LmtleXMoZSkuZm9yRWFjaCgoaSkgPT4ge1xuICAgICAgdC5zdHlsZVtpXSA9IGVbaV07XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0LCBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGxldCBpID0geS5nZXREYXRhKHRoaXMsIHhpKTtcbiAgICAgIGNvbnN0IG4gPSB0eXBlb2YgdCA9PSBcIm9iamVjdFwiICYmIHQ7XG4gICAgICBpZiAoISghaSAmJiAvZGlzcG9zZXxoaWRlLy50ZXN0KHQpKSAmJiAoaSB8fCAoaSA9IG5ldyAkaCh0aGlzLCBuKSksIHR5cGVvZiB0ID09IFwic3RyaW5nXCIpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaVt0XSA+IFwidVwiKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7dH1cImApO1xuICAgICAgICBpW3RdKGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBnZXRJbnN0YW5jZSh0KSB7XG4gICAgcmV0dXJuIHkuZ2V0RGF0YSh0LCB4aSk7XG4gIH1cbiAgc3RhdGljIGdldE9yQ3JlYXRlSW5zdGFuY2UodCwgZSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UodCkgfHwgbmV3IHRoaXModCwgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiA/IGUgOiBudWxsKTtcbiAgfVxufVxuY29uc3QgT0MgPSAocykgPT4ge1xuICBabCgoKSA9PiB7XG4gICAgY29uc3QgdCA9IHFsKCk7XG4gICAgaWYgKHQpIHtcbiAgICAgIGNvbnN0IGUgPSBzLk5BTUUsIGkgPSB0LmZuW2VdO1xuICAgICAgdC5mbltlXSA9IHMualF1ZXJ5SW50ZXJmYWNlLCB0LmZuW2VdLkNvbnN0cnVjdG9yID0gcywgdC5mbltlXS5ub0NvbmZsaWN0ID0gKCkgPT4gKHQuZm5bZV0gPSBpLCBzLmpRdWVyeUludGVyZmFjZSk7XG4gICAgfVxuICB9KTtcbn0sIFNDID0gKHMsIHQpID0+IHtcbiAgYy5vbihcbiAgICBkb2N1bWVudCxcbiAgICBgY2xpY2sudGUuJHtzLk5BTUV9YCxcbiAgICB0LFxuICAgIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKSwgcy5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMpLnRvZ2dsZSgpO1xuICAgIH1cbiAgKTtcbn0sIElDID0gKHMsIHQpID0+IHtcbiAgYy5vbihcbiAgICBkb2N1bWVudCxcbiAgICBgY2xpY2sudGUuJHtzLk5BTUV9LmRhdGEtYXBpYCxcbiAgICB0LFxuICAgIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmIChbXCJBXCIsIFwiQVJFQVwiXS5pbmNsdWRlcyh0aGlzLnRhZ05hbWUpICYmIGUucHJldmVudERlZmF1bHQoKSwgZ2UodGhpcykpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHMuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzKS5zaG93KCk7XG4gICAgfVxuICApO1xufSwgREMgPSAocywgdCkgPT4ge1xuICBjLm9uKFxuICAgIGRvY3VtZW50LFxuICAgIGBjbGljay50ZS4ke3MuTkFNRX0uZGF0YS1hcGlgLFxuICAgIHQsXG4gICAgZnVuY3Rpb24oZSkge1xuICAgICAgY29uc3QgaSA9IEp0KHRoaXMpO1xuICAgICAgaWYgKFtcIkFcIiwgXCJBUkVBXCJdLmluY2x1ZGVzKHRoaXMudGFnTmFtZSkgJiYgZS5wcmV2ZW50RGVmYXVsdCgpLCBnZSh0aGlzKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgYy5vbmUoaSwgcy5FVkVOVF9ISURERU4sICgpID0+IHtcbiAgICAgICAgTnQodGhpcykgJiYgdGhpcy5mb2N1cygpO1xuICAgICAgfSk7XG4gICAgICBjb25zdCBuID0gZC5maW5kT25lKHMuT1BFTl9TRUxFQ1RPUik7XG4gICAgICBuICYmIG4gIT09IGkgJiYgcy5nZXRJbnN0YW5jZShuKS5oaWRlKCksIHMuZ2V0T3JDcmVhdGVJbnN0YW5jZShpKS50b2dnbGUodGhpcyk7XG4gICAgfVxuICApO1xufSwgJEMgPSAocywgdCkgPT4ge1xuICBjLm9uKFxuICAgIGRvY3VtZW50LFxuICAgIGBjbGljay50ZS4ke3MuTkFNRX1gLFxuICAgIHQsXG4gICAgKGUpID0+IHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGNvbnN0IGkgPSBlLnRhcmdldC5jbG9zZXN0KHQpO1xuICAgICAgcy5nZXRPckNyZWF0ZUluc3RhbmNlKGkpLnRvZ2dsZSgpO1xuICAgIH1cbiAgKTtcbn0sIExDID0gKHMsIHQpID0+IHtcbiAgYy5vbihcbiAgICBkb2N1bWVudCxcbiAgICBgY2xpY2sudGUuJHtzLk5BTUV9YCxcbiAgICB0LFxuICAgIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGNvbnN0IGkgPSBKdCh0aGlzKTtcbiAgICAgIFtcIkFcIiwgXCJBUkVBXCJdLmluY2x1ZGVzKHRoaXMudGFnTmFtZSkgJiYgZS5wcmV2ZW50RGVmYXVsdCgpLCBjLm9uZShpLCBzLkVWRU5UX1NIT1csIChyKSA9PiB7XG4gICAgICAgIHIuZGVmYXVsdFByZXZlbnRlZCB8fCBjLm9uZShpLCBzLkVWRU5UX0hJRERFTiwgKCkgPT4ge1xuICAgICAgICAgIE50KHRoaXMpICYmIHRoaXMuZm9jdXMoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG4gPSBkLmZpbmRPbmUoXG4gICAgICAgIGBbJHtzLk9QRU5fU0VMRUNUT1J9PVwidHJ1ZVwiXWBcbiAgICAgICk7XG4gICAgICBuICYmIHMuZ2V0SW5zdGFuY2UobikuaGlkZSgpLCBzLmdldE9yQ3JlYXRlSW5zdGFuY2UoaSkudG9nZ2xlKHRoaXMpO1xuICAgIH1cbiAgKTtcbn0sIE5DID0gKHMsIHQpID0+IHtcbiAgYy5vbmUoXG4gICAgZG9jdW1lbnQsXG4gICAgXCJtb3VzZWRvd25cIixcbiAgICB0LFxuICAgIHMuYXV0b0luaXRpYWwobmV3IHMoKSlcbiAgKTtcbn0sIE1DID0gKHMsIHQpID0+IHtcbiAgYy5vbihcbiAgICBkb2N1bWVudCxcbiAgICBgY2xpY2sudGUuJHtzLk5BTUV9LmRhdGEtYXBpYCxcbiAgICB0LFxuICAgIGZ1bmN0aW9uKGUpIHtcbiAgICAgIChlLnRhcmdldC50YWdOYW1lID09PSBcIkFcIiB8fCBlLmRlbGVnYXRlVGFyZ2V0ICYmIGUuZGVsZWdhdGVUYXJnZXQudGFnTmFtZSA9PT0gXCJBXCIpICYmIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGNvbnN0IGkgPSBxbyh0aGlzKTtcbiAgICAgIGQuZmluZChpKS5mb3JFYWNoKChvKSA9PiB7XG4gICAgICAgIHMuZ2V0T3JDcmVhdGVJbnN0YW5jZShvLCB7IHRvZ2dsZTogITEgfSkudG9nZ2xlKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICk7XG59LCBSQyA9IChzLCB0KSA9PiB7XG4gIFtdLnNsaWNlLmNhbGwoXG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCh0KVxuICApLm1hcChmdW5jdGlvbihpKSB7XG4gICAgcmV0dXJuIG5ldyBzKGkpO1xuICB9KTtcbn0sIFBDID0gKHMsIHQpID0+IHtcbiAgW10uc2xpY2UuY2FsbChcbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHQpXG4gICkubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICByZXR1cm4gbmV3IHMoaSk7XG4gIH0pO1xufSwgQkMgPSAocywgdCkgPT4ge1xuICBkLmZpbmQodCkuZm9yRWFjaCgoZSkgPT4ge1xuICAgIG5ldyBzKGUpO1xuICB9KSwgYy5vbihcbiAgICBkb2N1bWVudCxcbiAgICBgY2xpY2sudGUuJHtzLk5BTUV9LmRhdGEtYXBpYCxcbiAgICBgJHt0fSBpbWc6bm90KFtkYXRhLXRlLWxpZ2h0Ym94LWRpc2FibGVkXSlgLFxuICAgIHMudG9nZ2xlKClcbiAgKTtcbn0sIEhDID0gKHMsIHQpID0+IHtcbiAgY29uc3QgZSA9IChvKSA9PiBvWzBdID09PSBcIntcIiAmJiBvW28ubGVuZ3RoIC0gMV0gPT09IFwifVwiIHx8IG9bMF0gPT09IFwiW1wiICYmIG9bby5sZW5ndGggLSAxXSA9PT0gXCJdXCIsIGkgPSAobykgPT4gdHlwZW9mIG8gIT0gXCJzdHJpbmdcIiA/IG8gOiBlKG8pID8gSlNPTi5wYXJzZShvLnJlcGxhY2UoLycvZywgJ1wiJykpIDogbywgbiA9IChvKSA9PiB7XG4gICAgY29uc3QgciA9IHt9O1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhvKS5mb3JFYWNoKChhKSA9PiB7XG4gICAgICBpZiAoYS5tYXRjaCgvZGF0YXNldC4qLykpIHtcbiAgICAgICAgY29uc3QgbCA9IGEuc2xpY2UoNywgOCkudG9Mb3dlckNhc2UoKS5jb25jYXQoYS5zbGljZSg4KSk7XG4gICAgICAgIHJbbF0gPSBpKG9bYV0pO1xuICAgICAgfVxuICAgIH0pLCByO1xuICB9O1xuICBkLmZpbmQodCkuZm9yRWFjaCgobykgPT4ge1xuICAgIGlmIChoLmdldERhdGFBdHRyaWJ1dGUobywgXCJjaGFydFwiKSAhPT0gXCJidWJibGVcIiAmJiBoLmdldERhdGFBdHRyaWJ1dGUobywgXCJjaGFydFwiKSAhPT0gXCJzY2F0dGVyXCIpIHtcbiAgICAgIGNvbnN0IHIgPSBoLmdldERhdGFBdHRyaWJ1dGVzKG8pLCBhID0ge1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgZGF0YXNldHM6IFtuKHIpXVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHIuY2hhcnQgJiYgKGEudHlwZSA9IHIuY2hhcnQpLCByLmxhYmVscyAmJiAoYS5kYXRhLmxhYmVscyA9IEpTT04ucGFyc2Uoci5sYWJlbHMucmVwbGFjZSgvJy9nLCAnXCInKSkpLCBuZXcgcyhvLCB7XG4gICAgICAgIC4uLmEsXG4gICAgICAgIC4uLlRpW2EudHlwZV1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfSk7XG59O1xuY2xhc3MgVkMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmluaXRzID0gW107XG4gIH1cbiAgZ2V0IGluaXRpYWxpemVkKCkge1xuICAgIHJldHVybiB0aGlzLmluaXRzO1xuICB9XG4gIGlzSW5pdGVkKHQpIHtcbiAgICByZXR1cm4gdGhpcy5pbml0cy5pbmNsdWRlcyh0KTtcbiAgfVxuICBhZGQodCkge1xuICAgIHRoaXMuaXNJbml0ZWQodCkgfHwgdGhpcy5pbml0cy5wdXNoKHQpO1xuICB9XG59XG5jb25zdCBHbyA9IG5ldyBWQygpLCBPaSA9IHtcbiAgYWxlcnQ6IHtcbiAgICBuYW1lOiBcIkFsZXJ0XCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtYWxlcnQtaW5pdF1cIixcbiAgICBpc1RvZ2dsZXI6ICExXG4gIH0sXG4gIGFuaW1hdGlvbjoge1xuICAgIG5hbWU6IFwiQW5pbWF0ZVwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLWFuaW1hdGlvbi1pbml0XVwiLFxuICAgIGlzVG9nZ2xlcjogITFcbiAgfSxcbiAgY2Fyb3VzZWw6IHtcbiAgICBuYW1lOiBcIkNhcm91c2VsXCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtY2Fyb3VzZWwtaW5pdF1cIixcbiAgICBpc1RvZ2dsZXI6ICExXG4gIH0sXG4gIGNoaXBzOiB7XG4gICAgbmFtZTogXCJDaGlwc0lucHV0XCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtY2hpcHMtaW5wdXQtaW5pdF1cIixcbiAgICBpc1RvZ2dsZXI6ICExXG4gIH0sXG4gIGNoaXA6IHtcbiAgICBuYW1lOiBcIkNoaXBcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS1jaGlwLWluaXRdXCIsXG4gICAgaXNUb2dnbGVyOiAhMSxcbiAgICBvbkluaXQ6IFwiaW5pdFwiXG4gIH0sXG4gIGRhdGVwaWNrZXI6IHtcbiAgICBuYW1lOiBcIkRhdGVwaWNrZXJcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS1kYXRlcGlja2VyLWluaXRdXCIsXG4gICAgaXNUb2dnbGVyOiAhMVxuICB9LFxuICBkYXRldGltZXBpY2tlcjoge1xuICAgIG5hbWU6IFwiRGF0ZXRpbWVwaWNrZXJcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS1kYXRlLXRpbWVwaWNrZXItaW5pdF1cIixcbiAgICBpc1RvZ2dsZXI6ICExXG4gIH0sXG4gIGlucHV0OiB7XG4gICAgbmFtZTogXCJJbnB1dFwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLWlucHV0LXdyYXBwZXItaW5pdF1cIixcbiAgICBpc1RvZ2dsZXI6ICExXG4gIH0sXG4gIHBlcmZlY3RTY3JvbGxiYXI6IHtcbiAgICBuYW1lOiBcIlBlcmZlY3RTY3JvbGxiYXJcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS1wZXJmZWN0LXNjcm9sbGJhci1pbml0XVwiLFxuICAgIGlzVG9nZ2xlcjogITFcbiAgfSxcbiAgcmF0aW5nOiB7XG4gICAgbmFtZTogXCJSYXRpbmdcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS1yYXRpbmctaW5pdF1cIixcbiAgICBpc1RvZ2dsZXI6ICExXG4gIH0sXG4gIHNjcm9sbHNweToge1xuICAgIG5hbWU6IFwiU2Nyb2xsU3B5XCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtc3B5PSdzY3JvbGwnXVwiLFxuICAgIGlzVG9nZ2xlcjogITFcbiAgfSxcbiAgc2VsZWN0OiB7XG4gICAgbmFtZTogXCJTZWxlY3RcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS1zZWxlY3QtaW5pdF1cIixcbiAgICBpc1RvZ2dsZXI6ICExXG4gIH0sXG4gIHNpZGVuYXY6IHtcbiAgICBuYW1lOiBcIlNpZGVuYXZcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS1zaWRlbmF2LWluaXRdXCIsXG4gICAgaXNUb2dnbGVyOiAhMVxuICB9LFxuICBzdGVwcGVyOiB7XG4gICAgbmFtZTogXCJTdGVwcGVyXCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtc3RlcHBlci1pbml0XVwiLFxuICAgIGlzVG9nZ2xlcjogITFcbiAgfSxcbiAgdGltZXBpY2tlcjoge1xuICAgIG5hbWU6IFwiVGltZXBpY2tlclwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLXRpbWVwaWNrZXItaW5pdF1cIixcbiAgICBpc1RvZ2dsZXI6ICExXG4gIH0sXG4gIHRvYXN0OiB7XG4gICAgbmFtZTogXCJUb2FzdFwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLXRvYXN0LWluaXRdXCIsXG4gICAgaXNUb2dnbGVyOiAhMVxuICB9LFxuICBkYXRhdGFibGU6IHtcbiAgICBuYW1lOiBcIkRhdGF0YWJsZVwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLWRhdGF0YWJsZS1pbml0XVwiXG4gIH0sXG4gIHBvcGNvbmZpcm06IHtcbiAgICBuYW1lOiBcIlBvcGNvbmZpcm1cIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS10b2dnbGU9J3BvcGNvbmZpcm0nXVwiXG4gIH0sXG4gIHZhbGlkYXRpb246IHtcbiAgICBuYW1lOiBcIlZhbGlkYXRpb25cIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS12YWxpZGF0aW9uLWluaXRdXCJcbiAgfSxcbiAgc21vb3RoU2Nyb2xsOiB7XG4gICAgbmFtZTogXCJTbW9vdGhTY3JvbGxcIixcbiAgICBzZWxlY3RvcjogXCJhW2RhdGEtdGUtc21vb3RoLXNjcm9sbC1pbml0XVwiXG4gIH0sXG4gIGxhenlMb2FkOiB7XG4gICAgbmFtZTogXCJMYXp5TG9hZFwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLWxhenktbG9hZC1pbml0XVwiXG4gIH0sXG4gIGNsaXBib2FyZDoge1xuICAgIG5hbWU6IFwiQ2xpcGJvYXJkXCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtY2xpcGJvYXJkLWluaXRdXCJcbiAgfSxcbiAgaW5maW5pdGVTY3JvbGw6IHtcbiAgICBuYW1lOiBcIkluZmluaXRlU2Nyb2xsXCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtaW5maW5pdGUtc2Nyb2xsLWluaXRdXCJcbiAgfSxcbiAgbG9hZGluZ01hbmFnZW1lbnQ6IHtcbiAgICBuYW1lOiBcIkxvYWRpbmdNYW5hZ2VtZW50XCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtbG9hZGluZy1tYW5hZ2VtZW50LWluaXRdXCJcbiAgfSxcbiAgc3RpY2t5OiB7XG4gICAgbmFtZTogXCJTdGlja3lcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS1zdGlja3ktaW5pdF1cIlxuICB9LFxuICAvLyBhZHZhbmNlZEluaXRzXG4gIGNoYXJ0OiB7XG4gICAgbmFtZTogXCJDaGFydFwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLWNoYXJ0XVwiLFxuICAgIGlzVG9nZ2xlcjogITEsXG4gICAgYWR2YW5jZWQ6IEhDXG4gIH0sXG4gIC8vIHRvZ2dsZXJzXG4gIGJ1dHRvbjoge1xuICAgIG5hbWU6IFwiQnV0dG9uXCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtdG9nZ2xlPSdidXR0b24nXVwiLFxuICAgIGlzVG9nZ2xlcjogITAsXG4gICAgY2FsbGJhY2s6ICRDXG4gIH0sXG4gIGNvbGxhcHNlOiB7XG4gICAgbmFtZTogXCJDb2xsYXBzZVwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLWNvbGxhcHNlLWluaXRdXCIsXG4gICAgaXNUb2dnbGVyOiAhMCxcbiAgICBjYWxsYmFjazogTUNcbiAgfSxcbiAgZHJvcGRvd246IHtcbiAgICBuYW1lOiBcIkRyb3Bkb3duXCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtZHJvcGRvd24tdG9nZ2xlLXJlZl1cIixcbiAgICBpc1RvZ2dsZXI6ICEwLFxuICAgIGNhbGxiYWNrOiBTQ1xuICB9LFxuICBtb2RhbDoge1xuICAgIG5hbWU6IFwiTW9kYWxcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS10b2dnbGU9J21vZGFsJ11cIixcbiAgICBpc1RvZ2dsZXI6ICEwLFxuICAgIGNhbGxiYWNrOiBMQ1xuICB9LFxuICByaXBwbGU6IHtcbiAgICBuYW1lOiBcIlJpcHBsZVwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLXJpcHBsZS1pbml0XVwiLFxuICAgIGlzVG9nZ2xlcjogITAsXG4gICAgY2FsbGJhY2s6IE5DXG4gIH0sXG4gIG9mZmNhbnZhczoge1xuICAgIG5hbWU6IFwiT2ZmY2FudmFzXCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtb2ZmY2FudmFzLXRvZ2dsZV1cIixcbiAgICBpc1RvZ2dsZXI6ICEwLFxuICAgIGNhbGxiYWNrOiBEQ1xuICB9LFxuICB0YWI6IHtcbiAgICBuYW1lOiBcIlRhYlwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLXRvZ2dsZT0ndGFiJ10sIFtkYXRhLXRlLXRvZ2dsZT0ncGlsbCddLCBbZGF0YS10ZS10b2dnbGU9J2xpc3QnXVwiLFxuICAgIGlzVG9nZ2xlcjogITAsXG4gICAgY2FsbGJhY2s6IElDXG4gIH0sXG4gIHRvb2x0aXA6IHtcbiAgICBuYW1lOiBcIlRvb2x0aXBcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS10b2dnbGU9J3Rvb2x0aXAnXVwiLFxuICAgIGlzVG9nZ2xlcjogITEsXG4gICAgY2FsbGJhY2s6IFJDXG4gIH0sXG4gIHBvcG92ZXI6IHtcbiAgICBuYW1lOiBcIlBvcG92ZXJcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS10b2dnbGU9J3BvcG92ZXInXVwiLFxuICAgIGlzVG9nZ2xlcjogITAsXG4gICAgY2FsbGJhY2s6IFBDXG4gIH0sXG4gIGxpZ2h0Ym94OiB7XG4gICAgbmFtZTogXCJMaWdodGJveFwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLWxpZ2h0Ym94LWluaXRdXCIsXG4gICAgaXNUb2dnbGVyOiAhMCxcbiAgICBjYWxsYmFjazogQkNcbiAgfSxcbiAgdG91Y2g6IHtcbiAgICBuYW1lOiBcIlRvdWNoXCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtdG91Y2gtaW5pdF1cIlxuICB9XG59LCBXQyA9IChzKSA9PiBPaVtzLk5BTUVdIHx8IG51bGwsIEZDID0gKHMsIHQpID0+IHtcbiAgaWYgKCFzIHx8ICF0LmFsbG93UmVpbml0cyAmJiBHby5pc0luaXRlZChzLk5BTUUpKVxuICAgIHJldHVybjtcbiAgR28uYWRkKHMuTkFNRSk7XG4gIGNvbnN0IGUgPSBXQyhzKSwgaSA9IChlID09IG51bGwgPyB2b2lkIDAgOiBlLmlzVG9nZ2xlcikgfHwgITE7XG4gIGlmIChPQyhzKSwgZSAhPSBudWxsICYmIGUuYWR2YW5jZWQpIHtcbiAgICBlID09IG51bGwgfHwgZS5hZHZhbmNlZChzLCBlID09IG51bGwgPyB2b2lkIDAgOiBlLnNlbGVjdG9yKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGkpIHtcbiAgICBlID09IG51bGwgfHwgZS5jYWxsYmFjayhzLCBlID09IG51bGwgPyB2b2lkIDAgOiBlLnNlbGVjdG9yKTtcbiAgICByZXR1cm47XG4gIH1cbiAgZC5maW5kKGUgPT0gbnVsbCA/IHZvaWQgMCA6IGUuc2VsZWN0b3IpLmZvckVhY2goKG4pID0+IHtcbiAgICBsZXQgbyA9IHMuZ2V0SW5zdGFuY2Uobik7XG4gICAgbyB8fCAobyA9IG5ldyBzKG4pLCBlICE9IG51bGwgJiYgZS5vbkluaXQgJiYgb1tlLm9uSW5pdF0oKSk7XG4gIH0pO1xufSwgWUMgPSAocywgdCkgPT4ge1xuICBzLmZvckVhY2goKGUpID0+IEZDKGUsIHQpKTtcbn0sIGpDID0ge1xuICBhbGxvd1JlaW5pdHM6ICExLFxuICBjaGVja090aGVySW1wb3J0czogITFcbn0sIFpDID0gKHMsIHQgPSB7fSkgPT4ge1xuICB0ID0geyAuLi5qQywgLi4udCB9O1xuICBjb25zdCBlID0gT2JqZWN0LmtleXMoT2kpLm1hcCgoaSkgPT4ge1xuICAgIGlmICghIWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoT2lbaV0uc2VsZWN0b3IpKSB7XG4gICAgICBjb25zdCBvID0gc1tPaVtpXS5uYW1lXTtcbiAgICAgIHJldHVybiAhbyAmJiAhR28uaXNJbml0ZWQoaSkgJiYgdC5jaGVja090aGVySW1wb3J0cyAmJiBjb25zb2xlLndhcm4oXG4gICAgICAgIGBQbGVhc2UgaW1wb3J0ICR7T2lbaV0ubmFtZX0gZnJvbSBcInR3LWVsZW1lbnRzXCIgcGFja2FnZSBhbmQgYWRkIGl0IHRvIGEgb2JqZWN0IHBhcmFtZXRlciBpbnNpZGUgXCJpbml0VEVcIiBmdW5jdGlvbmBcbiAgICAgICksIG87XG4gICAgfVxuICB9KTtcbiAgWUMoZSwgdCk7XG59O1xuZXhwb3J0IHtcbiAgTG8gYXMgQWxlcnQsXG4gIHByIGFzIEFuaW1hdGUsXG4gIHJjIGFzIEJ1dHRvbixcbiAgVXQgYXMgQ2Fyb3VzZWwsXG4gIGRoIGFzIENoYXJ0LFxuICBfaSBhcyBDaGlwLFxuICBHQyBhcyBDaGlwc0lucHV0LFxuICB3aCBhcyBDbGlwYm9hcmQsXG4gIFp0IGFzIENvbGxhcHNlLFxuICBnaCBhcyBEYXRhdGFibGUsXG4gIE5tIGFzIERhdGVwaWNrZXIsXG4gIEloIGFzIERhdGV0aW1lcGlja2VyLFxuICBEdCBhcyBEcm9wZG93bixcbiAga2ggYXMgSW5maW5pdGVTY3JvbGwsXG4gIFYgYXMgSW5wdXQsXG4gIFVvIGFzIExhenlMb2FkLFxuICBacyBhcyBMaWdodGJveCxcbiAgeGggYXMgTG9hZGluZ01hbmFnZW1lbnQsXG4gIE5vIGFzIE1vZGFsLFxuICBCcyBhcyBPZmZjYW52YXMsXG4gIG1oIGFzIFBlcmZlY3RTY3JvbGxiYXIsXG4gIHZoIGFzIFBvcGNvbmZpcm0sXG4gIFJjIGFzIFBvcG92ZXIsXG4gIHFDIGFzIFJhdGluZyxcbiAgWmUgYXMgUmlwcGxlLFxuICBIYyBhcyBTY3JvbGxTcHksXG4gIF9yIGFzIFNlbGVjdCxcbiAgZ2kgYXMgU2lkZW5hdixcbiAgeWggYXMgU21vb3RoU2Nyb2xsLFxuICBYQyBhcyBTdGVwcGVyLFxuICAkaCBhcyBTdGlja3ksXG4gIFZjIGFzIFRhYixcbiAgbmcgYXMgVGltZXBpY2tlcixcbiAgUm8gYXMgVG9hc3QsXG4gIGlpIGFzIFRvb2x0aXAsXG4gIEFoIGFzIFRvdWNoLFxuICBDaCBhcyBWYWxpZGF0aW9uLFxuICBaQyBhcyBpbml0VEVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10dy1lbGVtZW50cy5lcy5taW4uanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/tw-elements/dist/js/tw-elements.es.min.js\n"));

/***/ })

});